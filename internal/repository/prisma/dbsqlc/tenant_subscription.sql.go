// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: tenant_subscription.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getTenantSubscription = `-- name: GetTenantSubscription :one
SELECT
  "tenantId",
  "planCode",
  "status"
FROM
  "TenantSubscription"
WHERE
  "tenantId" = $1::uuid
`

func (q *Queries) GetTenantSubscription(ctx context.Context, db DBTX, tenantid pgtype.UUID) (*TenantSubscription, error) {
	row := db.QueryRow(ctx, getTenantSubscription, tenantid)
	var i TenantSubscription
	err := row.Scan(&i.TenantId, &i.PlanCode, &i.Status)
	return &i, err
}

const upsertTenantSubscription = `-- name: UpsertTenantSubscription :one
INSERT INTO "TenantSubscription" (
  "tenantId",
  "planCode",
  "status"
)
VALUES (
  $1::uuid,
  $2::text,
  $3::"TenantSubscriptionStatus"
)
ON CONFLICT ("tenantId") DO UPDATE SET
  "planCode" = $2::text,
  "status" = $3::"TenantSubscriptionStatus"
RETURNING "tenantId", "planCode", status
`

type UpsertTenantSubscriptionParams struct {
	Tenantid pgtype.UUID                  `json:"tenantid"`
	PlanCode pgtype.Text                  `json:"planCode"`
	Status   NullTenantSubscriptionStatus `json:"status"`
}

func (q *Queries) UpsertTenantSubscription(ctx context.Context, db DBTX, arg UpsertTenantSubscriptionParams) (*TenantSubscription, error) {
	row := db.QueryRow(ctx, upsertTenantSubscription, arg.Tenantid, arg.PlanCode, arg.Status)
	var i TenantSubscription
	err := row.Scan(&i.TenantId, &i.PlanCode, &i.Status)
	return &i, err
}
