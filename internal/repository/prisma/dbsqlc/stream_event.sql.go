// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: stream_event.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupStreamEvents = `-- name: CleanupStreamEvents :exec
DELETE FROM "StreamEvent"
WHERE
  -- older than than 5 minutes ago
  "createdAt" < NOW() - INTERVAL '5 minutes'
`

func (q *Queries) CleanupStreamEvents(ctx context.Context, db DBTX) error {
	_, err := db.Exec(ctx, cleanupStreamEvents)
	return err
}

const countStreamEvents = `-- name: CountStreamEvents :one
SELECT COUNT(*) AS total
FROM "StreamEvent"
WHERE
  "tenantId" = $1::uuid AND
  ($2::uuid IS NULL OR "stepRunId" = $2::uuid) AND
  ($3::"LogLineLevel"[] IS NULL OR "level" = ANY($3::"LogLineLevel"[]))
`

type CountStreamEventsParams struct {
	Tenantid  pgtype.UUID    `json:"tenantid"`
	StepRunId pgtype.UUID    `json:"stepRunId"`
	Levels    []LogLineLevel `json:"levels"`
}

func (q *Queries) CountStreamEvents(ctx context.Context, db DBTX, arg CountStreamEventsParams) (int64, error) {
	row := db.QueryRow(ctx, countStreamEvents, arg.Tenantid, arg.StepRunId, arg.Levels)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createStreamEvent = `-- name: CreateStreamEvent :one
INSERT INTO "StreamEvent" (
    "createdAt",
    "tenantId",
    "stepRunId",
    "message",
    "metadata"
) VALUES (
    coalesce($1::timestamp, now()),
    $2::uuid,
    $3::uuid,
    $4::bytea,
    coalesce($5::jsonb, '{}'::jsonb)
) RETURNING id, "createdAt", "tenantId", "stepRunId", message, metadata
`

type CreateStreamEventParams struct {
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	Tenantid  pgtype.UUID      `json:"tenantid"`
	Steprunid pgtype.UUID      `json:"steprunid"`
	Message   []byte           `json:"message"`
	Metadata  []byte           `json:"metadata"`
}

func (q *Queries) CreateStreamEvent(ctx context.Context, db DBTX, arg CreateStreamEventParams) (*StreamEvent, error) {
	row := db.QueryRow(ctx, createStreamEvent,
		arg.CreatedAt,
		arg.Tenantid,
		arg.Steprunid,
		arg.Message,
		arg.Metadata,
	)
	var i StreamEvent
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.TenantId,
		&i.StepRunId,
		&i.Message,
		&i.Metadata,
	)
	return &i, err
}

const deleteStreamEvent = `-- name: DeleteStreamEvent :one
DELETE FROM "StreamEvent"
WHERE
  "tenantId" = $1::uuid AND
  "id" = $2::bigint
RETURNING id, "createdAt", "tenantId", "stepRunId", message, metadata
`

type DeleteStreamEventParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	ID       int64       `json:"id"`
}

func (q *Queries) DeleteStreamEvent(ctx context.Context, db DBTX, arg DeleteStreamEventParams) (*StreamEvent, error) {
	row := db.QueryRow(ctx, deleteStreamEvent, arg.Tenantid, arg.ID)
	var i StreamEvent
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.TenantId,
		&i.StepRunId,
		&i.Message,
		&i.Metadata,
	)
	return &i, err
}

const getStreamEvent = `-- name: GetStreamEvent :one
SELECT id, "createdAt", "tenantId", "stepRunId", message, metadata FROM "StreamEvent"
WHERE
  "tenantId" = $1::uuid AND
  "id" = $2::bigint
`

type GetStreamEventParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	ID       int64       `json:"id"`
}

func (q *Queries) GetStreamEvent(ctx context.Context, db DBTX, arg GetStreamEventParams) (*StreamEvent, error) {
	row := db.QueryRow(ctx, getStreamEvent, arg.Tenantid, arg.ID)
	var i StreamEvent
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.TenantId,
		&i.StepRunId,
		&i.Message,
		&i.Metadata,
	)
	return &i, err
}
