// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: stream_event.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countStreamEvents = `-- name: CountStreamEvents :one
SELECT COUNT(*) AS total
FROM "StreamEvent"
WHERE
  "tenantId" = $1::uuid AND
  ($2::uuid IS NULL OR "stepRunId" = $2::uuid) AND
  ($3::"LogLineLevel"[] IS NULL OR "level" = ANY($3::"LogLineLevel"[]))
`

type CountStreamEventsParams struct {
	Tenantid  pgtype.UUID    `json:"tenantid"`
	StepRunId pgtype.UUID    `json:"stepRunId"`
	Levels    []LogLineLevel `json:"levels"`
}

func (q *Queries) CountStreamEvents(ctx context.Context, db DBTX, arg CountStreamEventsParams) (int64, error) {
	row := db.QueryRow(ctx, countStreamEvents, arg.Tenantid, arg.StepRunId, arg.Levels)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createStreamEvent = `-- name: CreateStreamEvent :one
INSERT INTO "StreamEvent" (
    "createdAt",
    "tenantId",
    "stepRunId",
    "message",
    "metadata"
) VALUES (
    coalesce($1::timestamp, now()),
    $2::uuid,
    $3::uuid,
    $4::bytes,
    coalesce($5::jsonb, '{}'::jsonb)
) RETURNING id, "createdAt", "tenantId", "stepRunId", message, metadata
`

type CreateStreamEventParams struct {
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	Tenantid  pgtype.UUID      `json:"tenantid"`
	Steprunid pgtype.UUID      `json:"steprunid"`
	Message   interface{}      `json:"message"`
	Metadata  []byte           `json:"metadata"`
}

func (q *Queries) CreateStreamEvent(ctx context.Context, db DBTX, arg CreateStreamEventParams) (*StreamEvent, error) {
	row := db.QueryRow(ctx, createStreamEvent,
		arg.CreatedAt,
		arg.Tenantid,
		arg.Steprunid,
		arg.Message,
		arg.Metadata,
	)
	var i StreamEvent
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.TenantId,
		&i.StepRunId,
		&i.Message,
		&i.Metadata,
	)
	return &i, err
}

const listStreamEvents = `-- name: ListStreamEvents :many
SELECT id, "createdAt", "tenantId", "stepRunId", message, metadata FROM "StreamEvent"
WHERE
  "tenantId" = $1::uuid AND
  ($2::uuid IS NULL OR "stepRunId" = $2::uuid)
ORDER BY
  CASE WHEN $3::text = 'createdAt ASC' THEN "createdAt" END ASC,
  CASE WHEN $3::text = 'createdAt DESC' THEN "createdAt" END DESC,
  -- add order by id to make sure the order is deterministic
  CASE WHEN $3::text = 'createdAt ASC' THEN "id" END ASC,
  CASE WHEN $3::text = 'createdAt DESC' THEN "id" END DESC
LIMIT COALESCE($5, 50)
OFFSET COALESCE($4, 0)
`

type ListStreamEventsParams struct {
	Tenantid  pgtype.UUID `json:"tenantid"`
	StepRunId pgtype.UUID `json:"stepRunId"`
	OrderBy   pgtype.Text `json:"orderBy"`
	Offset    interface{} `json:"offset"`
	Limit     interface{} `json:"limit"`
}

func (q *Queries) ListStreamEvents(ctx context.Context, db DBTX, arg ListStreamEventsParams) ([]*StreamEvent, error) {
	rows, err := db.Query(ctx, listStreamEvents,
		arg.Tenantid,
		arg.StepRunId,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StreamEvent
	for rows.Next() {
		var i StreamEvent
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.TenantId,
			&i.StepRunId,
			&i.Message,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
