// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: workflows.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countWorkflows = `-- name: CountWorkflows :one
SELECT
    count(workflows) OVER() AS total
FROM
    "Workflow" as workflows 
WHERE
    workflows."tenantId" = $1 AND
    (
        $2::text IS NULL OR
        workflows."id" IN (
            SELECT 
                DISTINCT ON(t1."workflowId") t1."workflowId"
            FROM 
                "WorkflowVersion" AS t1
                LEFT JOIN "WorkflowTriggers" AS j2 ON j2."workflowVersionId" = t1."id" 
            WHERE 
                (
                    j2."id" IN (
                        SELECT 
                            t3."parentId" 
                        FROM 
                            "public"."WorkflowTriggerEventRef" AS t3
                        WHERE 
                            t3."eventKey" = $2::text
                            AND t3."parentId" IS NOT NULL
                    ) 
                    AND j2."id" IS NOT NULL 
                    AND t1."workflowId" IS NOT NULL
                )
            ORDER BY 
                t1."workflowId" DESC, t1."order" DESC
        )
    )
`

type CountWorkflowsParams struct {
	TenantId pgtype.UUID `json:"tenantId"`
	EventKey pgtype.Text `json:"eventKey"`
}

func (q *Queries) CountWorkflows(ctx context.Context, db DBTX, arg CountWorkflowsParams) (int64, error) {
	row := db.QueryRow(ctx, countWorkflows, arg.TenantId, arg.EventKey)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const listWorkflows = `-- name: ListWorkflows :many
SELECT
    workflows.id, workflows."createdAt", workflows."updatedAt", workflows."deletedAt", workflows."tenantId", workflows.name, workflows.description
FROM
    "Workflow" as workflows 
LEFT JOIN
    (
        SELECT id, "createdAt", "updatedAt", "deletedAt", version, "order", "workflowId" FROM "WorkflowVersion" as workflowVersion ORDER BY workflowVersion."order" DESC LIMIT 1
    ) as workflowVersion ON workflows."id" = workflowVersion."workflowId"
LEFT JOIN
    "WorkflowTriggers" as workflowTrigger ON workflowVersion."id" = workflowTrigger."workflowVersionId"
LEFT JOIN
    "WorkflowTriggerEventRef" as workflowTriggerEventRef ON workflowTrigger."id" = workflowTriggerEventRef."parentId"
WHERE
    workflows."tenantId" = $1 
    AND
    (
        $2::text IS NULL OR
        workflows."id" IN (
            SELECT 
                DISTINCT ON(t1."workflowId") t1."workflowId"
            FROM 
                "WorkflowVersion" AS t1
                LEFT JOIN "WorkflowTriggers" AS j2 ON j2."workflowVersionId" = t1."id" 
            WHERE 
                (
                    j2."id" IN (
                        SELECT 
                            t3."parentId" 
                        FROM 
                            "public"."WorkflowTriggerEventRef" AS t3
                        WHERE 
                            t3."eventKey" = $2::text
                            AND t3."parentId" IS NOT NULL
                    ) 
                    AND j2."id" IS NOT NULL 
                    AND t1."workflowId" IS NOT NULL
                )
            ORDER BY 
                t1."workflowId" DESC, t1."order" DESC
        )
    )
ORDER BY
    case when $3 = 'createdAt ASC' THEN workflows."createdAt" END ASC ,
    case when $3 = 'createdAt DESC' then workflows."createdAt" END DESC
OFFSET
    COALESCE($4, 0)
LIMIT
    COALESCE($5, 50)
`

type ListWorkflowsParams struct {
	TenantId pgtype.UUID `json:"tenantId"`
	EventKey pgtype.Text `json:"eventKey"`
	Orderby  interface{} `json:"orderby"`
	Offset   interface{} `json:"offset"`
	Limit    interface{} `json:"limit"`
}

type ListWorkflowsRow struct {
	Workflow Workflow `json:"workflow"`
}

func (q *Queries) ListWorkflows(ctx context.Context, db DBTX, arg ListWorkflowsParams) ([]*ListWorkflowsRow, error) {
	rows, err := db.Query(ctx, listWorkflows,
		arg.TenantId,
		arg.EventKey,
		arg.Orderby,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListWorkflowsRow
	for rows.Next() {
		var i ListWorkflowsRow
		if err := rows.Scan(
			&i.Workflow.ID,
			&i.Workflow.CreatedAt,
			&i.Workflow.UpdatedAt,
			&i.Workflow.DeletedAt,
			&i.Workflow.TenantId,
			&i.Workflow.Name,
			&i.Workflow.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkflowsLatestRuns = `-- name: ListWorkflowsLatestRuns :many
SELECT
    DISTINCT ON (workflow."id") runs.id, runs."createdAt", runs."updatedAt", runs."deletedAt", runs."tenantId", runs."workflowVersionId", runs.status, runs.input, runs.error, runs."startedAt", runs."finishedAt", workflow."id" as "workflowId"
FROM
    "WorkflowRun" as runs
LEFT JOIN
    "WorkflowVersion" as workflowVersion ON runs."workflowVersionId" = workflowVersion."id"
LEFT JOIN
    "Workflow" as workflow ON workflowVersion."workflowId" = workflow."id"
WHERE
    runs."tenantId" = $1 AND
    (
        $2::text IS NULL OR
        workflow."id" IN (
            SELECT 
                DISTINCT ON(t1."workflowId") t1."workflowId"
            FROM 
                "WorkflowVersion" AS t1
                LEFT JOIN "WorkflowTriggers" AS j2 ON j2."workflowVersionId" = t1."id" 
            WHERE 
                (
                    j2."id" IN (
                        SELECT 
                            t3."parentId" 
                        FROM 
                            "public"."WorkflowTriggerEventRef" AS t3
                        WHERE 
                            t3."eventKey" = $2::text
                            AND t3."parentId" IS NOT NULL
                    ) 
                    AND j2."id" IS NOT NULL 
                    AND t1."workflowId" IS NOT NULL
                )
            ORDER BY 
                t1."workflowId" DESC, t1."order" DESC
        )
    )
ORDER BY 
    workflow."id" DESC, runs."createdAt" DESC
`

type ListWorkflowsLatestRunsParams struct {
	TenantId pgtype.UUID `json:"tenantId"`
	EventKey pgtype.Text `json:"eventKey"`
}

type ListWorkflowsLatestRunsRow struct {
	WorkflowRun WorkflowRun `json:"workflow_run"`
	WorkflowId  pgtype.UUID `json:"workflowId"`
}

func (q *Queries) ListWorkflowsLatestRuns(ctx context.Context, db DBTX, arg ListWorkflowsLatestRunsParams) ([]*ListWorkflowsLatestRunsRow, error) {
	rows, err := db.Query(ctx, listWorkflowsLatestRuns, arg.TenantId, arg.EventKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListWorkflowsLatestRunsRow
	for rows.Next() {
		var i ListWorkflowsLatestRunsRow
		if err := rows.Scan(
			&i.WorkflowRun.ID,
			&i.WorkflowRun.CreatedAt,
			&i.WorkflowRun.UpdatedAt,
			&i.WorkflowRun.DeletedAt,
			&i.WorkflowRun.TenantId,
			&i.WorkflowRun.WorkflowVersionId,
			&i.WorkflowRun.Status,
			&i.WorkflowRun.Input,
			&i.WorkflowRun.Error,
			&i.WorkflowRun.StartedAt,
			&i.WorkflowRun.FinishedAt,
			&i.WorkflowId,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
