// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: workflow_runs.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countWorkflowRuns = `-- name: CountWorkflowRuns :one
SELECT
    count(runs) OVER() AS total
FROM
    "WorkflowRun" as runs
LEFT JOIN
    "WorkflowRunTriggeredBy" as runTriggers ON runTriggers."parentId" = runs."id"
LEFT JOIN
    "Event" as events ON runTriggers."eventId" = events."id"
LEFT JOIN
    "WorkflowVersion" as workflowVersion ON runs."workflowVersionId" = workflowVersion."id"
LEFT JOIN
    "Workflow" as workflow ON workflowVersion."workflowId" = workflow."id"
WHERE
    runs."tenantId" = $1 AND
    (
        $2::uuid IS NULL OR
        workflow."id" = $2::uuid
    ) AND
    (
        $3::uuid IS NULL OR
        events."id" = $3::uuid
    )
`

type CountWorkflowRunsParams struct {
	TenantId   pgtype.UUID `json:"tenantId"`
	WorkflowId pgtype.UUID `json:"workflowId"`
	EventId    pgtype.UUID `json:"eventId"`
}

func (q *Queries) CountWorkflowRuns(ctx context.Context, db DBTX, arg CountWorkflowRunsParams) (int64, error) {
	row := db.QueryRow(ctx, countWorkflowRuns, arg.TenantId, arg.WorkflowId, arg.EventId)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const listWorkflowRuns = `-- name: ListWorkflowRuns :many
SELECT
    runs.id, runs."createdAt", runs."updatedAt", runs."deletedAt", runs."tenantId", runs."workflowVersionId", runs.status, runs.input, runs.error, runs."startedAt", runs."finishedAt", 
    workflow.id, workflow."createdAt", workflow."updatedAt", workflow."deletedAt", workflow."tenantId", workflow.name, workflow.description, 
    runtriggers.id, runtriggers."createdAt", runtriggers."updatedAt", runtriggers."deletedAt", runtriggers."tenantId", runtriggers."parentId", runtriggers."eventId", runtriggers."cronParentId", runtriggers."cronSchedule", runtriggers."scheduledId", 
    workflowversion.id, workflowversion."createdAt", workflowversion."updatedAt", workflowversion."deletedAt", workflowversion.version, workflowversion."order", workflowversion."workflowId", 
    -- waiting on https://github.com/sqlc-dev/sqlc/pull/2858 for nullable events field
    events.id, events.key, events."createdAt", events."updatedAt"
FROM
    "WorkflowRun" as runs 
LEFT JOIN
    "WorkflowRunTriggeredBy" as runTriggers ON runTriggers."parentId" = runs."id"
LEFT JOIN
    "Event" as events ON runTriggers."eventId" = events."id"
LEFT JOIN
    "WorkflowVersion" as workflowVersion ON runs."workflowVersionId" = workflowVersion."id"
LEFT JOIN
    "Workflow" as workflow ON workflowVersion."workflowId" = workflow."id"
WHERE
    runs."tenantId" = $1 AND
    (
        $2::uuid IS NULL OR
        workflow."id" = $2::uuid
    ) AND
    (
        $3::uuid IS NULL OR
        events."id" = $3::uuid
    )
ORDER BY
    case when $4 = 'createdAt ASC' THEN runs."createdAt" END ASC ,
    case when $4 = 'createdAt DESC' then runs."createdAt" END DESC
OFFSET
    COALESCE($5, 0)
LIMIT
    COALESCE($6, 50)
`

type ListWorkflowRunsParams struct {
	TenantId   pgtype.UUID `json:"tenantId"`
	WorkflowId pgtype.UUID `json:"workflowId"`
	EventId    pgtype.UUID `json:"eventId"`
	Orderby    interface{} `json:"orderby"`
	Offset     interface{} `json:"offset"`
	Limit      interface{} `json:"limit"`
}

type ListWorkflowRunsRow struct {
	WorkflowRun            WorkflowRun            `json:"workflow_run"`
	Workflow               Workflow               `json:"workflow"`
	WorkflowRunTriggeredBy WorkflowRunTriggeredBy `json:"workflow_run_triggered_by"`
	WorkflowVersion        WorkflowVersion        `json:"workflow_version"`
	ID                     pgtype.UUID            `json:"id"`
	Key                    pgtype.Text            `json:"key"`
	CreatedAt              pgtype.Timestamp       `json:"createdAt"`
	UpdatedAt              pgtype.Timestamp       `json:"updatedAt"`
}

func (q *Queries) ListWorkflowRuns(ctx context.Context, db DBTX, arg ListWorkflowRunsParams) ([]*ListWorkflowRunsRow, error) {
	rows, err := db.Query(ctx, listWorkflowRuns,
		arg.TenantId,
		arg.WorkflowId,
		arg.EventId,
		arg.Orderby,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListWorkflowRunsRow
	for rows.Next() {
		var i ListWorkflowRunsRow
		if err := rows.Scan(
			&i.WorkflowRun.ID,
			&i.WorkflowRun.CreatedAt,
			&i.WorkflowRun.UpdatedAt,
			&i.WorkflowRun.DeletedAt,
			&i.WorkflowRun.TenantId,
			&i.WorkflowRun.WorkflowVersionId,
			&i.WorkflowRun.Status,
			&i.WorkflowRun.Input,
			&i.WorkflowRun.Error,
			&i.WorkflowRun.StartedAt,
			&i.WorkflowRun.FinishedAt,
			&i.Workflow.ID,
			&i.Workflow.CreatedAt,
			&i.Workflow.UpdatedAt,
			&i.Workflow.DeletedAt,
			&i.Workflow.TenantId,
			&i.Workflow.Name,
			&i.Workflow.Description,
			&i.WorkflowRunTriggeredBy.ID,
			&i.WorkflowRunTriggeredBy.CreatedAt,
			&i.WorkflowRunTriggeredBy.UpdatedAt,
			&i.WorkflowRunTriggeredBy.DeletedAt,
			&i.WorkflowRunTriggeredBy.TenantId,
			&i.WorkflowRunTriggeredBy.ParentId,
			&i.WorkflowRunTriggeredBy.EventId,
			&i.WorkflowRunTriggeredBy.CronParentId,
			&i.WorkflowRunTriggeredBy.CronSchedule,
			&i.WorkflowRunTriggeredBy.ScheduledId,
			&i.WorkflowVersion.ID,
			&i.WorkflowVersion.CreatedAt,
			&i.WorkflowVersion.UpdatedAt,
			&i.WorkflowVersion.DeletedAt,
			&i.WorkflowVersion.Version,
			&i.WorkflowVersion.Order,
			&i.WorkflowVersion.WorkflowId,
			&i.ID,
			&i.Key,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveWorkflowRunStatus = `-- name: ResolveWorkflowRunStatus :one
WITH jobRuns AS (
    SELECT sum(case when runs."status" = 'PENDING' then 1 else 0 end) AS pendingRuns,
        sum(case when runs."status" = 'RUNNING' then 1 else 0 end) AS runningRuns,
        sum(case when runs."status" = 'SUCCEEDED' then 1 else 0 end) AS succeededRuns,
        sum(case when runs."status" = 'FAILED' then 1 else 0 end) AS failedRuns,
        sum(case when runs."status" = 'CANCELLED' then 1 else 0 end) AS cancelledRuns
    FROM "JobRun" as runs
    WHERE
        "workflowRunId" = (
            SELECT "workflowRunId"
            FROM "JobRun"
            WHERE "id" = $1::uuid
        ) AND
        "tenantId" = $2::uuid
)
UPDATE "WorkflowRun"
SET "status" = CASE 
    -- Final states are final, cannot be updated
    WHEN "status" IN ('SUCCEEDED', 'FAILED') THEN "status"
    -- We check for running first, because if a job run is running, then the workflow is running
    WHEN j.runningRuns > 0 THEN 'RUNNING'
    -- When at least one job run has failed or been cancelled, then the workflow is failed
    WHEN j.failedRuns > 0 OR j.cancelledRuns > 0 THEN 'FAILED'
    -- When all job runs have succeeded, then the workflow is succeeded
    WHEN j.succeededRuns > 0 AND j.pendingRuns = 0 AND j.runningRuns = 0 AND j.failedRuns = 0 AND j.cancelledRuns = 0 THEN 'SUCCEEDED'
    ELSE "status"
END, "finishedAt" = CASE 
    -- Final states are final, cannot be updated
    WHEN "finishedAt" IS NOT NULL THEN "finishedAt"
    -- We check for running first, because if a job run is running, then the workflow is not finished
    WHEN j.runningRuns > 0 THEN NULL
    -- When one job run has failed or been cancelled, then the workflow is failed
    WHEN j.failedRuns > 0 OR j.cancelledRuns > 0 OR j.succeededRuns > 0 THEN NOW()
    ELSE "finishedAt"
END, "startedAt" = CASE 
    -- Started at is final, cannot be changed
    WHEN "startedAt" IS NOT NULL THEN "startedAt"
    -- If a job is running, then the workflow has started
    WHEN j.runningRuns > 0 THEN NOW()
    ELSE "startedAt"
END
FROM
    jobRuns j
WHERE "id" = (
    SELECT "workflowRunId"
    FROM "JobRun"
    WHERE "id" = $1::uuid
) AND "tenantId" = $2::uuid
RETURNING "WorkflowRun".id, "WorkflowRun"."createdAt", "WorkflowRun"."updatedAt", "WorkflowRun"."deletedAt", "WorkflowRun"."tenantId", "WorkflowRun"."workflowVersionId", "WorkflowRun".status, "WorkflowRun".input, "WorkflowRun".error, "WorkflowRun"."startedAt", "WorkflowRun"."finishedAt"
`

type ResolveWorkflowRunStatusParams struct {
	Jobrunid pgtype.UUID `json:"jobrunid"`
	Tenantid pgtype.UUID `json:"tenantid"`
}

func (q *Queries) ResolveWorkflowRunStatus(ctx context.Context, db DBTX, arg ResolveWorkflowRunStatusParams) (*WorkflowRun, error) {
	row := db.QueryRow(ctx, resolveWorkflowRunStatus, arg.Jobrunid, arg.Tenantid)
	var i WorkflowRun
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.WorkflowVersionId,
		&i.Status,
		&i.Input,
		&i.Error,
		&i.StartedAt,
		&i.FinishedAt,
	)
	return &i, err
}
