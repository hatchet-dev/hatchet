// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: workflow_runs.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countWorkflowRuns = `-- name: CountWorkflowRuns :one
SELECT
    count(runs) OVER() AS total
FROM
    "WorkflowRun" as runs
LEFT JOIN
    "WorkflowRunTriggeredBy" as runTriggers ON runTriggers."parentId" = runs."id"
LEFT JOIN
    "Event" as events ON runTriggers."eventId" = events."id"
LEFT JOIN
    "WorkflowVersion" as workflowVersion ON runs."workflowVersionId" = workflowVersion."id"
LEFT JOIN
    "Workflow" as workflow ON workflowVersion."workflowId" = workflow."id"
WHERE
    runs."tenantId" = $1 AND
    (
        $2::uuid IS NULL OR
        workflowVersion."id" = $2::uuid
    ) AND
    (
        $3::uuid IS NULL OR
        workflow."id" = $3::uuid
    ) AND
    (
        $4::uuid[] IS NULL OR
        runs."id" = ANY($4::uuid[])
    ) AND
    (
        $5::uuid IS NULL OR
        runs."parentId" = $5::uuid
    ) AND
    (
        $6::uuid IS NULL OR
        runs."parentStepRunId" = $6::uuid
    ) AND
    (
        $7::jsonb IS NULL OR
        runs."additionalMetadata" @> $7::jsonb
    ) AND
    (
        $8::uuid IS NULL OR
        events."id" = $8::uuid
    ) AND
    (
        $9::text IS NULL OR
        runs."concurrencyGroupId" = $9::text
    ) AND
    (
        $10::text[] IS NULL OR
        "status" = ANY(cast($10::text[] as "WorkflowRunStatus"[]))
    ) AND
    (
        $11::timestamp IS NULL OR
        runs."createdAt" > $11::timestamp
    )
`

type CountWorkflowRunsParams struct {
	TenantId           pgtype.UUID      `json:"tenantId"`
	WorkflowVersionId  pgtype.UUID      `json:"workflowVersionId"`
	WorkflowId         pgtype.UUID      `json:"workflowId"`
	Ids                []pgtype.UUID    `json:"ids"`
	ParentId           pgtype.UUID      `json:"parentId"`
	ParentStepRunId    pgtype.UUID      `json:"parentStepRunId"`
	AdditionalMetadata []byte           `json:"additionalMetadata"`
	EventId            pgtype.UUID      `json:"eventId"`
	GroupKey           pgtype.Text      `json:"groupKey"`
	Statuses           []string         `json:"statuses"`
	CreatedAfter       pgtype.Timestamp `json:"createdAfter"`
}

func (q *Queries) CountWorkflowRuns(ctx context.Context, db DBTX, arg CountWorkflowRunsParams) (int64, error) {
	row := db.QueryRow(ctx, countWorkflowRuns,
		arg.TenantId,
		arg.WorkflowVersionId,
		arg.WorkflowId,
		arg.Ids,
		arg.ParentId,
		arg.ParentStepRunId,
		arg.AdditionalMetadata,
		arg.EventId,
		arg.GroupKey,
		arg.Statuses,
		arg.CreatedAfter,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createGetGroupKeyRun = `-- name: CreateGetGroupKeyRun :one
INSERT INTO "GetGroupKeyRun" (
    "id",
    "createdAt",
    "updatedAt",
    "deletedAt",
    "tenantId",
    "workflowRunId",
    "workerId",
    "tickerId",
    "status",
    "input",
    "output",
    "requeueAfter",
    "scheduleTimeoutAt",
    "error",
    "startedAt",
    "finishedAt",
    "timeoutAt",
    "cancelledAt",
    "cancelledReason",
    "cancelledError"
) VALUES (
    COALESCE($1::uuid, gen_random_uuid()),
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    NULL,
    $2::uuid,
    $3::uuid,
    NULL,
    NULL,
    'PENDING', -- default status
    $4::jsonb,
    NULL,
    $5::timestamp,
    $6::timestamp,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
) RETURNING id, "createdAt", "updatedAt", "deletedAt", "tenantId", "workerId", "tickerId", status, input, output, "requeueAfter", error, "startedAt", "finishedAt", "timeoutAt", "cancelledAt", "cancelledReason", "cancelledError", "workflowRunId", "scheduleTimeoutAt"
`

type CreateGetGroupKeyRunParams struct {
	ID                pgtype.UUID      `json:"id"`
	Tenantid          pgtype.UUID      `json:"tenantid"`
	Workflowrunid     pgtype.UUID      `json:"workflowrunid"`
	Input             []byte           `json:"input"`
	Requeueafter      pgtype.Timestamp `json:"requeueafter"`
	Scheduletimeoutat pgtype.Timestamp `json:"scheduletimeoutat"`
}

func (q *Queries) CreateGetGroupKeyRun(ctx context.Context, db DBTX, arg CreateGetGroupKeyRunParams) (*GetGroupKeyRun, error) {
	row := db.QueryRow(ctx, createGetGroupKeyRun,
		arg.ID,
		arg.Tenantid,
		arg.Workflowrunid,
		arg.Input,
		arg.Requeueafter,
		arg.Scheduletimeoutat,
	)
	var i GetGroupKeyRun
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.WorkerId,
		&i.TickerId,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.RequeueAfter,
		&i.Error,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TimeoutAt,
		&i.CancelledAt,
		&i.CancelledReason,
		&i.CancelledError,
		&i.WorkflowRunId,
		&i.ScheduleTimeoutAt,
	)
	return &i, err
}

const createJobRunLookupData = `-- name: CreateJobRunLookupData :one
INSERT INTO "JobRunLookupData" (
    "id",
    "createdAt",
    "updatedAt",
    "deletedAt",
    "jobRunId",
    "tenantId",
    "data"
) VALUES (
    COALESCE($1::uuid, gen_random_uuid()),
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    NULL,
    $2::uuid,
    $3::uuid,
    jsonb_build_object(
        'input', COALESCE($4::jsonb, '{}'::jsonb),
        'triggered_by', $5::text,
        'steps', '{}'::jsonb
    )
) RETURNING id, "createdAt", "updatedAt", "deletedAt", "jobRunId", "tenantId", data
`

type CreateJobRunLookupDataParams struct {
	ID          pgtype.UUID `json:"id"`
	Jobrunid    pgtype.UUID `json:"jobrunid"`
	Tenantid    pgtype.UUID `json:"tenantid"`
	Input       []byte      `json:"input"`
	Triggeredby string      `json:"triggeredby"`
}

func (q *Queries) CreateJobRunLookupData(ctx context.Context, db DBTX, arg CreateJobRunLookupDataParams) (*JobRunLookupData, error) {
	row := db.QueryRow(ctx, createJobRunLookupData,
		arg.ID,
		arg.Jobrunid,
		arg.Tenantid,
		arg.Input,
		arg.Triggeredby,
	)
	var i JobRunLookupData
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.JobRunId,
		&i.TenantId,
		&i.Data,
	)
	return &i, err
}

const createJobRuns = `-- name: CreateJobRuns :many
INSERT INTO "JobRun" (
    "id",
    "createdAt",
    "updatedAt",
    "tenantId",
    "workflowRunId",
    "jobId",
    "status"
) 
SELECT
    gen_random_uuid(),
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    $1::uuid,
    $2::uuid,
    "id",
    'PENDING' -- default status
FROM
    "Job"
WHERE
    "workflowVersionId" = $3::uuid
RETURNING "id"
`

type CreateJobRunsParams struct {
	Tenantid          pgtype.UUID `json:"tenantid"`
	Workflowrunid     pgtype.UUID `json:"workflowrunid"`
	Workflowversionid pgtype.UUID `json:"workflowversionid"`
}

func (q *Queries) CreateJobRuns(ctx context.Context, db DBTX, arg CreateJobRunsParams) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, createJobRuns, arg.Tenantid, arg.Workflowrunid, arg.Workflowversionid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createStepRuns = `-- name: CreateStepRuns :exec
WITH job_id AS (
    SELECT "jobId"
    FROM "JobRun"
    WHERE "id" = $2::uuid
)
INSERT INTO "StepRun" (
    "id",
    "createdAt",
    "updatedAt",
    "tenantId",
    "jobRunId",
    "stepId",
    "status",
    "requeueAfter",
    "callerFiles"
) 
SELECT
    gen_random_uuid(),
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    $1::uuid,
    $2::uuid,
    "id",
    'PENDING', -- default status
    CURRENT_TIMESTAMP + INTERVAL '5 seconds',
    '{}'
FROM
    "Step", job_id
WHERE
    "Step"."jobId" = job_id."jobId"
`

type CreateStepRunsParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Jobrunid pgtype.UUID `json:"jobrunid"`
}

func (q *Queries) CreateStepRuns(ctx context.Context, db DBTX, arg CreateStepRunsParams) error {
	_, err := db.Exec(ctx, createStepRuns, arg.Tenantid, arg.Jobrunid)
	return err
}

const createWorkflowRun = `-- name: CreateWorkflowRun :one
INSERT INTO "WorkflowRun" (
    "id",
    "createdAt",
    "updatedAt",
    "deletedAt",
    "displayName",
    "tenantId",
    "workflowVersionId",
    "status",
    "error",
    "startedAt",
    "finishedAt",
    "childIndex",
    "childKey",
    "parentId",
    "parentStepRunId",
    "additionalMetadata"
) VALUES (
    COALESCE($1::uuid, gen_random_uuid()),
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    NULL, -- assuming deletedAt is not set on creation
    $2::text,
    $3::uuid,
    $4::uuid,
    'PENDING', -- default status
    NULL, -- assuming error is not set on creation
    NULL, -- assuming startedAt is not set on creation
    NULL,  -- assuming finishedAt is not set on creation
    $5::int,
    $6::text,
    $7::uuid,
    $8::uuid,
    $9::jsonb
) RETURNING "createdAt", "updatedAt", "deletedAt", "tenantId", "workflowVersionId", status, error, "startedAt", "finishedAt", "concurrencyGroupId", "displayName", id, "gitRepoBranch", "childIndex", "childKey", "parentId", "parentStepRunId", "additionalMetadata"
`

type CreateWorkflowRunParams struct {
	ID                 pgtype.UUID `json:"id"`
	DisplayName        pgtype.Text `json:"displayName"`
	Tenantid           pgtype.UUID `json:"tenantid"`
	Workflowversionid  pgtype.UUID `json:"workflowversionid"`
	ChildIndex         pgtype.Int4 `json:"childIndex"`
	ChildKey           pgtype.Text `json:"childKey"`
	ParentId           pgtype.UUID `json:"parentId"`
	ParentStepRunId    pgtype.UUID `json:"parentStepRunId"`
	Additionalmetadata []byte      `json:"additionalmetadata"`
}

func (q *Queries) CreateWorkflowRun(ctx context.Context, db DBTX, arg CreateWorkflowRunParams) (*WorkflowRun, error) {
	row := db.QueryRow(ctx, createWorkflowRun,
		arg.ID,
		arg.DisplayName,
		arg.Tenantid,
		arg.Workflowversionid,
		arg.ChildIndex,
		arg.ChildKey,
		arg.ParentId,
		arg.ParentStepRunId,
		arg.Additionalmetadata,
	)
	var i WorkflowRun
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.WorkflowVersionId,
		&i.Status,
		&i.Error,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ConcurrencyGroupId,
		&i.DisplayName,
		&i.ID,
		&i.GitRepoBranch,
		&i.ChildIndex,
		&i.ChildKey,
		&i.ParentId,
		&i.ParentStepRunId,
		&i.AdditionalMetadata,
	)
	return &i, err
}

const createWorkflowRunTriggeredBy = `-- name: CreateWorkflowRunTriggeredBy :one
INSERT INTO "WorkflowRunTriggeredBy" (
    "id",
    "createdAt",
    "updatedAt",
    "deletedAt",
    "tenantId",
    "parentId",
    "eventId",
    "cronParentId",
    "cronSchedule",
    "scheduledId"
) VALUES (
    gen_random_uuid(), -- Generates a new UUID for id
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    NULL, -- assuming deletedAt is not set on creation
    $1::uuid,
    $2::uuid, -- assuming parentId is the workflowRunId
    $3::uuid, -- NULL if not provided
    $4::uuid, -- NULL if not provided
    $5::text, -- NULL if not provided
    $6::uuid -- NULL if not provided
) RETURNING id, "createdAt", "updatedAt", "deletedAt", "tenantId", "eventId", "cronParentId", "cronSchedule", "scheduledId", input, "parentId"
`

type CreateWorkflowRunTriggeredByParams struct {
	Tenantid      pgtype.UUID `json:"tenantid"`
	Workflowrunid pgtype.UUID `json:"workflowrunid"`
	EventId       pgtype.UUID `json:"eventId"`
	CronParentId  pgtype.UUID `json:"cronParentId"`
	Cron          pgtype.Text `json:"cron"`
	ScheduledId   pgtype.UUID `json:"scheduledId"`
}

func (q *Queries) CreateWorkflowRunTriggeredBy(ctx context.Context, db DBTX, arg CreateWorkflowRunTriggeredByParams) (*WorkflowRunTriggeredBy, error) {
	row := db.QueryRow(ctx, createWorkflowRunTriggeredBy,
		arg.Tenantid,
		arg.Workflowrunid,
		arg.EventId,
		arg.CronParentId,
		arg.Cron,
		arg.ScheduledId,
	)
	var i WorkflowRunTriggeredBy
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.EventId,
		&i.CronParentId,
		&i.CronSchedule,
		&i.ScheduledId,
		&i.Input,
		&i.ParentId,
	)
	return &i, err
}

const getChildWorkflowRun = `-- name: GetChildWorkflowRun :one
SELECT
    "createdAt", "updatedAt", "deletedAt", "tenantId", "workflowVersionId", status, error, "startedAt", "finishedAt", "concurrencyGroupId", "displayName", id, "gitRepoBranch", "childIndex", "childKey", "parentId", "parentStepRunId", "additionalMetadata"
FROM
    "WorkflowRun"
WHERE
    "parentId" = $1::uuid AND
    "parentStepRunId" = $2::uuid AND
    (
        -- if childKey is set, use that
        ($3::text IS NULL AND "childIndex" = $4) OR
        ($3::text IS NOT NULL AND "childKey" = $3::text)
    )
`

type GetChildWorkflowRunParams struct {
	Parentid        pgtype.UUID `json:"parentid"`
	Parentsteprunid pgtype.UUID `json:"parentsteprunid"`
	ChildKey        pgtype.Text `json:"childKey"`
	Childindex      pgtype.Int4 `json:"childindex"`
}

func (q *Queries) GetChildWorkflowRun(ctx context.Context, db DBTX, arg GetChildWorkflowRunParams) (*WorkflowRun, error) {
	row := db.QueryRow(ctx, getChildWorkflowRun,
		arg.Parentid,
		arg.Parentsteprunid,
		arg.ChildKey,
		arg.Childindex,
	)
	var i WorkflowRun
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.WorkflowVersionId,
		&i.Status,
		&i.Error,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ConcurrencyGroupId,
		&i.DisplayName,
		&i.ID,
		&i.GitRepoBranch,
		&i.ChildIndex,
		&i.ChildKey,
		&i.ParentId,
		&i.ParentStepRunId,
		&i.AdditionalMetadata,
	)
	return &i, err
}

const getScheduledChildWorkflowRun = `-- name: GetScheduledChildWorkflowRun :one
SELECT
    id, "parentId", "triggerAt", "tickerId", input, "childIndex", "childKey", "parentStepRunId", "parentWorkflowRunId"
FROM
    "WorkflowTriggerScheduledRef"
WHERE
    "parentId" = $1::uuid AND
    "parentStepRunId" = $2::uuid AND
    (
        -- if childKey is set, use that
        ($3::text IS NULL AND "childIndex" = $4) OR
        ($3::text IS NOT NULL AND "childKey" = $3::text)
    )
`

type GetScheduledChildWorkflowRunParams struct {
	Parentid        pgtype.UUID `json:"parentid"`
	Parentsteprunid pgtype.UUID `json:"parentsteprunid"`
	ChildKey        pgtype.Text `json:"childKey"`
	Childindex      pgtype.Int4 `json:"childindex"`
}

func (q *Queries) GetScheduledChildWorkflowRun(ctx context.Context, db DBTX, arg GetScheduledChildWorkflowRunParams) (*WorkflowTriggerScheduledRef, error) {
	row := db.QueryRow(ctx, getScheduledChildWorkflowRun,
		arg.Parentid,
		arg.Parentsteprunid,
		arg.ChildKey,
		arg.Childindex,
	)
	var i WorkflowTriggerScheduledRef
	err := row.Scan(
		&i.ID,
		&i.ParentId,
		&i.TriggerAt,
		&i.TickerId,
		&i.Input,
		&i.ChildIndex,
		&i.ChildKey,
		&i.ParentStepRunId,
		&i.ParentWorkflowRunId,
	)
	return &i, err
}

const getWorkflowRun = `-- name: GetWorkflowRun :many
SELECT
    runs."createdAt", runs."updatedAt", runs."deletedAt", runs."tenantId", runs."workflowVersionId", runs.status, runs.error, runs."startedAt", runs."finishedAt", runs."concurrencyGroupId", runs."displayName", runs.id, runs."gitRepoBranch", runs."childIndex", runs."childKey", runs."parentId", runs."parentStepRunId", runs."additionalMetadata", 
    runtriggers.id, runtriggers."createdAt", runtriggers."updatedAt", runtriggers."deletedAt", runtriggers."tenantId", runtriggers."eventId", runtriggers."cronParentId", runtriggers."cronSchedule", runtriggers."scheduledId", runtriggers.input, runtriggers."parentId", 
    workflowversion.id, workflowversion."createdAt", workflowversion."updatedAt", workflowversion."deletedAt", workflowversion.version, workflowversion."order", workflowversion."workflowId", workflowversion.checksum, workflowversion."scheduleTimeout", workflowversion."onFailureJobId", 
    workflow."name" as "workflowName",
    -- waiting on https://github.com/sqlc-dev/sqlc/pull/2858 for nullable fields
    wc."limitStrategy" as "concurrencyLimitStrategy",
    wc."maxRuns" as "concurrencyMaxRuns",
    groupKeyRun."id" as "getGroupKeyRunId"
FROM
    "WorkflowRun" as runs
LEFT JOIN
    "WorkflowRunTriggeredBy" as runTriggers ON runTriggers."parentId" = runs."id"
LEFT JOIN
    "WorkflowVersion" as workflowVersion ON runs."workflowVersionId" = workflowVersion."id"
LEFT JOIN
    "Workflow" as workflow ON workflowVersion."workflowId" = workflow."id"
LEFT JOIN
    "WorkflowConcurrency" as wc ON wc."workflowVersionId" = workflowVersion."id"
LEFT JOIN
    "GetGroupKeyRun" as groupKeyRun ON groupKeyRun."workflowRunId" = runs."id"
WHERE
    runs."id" = ANY($1::uuid[]) AND
    runs."tenantId" = $2::uuid
`

type GetWorkflowRunParams struct {
	Ids      []pgtype.UUID `json:"ids"`
	Tenantid pgtype.UUID   `json:"tenantid"`
}

type GetWorkflowRunRow struct {
	WorkflowRun              WorkflowRun                  `json:"workflow_run"`
	WorkflowRunTriggeredBy   WorkflowRunTriggeredBy       `json:"workflow_run_triggered_by"`
	WorkflowVersion          WorkflowVersion              `json:"workflow_version"`
	WorkflowName             pgtype.Text                  `json:"workflowName"`
	ConcurrencyLimitStrategy NullConcurrencyLimitStrategy `json:"concurrencyLimitStrategy"`
	ConcurrencyMaxRuns       pgtype.Int4                  `json:"concurrencyMaxRuns"`
	GetGroupKeyRunId         pgtype.UUID                  `json:"getGroupKeyRunId"`
}

func (q *Queries) GetWorkflowRun(ctx context.Context, db DBTX, arg GetWorkflowRunParams) ([]*GetWorkflowRunRow, error) {
	rows, err := db.Query(ctx, getWorkflowRun, arg.Ids, arg.Tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetWorkflowRunRow
	for rows.Next() {
		var i GetWorkflowRunRow
		if err := rows.Scan(
			&i.WorkflowRun.CreatedAt,
			&i.WorkflowRun.UpdatedAt,
			&i.WorkflowRun.DeletedAt,
			&i.WorkflowRun.TenantId,
			&i.WorkflowRun.WorkflowVersionId,
			&i.WorkflowRun.Status,
			&i.WorkflowRun.Error,
			&i.WorkflowRun.StartedAt,
			&i.WorkflowRun.FinishedAt,
			&i.WorkflowRun.ConcurrencyGroupId,
			&i.WorkflowRun.DisplayName,
			&i.WorkflowRun.ID,
			&i.WorkflowRun.GitRepoBranch,
			&i.WorkflowRun.ChildIndex,
			&i.WorkflowRun.ChildKey,
			&i.WorkflowRun.ParentId,
			&i.WorkflowRun.ParentStepRunId,
			&i.WorkflowRun.AdditionalMetadata,
			&i.WorkflowRunTriggeredBy.ID,
			&i.WorkflowRunTriggeredBy.CreatedAt,
			&i.WorkflowRunTriggeredBy.UpdatedAt,
			&i.WorkflowRunTriggeredBy.DeletedAt,
			&i.WorkflowRunTriggeredBy.TenantId,
			&i.WorkflowRunTriggeredBy.EventId,
			&i.WorkflowRunTriggeredBy.CronParentId,
			&i.WorkflowRunTriggeredBy.CronSchedule,
			&i.WorkflowRunTriggeredBy.ScheduledId,
			&i.WorkflowRunTriggeredBy.Input,
			&i.WorkflowRunTriggeredBy.ParentId,
			&i.WorkflowVersion.ID,
			&i.WorkflowVersion.CreatedAt,
			&i.WorkflowVersion.UpdatedAt,
			&i.WorkflowVersion.DeletedAt,
			&i.WorkflowVersion.Version,
			&i.WorkflowVersion.Order,
			&i.WorkflowVersion.WorkflowId,
			&i.WorkflowVersion.Checksum,
			&i.WorkflowVersion.ScheduleTimeout,
			&i.WorkflowVersion.OnFailureJobId,
			&i.WorkflowName,
			&i.ConcurrencyLimitStrategy,
			&i.ConcurrencyMaxRuns,
			&i.GetGroupKeyRunId,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkStepRunParents = `-- name: LinkStepRunParents :exec
INSERT INTO "_StepRunOrder" ("A", "B")
SELECT 
    parent_run."id" AS "A",
    child_run."id" AS "B"
FROM 
    "_StepOrder" AS step_order
JOIN 
    "StepRun" AS parent_run ON parent_run."stepId" = step_order."A" AND parent_run."jobRunId" = $1::uuid
JOIN 
    "StepRun" AS child_run ON child_run."stepId" = step_order."B" AND child_run."jobRunId" = $1::uuid
`

func (q *Queries) LinkStepRunParents(ctx context.Context, db DBTX, jobrunid pgtype.UUID) error {
	_, err := db.Exec(ctx, linkStepRunParents, jobrunid)
	return err
}

const listWorkflowRuns = `-- name: ListWorkflowRuns :many
SELECT
    runs."createdAt", runs."updatedAt", runs."deletedAt", runs."tenantId", runs."workflowVersionId", runs.status, runs.error, runs."startedAt", runs."finishedAt", runs."concurrencyGroupId", runs."displayName", runs.id, runs."gitRepoBranch", runs."childIndex", runs."childKey", runs."parentId", runs."parentStepRunId", runs."additionalMetadata", 
    workflow.id, workflow."createdAt", workflow."updatedAt", workflow."deletedAt", workflow."tenantId", workflow.name, workflow.description, 
    runtriggers.id, runtriggers."createdAt", runtriggers."updatedAt", runtriggers."deletedAt", runtriggers."tenantId", runtriggers."eventId", runtriggers."cronParentId", runtriggers."cronSchedule", runtriggers."scheduledId", runtriggers.input, runtriggers."parentId", 
    workflowversion.id, workflowversion."createdAt", workflowversion."updatedAt", workflowversion."deletedAt", workflowversion.version, workflowversion."order", workflowversion."workflowId", workflowversion.checksum, workflowversion."scheduleTimeout", workflowversion."onFailureJobId", 
    -- waiting on https://github.com/sqlc-dev/sqlc/pull/2858 for nullable events field
    events.id, events.key, events."createdAt", events."updatedAt"
FROM
    "WorkflowRun" as runs 
LEFT JOIN
    "WorkflowRunTriggeredBy" as runTriggers ON runTriggers."parentId" = runs."id"
LEFT JOIN
    "Event" as events ON runTriggers."eventId" = events."id"
LEFT JOIN
    "WorkflowVersion" as workflowVersion ON runs."workflowVersionId" = workflowVersion."id"
LEFT JOIN
    "Workflow" as workflow ON workflowVersion."workflowId" = workflow."id"
WHERE
    runs."tenantId" = $1 AND
    (
        $2::uuid IS NULL OR
        workflowVersion."id" = $2::uuid
    ) AND
    (
        $3::uuid IS NULL OR
        workflow."id" = $3::uuid
    ) AND
    (
        $4::uuid[] IS NULL OR
        runs."id" = ANY($4::uuid[])
    ) AND 
    (
        $5::jsonb IS NULL OR
        runs."additionalMetadata" @> $5::jsonb
    ) AND
    (
        $6::uuid IS NULL OR
        runs."parentId" = $6::uuid
    ) AND
    (
        $7::uuid IS NULL OR
        runs."parentStepRunId" = $7::uuid
    ) AND
    (
        $8::uuid IS NULL OR
        events."id" = $8::uuid
    ) AND
    (
        $9::text IS NULL OR
        runs."concurrencyGroupId" = $9::text
    ) AND
    (
        $10::text[] IS NULL OR
        "status" = ANY(cast($10::text[] as "WorkflowRunStatus"[]))
    ) AND
    (
        $11::timestamp IS NULL OR
        runs."createdAt" > $11::timestamp
    )
ORDER BY
    case when $12 = 'createdAt ASC' THEN runs."createdAt" END ASC ,
    case when $12 = 'createdAt DESC' then runs."createdAt" END DESC
OFFSET
    COALESCE($13, 0)
LIMIT
    COALESCE($14, 50)
`

type ListWorkflowRunsParams struct {
	TenantId           pgtype.UUID      `json:"tenantId"`
	WorkflowVersionId  pgtype.UUID      `json:"workflowVersionId"`
	WorkflowId         pgtype.UUID      `json:"workflowId"`
	Ids                []pgtype.UUID    `json:"ids"`
	AdditionalMetadata []byte           `json:"additionalMetadata"`
	ParentId           pgtype.UUID      `json:"parentId"`
	ParentStepRunId    pgtype.UUID      `json:"parentStepRunId"`
	EventId            pgtype.UUID      `json:"eventId"`
	GroupKey           pgtype.Text      `json:"groupKey"`
	Statuses           []string         `json:"statuses"`
	CreatedAfter       pgtype.Timestamp `json:"createdAfter"`
	Orderby            interface{}      `json:"orderby"`
	Offset             interface{}      `json:"offset"`
	Limit              interface{}      `json:"limit"`
}

type ListWorkflowRunsRow struct {
	WorkflowRun            WorkflowRun            `json:"workflow_run"`
	Workflow               Workflow               `json:"workflow"`
	WorkflowRunTriggeredBy WorkflowRunTriggeredBy `json:"workflow_run_triggered_by"`
	WorkflowVersion        WorkflowVersion        `json:"workflow_version"`
	ID                     pgtype.UUID            `json:"id"`
	Key                    pgtype.Text            `json:"key"`
	CreatedAt              pgtype.Timestamp       `json:"createdAt"`
	UpdatedAt              pgtype.Timestamp       `json:"updatedAt"`
}

func (q *Queries) ListWorkflowRuns(ctx context.Context, db DBTX, arg ListWorkflowRunsParams) ([]*ListWorkflowRunsRow, error) {
	rows, err := db.Query(ctx, listWorkflowRuns,
		arg.TenantId,
		arg.WorkflowVersionId,
		arg.WorkflowId,
		arg.Ids,
		arg.AdditionalMetadata,
		arg.ParentId,
		arg.ParentStepRunId,
		arg.EventId,
		arg.GroupKey,
		arg.Statuses,
		arg.CreatedAfter,
		arg.Orderby,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListWorkflowRunsRow
	for rows.Next() {
		var i ListWorkflowRunsRow
		if err := rows.Scan(
			&i.WorkflowRun.CreatedAt,
			&i.WorkflowRun.UpdatedAt,
			&i.WorkflowRun.DeletedAt,
			&i.WorkflowRun.TenantId,
			&i.WorkflowRun.WorkflowVersionId,
			&i.WorkflowRun.Status,
			&i.WorkflowRun.Error,
			&i.WorkflowRun.StartedAt,
			&i.WorkflowRun.FinishedAt,
			&i.WorkflowRun.ConcurrencyGroupId,
			&i.WorkflowRun.DisplayName,
			&i.WorkflowRun.ID,
			&i.WorkflowRun.GitRepoBranch,
			&i.WorkflowRun.ChildIndex,
			&i.WorkflowRun.ChildKey,
			&i.WorkflowRun.ParentId,
			&i.WorkflowRun.ParentStepRunId,
			&i.WorkflowRun.AdditionalMetadata,
			&i.Workflow.ID,
			&i.Workflow.CreatedAt,
			&i.Workflow.UpdatedAt,
			&i.Workflow.DeletedAt,
			&i.Workflow.TenantId,
			&i.Workflow.Name,
			&i.Workflow.Description,
			&i.WorkflowRunTriggeredBy.ID,
			&i.WorkflowRunTriggeredBy.CreatedAt,
			&i.WorkflowRunTriggeredBy.UpdatedAt,
			&i.WorkflowRunTriggeredBy.DeletedAt,
			&i.WorkflowRunTriggeredBy.TenantId,
			&i.WorkflowRunTriggeredBy.EventId,
			&i.WorkflowRunTriggeredBy.CronParentId,
			&i.WorkflowRunTriggeredBy.CronSchedule,
			&i.WorkflowRunTriggeredBy.ScheduledId,
			&i.WorkflowRunTriggeredBy.Input,
			&i.WorkflowRunTriggeredBy.ParentId,
			&i.WorkflowVersion.ID,
			&i.WorkflowVersion.CreatedAt,
			&i.WorkflowVersion.UpdatedAt,
			&i.WorkflowVersion.DeletedAt,
			&i.WorkflowVersion.Version,
			&i.WorkflowVersion.Order,
			&i.WorkflowVersion.WorkflowId,
			&i.WorkflowVersion.Checksum,
			&i.WorkflowVersion.ScheduleTimeout,
			&i.WorkflowVersion.OnFailureJobId,
			&i.ID,
			&i.Key,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const popWorkflowRunsRoundRobin = `-- name: PopWorkflowRunsRoundRobin :many
WITH workflow_runs AS (
    SELECT
        r2.id,
        r2."status",
        row_number() OVER (PARTITION BY r2."concurrencyGroupId" ORDER BY r2."createdAt") AS rn,
        row_number() over (order by r2."createdAt" ASC) as seqnum
    FROM
        "WorkflowRun" r2
    LEFT JOIN
        "WorkflowVersion" workflowVersion ON r2."workflowVersionId" = workflowVersion."id"
    WHERE
        r2."tenantId" = $1::uuid AND
        (r2."status" = 'QUEUED' OR r2."status" = 'RUNNING') AND
        workflowVersion."workflowId" = $2::uuid
    ORDER BY
        rn, seqnum ASC
), min_rn AS (
    SELECT
        MIN(rn) as min_rn
    FROM
        workflow_runs
), total_group_count AS ( -- counts the number of groups
    SELECT
        COUNT(*) as count
    FROM
        workflow_runs
    WHERE
        rn = (SELECT min_rn FROM min_rn)
), eligible_runs AS (
    SELECT
        id
    FROM
        "WorkflowRun" wr
    WHERE
        wr."id" IN (
            SELECT
                id
            FROM
                workflow_runs
            ORDER BY
                rn, seqnum ASC
            LIMIT
                -- We can run up to maxRuns per group, so we multiple max runs by the number of groups, then subtract the 
                -- total number of running workflows.
                ($3::int) * (SELECT count FROM total_group_count)
        ) AND
        wr."status" = 'QUEUED'
    FOR UPDATE SKIP LOCKED
)
UPDATE "WorkflowRun"
SET
    "status" = 'RUNNING'
FROM
    eligible_runs
WHERE
    "WorkflowRun".id = eligible_runs.id AND
    "WorkflowRun"."status" = 'QUEUED'
RETURNING
    "WorkflowRun"."createdAt", "WorkflowRun"."updatedAt", "WorkflowRun"."deletedAt", "WorkflowRun"."tenantId", "WorkflowRun"."workflowVersionId", "WorkflowRun".status, "WorkflowRun".error, "WorkflowRun"."startedAt", "WorkflowRun"."finishedAt", "WorkflowRun"."concurrencyGroupId", "WorkflowRun"."displayName", "WorkflowRun".id, "WorkflowRun"."gitRepoBranch", "WorkflowRun"."childIndex", "WorkflowRun"."childKey", "WorkflowRun"."parentId", "WorkflowRun"."parentStepRunId", "WorkflowRun"."additionalMetadata"
`

type PopWorkflowRunsRoundRobinParams struct {
	Tenantid   pgtype.UUID `json:"tenantid"`
	Workflowid pgtype.UUID `json:"workflowid"`
	Maxruns    int32       `json:"maxruns"`
}

func (q *Queries) PopWorkflowRunsRoundRobin(ctx context.Context, db DBTX, arg PopWorkflowRunsRoundRobinParams) ([]*WorkflowRun, error) {
	rows, err := db.Query(ctx, popWorkflowRunsRoundRobin, arg.Tenantid, arg.Workflowid, arg.Maxruns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WorkflowRun
	for rows.Next() {
		var i WorkflowRun
		if err := rows.Scan(
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TenantId,
			&i.WorkflowVersionId,
			&i.Status,
			&i.Error,
			&i.StartedAt,
			&i.FinishedAt,
			&i.ConcurrencyGroupId,
			&i.DisplayName,
			&i.ID,
			&i.GitRepoBranch,
			&i.ChildIndex,
			&i.ChildKey,
			&i.ParentId,
			&i.ParentStepRunId,
			&i.AdditionalMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveWorkflowRunStatus = `-- name: ResolveWorkflowRunStatus :one
WITH jobRuns AS (
    SELECT sum(case when runs."status" = 'PENDING' then 1 else 0 end) AS pendingRuns,
        sum(case when runs."status" = 'RUNNING' then 1 else 0 end) AS runningRuns,
        sum(case when runs."status" = 'SUCCEEDED' then 1 else 0 end) AS succeededRuns,
        sum(case when runs."status" = 'FAILED' then 1 else 0 end) AS failedRuns,
        sum(case when runs."status" = 'CANCELLED' then 1 else 0 end) AS cancelledRuns
    FROM "JobRun" as runs
    JOIN "Job" as job ON runs."jobId" = job."id"
    WHERE
        "workflowRunId" = (
            SELECT "workflowRunId"
            FROM "JobRun"
            WHERE "id" = $1::uuid
        ) AND
        runs."tenantId" = $2::uuid AND
        -- we should not include onFailure jobs in the calculation
        job."kind" = 'DEFAULT'
)
UPDATE "WorkflowRun"
SET "status" = CASE 
    -- Final states are final, cannot be updated
    WHEN "status" IN ('SUCCEEDED', 'FAILED') THEN "status"
    -- We check for running first, because if a job run is running, then the workflow is running
    WHEN j.runningRuns > 0 THEN 'RUNNING'
    -- When at least one job run has failed or been cancelled, then the workflow is failed
    WHEN j.failedRuns > 0 OR j.cancelledRuns > 0 THEN 'FAILED'
    -- When all job runs have succeeded, then the workflow is succeeded
    WHEN j.succeededRuns > 0 AND j.pendingRuns = 0 AND j.runningRuns = 0 AND j.failedRuns = 0 AND j.cancelledRuns = 0 THEN 'SUCCEEDED'
    ELSE "status"
END, "finishedAt" = CASE 
    -- Final states are final, cannot be updated
    WHEN "finishedAt" IS NOT NULL THEN "finishedAt"
    -- We check for running first, because if a job run is running, then the workflow is not finished
    WHEN j.runningRuns > 0 THEN NULL
    -- When one job run has failed or been cancelled, then the workflow is failed
    WHEN j.failedRuns > 0 OR j.cancelledRuns > 0 OR j.succeededRuns > 0 THEN NOW()
    ELSE "finishedAt"
END, "startedAt" = CASE 
    -- Started at is final, cannot be changed
    WHEN "startedAt" IS NOT NULL THEN "startedAt"
    -- If a job is running or in a final state, then the workflow has started
    WHEN j.runningRuns > 0 OR j.succeededRuns > 0 OR j.failedRuns > 0 OR j.cancelledRuns > 0 THEN NOW()
    ELSE "startedAt"
END
FROM
    jobRuns j
WHERE "id" = (
    SELECT "workflowRunId"
    FROM "JobRun"
    WHERE "id" = $1::uuid
) AND "tenantId" = $2::uuid
RETURNING "WorkflowRun"."createdAt", "WorkflowRun"."updatedAt", "WorkflowRun"."deletedAt", "WorkflowRun"."tenantId", "WorkflowRun"."workflowVersionId", "WorkflowRun".status, "WorkflowRun".error, "WorkflowRun"."startedAt", "WorkflowRun"."finishedAt", "WorkflowRun"."concurrencyGroupId", "WorkflowRun"."displayName", "WorkflowRun".id, "WorkflowRun"."gitRepoBranch", "WorkflowRun"."childIndex", "WorkflowRun"."childKey", "WorkflowRun"."parentId", "WorkflowRun"."parentStepRunId", "WorkflowRun"."additionalMetadata"
`

type ResolveWorkflowRunStatusParams struct {
	Jobrunid pgtype.UUID `json:"jobrunid"`
	Tenantid pgtype.UUID `json:"tenantid"`
}

func (q *Queries) ResolveWorkflowRunStatus(ctx context.Context, db DBTX, arg ResolveWorkflowRunStatusParams) (*WorkflowRun, error) {
	row := db.QueryRow(ctx, resolveWorkflowRunStatus, arg.Jobrunid, arg.Tenantid)
	var i WorkflowRun
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.WorkflowVersionId,
		&i.Status,
		&i.Error,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ConcurrencyGroupId,
		&i.DisplayName,
		&i.ID,
		&i.GitRepoBranch,
		&i.ChildIndex,
		&i.ChildKey,
		&i.ParentId,
		&i.ParentStepRunId,
		&i.AdditionalMetadata,
	)
	return &i, err
}

const updateManyWorkflowRun = `-- name: UpdateManyWorkflowRun :many
UPDATE
    "WorkflowRun"
SET
    "status" = COALESCE($1::"WorkflowRunStatus", "status"),
    "error" = COALESCE($2::text, "error"),
    "startedAt" = COALESCE($3::timestamp, "startedAt"),
    "finishedAt" = COALESCE($4::timestamp, "finishedAt")
WHERE 
    "tenantId" = $5::uuid AND
    "id" = ANY($6::uuid[])
RETURNING "WorkflowRun"."createdAt", "WorkflowRun"."updatedAt", "WorkflowRun"."deletedAt", "WorkflowRun"."tenantId", "WorkflowRun"."workflowVersionId", "WorkflowRun".status, "WorkflowRun".error, "WorkflowRun"."startedAt", "WorkflowRun"."finishedAt", "WorkflowRun"."concurrencyGroupId", "WorkflowRun"."displayName", "WorkflowRun".id, "WorkflowRun"."gitRepoBranch", "WorkflowRun"."childIndex", "WorkflowRun"."childKey", "WorkflowRun"."parentId", "WorkflowRun"."parentStepRunId", "WorkflowRun"."additionalMetadata"
`

type UpdateManyWorkflowRunParams struct {
	Status     NullWorkflowRunStatus `json:"status"`
	Error      pgtype.Text           `json:"error"`
	StartedAt  pgtype.Timestamp      `json:"startedAt"`
	FinishedAt pgtype.Timestamp      `json:"finishedAt"`
	Tenantid   pgtype.UUID           `json:"tenantid"`
	Ids        []pgtype.UUID         `json:"ids"`
}

func (q *Queries) UpdateManyWorkflowRun(ctx context.Context, db DBTX, arg UpdateManyWorkflowRunParams) ([]*WorkflowRun, error) {
	rows, err := db.Query(ctx, updateManyWorkflowRun,
		arg.Status,
		arg.Error,
		arg.StartedAt,
		arg.FinishedAt,
		arg.Tenantid,
		arg.Ids,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WorkflowRun
	for rows.Next() {
		var i WorkflowRun
		if err := rows.Scan(
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TenantId,
			&i.WorkflowVersionId,
			&i.Status,
			&i.Error,
			&i.StartedAt,
			&i.FinishedAt,
			&i.ConcurrencyGroupId,
			&i.DisplayName,
			&i.ID,
			&i.GitRepoBranch,
			&i.ChildIndex,
			&i.ChildKey,
			&i.ParentId,
			&i.ParentStepRunId,
			&i.AdditionalMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWorkflowRun = `-- name: UpdateWorkflowRun :one
UPDATE
    "WorkflowRun"
SET
    "status" = CASE 
    -- Final states are final, cannot be updated
        WHEN "status" IN ('SUCCEEDED', 'FAILED') THEN "status"
        ELSE COALESCE($1::"WorkflowRunStatus", "status")
    END,
    "error" = COALESCE($2::text, "error"),
    "startedAt" = COALESCE($3::timestamp, "startedAt"),
    "finishedAt" = COALESCE($4::timestamp, "finishedAt")
WHERE 
    "id" = $5::uuid AND
    "tenantId" = $6::uuid
RETURNING "WorkflowRun"."createdAt", "WorkflowRun"."updatedAt", "WorkflowRun"."deletedAt", "WorkflowRun"."tenantId", "WorkflowRun"."workflowVersionId", "WorkflowRun".status, "WorkflowRun".error, "WorkflowRun"."startedAt", "WorkflowRun"."finishedAt", "WorkflowRun"."concurrencyGroupId", "WorkflowRun"."displayName", "WorkflowRun".id, "WorkflowRun"."gitRepoBranch", "WorkflowRun"."childIndex", "WorkflowRun"."childKey", "WorkflowRun"."parentId", "WorkflowRun"."parentStepRunId", "WorkflowRun"."additionalMetadata"
`

type UpdateWorkflowRunParams struct {
	Status     NullWorkflowRunStatus `json:"status"`
	Error      pgtype.Text           `json:"error"`
	StartedAt  pgtype.Timestamp      `json:"startedAt"`
	FinishedAt pgtype.Timestamp      `json:"finishedAt"`
	ID         pgtype.UUID           `json:"id"`
	Tenantid   pgtype.UUID           `json:"tenantid"`
}

func (q *Queries) UpdateWorkflowRun(ctx context.Context, db DBTX, arg UpdateWorkflowRunParams) (*WorkflowRun, error) {
	row := db.QueryRow(ctx, updateWorkflowRun,
		arg.Status,
		arg.Error,
		arg.StartedAt,
		arg.FinishedAt,
		arg.ID,
		arg.Tenantid,
	)
	var i WorkflowRun
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.WorkflowVersionId,
		&i.Status,
		&i.Error,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ConcurrencyGroupId,
		&i.DisplayName,
		&i.ID,
		&i.GitRepoBranch,
		&i.ChildIndex,
		&i.ChildKey,
		&i.ParentId,
		&i.ParentStepRunId,
		&i.AdditionalMetadata,
	)
	return &i, err
}

const updateWorkflowRunGroupKey = `-- name: UpdateWorkflowRunGroupKey :one
WITH groupKeyRun AS (
    SELECT "id", "status" as groupKeyRunStatus, "output", "workflowRunId"
    FROM "GetGroupKeyRun" as groupKeyRun
    WHERE
        "id" = $2::uuid AND
        "tenantId" = $1::uuid
)
UPDATE "WorkflowRun" workflowRun
SET "status" = CASE 
    -- Final states are final, cannot be updated. We also can't move out of a queued state
    WHEN "status" IN ('SUCCEEDED', 'FAILED', 'QUEUED') THEN "status"
    -- When the GetGroupKeyRun failed or been cancelled, then the workflow is failed
    WHEN groupKeyRun.groupKeyRunStatus IN ('FAILED', 'CANCELLED') THEN 'FAILED'
    WHEN groupKeyRun.output IS NOT NULL THEN 'QUEUED'
    ELSE "status"
END, "finishedAt" = CASE 
    -- Final states are final, cannot be updated
    WHEN "finishedAt" IS NOT NULL THEN "finishedAt"
    -- When one job run has failed or been cancelled, then the workflow is failed
    WHEN groupKeyRun.groupKeyRunStatus IN ('FAILED', 'CANCELLED') THEN NOW()
    ELSE "finishedAt"
END, 
"concurrencyGroupId" = groupKeyRun."output"
FROM
    groupKeyRun
WHERE 
workflowRun."id" = groupKeyRun."workflowRunId" AND
workflowRun."tenantId" = $1::uuid
RETURNING workflowrun."createdAt", workflowrun."updatedAt", workflowrun."deletedAt", workflowrun."tenantId", workflowrun."workflowVersionId", workflowrun.status, workflowrun.error, workflowrun."startedAt", workflowrun."finishedAt", workflowrun."concurrencyGroupId", workflowrun."displayName", workflowrun.id, workflowrun."gitRepoBranch", workflowrun."childIndex", workflowrun."childKey", workflowrun."parentId", workflowrun."parentStepRunId", workflowrun."additionalMetadata"
`

type UpdateWorkflowRunGroupKeyParams struct {
	Tenantid      pgtype.UUID `json:"tenantid"`
	Groupkeyrunid pgtype.UUID `json:"groupkeyrunid"`
}

func (q *Queries) UpdateWorkflowRunGroupKey(ctx context.Context, db DBTX, arg UpdateWorkflowRunGroupKeyParams) (*WorkflowRun, error) {
	row := db.QueryRow(ctx, updateWorkflowRunGroupKey, arg.Tenantid, arg.Groupkeyrunid)
	var i WorkflowRun
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.WorkflowVersionId,
		&i.Status,
		&i.Error,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ConcurrencyGroupId,
		&i.DisplayName,
		&i.ID,
		&i.GitRepoBranch,
		&i.ChildIndex,
		&i.ChildKey,
		&i.ParentId,
		&i.ParentStepRunId,
		&i.AdditionalMetadata,
	)
	return &i, err
}

const workflowRunsMetricsCount = `-- name: WorkflowRunsMetricsCount :one
SELECT
    COUNT(CASE WHEN runs."status" = 'PENDING' THEN 1 END) AS "PENDING",
    COUNT(CASE WHEN runs."status" = 'RUNNING' THEN 1 END) AS "RUNNING",
    COUNT(CASE WHEN runs."status" = 'SUCCEEDED' THEN 1 END) AS "SUCCEEDED",
    COUNT(CASE WHEN runs."status" = 'FAILED' THEN 1 END) AS "FAILED",
    COUNT(CASE WHEN runs."status" = 'QUEUED' THEN 1 END) AS "QUEUED"
FROM
    "WorkflowRun" as runs
LEFT JOIN
    "WorkflowRunTriggeredBy" as runTriggers ON runTriggers."parentId" = runs."id"
LEFT JOIN
    "Event" as events ON runTriggers."eventId" = events."id"
LEFT JOIN
    "WorkflowVersion" as workflowVersion ON runs."workflowVersionId" = workflowVersion."id"
LEFT JOIN
    "Workflow" as workflow ON workflowVersion."workflowId" = workflow."id"
WHERE
    runs."tenantId" = $1::uuid AND
    (
        $2::uuid IS NULL OR
        workflow."id" = $2::uuid
    ) AND
    (
        $3::uuid IS NULL OR
        runs."parentId" = $3::uuid
    ) AND
    (
        $4::uuid IS NULL OR
        runs."parentStepRunId" = $4::uuid
    ) AND
    (
        $5::jsonb IS NULL OR
        runs."additionalMetadata" @> $5::jsonb
    ) AND
    (
        $6::uuid IS NULL OR
        events."id" = $6::uuid
    )
`

type WorkflowRunsMetricsCountParams struct {
	Tenantid           pgtype.UUID `json:"tenantid"`
	WorkflowId         pgtype.UUID `json:"workflowId"`
	ParentId           pgtype.UUID `json:"parentId"`
	ParentStepRunId    pgtype.UUID `json:"parentStepRunId"`
	AdditionalMetadata []byte      `json:"additionalMetadata"`
	EventId            pgtype.UUID `json:"eventId"`
}

type WorkflowRunsMetricsCountRow struct {
	PENDING   int64 `json:"PENDING"`
	RUNNING   int64 `json:"RUNNING"`
	SUCCEEDED int64 `json:"SUCCEEDED"`
	FAILED    int64 `json:"FAILED"`
	QUEUED    int64 `json:"QUEUED"`
}

func (q *Queries) WorkflowRunsMetricsCount(ctx context.Context, db DBTX, arg WorkflowRunsMetricsCountParams) (*WorkflowRunsMetricsCountRow, error) {
	row := db.QueryRow(ctx, workflowRunsMetricsCount,
		arg.Tenantid,
		arg.WorkflowId,
		arg.ParentId,
		arg.ParentStepRunId,
		arg.AdditionalMetadata,
		arg.EventId,
	)
	var i WorkflowRunsMetricsCountRow
	err := row.Scan(
		&i.PENDING,
		&i.RUNNING,
		&i.SUCCEEDED,
		&i.FAILED,
		&i.QUEUED,
	)
	return &i, err
}
