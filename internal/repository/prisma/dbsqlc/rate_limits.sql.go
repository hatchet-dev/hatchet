// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: rate_limits.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const upsertRateLimit = `-- name: UpsertRateLimit :one
INSERT INTO "RateLimit" (
    "tenantId", 
    "key", 
    "limitValue", 
    "value", 
    "window"
) VALUES (
    $1::uuid,
    $2::text,
    $3::int,
    $3::int,
    COALESCE($4::text, '1 minute')
) ON CONFLICT ("tenantId", "key") DO UPDATE SET 
    "limitValue" = $3::int,
    "window" = COALESCE($4::text, '1 minute')
RETURNING "tenantId", key, "limitValue", value, "window", "lastRefill"
`

type UpsertRateLimitParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Key      string      `json:"key"`
	Limit    int32       `json:"limit"`
	Window   pgtype.Text `json:"window"`
}

func (q *Queries) UpsertRateLimit(ctx context.Context, db DBTX, arg UpsertRateLimitParams) (*RateLimit, error) {
	row := db.QueryRow(ctx, upsertRateLimit,
		arg.Tenantid,
		arg.Key,
		arg.Limit,
		arg.Window,
	)
	var i RateLimit
	err := row.Scan(
		&i.TenantId,
		&i.Key,
		&i.LimitValue,
		&i.Value,
		&i.Window,
		&i.LastRefill,
	)
	return &i, err
}
