// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: tenant_limits.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTenantResourceLimit = `-- name: CreateTenantResourceLimit :one
INSERT INTO "TenantResourceLimit" ("id", "tenantId", "resource", "value", "limitValue", "alarmValue", "window", "lastRefill")
VALUES (gen_random_uuid(), $1::uuid, $2::"LimitResource", 0, $3::int, $4::int, $5::text, CURRENT_TIMESTAMP)
RETURNING id, resource, "tenantId", "limitValue", "alarmValue", value, "window", "lastRefill"
`

type CreateTenantResourceLimitParams struct {
	Tenantid   pgtype.UUID       `json:"tenantid"`
	Resource   NullLimitResource `json:"resource"`
	LimitValue pgtype.Int4       `json:"limitValue"`
	AlarmValue pgtype.Int4       `json:"alarmValue"`
	Window     pgtype.Text       `json:"window"`
}

func (q *Queries) CreateTenantResourceLimit(ctx context.Context, db DBTX, arg CreateTenantResourceLimitParams) (*TenantResourceLimit, error) {
	row := db.QueryRow(ctx, createTenantResourceLimit,
		arg.Tenantid,
		arg.Resource,
		arg.LimitValue,
		arg.AlarmValue,
		arg.Window,
	)
	var i TenantResourceLimit
	err := row.Scan(
		&i.ID,
		&i.Resource,
		&i.TenantId,
		&i.LimitValue,
		&i.AlarmValue,
		&i.Value,
		&i.Window,
		&i.LastRefill,
	)
	return &i, err
}

const getTenantResourceLimit = `-- name: GetTenantResourceLimit :one
WITH updated AS (
    UPDATE "TenantResourceLimit"
    SET
        "value" = 0, -- Reset to 0 if the window has passed
        "lastRefill" = CURRENT_TIMESTAMP -- Update lastRefill if the window has passed
    WHERE "tenantId" = $1::uuid
      AND NOW() - "lastRefill" >= "window"::INTERVAL
      AND "resource" = $2::"LimitResource"
    RETURNING id, resource, "tenantId", "limitValue", "alarmValue", value, "window", "lastRefill"
)
SELECT id, resource, "tenantId", "limitValue", "alarmValue", value, "window", "lastRefill" FROM updated
UNION ALL
SELECT id, resource, "tenantId", "limitValue", "alarmValue", value, "window", "lastRefill" FROM "TenantResourceLimit"
WHERE "tenantId" = $1::uuid
    AND "resource" = $2::"LimitResource"
    AND NOT EXISTS (SELECT 1 FROM updated)
`

type GetTenantResourceLimitParams struct {
	Tenantid pgtype.UUID       `json:"tenantid"`
	Resource NullLimitResource `json:"resource"`
}

type GetTenantResourceLimitRow struct {
	ID         pgtype.UUID      `json:"id"`
	Resource   LimitResource    `json:"resource"`
	TenantId   pgtype.UUID      `json:"tenantId"`
	LimitValue int32            `json:"limitValue"`
	AlarmValue pgtype.Int4      `json:"alarmValue"`
	Value      int32            `json:"value"`
	Window     string           `json:"window"`
	LastRefill pgtype.Timestamp `json:"lastRefill"`
}

func (q *Queries) GetTenantResourceLimit(ctx context.Context, db DBTX, arg GetTenantResourceLimitParams) (*GetTenantResourceLimitRow, error) {
	row := db.QueryRow(ctx, getTenantResourceLimit, arg.Tenantid, arg.Resource)
	var i GetTenantResourceLimitRow
	err := row.Scan(
		&i.ID,
		&i.Resource,
		&i.TenantId,
		&i.LimitValue,
		&i.AlarmValue,
		&i.Value,
		&i.Window,
		&i.LastRefill,
	)
	return &i, err
}

const meterTenantResource = `-- name: MeterTenantResource :one
UPDATE "TenantResourceLimit"
SET
    "value" = CASE
        WHEN NOW() - "lastRefill" >= "window"::INTERVAL THEN
            0 -- Refill to 0 since the window has passed
        ELSE
            "value" + 1 -- Increment the current value within the window
    END,
    "lastRefill" = CASE
        WHEN NOW() - "lastRefill" >= "window"::INTERVAL THEN
            CURRENT_TIMESTAMP -- Update lastRefill if the window has passed
        ELSE
            "lastRefill" -- Keep the lastRefill unchanged if within the window
    END
WHERE "tenantId" = $1::uuid
    AND "resource" = $2::"LimitResource"
RETURNING id, resource, "tenantId", "limitValue", "alarmValue", value, "window", "lastRefill"
`

type MeterTenantResourceParams struct {
	Tenantid pgtype.UUID       `json:"tenantid"`
	Resource NullLimitResource `json:"resource"`
}

func (q *Queries) MeterTenantResource(ctx context.Context, db DBTX, arg MeterTenantResourceParams) (*TenantResourceLimit, error) {
	row := db.QueryRow(ctx, meterTenantResource, arg.Tenantid, arg.Resource)
	var i TenantResourceLimit
	err := row.Scan(
		&i.ID,
		&i.Resource,
		&i.TenantId,
		&i.LimitValue,
		&i.AlarmValue,
		&i.Value,
		&i.Window,
		&i.LastRefill,
	)
	return &i, err
}
