// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: tenant_limits.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTenantWorkers = `-- name: CountTenantWorkers :one
SELECT COUNT(distinct id) AS "count"
FROM "Worker"
WHERE "tenantId" = $1::uuid
AND "lastHeartbeatAt" >= NOW() - '30 seconds'::INTERVAL
AND "isActive" = true
`

func (q *Queries) CountTenantWorkers(ctx context.Context, db DBTX, tenantid pgtype.UUID) (int64, error) {
	row := db.QueryRow(ctx, countTenantWorkers, tenantid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTenantResourceLimit = `-- name: CreateTenantResourceLimit :one
INSERT INTO "TenantResourceLimit" ("id", "tenantId", "resource", "value", "limitValue", "alarmValue", "window", "lastRefill")
VALUES (gen_random_uuid(), $1::uuid, $2::"LimitResource", 0, $3::int, $4::int, $5::text, CURRENT_TIMESTAMP)
RETURNING id, resource, "tenantId", "limitValue", "alarmValue", value, "window", "lastRefill", "createdAt", "updatedAt"
`

type CreateTenantResourceLimitParams struct {
	Tenantid   pgtype.UUID       `json:"tenantid"`
	Resource   NullLimitResource `json:"resource"`
	LimitValue pgtype.Int4       `json:"limitValue"`
	AlarmValue pgtype.Int4       `json:"alarmValue"`
	Window     pgtype.Text       `json:"window"`
}

func (q *Queries) CreateTenantResourceLimit(ctx context.Context, db DBTX, arg CreateTenantResourceLimitParams) (*TenantResourceLimit, error) {
	row := db.QueryRow(ctx, createTenantResourceLimit,
		arg.Tenantid,
		arg.Resource,
		arg.LimitValue,
		arg.AlarmValue,
		arg.Window,
	)
	var i TenantResourceLimit
	err := row.Scan(
		&i.ID,
		&i.Resource,
		&i.TenantId,
		&i.LimitValue,
		&i.AlarmValue,
		&i.Value,
		&i.Window,
		&i.LastRefill,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getTenantResourceLimit = `-- name: GetTenantResourceLimit :one
WITH updated AS (
    UPDATE "TenantResourceLimit"
    SET
        "value" = 0, -- Reset to 0 if the window has passed
        "lastRefill" = CURRENT_TIMESTAMP -- Update lastRefill if the window has passed
    WHERE "tenantId" = $1::uuid
      AND (("window" IS NOT NULL AND "window" != '' AND NOW() - "lastRefill" >= "window"::INTERVAL) OR "window" IS NULL OR "window" = '')
      AND "resource" = $2::"LimitResource"
    RETURNING id, resource, "tenantId", "limitValue", "alarmValue", value, "window", "lastRefill", "createdAt", "updatedAt"
)
SELECT id, resource, "tenantId", "limitValue", "alarmValue", value, "window", "lastRefill", "createdAt", "updatedAt" FROM updated
UNION ALL
SELECT id, resource, "tenantId", "limitValue", "alarmValue", value, "window", "lastRefill", "createdAt", "updatedAt" FROM "TenantResourceLimit"
WHERE "tenantId" = $1::uuid
    AND "resource" = $2::"LimitResource"
    AND NOT EXISTS (SELECT 1 FROM updated)
`

type GetTenantResourceLimitParams struct {
	Tenantid pgtype.UUID       `json:"tenantid"`
	Resource NullLimitResource `json:"resource"`
}

type GetTenantResourceLimitRow struct {
	ID         pgtype.UUID      `json:"id"`
	Resource   LimitResource    `json:"resource"`
	TenantId   pgtype.UUID      `json:"tenantId"`
	LimitValue int32            `json:"limitValue"`
	AlarmValue pgtype.Int4      `json:"alarmValue"`
	Value      int32            `json:"value"`
	Window     pgtype.Text      `json:"window"`
	LastRefill pgtype.Timestamp `json:"lastRefill"`
	CreatedAt  pgtype.Timestamp `json:"createdAt"`
	UpdatedAt  pgtype.Timestamp `json:"updatedAt"`
}

func (q *Queries) GetTenantResourceLimit(ctx context.Context, db DBTX, arg GetTenantResourceLimitParams) (*GetTenantResourceLimitRow, error) {
	row := db.QueryRow(ctx, getTenantResourceLimit, arg.Tenantid, arg.Resource)
	var i GetTenantResourceLimitRow
	err := row.Scan(
		&i.ID,
		&i.Resource,
		&i.TenantId,
		&i.LimitValue,
		&i.AlarmValue,
		&i.Value,
		&i.Window,
		&i.LastRefill,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listTenantResourceLimits = `-- name: ListTenantResourceLimits :many
SELECT id, resource, "tenantId", "limitValue", "alarmValue", value, "window", "lastRefill", "createdAt", "updatedAt" FROM "TenantResourceLimit"
WHERE "tenantId" = $1::uuid
`

func (q *Queries) ListTenantResourceLimits(ctx context.Context, db DBTX, tenantid pgtype.UUID) ([]*TenantResourceLimit, error) {
	rows, err := db.Query(ctx, listTenantResourceLimits, tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*TenantResourceLimit
	for rows.Next() {
		var i TenantResourceLimit
		if err := rows.Scan(
			&i.ID,
			&i.Resource,
			&i.TenantId,
			&i.LimitValue,
			&i.AlarmValue,
			&i.Value,
			&i.Window,
			&i.LastRefill,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const meterTenantResource = `-- name: MeterTenantResource :one
UPDATE "TenantResourceLimit"
SET
    "value" = CASE
        WHEN ("window" IS NOT NULL AND "window" != '' AND NOW() - "lastRefill" >= "window"::INTERVAL) THEN
            0 -- Refill to 0 since the window has passed
        ELSE
            "value" + 1 -- Increment the current value within the window
    END,
    "lastRefill" = CASE
        WHEN ("window" IS NOT NULL AND "window" != '' AND NOW() - "lastRefill" >= "window"::INTERVAL) THEN
            CURRENT_TIMESTAMP -- Update lastRefill if the window has passed
        ELSE
            "lastRefill" -- Keep the lastRefill unchanged if within the window
    END
WHERE "tenantId" = $1::uuid
    AND "resource" = $2::"LimitResource"
RETURNING id, resource, "tenantId", "limitValue", "alarmValue", value, "window", "lastRefill", "createdAt", "updatedAt"
`

type MeterTenantResourceParams struct {
	Tenantid pgtype.UUID       `json:"tenantid"`
	Resource NullLimitResource `json:"resource"`
}

func (q *Queries) MeterTenantResource(ctx context.Context, db DBTX, arg MeterTenantResourceParams) (*TenantResourceLimit, error) {
	row := db.QueryRow(ctx, meterTenantResource, arg.Tenantid, arg.Resource)
	var i TenantResourceLimit
	err := row.Scan(
		&i.ID,
		&i.Resource,
		&i.TenantId,
		&i.LimitValue,
		&i.AlarmValue,
		&i.Value,
		&i.Window,
		&i.LastRefill,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
