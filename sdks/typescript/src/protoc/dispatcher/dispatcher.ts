// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.19.1
// source: dispatcher/dispatcher.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import { type CallContext, type CallOptions } from 'nice-grpc-common';
import { Timestamp } from '../google/protobuf/timestamp';

export const protobufPackage = '';

export enum SDKS {
  UNKNOWN = 0,
  GO = 1,
  PYTHON = 2,
  TYPESCRIPT = 3,
  UNRECOGNIZED = -1,
}

export function sDKSFromJSON(object: any): SDKS {
  switch (object) {
    case 0:
    case 'UNKNOWN':
      return SDKS.UNKNOWN;
    case 1:
    case 'GO':
      return SDKS.GO;
    case 2:
    case 'PYTHON':
      return SDKS.PYTHON;
    case 3:
    case 'TYPESCRIPT':
      return SDKS.TYPESCRIPT;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return SDKS.UNRECOGNIZED;
  }
}

export function sDKSToJSON(object: SDKS): string {
  switch (object) {
    case SDKS.UNKNOWN:
      return 'UNKNOWN';
    case SDKS.GO:
      return 'GO';
    case SDKS.PYTHON:
      return 'PYTHON';
    case SDKS.TYPESCRIPT:
      return 'TYPESCRIPT';
    case SDKS.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum ActionType {
  START_STEP_RUN = 0,
  CANCEL_STEP_RUN = 1,
  START_GET_GROUP_KEY = 2,
  UNRECOGNIZED = -1,
}

export function actionTypeFromJSON(object: any): ActionType {
  switch (object) {
    case 0:
    case 'START_STEP_RUN':
      return ActionType.START_STEP_RUN;
    case 1:
    case 'CANCEL_STEP_RUN':
      return ActionType.CANCEL_STEP_RUN;
    case 2:
    case 'START_GET_GROUP_KEY':
      return ActionType.START_GET_GROUP_KEY;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return ActionType.UNRECOGNIZED;
  }
}

export function actionTypeToJSON(object: ActionType): string {
  switch (object) {
    case ActionType.START_STEP_RUN:
      return 'START_STEP_RUN';
    case ActionType.CANCEL_STEP_RUN:
      return 'CANCEL_STEP_RUN';
    case ActionType.START_GET_GROUP_KEY:
      return 'START_GET_GROUP_KEY';
    case ActionType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum GroupKeyActionEventType {
  GROUP_KEY_EVENT_TYPE_UNKNOWN = 0,
  GROUP_KEY_EVENT_TYPE_STARTED = 1,
  GROUP_KEY_EVENT_TYPE_COMPLETED = 2,
  GROUP_KEY_EVENT_TYPE_FAILED = 3,
  UNRECOGNIZED = -1,
}

export function groupKeyActionEventTypeFromJSON(object: any): GroupKeyActionEventType {
  switch (object) {
    case 0:
    case 'GROUP_KEY_EVENT_TYPE_UNKNOWN':
      return GroupKeyActionEventType.GROUP_KEY_EVENT_TYPE_UNKNOWN;
    case 1:
    case 'GROUP_KEY_EVENT_TYPE_STARTED':
      return GroupKeyActionEventType.GROUP_KEY_EVENT_TYPE_STARTED;
    case 2:
    case 'GROUP_KEY_EVENT_TYPE_COMPLETED':
      return GroupKeyActionEventType.GROUP_KEY_EVENT_TYPE_COMPLETED;
    case 3:
    case 'GROUP_KEY_EVENT_TYPE_FAILED':
      return GroupKeyActionEventType.GROUP_KEY_EVENT_TYPE_FAILED;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return GroupKeyActionEventType.UNRECOGNIZED;
  }
}

export function groupKeyActionEventTypeToJSON(object: GroupKeyActionEventType): string {
  switch (object) {
    case GroupKeyActionEventType.GROUP_KEY_EVENT_TYPE_UNKNOWN:
      return 'GROUP_KEY_EVENT_TYPE_UNKNOWN';
    case GroupKeyActionEventType.GROUP_KEY_EVENT_TYPE_STARTED:
      return 'GROUP_KEY_EVENT_TYPE_STARTED';
    case GroupKeyActionEventType.GROUP_KEY_EVENT_TYPE_COMPLETED:
      return 'GROUP_KEY_EVENT_TYPE_COMPLETED';
    case GroupKeyActionEventType.GROUP_KEY_EVENT_TYPE_FAILED:
      return 'GROUP_KEY_EVENT_TYPE_FAILED';
    case GroupKeyActionEventType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum StepActionEventType {
  STEP_EVENT_TYPE_UNKNOWN = 0,
  STEP_EVENT_TYPE_STARTED = 1,
  STEP_EVENT_TYPE_COMPLETED = 2,
  STEP_EVENT_TYPE_FAILED = 3,
  STEP_EVENT_TYPE_ACKNOWLEDGED = 4,
  UNRECOGNIZED = -1,
}

export function stepActionEventTypeFromJSON(object: any): StepActionEventType {
  switch (object) {
    case 0:
    case 'STEP_EVENT_TYPE_UNKNOWN':
      return StepActionEventType.STEP_EVENT_TYPE_UNKNOWN;
    case 1:
    case 'STEP_EVENT_TYPE_STARTED':
      return StepActionEventType.STEP_EVENT_TYPE_STARTED;
    case 2:
    case 'STEP_EVENT_TYPE_COMPLETED':
      return StepActionEventType.STEP_EVENT_TYPE_COMPLETED;
    case 3:
    case 'STEP_EVENT_TYPE_FAILED':
      return StepActionEventType.STEP_EVENT_TYPE_FAILED;
    case 4:
    case 'STEP_EVENT_TYPE_ACKNOWLEDGED':
      return StepActionEventType.STEP_EVENT_TYPE_ACKNOWLEDGED;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return StepActionEventType.UNRECOGNIZED;
  }
}

export function stepActionEventTypeToJSON(object: StepActionEventType): string {
  switch (object) {
    case StepActionEventType.STEP_EVENT_TYPE_UNKNOWN:
      return 'STEP_EVENT_TYPE_UNKNOWN';
    case StepActionEventType.STEP_EVENT_TYPE_STARTED:
      return 'STEP_EVENT_TYPE_STARTED';
    case StepActionEventType.STEP_EVENT_TYPE_COMPLETED:
      return 'STEP_EVENT_TYPE_COMPLETED';
    case StepActionEventType.STEP_EVENT_TYPE_FAILED:
      return 'STEP_EVENT_TYPE_FAILED';
    case StepActionEventType.STEP_EVENT_TYPE_ACKNOWLEDGED:
      return 'STEP_EVENT_TYPE_ACKNOWLEDGED';
    case StepActionEventType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum ResourceType {
  RESOURCE_TYPE_UNKNOWN = 0,
  RESOURCE_TYPE_STEP_RUN = 1,
  RESOURCE_TYPE_WORKFLOW_RUN = 2,
  UNRECOGNIZED = -1,
}

export function resourceTypeFromJSON(object: any): ResourceType {
  switch (object) {
    case 0:
    case 'RESOURCE_TYPE_UNKNOWN':
      return ResourceType.RESOURCE_TYPE_UNKNOWN;
    case 1:
    case 'RESOURCE_TYPE_STEP_RUN':
      return ResourceType.RESOURCE_TYPE_STEP_RUN;
    case 2:
    case 'RESOURCE_TYPE_WORKFLOW_RUN':
      return ResourceType.RESOURCE_TYPE_WORKFLOW_RUN;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return ResourceType.UNRECOGNIZED;
  }
}

export function resourceTypeToJSON(object: ResourceType): string {
  switch (object) {
    case ResourceType.RESOURCE_TYPE_UNKNOWN:
      return 'RESOURCE_TYPE_UNKNOWN';
    case ResourceType.RESOURCE_TYPE_STEP_RUN:
      return 'RESOURCE_TYPE_STEP_RUN';
    case ResourceType.RESOURCE_TYPE_WORKFLOW_RUN:
      return 'RESOURCE_TYPE_WORKFLOW_RUN';
    case ResourceType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum ResourceEventType {
  RESOURCE_EVENT_TYPE_UNKNOWN = 0,
  RESOURCE_EVENT_TYPE_STARTED = 1,
  RESOURCE_EVENT_TYPE_COMPLETED = 2,
  RESOURCE_EVENT_TYPE_FAILED = 3,
  RESOURCE_EVENT_TYPE_CANCELLED = 4,
  RESOURCE_EVENT_TYPE_TIMED_OUT = 5,
  RESOURCE_EVENT_TYPE_STREAM = 6,
  UNRECOGNIZED = -1,
}

export function resourceEventTypeFromJSON(object: any): ResourceEventType {
  switch (object) {
    case 0:
    case 'RESOURCE_EVENT_TYPE_UNKNOWN':
      return ResourceEventType.RESOURCE_EVENT_TYPE_UNKNOWN;
    case 1:
    case 'RESOURCE_EVENT_TYPE_STARTED':
      return ResourceEventType.RESOURCE_EVENT_TYPE_STARTED;
    case 2:
    case 'RESOURCE_EVENT_TYPE_COMPLETED':
      return ResourceEventType.RESOURCE_EVENT_TYPE_COMPLETED;
    case 3:
    case 'RESOURCE_EVENT_TYPE_FAILED':
      return ResourceEventType.RESOURCE_EVENT_TYPE_FAILED;
    case 4:
    case 'RESOURCE_EVENT_TYPE_CANCELLED':
      return ResourceEventType.RESOURCE_EVENT_TYPE_CANCELLED;
    case 5:
    case 'RESOURCE_EVENT_TYPE_TIMED_OUT':
      return ResourceEventType.RESOURCE_EVENT_TYPE_TIMED_OUT;
    case 6:
    case 'RESOURCE_EVENT_TYPE_STREAM':
      return ResourceEventType.RESOURCE_EVENT_TYPE_STREAM;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return ResourceEventType.UNRECOGNIZED;
  }
}

export function resourceEventTypeToJSON(object: ResourceEventType): string {
  switch (object) {
    case ResourceEventType.RESOURCE_EVENT_TYPE_UNKNOWN:
      return 'RESOURCE_EVENT_TYPE_UNKNOWN';
    case ResourceEventType.RESOURCE_EVENT_TYPE_STARTED:
      return 'RESOURCE_EVENT_TYPE_STARTED';
    case ResourceEventType.RESOURCE_EVENT_TYPE_COMPLETED:
      return 'RESOURCE_EVENT_TYPE_COMPLETED';
    case ResourceEventType.RESOURCE_EVENT_TYPE_FAILED:
      return 'RESOURCE_EVENT_TYPE_FAILED';
    case ResourceEventType.RESOURCE_EVENT_TYPE_CANCELLED:
      return 'RESOURCE_EVENT_TYPE_CANCELLED';
    case ResourceEventType.RESOURCE_EVENT_TYPE_TIMED_OUT:
      return 'RESOURCE_EVENT_TYPE_TIMED_OUT';
    case ResourceEventType.RESOURCE_EVENT_TYPE_STREAM:
      return 'RESOURCE_EVENT_TYPE_STREAM';
    case ResourceEventType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum WorkflowRunEventType {
  WORKFLOW_RUN_EVENT_TYPE_FINISHED = 0,
  UNRECOGNIZED = -1,
}

export function workflowRunEventTypeFromJSON(object: any): WorkflowRunEventType {
  switch (object) {
    case 0:
    case 'WORKFLOW_RUN_EVENT_TYPE_FINISHED':
      return WorkflowRunEventType.WORKFLOW_RUN_EVENT_TYPE_FINISHED;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return WorkflowRunEventType.UNRECOGNIZED;
  }
}

export function workflowRunEventTypeToJSON(object: WorkflowRunEventType): string {
  switch (object) {
    case WorkflowRunEventType.WORKFLOW_RUN_EVENT_TYPE_FINISHED:
      return 'WORKFLOW_RUN_EVENT_TYPE_FINISHED';
    case WorkflowRunEventType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface WorkerLabels {
  /** value of the label */
  strValue?: string | undefined;
  intValue?: number | undefined;
}

export interface RuntimeInfo {
  sdkVersion?: string | undefined;
  language?: SDKS | undefined;
  languageVersion?: string | undefined;
  os?: string | undefined;
  extra?: string | undefined;
}

export interface WorkerRegisterRequest {
  /** the name of the worker */
  workerName: string;
  /** a list of actions that this worker can run */
  actions: string[];
  /** (optional) the services for this worker */
  services: string[];
  /** (optional) the max number of runs this worker can handle */
  maxRuns?: number | undefined;
  /** (optional) worker labels (i.e. state or other metadata) */
  labels: { [key: string]: WorkerLabels };
  /** (optional) webhookId is the id of the webhook that the worker is associated with (if any) */
  webhookId?: string | undefined;
  /** (optional) information regarding the runtime environment of the worker */
  runtimeInfo?: RuntimeInfo | undefined;
}

export interface WorkerRegisterRequest_LabelsEntry {
  key: string;
  value: WorkerLabels | undefined;
}

export interface WorkerRegisterResponse {
  /** the tenant id */
  tenantId: string;
  /** the id of the worker */
  workerId: string;
  /** the name of the worker */
  workerName: string;
}

export interface UpsertWorkerLabelsRequest {
  /** the name of the worker */
  workerId: string;
  /** (optional) the worker labels */
  labels: { [key: string]: WorkerLabels };
}

export interface UpsertWorkerLabelsRequest_LabelsEntry {
  key: string;
  value: WorkerLabels | undefined;
}

export interface UpsertWorkerLabelsResponse {
  /** the tenant id */
  tenantId: string;
  /** the id of the worker */
  workerId: string;
}

export interface AssignedAction {
  /** the tenant id */
  tenantId: string;
  /** the workflow run id (optional) */
  workflowRunId: string;
  /** the get group key run id (optional) */
  getGroupKeyRunId: string;
  /** the job id */
  jobId: string;
  /** the job name */
  jobName: string;
  /** the job run id */
  jobRunId: string;
  /** the step id */
  stepId: string;
  /** the step run id */
  stepRunId: string;
  /** the action id */
  actionId: string;
  /** the action type */
  actionType: ActionType;
  /** the action payload */
  actionPayload: string;
  /** the step name */
  stepName: string;
  /** the count number of the retry attempt */
  retryCount: number;
  /** (optional) additional metadata set on the workflow */
  additionalMetadata?: string | undefined;
  /** (optional) the child workflow index (if this is a child workflow) */
  childWorkflowIndex?: number | undefined;
  /** (optional) the child workflow key (if this is a child workflow) */
  childWorkflowKey?: string | undefined;
  /** (optional) the parent workflow run id (if this is a child workflow) */
  parentWorkflowRunId?: string | undefined;
  /** (optional) the priority of the run */
  priority: number;
  /** (optional) the workflow id */
  workflowId?: string | undefined;
  /** (optional) the workflow version id */
  workflowVersionId?: string | undefined;
}

export interface WorkerListenRequest {
  /** the id of the worker */
  workerId: string;
}

export interface WorkerUnsubscribeRequest {
  /** the id of the worker */
  workerId: string;
}

export interface WorkerUnsubscribeResponse {
  /** the tenant id to unsubscribe from */
  tenantId: string;
  /** the id of the worker */
  workerId: string;
}

export interface GroupKeyActionEvent {
  /** the id of the worker */
  workerId: string;
  /** the id of the job */
  workflowRunId: string;
  getGroupKeyRunId: string;
  /** the action id */
  actionId: string;
  eventTimestamp: Date | undefined;
  /** the step event type */
  eventType: GroupKeyActionEventType;
  /** the event payload */
  eventPayload: string;
}

export interface StepActionEvent {
  /** the id of the worker */
  workerId: string;
  /** the id of the job */
  jobId: string;
  /** the job run id */
  jobRunId: string;
  /** the id of the step */
  stepId: string;
  /** the step run id */
  stepRunId: string;
  /** the action id */
  actionId: string;
  eventTimestamp: Date | undefined;
  /** the step event type */
  eventType: StepActionEventType;
  /** the event payload */
  eventPayload: string;
  /** the retry count */
  retryCount?: number | undefined;
  /** a flag indicating if the task should _not_ be retried */
  shouldNotRetry?: boolean | undefined;
}

export interface ActionEventResponse {
  /** the tenant id */
  tenantId: string;
  /** the id of the worker */
  workerId: string;
}

export interface SubscribeToWorkflowEventsRequest {
  /** the id of the workflow run */
  workflowRunId?: string | undefined;
  /** the key of the additional meta field to subscribe to */
  additionalMetaKey?: string | undefined;
  /** the value of the additional meta field to subscribe to */
  additionalMetaValue?: string | undefined;
}

export interface SubscribeToWorkflowRunsRequest {
  /** the id of the workflow run */
  workflowRunId: string;
}

export interface WorkflowEvent {
  /** the id of the workflow run */
  workflowRunId: string;
  resourceType: ResourceType;
  eventType: ResourceEventType;
  resourceId: string;
  eventTimestamp: Date | undefined;
  /** the event payload */
  eventPayload: string;
  /**
   * whether this is the last event for the workflow run - server
   * will hang up the connection but clients might want to case
   */
  hangup: boolean;
  /** (optional) the max number of retries this step can handle */
  stepRetries?: number | undefined;
  /** (optional) the retry count of this step */
  retryCount?: number | undefined;
}

export interface WorkflowRunEvent {
  /** the id of the workflow run */
  workflowRunId: string;
  eventType: WorkflowRunEventType;
  eventTimestamp: Date | undefined;
  results: StepRunResult[];
}

export interface StepRunResult {
  stepRunId: string;
  stepReadableId: string;
  jobRunId: string;
  error?: string | undefined;
  output?: string | undefined;
}

export interface OverridesData {
  /** the step run id */
  stepRunId: string;
  /** the path of the data to set */
  path: string;
  /** the value to set */
  value: string;
  /** the filename of the caller */
  callerFilename: string;
}

export interface OverridesDataResponse {}

export interface HeartbeatRequest {
  /** the id of the worker */
  workerId: string;
  /** heartbeatAt is the time the worker sent the heartbeat */
  heartbeatAt: Date | undefined;
}

export interface HeartbeatResponse {}

export interface RefreshTimeoutRequest {
  /** the id of the step run to release */
  stepRunId: string;
  incrementTimeoutBy: string;
}

export interface RefreshTimeoutResponse {
  timeoutAt: Date | undefined;
}

export interface ReleaseSlotRequest {
  /** the id of the step run to release */
  stepRunId: string;
}

export interface ReleaseSlotResponse {}

function createBaseWorkerLabels(): WorkerLabels {
  return { strValue: undefined, intValue: undefined };
}

export const WorkerLabels: MessageFns<WorkerLabels> = {
  encode(message: WorkerLabels, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.strValue !== undefined) {
      writer.uint32(10).string(message.strValue);
    }
    if (message.intValue !== undefined) {
      writer.uint32(16).int32(message.intValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerLabels {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerLabels();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.strValue = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.intValue = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerLabels {
    return {
      strValue: isSet(object.strValue) ? globalThis.String(object.strValue) : undefined,
      intValue: isSet(object.intValue) ? globalThis.Number(object.intValue) : undefined,
    };
  },

  toJSON(message: WorkerLabels): unknown {
    const obj: any = {};
    if (message.strValue !== undefined) {
      obj.strValue = message.strValue;
    }
    if (message.intValue !== undefined) {
      obj.intValue = Math.round(message.intValue);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkerLabels>): WorkerLabels {
    return WorkerLabels.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerLabels>): WorkerLabels {
    const message = createBaseWorkerLabels();
    message.strValue = object.strValue ?? undefined;
    message.intValue = object.intValue ?? undefined;
    return message;
  },
};

function createBaseRuntimeInfo(): RuntimeInfo {
  return {
    sdkVersion: undefined,
    language: undefined,
    languageVersion: undefined,
    os: undefined,
    extra: undefined,
  };
}

export const RuntimeInfo: MessageFns<RuntimeInfo> = {
  encode(message: RuntimeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sdkVersion !== undefined) {
      writer.uint32(10).string(message.sdkVersion);
    }
    if (message.language !== undefined) {
      writer.uint32(16).int32(message.language);
    }
    if (message.languageVersion !== undefined) {
      writer.uint32(26).string(message.languageVersion);
    }
    if (message.os !== undefined) {
      writer.uint32(34).string(message.os);
    }
    if (message.extra !== undefined) {
      writer.uint32(42).string(message.extra);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sdkVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.languageVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.os = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.extra = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeInfo {
    return {
      sdkVersion: isSet(object.sdkVersion) ? globalThis.String(object.sdkVersion) : undefined,
      language: isSet(object.language) ? sDKSFromJSON(object.language) : undefined,
      languageVersion: isSet(object.languageVersion)
        ? globalThis.String(object.languageVersion)
        : undefined,
      os: isSet(object.os) ? globalThis.String(object.os) : undefined,
      extra: isSet(object.extra) ? globalThis.String(object.extra) : undefined,
    };
  },

  toJSON(message: RuntimeInfo): unknown {
    const obj: any = {};
    if (message.sdkVersion !== undefined) {
      obj.sdkVersion = message.sdkVersion;
    }
    if (message.language !== undefined) {
      obj.language = sDKSToJSON(message.language);
    }
    if (message.languageVersion !== undefined) {
      obj.languageVersion = message.languageVersion;
    }
    if (message.os !== undefined) {
      obj.os = message.os;
    }
    if (message.extra !== undefined) {
      obj.extra = message.extra;
    }
    return obj;
  },

  create(base?: DeepPartial<RuntimeInfo>): RuntimeInfo {
    return RuntimeInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuntimeInfo>): RuntimeInfo {
    const message = createBaseRuntimeInfo();
    message.sdkVersion = object.sdkVersion ?? undefined;
    message.language = object.language ?? undefined;
    message.languageVersion = object.languageVersion ?? undefined;
    message.os = object.os ?? undefined;
    message.extra = object.extra ?? undefined;
    return message;
  },
};

function createBaseWorkerRegisterRequest(): WorkerRegisterRequest {
  return {
    workerName: '',
    actions: [],
    services: [],
    maxRuns: undefined,
    labels: {},
    webhookId: undefined,
    runtimeInfo: undefined,
  };
}

export const WorkerRegisterRequest: MessageFns<WorkerRegisterRequest> = {
  encode(message: WorkerRegisterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workerName !== '') {
      writer.uint32(10).string(message.workerName);
    }
    for (const v of message.actions) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.services) {
      writer.uint32(26).string(v!);
    }
    if (message.maxRuns !== undefined) {
      writer.uint32(32).int32(message.maxRuns);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      WorkerRegisterRequest_LabelsEntry.encode(
        { key: key as any, value },
        writer.uint32(42).fork()
      ).join();
    });
    if (message.webhookId !== undefined) {
      writer.uint32(50).string(message.webhookId);
    }
    if (message.runtimeInfo !== undefined) {
      RuntimeInfo.encode(message.runtimeInfo, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerRegisterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerRegisterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workerName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.actions.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.services.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxRuns = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = WorkerRegisterRequest_LabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.webhookId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.runtimeInfo = RuntimeInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerRegisterRequest {
    return {
      workerName: isSet(object.workerName) ? globalThis.String(object.workerName) : '',
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => globalThis.String(e))
        : [],
      services: globalThis.Array.isArray(object?.services)
        ? object.services.map((e: any) => globalThis.String(e))
        : [],
      maxRuns: isSet(object.maxRuns) ? globalThis.Number(object.maxRuns) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: WorkerLabels }>(
            (acc, [key, value]) => {
              acc[key] = WorkerLabels.fromJSON(value);
              return acc;
            },
            {}
          )
        : {},
      webhookId: isSet(object.webhookId) ? globalThis.String(object.webhookId) : undefined,
      runtimeInfo: isSet(object.runtimeInfo) ? RuntimeInfo.fromJSON(object.runtimeInfo) : undefined,
    };
  },

  toJSON(message: WorkerRegisterRequest): unknown {
    const obj: any = {};
    if (message.workerName !== '') {
      obj.workerName = message.workerName;
    }
    if (message.actions?.length) {
      obj.actions = message.actions;
    }
    if (message.services?.length) {
      obj.services = message.services;
    }
    if (message.maxRuns !== undefined) {
      obj.maxRuns = Math.round(message.maxRuns);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = WorkerLabels.toJSON(v);
        });
      }
    }
    if (message.webhookId !== undefined) {
      obj.webhookId = message.webhookId;
    }
    if (message.runtimeInfo !== undefined) {
      obj.runtimeInfo = RuntimeInfo.toJSON(message.runtimeInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkerRegisterRequest>): WorkerRegisterRequest {
    return WorkerRegisterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerRegisterRequest>): WorkerRegisterRequest {
    const message = createBaseWorkerRegisterRequest();
    message.workerName = object.workerName ?? '';
    message.actions = object.actions?.map((e) => e) || [];
    message.services = object.services?.map((e) => e) || [];
    message.maxRuns = object.maxRuns ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: WorkerLabels }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = WorkerLabels.fromPartial(value);
        }
        return acc;
      },
      {}
    );
    message.webhookId = object.webhookId ?? undefined;
    message.runtimeInfo =
      object.runtimeInfo !== undefined && object.runtimeInfo !== null
        ? RuntimeInfo.fromPartial(object.runtimeInfo)
        : undefined;
    return message;
  },
};

function createBaseWorkerRegisterRequest_LabelsEntry(): WorkerRegisterRequest_LabelsEntry {
  return { key: '', value: undefined };
}

export const WorkerRegisterRequest_LabelsEntry: MessageFns<WorkerRegisterRequest_LabelsEntry> = {
  encode(
    message: WorkerRegisterRequest_LabelsEntry,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      WorkerLabels.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerRegisterRequest_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerRegisterRequest_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = WorkerLabels.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerRegisterRequest_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : '',
      value: isSet(object.value) ? WorkerLabels.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: WorkerRegisterRequest_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== '') {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = WorkerLabels.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkerRegisterRequest_LabelsEntry>): WorkerRegisterRequest_LabelsEntry {
    return WorkerRegisterRequest_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WorkerRegisterRequest_LabelsEntry>
  ): WorkerRegisterRequest_LabelsEntry {
    const message = createBaseWorkerRegisterRequest_LabelsEntry();
    message.key = object.key ?? '';
    message.value =
      object.value !== undefined && object.value !== null
        ? WorkerLabels.fromPartial(object.value)
        : undefined;
    return message;
  },
};

function createBaseWorkerRegisterResponse(): WorkerRegisterResponse {
  return { tenantId: '', workerId: '', workerName: '' };
}

export const WorkerRegisterResponse: MessageFns<WorkerRegisterResponse> = {
  encode(message: WorkerRegisterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tenantId !== '') {
      writer.uint32(10).string(message.tenantId);
    }
    if (message.workerId !== '') {
      writer.uint32(18).string(message.workerId);
    }
    if (message.workerName !== '') {
      writer.uint32(26).string(message.workerName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerRegisterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerRegisterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tenantId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workerName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerRegisterResponse {
    return {
      tenantId: isSet(object.tenantId) ? globalThis.String(object.tenantId) : '',
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : '',
      workerName: isSet(object.workerName) ? globalThis.String(object.workerName) : '',
    };
  },

  toJSON(message: WorkerRegisterResponse): unknown {
    const obj: any = {};
    if (message.tenantId !== '') {
      obj.tenantId = message.tenantId;
    }
    if (message.workerId !== '') {
      obj.workerId = message.workerId;
    }
    if (message.workerName !== '') {
      obj.workerName = message.workerName;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkerRegisterResponse>): WorkerRegisterResponse {
    return WorkerRegisterResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerRegisterResponse>): WorkerRegisterResponse {
    const message = createBaseWorkerRegisterResponse();
    message.tenantId = object.tenantId ?? '';
    message.workerId = object.workerId ?? '';
    message.workerName = object.workerName ?? '';
    return message;
  },
};

function createBaseUpsertWorkerLabelsRequest(): UpsertWorkerLabelsRequest {
  return { workerId: '', labels: {} };
}

export const UpsertWorkerLabelsRequest: MessageFns<UpsertWorkerLabelsRequest> = {
  encode(
    message: UpsertWorkerLabelsRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.workerId !== '') {
      writer.uint32(10).string(message.workerId);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      UpsertWorkerLabelsRequest_LabelsEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork()
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertWorkerLabelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertWorkerLabelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = UpsertWorkerLabelsRequest_LabelsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.labels[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertWorkerLabelsRequest {
    return {
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : '',
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: WorkerLabels }>(
            (acc, [key, value]) => {
              acc[key] = WorkerLabels.fromJSON(value);
              return acc;
            },
            {}
          )
        : {},
    };
  },

  toJSON(message: UpsertWorkerLabelsRequest): unknown {
    const obj: any = {};
    if (message.workerId !== '') {
      obj.workerId = message.workerId;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = WorkerLabels.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<UpsertWorkerLabelsRequest>): UpsertWorkerLabelsRequest {
    return UpsertWorkerLabelsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpsertWorkerLabelsRequest>): UpsertWorkerLabelsRequest {
    const message = createBaseUpsertWorkerLabelsRequest();
    message.workerId = object.workerId ?? '';
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: WorkerLabels }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = WorkerLabels.fromPartial(value);
        }
        return acc;
      },
      {}
    );
    return message;
  },
};

function createBaseUpsertWorkerLabelsRequest_LabelsEntry(): UpsertWorkerLabelsRequest_LabelsEntry {
  return { key: '', value: undefined };
}

export const UpsertWorkerLabelsRequest_LabelsEntry: MessageFns<UpsertWorkerLabelsRequest_LabelsEntry> =
  {
    encode(
      message: UpsertWorkerLabelsRequest_LabelsEntry,
      writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
      if (message.key !== '') {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        WorkerLabels.encode(message.value, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number
    ): UpsertWorkerLabelsRequest_LabelsEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseUpsertWorkerLabelsRequest_LabelsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = WorkerLabels.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): UpsertWorkerLabelsRequest_LabelsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : '',
        value: isSet(object.value) ? WorkerLabels.fromJSON(object.value) : undefined,
      };
    },

    toJSON(message: UpsertWorkerLabelsRequest_LabelsEntry): unknown {
      const obj: any = {};
      if (message.key !== '') {
        obj.key = message.key;
      }
      if (message.value !== undefined) {
        obj.value = WorkerLabels.toJSON(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<UpsertWorkerLabelsRequest_LabelsEntry>
    ): UpsertWorkerLabelsRequest_LabelsEntry {
      return UpsertWorkerLabelsRequest_LabelsEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<UpsertWorkerLabelsRequest_LabelsEntry>
    ): UpsertWorkerLabelsRequest_LabelsEntry {
      const message = createBaseUpsertWorkerLabelsRequest_LabelsEntry();
      message.key = object.key ?? '';
      message.value =
        object.value !== undefined && object.value !== null
          ? WorkerLabels.fromPartial(object.value)
          : undefined;
      return message;
    },
  };

function createBaseUpsertWorkerLabelsResponse(): UpsertWorkerLabelsResponse {
  return { tenantId: '', workerId: '' };
}

export const UpsertWorkerLabelsResponse: MessageFns<UpsertWorkerLabelsResponse> = {
  encode(
    message: UpsertWorkerLabelsResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.tenantId !== '') {
      writer.uint32(10).string(message.tenantId);
    }
    if (message.workerId !== '') {
      writer.uint32(18).string(message.workerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertWorkerLabelsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertWorkerLabelsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tenantId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertWorkerLabelsResponse {
    return {
      tenantId: isSet(object.tenantId) ? globalThis.String(object.tenantId) : '',
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : '',
    };
  },

  toJSON(message: UpsertWorkerLabelsResponse): unknown {
    const obj: any = {};
    if (message.tenantId !== '') {
      obj.tenantId = message.tenantId;
    }
    if (message.workerId !== '') {
      obj.workerId = message.workerId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpsertWorkerLabelsResponse>): UpsertWorkerLabelsResponse {
    return UpsertWorkerLabelsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpsertWorkerLabelsResponse>): UpsertWorkerLabelsResponse {
    const message = createBaseUpsertWorkerLabelsResponse();
    message.tenantId = object.tenantId ?? '';
    message.workerId = object.workerId ?? '';
    return message;
  },
};

function createBaseAssignedAction(): AssignedAction {
  return {
    tenantId: '',
    workflowRunId: '',
    getGroupKeyRunId: '',
    jobId: '',
    jobName: '',
    jobRunId: '',
    stepId: '',
    stepRunId: '',
    actionId: '',
    actionType: 0,
    actionPayload: '',
    stepName: '',
    retryCount: 0,
    additionalMetadata: undefined,
    childWorkflowIndex: undefined,
    childWorkflowKey: undefined,
    parentWorkflowRunId: undefined,
    priority: 0,
    workflowId: undefined,
    workflowVersionId: undefined,
  };
}

export const AssignedAction: MessageFns<AssignedAction> = {
  encode(message: AssignedAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tenantId !== '') {
      writer.uint32(10).string(message.tenantId);
    }
    if (message.workflowRunId !== '') {
      writer.uint32(18).string(message.workflowRunId);
    }
    if (message.getGroupKeyRunId !== '') {
      writer.uint32(26).string(message.getGroupKeyRunId);
    }
    if (message.jobId !== '') {
      writer.uint32(34).string(message.jobId);
    }
    if (message.jobName !== '') {
      writer.uint32(42).string(message.jobName);
    }
    if (message.jobRunId !== '') {
      writer.uint32(50).string(message.jobRunId);
    }
    if (message.stepId !== '') {
      writer.uint32(58).string(message.stepId);
    }
    if (message.stepRunId !== '') {
      writer.uint32(66).string(message.stepRunId);
    }
    if (message.actionId !== '') {
      writer.uint32(74).string(message.actionId);
    }
    if (message.actionType !== 0) {
      writer.uint32(80).int32(message.actionType);
    }
    if (message.actionPayload !== '') {
      writer.uint32(90).string(message.actionPayload);
    }
    if (message.stepName !== '') {
      writer.uint32(98).string(message.stepName);
    }
    if (message.retryCount !== 0) {
      writer.uint32(104).int32(message.retryCount);
    }
    if (message.additionalMetadata !== undefined) {
      writer.uint32(114).string(message.additionalMetadata);
    }
    if (message.childWorkflowIndex !== undefined) {
      writer.uint32(120).int32(message.childWorkflowIndex);
    }
    if (message.childWorkflowKey !== undefined) {
      writer.uint32(130).string(message.childWorkflowKey);
    }
    if (message.parentWorkflowRunId !== undefined) {
      writer.uint32(138).string(message.parentWorkflowRunId);
    }
    if (message.priority !== 0) {
      writer.uint32(144).int32(message.priority);
    }
    if (message.workflowId !== undefined) {
      writer.uint32(154).string(message.workflowId);
    }
    if (message.workflowVersionId !== undefined) {
      writer.uint32(162).string(message.workflowVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssignedAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignedAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tenantId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowRunId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.getGroupKeyRunId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.jobName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.jobRunId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.stepId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.stepRunId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.actionId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.actionType = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.actionPayload = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.stepName = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.additionalMetadata = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.childWorkflowIndex = reader.int32();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.childWorkflowKey = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.parentWorkflowRunId = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.workflowVersionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssignedAction {
    return {
      tenantId: isSet(object.tenantId) ? globalThis.String(object.tenantId) : '',
      workflowRunId: isSet(object.workflowRunId) ? globalThis.String(object.workflowRunId) : '',
      getGroupKeyRunId: isSet(object.getGroupKeyRunId)
        ? globalThis.String(object.getGroupKeyRunId)
        : '',
      jobId: isSet(object.jobId) ? globalThis.String(object.jobId) : '',
      jobName: isSet(object.jobName) ? globalThis.String(object.jobName) : '',
      jobRunId: isSet(object.jobRunId) ? globalThis.String(object.jobRunId) : '',
      stepId: isSet(object.stepId) ? globalThis.String(object.stepId) : '',
      stepRunId: isSet(object.stepRunId) ? globalThis.String(object.stepRunId) : '',
      actionId: isSet(object.actionId) ? globalThis.String(object.actionId) : '',
      actionType: isSet(object.actionType) ? actionTypeFromJSON(object.actionType) : 0,
      actionPayload: isSet(object.actionPayload) ? globalThis.String(object.actionPayload) : '',
      stepName: isSet(object.stepName) ? globalThis.String(object.stepName) : '',
      retryCount: isSet(object.retryCount) ? globalThis.Number(object.retryCount) : 0,
      additionalMetadata: isSet(object.additionalMetadata)
        ? globalThis.String(object.additionalMetadata)
        : undefined,
      childWorkflowIndex: isSet(object.childWorkflowIndex)
        ? globalThis.Number(object.childWorkflowIndex)
        : undefined,
      childWorkflowKey: isSet(object.childWorkflowKey)
        ? globalThis.String(object.childWorkflowKey)
        : undefined,
      parentWorkflowRunId: isSet(object.parentWorkflowRunId)
        ? globalThis.String(object.parentWorkflowRunId)
        : undefined,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : undefined,
      workflowVersionId: isSet(object.workflowVersionId)
        ? globalThis.String(object.workflowVersionId)
        : undefined,
    };
  },

  toJSON(message: AssignedAction): unknown {
    const obj: any = {};
    if (message.tenantId !== '') {
      obj.tenantId = message.tenantId;
    }
    if (message.workflowRunId !== '') {
      obj.workflowRunId = message.workflowRunId;
    }
    if (message.getGroupKeyRunId !== '') {
      obj.getGroupKeyRunId = message.getGroupKeyRunId;
    }
    if (message.jobId !== '') {
      obj.jobId = message.jobId;
    }
    if (message.jobName !== '') {
      obj.jobName = message.jobName;
    }
    if (message.jobRunId !== '') {
      obj.jobRunId = message.jobRunId;
    }
    if (message.stepId !== '') {
      obj.stepId = message.stepId;
    }
    if (message.stepRunId !== '') {
      obj.stepRunId = message.stepRunId;
    }
    if (message.actionId !== '') {
      obj.actionId = message.actionId;
    }
    if (message.actionType !== 0) {
      obj.actionType = actionTypeToJSON(message.actionType);
    }
    if (message.actionPayload !== '') {
      obj.actionPayload = message.actionPayload;
    }
    if (message.stepName !== '') {
      obj.stepName = message.stepName;
    }
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    if (message.additionalMetadata !== undefined) {
      obj.additionalMetadata = message.additionalMetadata;
    }
    if (message.childWorkflowIndex !== undefined) {
      obj.childWorkflowIndex = Math.round(message.childWorkflowIndex);
    }
    if (message.childWorkflowKey !== undefined) {
      obj.childWorkflowKey = message.childWorkflowKey;
    }
    if (message.parentWorkflowRunId !== undefined) {
      obj.parentWorkflowRunId = message.parentWorkflowRunId;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.workflowId !== undefined) {
      obj.workflowId = message.workflowId;
    }
    if (message.workflowVersionId !== undefined) {
      obj.workflowVersionId = message.workflowVersionId;
    }
    return obj;
  },

  create(base?: DeepPartial<AssignedAction>): AssignedAction {
    return AssignedAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssignedAction>): AssignedAction {
    const message = createBaseAssignedAction();
    message.tenantId = object.tenantId ?? '';
    message.workflowRunId = object.workflowRunId ?? '';
    message.getGroupKeyRunId = object.getGroupKeyRunId ?? '';
    message.jobId = object.jobId ?? '';
    message.jobName = object.jobName ?? '';
    message.jobRunId = object.jobRunId ?? '';
    message.stepId = object.stepId ?? '';
    message.stepRunId = object.stepRunId ?? '';
    message.actionId = object.actionId ?? '';
    message.actionType = object.actionType ?? 0;
    message.actionPayload = object.actionPayload ?? '';
    message.stepName = object.stepName ?? '';
    message.retryCount = object.retryCount ?? 0;
    message.additionalMetadata = object.additionalMetadata ?? undefined;
    message.childWorkflowIndex = object.childWorkflowIndex ?? undefined;
    message.childWorkflowKey = object.childWorkflowKey ?? undefined;
    message.parentWorkflowRunId = object.parentWorkflowRunId ?? undefined;
    message.priority = object.priority ?? 0;
    message.workflowId = object.workflowId ?? undefined;
    message.workflowVersionId = object.workflowVersionId ?? undefined;
    return message;
  },
};

function createBaseWorkerListenRequest(): WorkerListenRequest {
  return { workerId: '' };
}

export const WorkerListenRequest: MessageFns<WorkerListenRequest> = {
  encode(message: WorkerListenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workerId !== '') {
      writer.uint32(10).string(message.workerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerListenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerListenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerListenRequest {
    return { workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : '' };
  },

  toJSON(message: WorkerListenRequest): unknown {
    const obj: any = {};
    if (message.workerId !== '') {
      obj.workerId = message.workerId;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkerListenRequest>): WorkerListenRequest {
    return WorkerListenRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerListenRequest>): WorkerListenRequest {
    const message = createBaseWorkerListenRequest();
    message.workerId = object.workerId ?? '';
    return message;
  },
};

function createBaseWorkerUnsubscribeRequest(): WorkerUnsubscribeRequest {
  return { workerId: '' };
}

export const WorkerUnsubscribeRequest: MessageFns<WorkerUnsubscribeRequest> = {
  encode(
    message: WorkerUnsubscribeRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.workerId !== '') {
      writer.uint32(10).string(message.workerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerUnsubscribeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerUnsubscribeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerUnsubscribeRequest {
    return { workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : '' };
  },

  toJSON(message: WorkerUnsubscribeRequest): unknown {
    const obj: any = {};
    if (message.workerId !== '') {
      obj.workerId = message.workerId;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkerUnsubscribeRequest>): WorkerUnsubscribeRequest {
    return WorkerUnsubscribeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerUnsubscribeRequest>): WorkerUnsubscribeRequest {
    const message = createBaseWorkerUnsubscribeRequest();
    message.workerId = object.workerId ?? '';
    return message;
  },
};

function createBaseWorkerUnsubscribeResponse(): WorkerUnsubscribeResponse {
  return { tenantId: '', workerId: '' };
}

export const WorkerUnsubscribeResponse: MessageFns<WorkerUnsubscribeResponse> = {
  encode(
    message: WorkerUnsubscribeResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.tenantId !== '') {
      writer.uint32(10).string(message.tenantId);
    }
    if (message.workerId !== '') {
      writer.uint32(18).string(message.workerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerUnsubscribeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerUnsubscribeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tenantId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerUnsubscribeResponse {
    return {
      tenantId: isSet(object.tenantId) ? globalThis.String(object.tenantId) : '',
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : '',
    };
  },

  toJSON(message: WorkerUnsubscribeResponse): unknown {
    const obj: any = {};
    if (message.tenantId !== '') {
      obj.tenantId = message.tenantId;
    }
    if (message.workerId !== '') {
      obj.workerId = message.workerId;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkerUnsubscribeResponse>): WorkerUnsubscribeResponse {
    return WorkerUnsubscribeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerUnsubscribeResponse>): WorkerUnsubscribeResponse {
    const message = createBaseWorkerUnsubscribeResponse();
    message.tenantId = object.tenantId ?? '';
    message.workerId = object.workerId ?? '';
    return message;
  },
};

function createBaseGroupKeyActionEvent(): GroupKeyActionEvent {
  return {
    workerId: '',
    workflowRunId: '',
    getGroupKeyRunId: '',
    actionId: '',
    eventTimestamp: undefined,
    eventType: 0,
    eventPayload: '',
  };
}

export const GroupKeyActionEvent: MessageFns<GroupKeyActionEvent> = {
  encode(message: GroupKeyActionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workerId !== '') {
      writer.uint32(10).string(message.workerId);
    }
    if (message.workflowRunId !== '') {
      writer.uint32(18).string(message.workflowRunId);
    }
    if (message.getGroupKeyRunId !== '') {
      writer.uint32(26).string(message.getGroupKeyRunId);
    }
    if (message.actionId !== '') {
      writer.uint32(34).string(message.actionId);
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTimestamp), writer.uint32(42).fork()).join();
    }
    if (message.eventType !== 0) {
      writer.uint32(48).int32(message.eventType);
    }
    if (message.eventPayload !== '') {
      writer.uint32(58).string(message.eventPayload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupKeyActionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupKeyActionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowRunId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.getGroupKeyRunId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.actionId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.eventTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.eventPayload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupKeyActionEvent {
    return {
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : '',
      workflowRunId: isSet(object.workflowRunId) ? globalThis.String(object.workflowRunId) : '',
      getGroupKeyRunId: isSet(object.getGroupKeyRunId)
        ? globalThis.String(object.getGroupKeyRunId)
        : '',
      actionId: isSet(object.actionId) ? globalThis.String(object.actionId) : '',
      eventTimestamp: isSet(object.eventTimestamp)
        ? fromJsonTimestamp(object.eventTimestamp)
        : undefined,
      eventType: isSet(object.eventType) ? groupKeyActionEventTypeFromJSON(object.eventType) : 0,
      eventPayload: isSet(object.eventPayload) ? globalThis.String(object.eventPayload) : '',
    };
  },

  toJSON(message: GroupKeyActionEvent): unknown {
    const obj: any = {};
    if (message.workerId !== '') {
      obj.workerId = message.workerId;
    }
    if (message.workflowRunId !== '') {
      obj.workflowRunId = message.workflowRunId;
    }
    if (message.getGroupKeyRunId !== '') {
      obj.getGroupKeyRunId = message.getGroupKeyRunId;
    }
    if (message.actionId !== '') {
      obj.actionId = message.actionId;
    }
    if (message.eventTimestamp !== undefined) {
      obj.eventTimestamp = message.eventTimestamp.toISOString();
    }
    if (message.eventType !== 0) {
      obj.eventType = groupKeyActionEventTypeToJSON(message.eventType);
    }
    if (message.eventPayload !== '') {
      obj.eventPayload = message.eventPayload;
    }
    return obj;
  },

  create(base?: DeepPartial<GroupKeyActionEvent>): GroupKeyActionEvent {
    return GroupKeyActionEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroupKeyActionEvent>): GroupKeyActionEvent {
    const message = createBaseGroupKeyActionEvent();
    message.workerId = object.workerId ?? '';
    message.workflowRunId = object.workflowRunId ?? '';
    message.getGroupKeyRunId = object.getGroupKeyRunId ?? '';
    message.actionId = object.actionId ?? '';
    message.eventTimestamp = object.eventTimestamp ?? undefined;
    message.eventType = object.eventType ?? 0;
    message.eventPayload = object.eventPayload ?? '';
    return message;
  },
};

function createBaseStepActionEvent(): StepActionEvent {
  return {
    workerId: '',
    jobId: '',
    jobRunId: '',
    stepId: '',
    stepRunId: '',
    actionId: '',
    eventTimestamp: undefined,
    eventType: 0,
    eventPayload: '',
    retryCount: undefined,
    shouldNotRetry: undefined,
  };
}

export const StepActionEvent: MessageFns<StepActionEvent> = {
  encode(message: StepActionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workerId !== '') {
      writer.uint32(10).string(message.workerId);
    }
    if (message.jobId !== '') {
      writer.uint32(18).string(message.jobId);
    }
    if (message.jobRunId !== '') {
      writer.uint32(26).string(message.jobRunId);
    }
    if (message.stepId !== '') {
      writer.uint32(34).string(message.stepId);
    }
    if (message.stepRunId !== '') {
      writer.uint32(42).string(message.stepRunId);
    }
    if (message.actionId !== '') {
      writer.uint32(50).string(message.actionId);
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTimestamp), writer.uint32(58).fork()).join();
    }
    if (message.eventType !== 0) {
      writer.uint32(64).int32(message.eventType);
    }
    if (message.eventPayload !== '') {
      writer.uint32(74).string(message.eventPayload);
    }
    if (message.retryCount !== undefined) {
      writer.uint32(80).int32(message.retryCount);
    }
    if (message.shouldNotRetry !== undefined) {
      writer.uint32(88).bool(message.shouldNotRetry);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StepActionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStepActionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.jobRunId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stepId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.stepRunId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.actionId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.eventTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.eventPayload = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.shouldNotRetry = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StepActionEvent {
    return {
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : '',
      jobId: isSet(object.jobId) ? globalThis.String(object.jobId) : '',
      jobRunId: isSet(object.jobRunId) ? globalThis.String(object.jobRunId) : '',
      stepId: isSet(object.stepId) ? globalThis.String(object.stepId) : '',
      stepRunId: isSet(object.stepRunId) ? globalThis.String(object.stepRunId) : '',
      actionId: isSet(object.actionId) ? globalThis.String(object.actionId) : '',
      eventTimestamp: isSet(object.eventTimestamp)
        ? fromJsonTimestamp(object.eventTimestamp)
        : undefined,
      eventType: isSet(object.eventType) ? stepActionEventTypeFromJSON(object.eventType) : 0,
      eventPayload: isSet(object.eventPayload) ? globalThis.String(object.eventPayload) : '',
      retryCount: isSet(object.retryCount) ? globalThis.Number(object.retryCount) : undefined,
      shouldNotRetry: isSet(object.shouldNotRetry)
        ? globalThis.Boolean(object.shouldNotRetry)
        : undefined,
    };
  },

  toJSON(message: StepActionEvent): unknown {
    const obj: any = {};
    if (message.workerId !== '') {
      obj.workerId = message.workerId;
    }
    if (message.jobId !== '') {
      obj.jobId = message.jobId;
    }
    if (message.jobRunId !== '') {
      obj.jobRunId = message.jobRunId;
    }
    if (message.stepId !== '') {
      obj.stepId = message.stepId;
    }
    if (message.stepRunId !== '') {
      obj.stepRunId = message.stepRunId;
    }
    if (message.actionId !== '') {
      obj.actionId = message.actionId;
    }
    if (message.eventTimestamp !== undefined) {
      obj.eventTimestamp = message.eventTimestamp.toISOString();
    }
    if (message.eventType !== 0) {
      obj.eventType = stepActionEventTypeToJSON(message.eventType);
    }
    if (message.eventPayload !== '') {
      obj.eventPayload = message.eventPayload;
    }
    if (message.retryCount !== undefined) {
      obj.retryCount = Math.round(message.retryCount);
    }
    if (message.shouldNotRetry !== undefined) {
      obj.shouldNotRetry = message.shouldNotRetry;
    }
    return obj;
  },

  create(base?: DeepPartial<StepActionEvent>): StepActionEvent {
    return StepActionEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StepActionEvent>): StepActionEvent {
    const message = createBaseStepActionEvent();
    message.workerId = object.workerId ?? '';
    message.jobId = object.jobId ?? '';
    message.jobRunId = object.jobRunId ?? '';
    message.stepId = object.stepId ?? '';
    message.stepRunId = object.stepRunId ?? '';
    message.actionId = object.actionId ?? '';
    message.eventTimestamp = object.eventTimestamp ?? undefined;
    message.eventType = object.eventType ?? 0;
    message.eventPayload = object.eventPayload ?? '';
    message.retryCount = object.retryCount ?? undefined;
    message.shouldNotRetry = object.shouldNotRetry ?? undefined;
    return message;
  },
};

function createBaseActionEventResponse(): ActionEventResponse {
  return { tenantId: '', workerId: '' };
}

export const ActionEventResponse: MessageFns<ActionEventResponse> = {
  encode(message: ActionEventResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tenantId !== '') {
      writer.uint32(10).string(message.tenantId);
    }
    if (message.workerId !== '') {
      writer.uint32(18).string(message.workerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionEventResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tenantId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionEventResponse {
    return {
      tenantId: isSet(object.tenantId) ? globalThis.String(object.tenantId) : '',
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : '',
    };
  },

  toJSON(message: ActionEventResponse): unknown {
    const obj: any = {};
    if (message.tenantId !== '') {
      obj.tenantId = message.tenantId;
    }
    if (message.workerId !== '') {
      obj.workerId = message.workerId;
    }
    return obj;
  },

  create(base?: DeepPartial<ActionEventResponse>): ActionEventResponse {
    return ActionEventResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActionEventResponse>): ActionEventResponse {
    const message = createBaseActionEventResponse();
    message.tenantId = object.tenantId ?? '';
    message.workerId = object.workerId ?? '';
    return message;
  },
};

function createBaseSubscribeToWorkflowEventsRequest(): SubscribeToWorkflowEventsRequest {
  return { workflowRunId: undefined, additionalMetaKey: undefined, additionalMetaValue: undefined };
}

export const SubscribeToWorkflowEventsRequest: MessageFns<SubscribeToWorkflowEventsRequest> = {
  encode(
    message: SubscribeToWorkflowEventsRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.workflowRunId !== undefined) {
      writer.uint32(10).string(message.workflowRunId);
    }
    if (message.additionalMetaKey !== undefined) {
      writer.uint32(18).string(message.additionalMetaKey);
    }
    if (message.additionalMetaValue !== undefined) {
      writer.uint32(26).string(message.additionalMetaValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeToWorkflowEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeToWorkflowEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflowRunId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.additionalMetaKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.additionalMetaValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeToWorkflowEventsRequest {
    return {
      workflowRunId: isSet(object.workflowRunId)
        ? globalThis.String(object.workflowRunId)
        : undefined,
      additionalMetaKey: isSet(object.additionalMetaKey)
        ? globalThis.String(object.additionalMetaKey)
        : undefined,
      additionalMetaValue: isSet(object.additionalMetaValue)
        ? globalThis.String(object.additionalMetaValue)
        : undefined,
    };
  },

  toJSON(message: SubscribeToWorkflowEventsRequest): unknown {
    const obj: any = {};
    if (message.workflowRunId !== undefined) {
      obj.workflowRunId = message.workflowRunId;
    }
    if (message.additionalMetaKey !== undefined) {
      obj.additionalMetaKey = message.additionalMetaKey;
    }
    if (message.additionalMetaValue !== undefined) {
      obj.additionalMetaValue = message.additionalMetaValue;
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribeToWorkflowEventsRequest>): SubscribeToWorkflowEventsRequest {
    return SubscribeToWorkflowEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SubscribeToWorkflowEventsRequest>
  ): SubscribeToWorkflowEventsRequest {
    const message = createBaseSubscribeToWorkflowEventsRequest();
    message.workflowRunId = object.workflowRunId ?? undefined;
    message.additionalMetaKey = object.additionalMetaKey ?? undefined;
    message.additionalMetaValue = object.additionalMetaValue ?? undefined;
    return message;
  },
};

function createBaseSubscribeToWorkflowRunsRequest(): SubscribeToWorkflowRunsRequest {
  return { workflowRunId: '' };
}

export const SubscribeToWorkflowRunsRequest: MessageFns<SubscribeToWorkflowRunsRequest> = {
  encode(
    message: SubscribeToWorkflowRunsRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.workflowRunId !== '') {
      writer.uint32(10).string(message.workflowRunId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeToWorkflowRunsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeToWorkflowRunsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflowRunId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeToWorkflowRunsRequest {
    return {
      workflowRunId: isSet(object.workflowRunId) ? globalThis.String(object.workflowRunId) : '',
    };
  },

  toJSON(message: SubscribeToWorkflowRunsRequest): unknown {
    const obj: any = {};
    if (message.workflowRunId !== '') {
      obj.workflowRunId = message.workflowRunId;
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribeToWorkflowRunsRequest>): SubscribeToWorkflowRunsRequest {
    return SubscribeToWorkflowRunsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeToWorkflowRunsRequest>): SubscribeToWorkflowRunsRequest {
    const message = createBaseSubscribeToWorkflowRunsRequest();
    message.workflowRunId = object.workflowRunId ?? '';
    return message;
  },
};

function createBaseWorkflowEvent(): WorkflowEvent {
  return {
    workflowRunId: '',
    resourceType: 0,
    eventType: 0,
    resourceId: '',
    eventTimestamp: undefined,
    eventPayload: '',
    hangup: false,
    stepRetries: undefined,
    retryCount: undefined,
  };
}

export const WorkflowEvent: MessageFns<WorkflowEvent> = {
  encode(message: WorkflowEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workflowRunId !== '') {
      writer.uint32(10).string(message.workflowRunId);
    }
    if (message.resourceType !== 0) {
      writer.uint32(16).int32(message.resourceType);
    }
    if (message.eventType !== 0) {
      writer.uint32(24).int32(message.eventType);
    }
    if (message.resourceId !== '') {
      writer.uint32(34).string(message.resourceId);
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTimestamp), writer.uint32(42).fork()).join();
    }
    if (message.eventPayload !== '') {
      writer.uint32(50).string(message.eventPayload);
    }
    if (message.hangup !== false) {
      writer.uint32(56).bool(message.hangup);
    }
    if (message.stepRetries !== undefined) {
      writer.uint32(64).int32(message.stepRetries);
    }
    if (message.retryCount !== undefined) {
      writer.uint32(72).int32(message.retryCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflowRunId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.resourceType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resourceId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.eventTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.eventPayload = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.hangup = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.stepRetries = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowEvent {
    return {
      workflowRunId: isSet(object.workflowRunId) ? globalThis.String(object.workflowRunId) : '',
      resourceType: isSet(object.resourceType) ? resourceTypeFromJSON(object.resourceType) : 0,
      eventType: isSet(object.eventType) ? resourceEventTypeFromJSON(object.eventType) : 0,
      resourceId: isSet(object.resourceId) ? globalThis.String(object.resourceId) : '',
      eventTimestamp: isSet(object.eventTimestamp)
        ? fromJsonTimestamp(object.eventTimestamp)
        : undefined,
      eventPayload: isSet(object.eventPayload) ? globalThis.String(object.eventPayload) : '',
      hangup: isSet(object.hangup) ? globalThis.Boolean(object.hangup) : false,
      stepRetries: isSet(object.stepRetries) ? globalThis.Number(object.stepRetries) : undefined,
      retryCount: isSet(object.retryCount) ? globalThis.Number(object.retryCount) : undefined,
    };
  },

  toJSON(message: WorkflowEvent): unknown {
    const obj: any = {};
    if (message.workflowRunId !== '') {
      obj.workflowRunId = message.workflowRunId;
    }
    if (message.resourceType !== 0) {
      obj.resourceType = resourceTypeToJSON(message.resourceType);
    }
    if (message.eventType !== 0) {
      obj.eventType = resourceEventTypeToJSON(message.eventType);
    }
    if (message.resourceId !== '') {
      obj.resourceId = message.resourceId;
    }
    if (message.eventTimestamp !== undefined) {
      obj.eventTimestamp = message.eventTimestamp.toISOString();
    }
    if (message.eventPayload !== '') {
      obj.eventPayload = message.eventPayload;
    }
    if (message.hangup !== false) {
      obj.hangup = message.hangup;
    }
    if (message.stepRetries !== undefined) {
      obj.stepRetries = Math.round(message.stepRetries);
    }
    if (message.retryCount !== undefined) {
      obj.retryCount = Math.round(message.retryCount);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkflowEvent>): WorkflowEvent {
    return WorkflowEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkflowEvent>): WorkflowEvent {
    const message = createBaseWorkflowEvent();
    message.workflowRunId = object.workflowRunId ?? '';
    message.resourceType = object.resourceType ?? 0;
    message.eventType = object.eventType ?? 0;
    message.resourceId = object.resourceId ?? '';
    message.eventTimestamp = object.eventTimestamp ?? undefined;
    message.eventPayload = object.eventPayload ?? '';
    message.hangup = object.hangup ?? false;
    message.stepRetries = object.stepRetries ?? undefined;
    message.retryCount = object.retryCount ?? undefined;
    return message;
  },
};

function createBaseWorkflowRunEvent(): WorkflowRunEvent {
  return { workflowRunId: '', eventType: 0, eventTimestamp: undefined, results: [] };
}

export const WorkflowRunEvent: MessageFns<WorkflowRunEvent> = {
  encode(message: WorkflowRunEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workflowRunId !== '') {
      writer.uint32(10).string(message.workflowRunId);
    }
    if (message.eventType !== 0) {
      writer.uint32(16).int32(message.eventType);
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTimestamp), writer.uint32(26).fork()).join();
    }
    for (const v of message.results) {
      StepRunResult.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowRunEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowRunEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflowRunId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.eventTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.results.push(StepRunResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowRunEvent {
    return {
      workflowRunId: isSet(object.workflowRunId) ? globalThis.String(object.workflowRunId) : '',
      eventType: isSet(object.eventType) ? workflowRunEventTypeFromJSON(object.eventType) : 0,
      eventTimestamp: isSet(object.eventTimestamp)
        ? fromJsonTimestamp(object.eventTimestamp)
        : undefined,
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => StepRunResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WorkflowRunEvent): unknown {
    const obj: any = {};
    if (message.workflowRunId !== '') {
      obj.workflowRunId = message.workflowRunId;
    }
    if (message.eventType !== 0) {
      obj.eventType = workflowRunEventTypeToJSON(message.eventType);
    }
    if (message.eventTimestamp !== undefined) {
      obj.eventTimestamp = message.eventTimestamp.toISOString();
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => StepRunResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<WorkflowRunEvent>): WorkflowRunEvent {
    return WorkflowRunEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkflowRunEvent>): WorkflowRunEvent {
    const message = createBaseWorkflowRunEvent();
    message.workflowRunId = object.workflowRunId ?? '';
    message.eventType = object.eventType ?? 0;
    message.eventTimestamp = object.eventTimestamp ?? undefined;
    message.results = object.results?.map((e) => StepRunResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStepRunResult(): StepRunResult {
  return { stepRunId: '', stepReadableId: '', jobRunId: '', error: undefined, output: undefined };
}

export const StepRunResult: MessageFns<StepRunResult> = {
  encode(message: StepRunResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stepRunId !== '') {
      writer.uint32(10).string(message.stepRunId);
    }
    if (message.stepReadableId !== '') {
      writer.uint32(18).string(message.stepReadableId);
    }
    if (message.jobRunId !== '') {
      writer.uint32(26).string(message.jobRunId);
    }
    if (message.error !== undefined) {
      writer.uint32(34).string(message.error);
    }
    if (message.output !== undefined) {
      writer.uint32(42).string(message.output);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StepRunResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStepRunResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stepRunId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stepReadableId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.jobRunId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.output = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StepRunResult {
    return {
      stepRunId: isSet(object.stepRunId) ? globalThis.String(object.stepRunId) : '',
      stepReadableId: isSet(object.stepReadableId) ? globalThis.String(object.stepReadableId) : '',
      jobRunId: isSet(object.jobRunId) ? globalThis.String(object.jobRunId) : '',
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
      output: isSet(object.output) ? globalThis.String(object.output) : undefined,
    };
  },

  toJSON(message: StepRunResult): unknown {
    const obj: any = {};
    if (message.stepRunId !== '') {
      obj.stepRunId = message.stepRunId;
    }
    if (message.stepReadableId !== '') {
      obj.stepReadableId = message.stepReadableId;
    }
    if (message.jobRunId !== '') {
      obj.jobRunId = message.jobRunId;
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    if (message.output !== undefined) {
      obj.output = message.output;
    }
    return obj;
  },

  create(base?: DeepPartial<StepRunResult>): StepRunResult {
    return StepRunResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StepRunResult>): StepRunResult {
    const message = createBaseStepRunResult();
    message.stepRunId = object.stepRunId ?? '';
    message.stepReadableId = object.stepReadableId ?? '';
    message.jobRunId = object.jobRunId ?? '';
    message.error = object.error ?? undefined;
    message.output = object.output ?? undefined;
    return message;
  },
};

function createBaseOverridesData(): OverridesData {
  return { stepRunId: '', path: '', value: '', callerFilename: '' };
}

export const OverridesData: MessageFns<OverridesData> = {
  encode(message: OverridesData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stepRunId !== '') {
      writer.uint32(10).string(message.stepRunId);
    }
    if (message.path !== '') {
      writer.uint32(18).string(message.path);
    }
    if (message.value !== '') {
      writer.uint32(26).string(message.value);
    }
    if (message.callerFilename !== '') {
      writer.uint32(34).string(message.callerFilename);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OverridesData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverridesData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stepRunId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.callerFilename = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OverridesData {
    return {
      stepRunId: isSet(object.stepRunId) ? globalThis.String(object.stepRunId) : '',
      path: isSet(object.path) ? globalThis.String(object.path) : '',
      value: isSet(object.value) ? globalThis.String(object.value) : '',
      callerFilename: isSet(object.callerFilename) ? globalThis.String(object.callerFilename) : '',
    };
  },

  toJSON(message: OverridesData): unknown {
    const obj: any = {};
    if (message.stepRunId !== '') {
      obj.stepRunId = message.stepRunId;
    }
    if (message.path !== '') {
      obj.path = message.path;
    }
    if (message.value !== '') {
      obj.value = message.value;
    }
    if (message.callerFilename !== '') {
      obj.callerFilename = message.callerFilename;
    }
    return obj;
  },

  create(base?: DeepPartial<OverridesData>): OverridesData {
    return OverridesData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OverridesData>): OverridesData {
    const message = createBaseOverridesData();
    message.stepRunId = object.stepRunId ?? '';
    message.path = object.path ?? '';
    message.value = object.value ?? '';
    message.callerFilename = object.callerFilename ?? '';
    return message;
  },
};

function createBaseOverridesDataResponse(): OverridesDataResponse {
  return {};
}

export const OverridesDataResponse: MessageFns<OverridesDataResponse> = {
  encode(_: OverridesDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OverridesDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverridesDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): OverridesDataResponse {
    return {};
  },

  toJSON(_: OverridesDataResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<OverridesDataResponse>): OverridesDataResponse {
    return OverridesDataResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<OverridesDataResponse>): OverridesDataResponse {
    const message = createBaseOverridesDataResponse();
    return message;
  },
};

function createBaseHeartbeatRequest(): HeartbeatRequest {
  return { workerId: '', heartbeatAt: undefined };
}

export const HeartbeatRequest: MessageFns<HeartbeatRequest> = {
  encode(message: HeartbeatRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workerId !== '') {
      writer.uint32(10).string(message.workerId);
    }
    if (message.heartbeatAt !== undefined) {
      Timestamp.encode(toTimestamp(message.heartbeatAt), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.heartbeatAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatRequest {
    return {
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : '',
      heartbeatAt: isSet(object.heartbeatAt) ? fromJsonTimestamp(object.heartbeatAt) : undefined,
    };
  },

  toJSON(message: HeartbeatRequest): unknown {
    const obj: any = {};
    if (message.workerId !== '') {
      obj.workerId = message.workerId;
    }
    if (message.heartbeatAt !== undefined) {
      obj.heartbeatAt = message.heartbeatAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<HeartbeatRequest>): HeartbeatRequest {
    return HeartbeatRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HeartbeatRequest>): HeartbeatRequest {
    const message = createBaseHeartbeatRequest();
    message.workerId = object.workerId ?? '';
    message.heartbeatAt = object.heartbeatAt ?? undefined;
    return message;
  },
};

function createBaseHeartbeatResponse(): HeartbeatResponse {
  return {};
}

export const HeartbeatResponse: MessageFns<HeartbeatResponse> = {
  encode(_: HeartbeatResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HeartbeatResponse {
    return {};
  },

  toJSON(_: HeartbeatResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<HeartbeatResponse>): HeartbeatResponse {
    return HeartbeatResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<HeartbeatResponse>): HeartbeatResponse {
    const message = createBaseHeartbeatResponse();
    return message;
  },
};

function createBaseRefreshTimeoutRequest(): RefreshTimeoutRequest {
  return { stepRunId: '', incrementTimeoutBy: '' };
}

export const RefreshTimeoutRequest: MessageFns<RefreshTimeoutRequest> = {
  encode(message: RefreshTimeoutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stepRunId !== '') {
      writer.uint32(10).string(message.stepRunId);
    }
    if (message.incrementTimeoutBy !== '') {
      writer.uint32(18).string(message.incrementTimeoutBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTimeoutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTimeoutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stepRunId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.incrementTimeoutBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTimeoutRequest {
    return {
      stepRunId: isSet(object.stepRunId) ? globalThis.String(object.stepRunId) : '',
      incrementTimeoutBy: isSet(object.incrementTimeoutBy)
        ? globalThis.String(object.incrementTimeoutBy)
        : '',
    };
  },

  toJSON(message: RefreshTimeoutRequest): unknown {
    const obj: any = {};
    if (message.stepRunId !== '') {
      obj.stepRunId = message.stepRunId;
    }
    if (message.incrementTimeoutBy !== '') {
      obj.incrementTimeoutBy = message.incrementTimeoutBy;
    }
    return obj;
  },

  create(base?: DeepPartial<RefreshTimeoutRequest>): RefreshTimeoutRequest {
    return RefreshTimeoutRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RefreshTimeoutRequest>): RefreshTimeoutRequest {
    const message = createBaseRefreshTimeoutRequest();
    message.stepRunId = object.stepRunId ?? '';
    message.incrementTimeoutBy = object.incrementTimeoutBy ?? '';
    return message;
  },
};

function createBaseRefreshTimeoutResponse(): RefreshTimeoutResponse {
  return { timeoutAt: undefined };
}

export const RefreshTimeoutResponse: MessageFns<RefreshTimeoutResponse> = {
  encode(message: RefreshTimeoutResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeoutAt !== undefined) {
      Timestamp.encode(toTimestamp(message.timeoutAt), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTimeoutResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTimeoutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timeoutAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTimeoutResponse {
    return { timeoutAt: isSet(object.timeoutAt) ? fromJsonTimestamp(object.timeoutAt) : undefined };
  },

  toJSON(message: RefreshTimeoutResponse): unknown {
    const obj: any = {};
    if (message.timeoutAt !== undefined) {
      obj.timeoutAt = message.timeoutAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<RefreshTimeoutResponse>): RefreshTimeoutResponse {
    return RefreshTimeoutResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RefreshTimeoutResponse>): RefreshTimeoutResponse {
    const message = createBaseRefreshTimeoutResponse();
    message.timeoutAt = object.timeoutAt ?? undefined;
    return message;
  },
};

function createBaseReleaseSlotRequest(): ReleaseSlotRequest {
  return { stepRunId: '' };
}

export const ReleaseSlotRequest: MessageFns<ReleaseSlotRequest> = {
  encode(message: ReleaseSlotRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stepRunId !== '') {
      writer.uint32(10).string(message.stepRunId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReleaseSlotRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReleaseSlotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stepRunId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReleaseSlotRequest {
    return { stepRunId: isSet(object.stepRunId) ? globalThis.String(object.stepRunId) : '' };
  },

  toJSON(message: ReleaseSlotRequest): unknown {
    const obj: any = {};
    if (message.stepRunId !== '') {
      obj.stepRunId = message.stepRunId;
    }
    return obj;
  },

  create(base?: DeepPartial<ReleaseSlotRequest>): ReleaseSlotRequest {
    return ReleaseSlotRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReleaseSlotRequest>): ReleaseSlotRequest {
    const message = createBaseReleaseSlotRequest();
    message.stepRunId = object.stepRunId ?? '';
    return message;
  },
};

function createBaseReleaseSlotResponse(): ReleaseSlotResponse {
  return {};
}

export const ReleaseSlotResponse: MessageFns<ReleaseSlotResponse> = {
  encode(_: ReleaseSlotResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReleaseSlotResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReleaseSlotResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ReleaseSlotResponse {
    return {};
  },

  toJSON(_: ReleaseSlotResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ReleaseSlotResponse>): ReleaseSlotResponse {
    return ReleaseSlotResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ReleaseSlotResponse>): ReleaseSlotResponse {
    const message = createBaseReleaseSlotResponse();
    return message;
  },
};

export type DispatcherDefinition = typeof DispatcherDefinition;
export const DispatcherDefinition = {
  name: 'Dispatcher',
  fullName: 'Dispatcher',
  methods: {
    register: {
      name: 'Register',
      requestType: WorkerRegisterRequest,
      requestStream: false,
      responseType: WorkerRegisterResponse,
      responseStream: false,
      options: {},
    },
    listen: {
      name: 'Listen',
      requestType: WorkerListenRequest,
      requestStream: false,
      responseType: AssignedAction,
      responseStream: true,
      options: {},
    },
    /**
     * ListenV2 is like listen, but implementation does not include heartbeats. This should only used by SDKs
     * against engine version v0.18.1+
     */
    listenV2: {
      name: 'ListenV2',
      requestType: WorkerListenRequest,
      requestStream: false,
      responseType: AssignedAction,
      responseStream: true,
      options: {},
    },
    /** Heartbeat is a method for workers to send heartbeats to the dispatcher */
    heartbeat: {
      name: 'Heartbeat',
      requestType: HeartbeatRequest,
      requestStream: false,
      responseType: HeartbeatResponse,
      responseStream: false,
      options: {},
    },
    subscribeToWorkflowEvents: {
      name: 'SubscribeToWorkflowEvents',
      requestType: SubscribeToWorkflowEventsRequest,
      requestStream: false,
      responseType: WorkflowEvent,
      responseStream: true,
      options: {},
    },
    subscribeToWorkflowRuns: {
      name: 'SubscribeToWorkflowRuns',
      requestType: SubscribeToWorkflowRunsRequest,
      requestStream: true,
      responseType: WorkflowRunEvent,
      responseStream: true,
      options: {},
    },
    sendStepActionEvent: {
      name: 'SendStepActionEvent',
      requestType: StepActionEvent,
      requestStream: false,
      responseType: ActionEventResponse,
      responseStream: false,
      options: {},
    },
    sendGroupKeyActionEvent: {
      name: 'SendGroupKeyActionEvent',
      requestType: GroupKeyActionEvent,
      requestStream: false,
      responseType: ActionEventResponse,
      responseStream: false,
      options: {},
    },
    putOverridesData: {
      name: 'PutOverridesData',
      requestType: OverridesData,
      requestStream: false,
      responseType: OverridesDataResponse,
      responseStream: false,
      options: {},
    },
    unsubscribe: {
      name: 'Unsubscribe',
      requestType: WorkerUnsubscribeRequest,
      requestStream: false,
      responseType: WorkerUnsubscribeResponse,
      responseStream: false,
      options: {},
    },
    refreshTimeout: {
      name: 'RefreshTimeout',
      requestType: RefreshTimeoutRequest,
      requestStream: false,
      responseType: RefreshTimeoutResponse,
      responseStream: false,
      options: {},
    },
    releaseSlot: {
      name: 'ReleaseSlot',
      requestType: ReleaseSlotRequest,
      requestStream: false,
      responseType: ReleaseSlotResponse,
      responseStream: false,
      options: {},
    },
    upsertWorkerLabels: {
      name: 'UpsertWorkerLabels',
      requestType: UpsertWorkerLabelsRequest,
      requestStream: false,
      responseType: UpsertWorkerLabelsResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface DispatcherServiceImplementation<CallContextExt = {}> {
  register(
    request: WorkerRegisterRequest,
    context: CallContext & CallContextExt
  ): Promise<DeepPartial<WorkerRegisterResponse>>;
  listen(
    request: WorkerListenRequest,
    context: CallContext & CallContextExt
  ): ServerStreamingMethodResult<DeepPartial<AssignedAction>>;
  /**
   * ListenV2 is like listen, but implementation does not include heartbeats. This should only used by SDKs
   * against engine version v0.18.1+
   */
  listenV2(
    request: WorkerListenRequest,
    context: CallContext & CallContextExt
  ): ServerStreamingMethodResult<DeepPartial<AssignedAction>>;
  /** Heartbeat is a method for workers to send heartbeats to the dispatcher */
  heartbeat(
    request: HeartbeatRequest,
    context: CallContext & CallContextExt
  ): Promise<DeepPartial<HeartbeatResponse>>;
  subscribeToWorkflowEvents(
    request: SubscribeToWorkflowEventsRequest,
    context: CallContext & CallContextExt
  ): ServerStreamingMethodResult<DeepPartial<WorkflowEvent>>;
  subscribeToWorkflowRuns(
    request: AsyncIterable<SubscribeToWorkflowRunsRequest>,
    context: CallContext & CallContextExt
  ): ServerStreamingMethodResult<DeepPartial<WorkflowRunEvent>>;
  sendStepActionEvent(
    request: StepActionEvent,
    context: CallContext & CallContextExt
  ): Promise<DeepPartial<ActionEventResponse>>;
  sendGroupKeyActionEvent(
    request: GroupKeyActionEvent,
    context: CallContext & CallContextExt
  ): Promise<DeepPartial<ActionEventResponse>>;
  putOverridesData(
    request: OverridesData,
    context: CallContext & CallContextExt
  ): Promise<DeepPartial<OverridesDataResponse>>;
  unsubscribe(
    request: WorkerUnsubscribeRequest,
    context: CallContext & CallContextExt
  ): Promise<DeepPartial<WorkerUnsubscribeResponse>>;
  refreshTimeout(
    request: RefreshTimeoutRequest,
    context: CallContext & CallContextExt
  ): Promise<DeepPartial<RefreshTimeoutResponse>>;
  releaseSlot(
    request: ReleaseSlotRequest,
    context: CallContext & CallContextExt
  ): Promise<DeepPartial<ReleaseSlotResponse>>;
  upsertWorkerLabels(
    request: UpsertWorkerLabelsRequest,
    context: CallContext & CallContextExt
  ): Promise<DeepPartial<UpsertWorkerLabelsResponse>>;
}

export interface DispatcherClient<CallOptionsExt = {}> {
  register(
    request: DeepPartial<WorkerRegisterRequest>,
    options?: CallOptions & CallOptionsExt
  ): Promise<WorkerRegisterResponse>;
  listen(
    request: DeepPartial<WorkerListenRequest>,
    options?: CallOptions & CallOptionsExt
  ): AsyncIterable<AssignedAction>;
  /**
   * ListenV2 is like listen, but implementation does not include heartbeats. This should only used by SDKs
   * against engine version v0.18.1+
   */
  listenV2(
    request: DeepPartial<WorkerListenRequest>,
    options?: CallOptions & CallOptionsExt
  ): AsyncIterable<AssignedAction>;
  /** Heartbeat is a method for workers to send heartbeats to the dispatcher */
  heartbeat(
    request: DeepPartial<HeartbeatRequest>,
    options?: CallOptions & CallOptionsExt
  ): Promise<HeartbeatResponse>;
  subscribeToWorkflowEvents(
    request: DeepPartial<SubscribeToWorkflowEventsRequest>,
    options?: CallOptions & CallOptionsExt
  ): AsyncIterable<WorkflowEvent>;
  subscribeToWorkflowRuns(
    request: AsyncIterable<DeepPartial<SubscribeToWorkflowRunsRequest>>,
    options?: CallOptions & CallOptionsExt
  ): AsyncIterable<WorkflowRunEvent>;
  sendStepActionEvent(
    request: DeepPartial<StepActionEvent>,
    options?: CallOptions & CallOptionsExt
  ): Promise<ActionEventResponse>;
  sendGroupKeyActionEvent(
    request: DeepPartial<GroupKeyActionEvent>,
    options?: CallOptions & CallOptionsExt
  ): Promise<ActionEventResponse>;
  putOverridesData(
    request: DeepPartial<OverridesData>,
    options?: CallOptions & CallOptionsExt
  ): Promise<OverridesDataResponse>;
  unsubscribe(
    request: DeepPartial<WorkerUnsubscribeRequest>,
    options?: CallOptions & CallOptionsExt
  ): Promise<WorkerUnsubscribeResponse>;
  refreshTimeout(
    request: DeepPartial<RefreshTimeoutRequest>,
    options?: CallOptions & CallOptionsExt
  ): Promise<RefreshTimeoutResponse>;
  releaseSlot(
    request: DeepPartial<ReleaseSlotRequest>,
    options?: CallOptions & CallOptionsExt
  ): Promise<ReleaseSlotResponse>;
  upsertWorkerLabels(
    request: DeepPartial<UpsertWorkerLabelsRequest>,
    options?: CallOptions & CallOptionsExt
  ): Promise<UpsertWorkerLabelsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === 'string') {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === 'object' && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = {
  [Symbol.asyncIterator](): AsyncIterator<Response, void>;
};

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
