// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.19.1
// source: v1/workflows.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Timestamp } from "../google/protobuf/timestamp";
import { TaskConditions } from "./shared/condition";

export const protobufPackage = "v1";

export enum StickyStrategy {
  SOFT = 0,
  HARD = 1,
  UNRECOGNIZED = -1,
}

export function stickyStrategyFromJSON(object: any): StickyStrategy {
  switch (object) {
    case 0:
    case "SOFT":
      return StickyStrategy.SOFT;
    case 1:
    case "HARD":
      return StickyStrategy.HARD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StickyStrategy.UNRECOGNIZED;
  }
}

export function stickyStrategyToJSON(object: StickyStrategy): string {
  switch (object) {
    case StickyStrategy.SOFT:
      return "SOFT";
    case StickyStrategy.HARD:
      return "HARD";
    case StickyStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RateLimitDuration {
  SECOND = 0,
  MINUTE = 1,
  HOUR = 2,
  DAY = 3,
  WEEK = 4,
  MONTH = 5,
  YEAR = 6,
  UNRECOGNIZED = -1,
}

export function rateLimitDurationFromJSON(object: any): RateLimitDuration {
  switch (object) {
    case 0:
    case "SECOND":
      return RateLimitDuration.SECOND;
    case 1:
    case "MINUTE":
      return RateLimitDuration.MINUTE;
    case 2:
    case "HOUR":
      return RateLimitDuration.HOUR;
    case 3:
    case "DAY":
      return RateLimitDuration.DAY;
    case 4:
    case "WEEK":
      return RateLimitDuration.WEEK;
    case 5:
    case "MONTH":
      return RateLimitDuration.MONTH;
    case 6:
    case "YEAR":
      return RateLimitDuration.YEAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RateLimitDuration.UNRECOGNIZED;
  }
}

export function rateLimitDurationToJSON(object: RateLimitDuration): string {
  switch (object) {
    case RateLimitDuration.SECOND:
      return "SECOND";
    case RateLimitDuration.MINUTE:
      return "MINUTE";
    case RateLimitDuration.HOUR:
      return "HOUR";
    case RateLimitDuration.DAY:
      return "DAY";
    case RateLimitDuration.WEEK:
      return "WEEK";
    case RateLimitDuration.MONTH:
      return "MONTH";
    case RateLimitDuration.YEAR:
      return "YEAR";
    case RateLimitDuration.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ConcurrencyLimitStrategy {
  CANCEL_IN_PROGRESS = 0,
  /** DROP_NEWEST - deprecated */
  DROP_NEWEST = 1,
  /** QUEUE_NEWEST - deprecated */
  QUEUE_NEWEST = 2,
  GROUP_ROUND_ROBIN = 3,
  CANCEL_NEWEST = 4,
  UNRECOGNIZED = -1,
}

export function concurrencyLimitStrategyFromJSON(object: any): ConcurrencyLimitStrategy {
  switch (object) {
    case 0:
    case "CANCEL_IN_PROGRESS":
      return ConcurrencyLimitStrategy.CANCEL_IN_PROGRESS;
    case 1:
    case "DROP_NEWEST":
      return ConcurrencyLimitStrategy.DROP_NEWEST;
    case 2:
    case "QUEUE_NEWEST":
      return ConcurrencyLimitStrategy.QUEUE_NEWEST;
    case 3:
    case "GROUP_ROUND_ROBIN":
      return ConcurrencyLimitStrategy.GROUP_ROUND_ROBIN;
    case 4:
    case "CANCEL_NEWEST":
      return ConcurrencyLimitStrategy.CANCEL_NEWEST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConcurrencyLimitStrategy.UNRECOGNIZED;
  }
}

export function concurrencyLimitStrategyToJSON(object: ConcurrencyLimitStrategy): string {
  switch (object) {
    case ConcurrencyLimitStrategy.CANCEL_IN_PROGRESS:
      return "CANCEL_IN_PROGRESS";
    case ConcurrencyLimitStrategy.DROP_NEWEST:
      return "DROP_NEWEST";
    case ConcurrencyLimitStrategy.QUEUE_NEWEST:
      return "QUEUE_NEWEST";
    case ConcurrencyLimitStrategy.GROUP_ROUND_ROBIN:
      return "GROUP_ROUND_ROBIN";
    case ConcurrencyLimitStrategy.CANCEL_NEWEST:
      return "CANCEL_NEWEST";
    case ConcurrencyLimitStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WorkerLabelComparator {
  EQUAL = 0,
  NOT_EQUAL = 1,
  GREATER_THAN = 2,
  GREATER_THAN_OR_EQUAL = 3,
  LESS_THAN = 4,
  LESS_THAN_OR_EQUAL = 5,
  UNRECOGNIZED = -1,
}

export function workerLabelComparatorFromJSON(object: any): WorkerLabelComparator {
  switch (object) {
    case 0:
    case "EQUAL":
      return WorkerLabelComparator.EQUAL;
    case 1:
    case "NOT_EQUAL":
      return WorkerLabelComparator.NOT_EQUAL;
    case 2:
    case "GREATER_THAN":
      return WorkerLabelComparator.GREATER_THAN;
    case 3:
    case "GREATER_THAN_OR_EQUAL":
      return WorkerLabelComparator.GREATER_THAN_OR_EQUAL;
    case 4:
    case "LESS_THAN":
      return WorkerLabelComparator.LESS_THAN;
    case 5:
    case "LESS_THAN_OR_EQUAL":
      return WorkerLabelComparator.LESS_THAN_OR_EQUAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WorkerLabelComparator.UNRECOGNIZED;
  }
}

export function workerLabelComparatorToJSON(object: WorkerLabelComparator): string {
  switch (object) {
    case WorkerLabelComparator.EQUAL:
      return "EQUAL";
    case WorkerLabelComparator.NOT_EQUAL:
      return "NOT_EQUAL";
    case WorkerLabelComparator.GREATER_THAN:
      return "GREATER_THAN";
    case WorkerLabelComparator.GREATER_THAN_OR_EQUAL:
      return "GREATER_THAN_OR_EQUAL";
    case WorkerLabelComparator.LESS_THAN:
      return "LESS_THAN";
    case WorkerLabelComparator.LESS_THAN_OR_EQUAL:
      return "LESS_THAN_OR_EQUAL";
    case WorkerLabelComparator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CancelTasksRequest {
  /** a list of external UUIDs */
  externalIds: string[];
  filter?: TasksFilter | undefined;
}

export interface ReplayTasksRequest {
  /** a list of external UUIDs */
  externalIds: string[];
  filter?: TasksFilter | undefined;
}

export interface TasksFilter {
  statuses: string[];
  since: Date | undefined;
  until?: Date | undefined;
  workflowIds: string[];
  additionalMetadata: string[];
}

export interface CancelTasksResponse {
  cancelledTasks: string[];
}

export interface ReplayTasksResponse {
  replayedTasks: string[];
}

export interface TriggerWorkflowRunRequest {
  workflowName: string;
  input: Uint8Array;
  additionalMetadata: Uint8Array;
}

export interface TriggerWorkflowRunResponse {
  externalId: string;
}

/** CreateWorkflowVersionRequest represents options to create a workflow version. */
export interface CreateWorkflowVersionRequest {
  /** (required) the workflow name */
  name: string;
  /** (optional) the workflow description */
  description: string;
  /** (optional) the workflow version */
  version: string;
  /** (optional) event triggers for the workflow */
  eventTriggers: string[];
  /** (optional) cron triggers for the workflow */
  cronTriggers: string[];
  /** (required) the workflow jobs */
  tasks: CreateTaskOpts[];
  /** Deprecated: use concurrency_arr instead */
  concurrency:
    | Concurrency
    | undefined;
  /** (optional) the input for the cron trigger */
  cronInput?:
    | string
    | undefined;
  /** (optional) the job to run on failure */
  onFailureTask?:
    | CreateTaskOpts
    | undefined;
  /** (optional) the sticky strategy for assigning steps to workers */
  sticky?:
    | StickyStrategy
    | undefined;
  /** (optional) the workflow concurrency options */
  concurrencyArr: Concurrency[];
}

export interface Concurrency {
  /** (required) the expression to use for concurrency */
  expression: string;
  /** (optional) the maximum number of concurrent workflow runs, default 1 */
  maxRuns?:
    | number
    | undefined;
  /** (optional) the strategy to use when the concurrency limit is reached, default CANCEL_IN_PROGRESS */
  limitStrategy?: ConcurrencyLimitStrategy | undefined;
}

export interface DesiredWorkerLabels {
  /** value of the affinity */
  strValue?: string | undefined;
  intValue?:
    | number
    | undefined;
  /**
   * (optional) Specifies whether the affinity setting is required.
   * If required, the worker will not accept actions that do not have a truthy affinity setting.
   *
   * Defaults to false.
   */
  required?:
    | boolean
    | undefined;
  /**
   * (optional) Specifies the comparator for the affinity setting.
   * If not set, the default is EQUAL.
   */
  comparator?:
    | WorkerLabelComparator
    | undefined;
  /**
   * (optional) Specifies the weight of the affinity setting.
   * If not set, the default is 100.
   */
  weight?: number | undefined;
}

/** CreateTaskOpts represents options to create a task. */
export interface CreateTaskOpts {
  /** (required) the task name */
  readableId: string;
  /** (required) the task action id */
  action: string;
  /** (optional) the task timeout */
  timeout: string;
  /** (optional) the task inputs, assuming string representation of JSON */
  inputs: string;
  /** (optional) the task parents. if none are passed in, this is a root task */
  parents: string[];
  /** (optional) the number of retries for the step, default 0 */
  retries: number;
  /** (optional) the rate limits for the step */
  rateLimits: CreateTaskRateLimit[];
  /** (optional) the desired worker affinity state for the step */
  workerLabels: { [key: string]: DesiredWorkerLabels };
  /** (optional) the retry backoff factor for the step */
  backoffFactor?:
    | number
    | undefined;
  /** (optional) the maximum backoff time for the step */
  backoffMaxSeconds?:
    | number
    | undefined;
  /** (optional) the task concurrency options */
  concurrency: Concurrency[];
  /** (optional) the task conditions for creating the task */
  conditions?:
    | TaskConditions
    | undefined;
  /** (optional) the timeout for the schedule */
  scheduleTimeout?: string | undefined;
}

export interface CreateTaskOpts_WorkerLabelsEntry {
  key: string;
  value: DesiredWorkerLabels | undefined;
}

export interface CreateTaskRateLimit {
  /** (required) the key for the rate limit */
  key: string;
  /** (optional) the number of units this step consumes */
  units?:
    | number
    | undefined;
  /** (optional) a CEL expression for determining the rate limit key */
  keyExpr?:
    | string
    | undefined;
  /** (optional) a CEL expression for determining the number of units consumed */
  unitsExpr?:
    | string
    | undefined;
  /** (optional) a CEL expression for determining the total amount of rate limit units */
  limitValuesExpr?:
    | string
    | undefined;
  /** (optional) the default rate limit window to use for dynamic rate limits */
  duration?: RateLimitDuration | undefined;
}

/** CreateWorkflowVersionResponse represents the response after creating a workflow version. */
export interface CreateWorkflowVersionResponse {
  id: string;
  workflowId: string;
}

function createBaseCancelTasksRequest(): CancelTasksRequest {
  return { externalIds: [], filter: undefined };
}

export const CancelTasksRequest: MessageFns<CancelTasksRequest> = {
  encode(message: CancelTasksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.externalIds) {
      writer.uint32(10).string(v!);
    }
    if (message.filter !== undefined) {
      TasksFilter.encode(message.filter, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelTasksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelTasksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.externalIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filter = TasksFilter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelTasksRequest {
    return {
      externalIds: globalThis.Array.isArray(object?.externalIds)
        ? object.externalIds.map((e: any) => globalThis.String(e))
        : [],
      filter: isSet(object.filter) ? TasksFilter.fromJSON(object.filter) : undefined,
    };
  },

  toJSON(message: CancelTasksRequest): unknown {
    const obj: any = {};
    if (message.externalIds?.length) {
      obj.externalIds = message.externalIds;
    }
    if (message.filter !== undefined) {
      obj.filter = TasksFilter.toJSON(message.filter);
    }
    return obj;
  },

  create(base?: DeepPartial<CancelTasksRequest>): CancelTasksRequest {
    return CancelTasksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelTasksRequest>): CancelTasksRequest {
    const message = createBaseCancelTasksRequest();
    message.externalIds = object.externalIds?.map((e) => e) || [];
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? TasksFilter.fromPartial(object.filter)
      : undefined;
    return message;
  },
};

function createBaseReplayTasksRequest(): ReplayTasksRequest {
  return { externalIds: [], filter: undefined };
}

export const ReplayTasksRequest: MessageFns<ReplayTasksRequest> = {
  encode(message: ReplayTasksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.externalIds) {
      writer.uint32(10).string(v!);
    }
    if (message.filter !== undefined) {
      TasksFilter.encode(message.filter, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplayTasksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplayTasksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.externalIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filter = TasksFilter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplayTasksRequest {
    return {
      externalIds: globalThis.Array.isArray(object?.externalIds)
        ? object.externalIds.map((e: any) => globalThis.String(e))
        : [],
      filter: isSet(object.filter) ? TasksFilter.fromJSON(object.filter) : undefined,
    };
  },

  toJSON(message: ReplayTasksRequest): unknown {
    const obj: any = {};
    if (message.externalIds?.length) {
      obj.externalIds = message.externalIds;
    }
    if (message.filter !== undefined) {
      obj.filter = TasksFilter.toJSON(message.filter);
    }
    return obj;
  },

  create(base?: DeepPartial<ReplayTasksRequest>): ReplayTasksRequest {
    return ReplayTasksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplayTasksRequest>): ReplayTasksRequest {
    const message = createBaseReplayTasksRequest();
    message.externalIds = object.externalIds?.map((e) => e) || [];
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? TasksFilter.fromPartial(object.filter)
      : undefined;
    return message;
  },
};

function createBaseTasksFilter(): TasksFilter {
  return { statuses: [], since: undefined, until: undefined, workflowIds: [], additionalMetadata: [] };
}

export const TasksFilter: MessageFns<TasksFilter> = {
  encode(message: TasksFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.statuses) {
      writer.uint32(10).string(v!);
    }
    if (message.since !== undefined) {
      Timestamp.encode(toTimestamp(message.since), writer.uint32(18).fork()).join();
    }
    if (message.until !== undefined) {
      Timestamp.encode(toTimestamp(message.until), writer.uint32(26).fork()).join();
    }
    for (const v of message.workflowIds) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.additionalMetadata) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TasksFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTasksFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statuses.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.since = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.until = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workflowIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.additionalMetadata.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TasksFilter {
    return {
      statuses: globalThis.Array.isArray(object?.statuses) ? object.statuses.map((e: any) => globalThis.String(e)) : [],
      since: isSet(object.since) ? fromJsonTimestamp(object.since) : undefined,
      until: isSet(object.until) ? fromJsonTimestamp(object.until) : undefined,
      workflowIds: globalThis.Array.isArray(object?.workflowIds)
        ? object.workflowIds.map((e: any) => globalThis.String(e))
        : [],
      additionalMetadata: globalThis.Array.isArray(object?.additionalMetadata)
        ? object.additionalMetadata.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: TasksFilter): unknown {
    const obj: any = {};
    if (message.statuses?.length) {
      obj.statuses = message.statuses;
    }
    if (message.since !== undefined) {
      obj.since = message.since.toISOString();
    }
    if (message.until !== undefined) {
      obj.until = message.until.toISOString();
    }
    if (message.workflowIds?.length) {
      obj.workflowIds = message.workflowIds;
    }
    if (message.additionalMetadata?.length) {
      obj.additionalMetadata = message.additionalMetadata;
    }
    return obj;
  },

  create(base?: DeepPartial<TasksFilter>): TasksFilter {
    return TasksFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TasksFilter>): TasksFilter {
    const message = createBaseTasksFilter();
    message.statuses = object.statuses?.map((e) => e) || [];
    message.since = object.since ?? undefined;
    message.until = object.until ?? undefined;
    message.workflowIds = object.workflowIds?.map((e) => e) || [];
    message.additionalMetadata = object.additionalMetadata?.map((e) => e) || [];
    return message;
  },
};

function createBaseCancelTasksResponse(): CancelTasksResponse {
  return { cancelledTasks: [] };
}

export const CancelTasksResponse: MessageFns<CancelTasksResponse> = {
  encode(message: CancelTasksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cancelledTasks) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelTasksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelTasksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cancelledTasks.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelTasksResponse {
    return {
      cancelledTasks: globalThis.Array.isArray(object?.cancelledTasks)
        ? object.cancelledTasks.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CancelTasksResponse): unknown {
    const obj: any = {};
    if (message.cancelledTasks?.length) {
      obj.cancelledTasks = message.cancelledTasks;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelTasksResponse>): CancelTasksResponse {
    return CancelTasksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelTasksResponse>): CancelTasksResponse {
    const message = createBaseCancelTasksResponse();
    message.cancelledTasks = object.cancelledTasks?.map((e) => e) || [];
    return message;
  },
};

function createBaseReplayTasksResponse(): ReplayTasksResponse {
  return { replayedTasks: [] };
}

export const ReplayTasksResponse: MessageFns<ReplayTasksResponse> = {
  encode(message: ReplayTasksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.replayedTasks) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplayTasksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplayTasksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.replayedTasks.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplayTasksResponse {
    return {
      replayedTasks: globalThis.Array.isArray(object?.replayedTasks)
        ? object.replayedTasks.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ReplayTasksResponse): unknown {
    const obj: any = {};
    if (message.replayedTasks?.length) {
      obj.replayedTasks = message.replayedTasks;
    }
    return obj;
  },

  create(base?: DeepPartial<ReplayTasksResponse>): ReplayTasksResponse {
    return ReplayTasksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplayTasksResponse>): ReplayTasksResponse {
    const message = createBaseReplayTasksResponse();
    message.replayedTasks = object.replayedTasks?.map((e) => e) || [];
    return message;
  },
};

function createBaseTriggerWorkflowRunRequest(): TriggerWorkflowRunRequest {
  return { workflowName: "", input: new Uint8Array(0), additionalMetadata: new Uint8Array(0) };
}

export const TriggerWorkflowRunRequest: MessageFns<TriggerWorkflowRunRequest> = {
  encode(message: TriggerWorkflowRunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workflowName !== "") {
      writer.uint32(10).string(message.workflowName);
    }
    if (message.input.length !== 0) {
      writer.uint32(18).bytes(message.input);
    }
    if (message.additionalMetadata.length !== 0) {
      writer.uint32(26).bytes(message.additionalMetadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TriggerWorkflowRunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTriggerWorkflowRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflowName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.additionalMetadata = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TriggerWorkflowRunRequest {
    return {
      workflowName: isSet(object.workflowName) ? globalThis.String(object.workflowName) : "",
      input: isSet(object.input) ? bytesFromBase64(object.input) : new Uint8Array(0),
      additionalMetadata: isSet(object.additionalMetadata)
        ? bytesFromBase64(object.additionalMetadata)
        : new Uint8Array(0),
    };
  },

  toJSON(message: TriggerWorkflowRunRequest): unknown {
    const obj: any = {};
    if (message.workflowName !== "") {
      obj.workflowName = message.workflowName;
    }
    if (message.input.length !== 0) {
      obj.input = base64FromBytes(message.input);
    }
    if (message.additionalMetadata.length !== 0) {
      obj.additionalMetadata = base64FromBytes(message.additionalMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<TriggerWorkflowRunRequest>): TriggerWorkflowRunRequest {
    return TriggerWorkflowRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TriggerWorkflowRunRequest>): TriggerWorkflowRunRequest {
    const message = createBaseTriggerWorkflowRunRequest();
    message.workflowName = object.workflowName ?? "";
    message.input = object.input ?? new Uint8Array(0);
    message.additionalMetadata = object.additionalMetadata ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTriggerWorkflowRunResponse(): TriggerWorkflowRunResponse {
  return { externalId: "" };
}

export const TriggerWorkflowRunResponse: MessageFns<TriggerWorkflowRunResponse> = {
  encode(message: TriggerWorkflowRunResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.externalId !== "") {
      writer.uint32(10).string(message.externalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TriggerWorkflowRunResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTriggerWorkflowRunResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TriggerWorkflowRunResponse {
    return { externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "" };
  },

  toJSON(message: TriggerWorkflowRunResponse): unknown {
    const obj: any = {};
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    return obj;
  },

  create(base?: DeepPartial<TriggerWorkflowRunResponse>): TriggerWorkflowRunResponse {
    return TriggerWorkflowRunResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TriggerWorkflowRunResponse>): TriggerWorkflowRunResponse {
    const message = createBaseTriggerWorkflowRunResponse();
    message.externalId = object.externalId ?? "";
    return message;
  },
};

function createBaseCreateWorkflowVersionRequest(): CreateWorkflowVersionRequest {
  return {
    name: "",
    description: "",
    version: "",
    eventTriggers: [],
    cronTriggers: [],
    tasks: [],
    concurrency: undefined,
    cronInput: undefined,
    onFailureTask: undefined,
    sticky: undefined,
    concurrencyArr: [],
  };
}

export const CreateWorkflowVersionRequest: MessageFns<CreateWorkflowVersionRequest> = {
  encode(message: CreateWorkflowVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    for (const v of message.eventTriggers) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.cronTriggers) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.tasks) {
      CreateTaskOpts.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.concurrency !== undefined) {
      Concurrency.encode(message.concurrency, writer.uint32(58).fork()).join();
    }
    if (message.cronInput !== undefined) {
      writer.uint32(66).string(message.cronInput);
    }
    if (message.onFailureTask !== undefined) {
      CreateTaskOpts.encode(message.onFailureTask, writer.uint32(74).fork()).join();
    }
    if (message.sticky !== undefined) {
      writer.uint32(80).int32(message.sticky);
    }
    for (const v of message.concurrencyArr) {
      Concurrency.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateWorkflowVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWorkflowVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.eventTriggers.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cronTriggers.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tasks.push(CreateTaskOpts.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.concurrency = Concurrency.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cronInput = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.onFailureTask = CreateTaskOpts.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.sticky = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.concurrencyArr.push(Concurrency.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWorkflowVersionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      eventTriggers: globalThis.Array.isArray(object?.eventTriggers)
        ? object.eventTriggers.map((e: any) => globalThis.String(e))
        : [],
      cronTriggers: globalThis.Array.isArray(object?.cronTriggers)
        ? object.cronTriggers.map((e: any) => globalThis.String(e))
        : [],
      tasks: globalThis.Array.isArray(object?.tasks) ? object.tasks.map((e: any) => CreateTaskOpts.fromJSON(e)) : [],
      concurrency: isSet(object.concurrency) ? Concurrency.fromJSON(object.concurrency) : undefined,
      cronInput: isSet(object.cronInput) ? globalThis.String(object.cronInput) : undefined,
      onFailureTask: isSet(object.onFailureTask) ? CreateTaskOpts.fromJSON(object.onFailureTask) : undefined,
      sticky: isSet(object.sticky) ? stickyStrategyFromJSON(object.sticky) : undefined,
      concurrencyArr: globalThis.Array.isArray(object?.concurrencyArr)
        ? object.concurrencyArr.map((e: any) => Concurrency.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateWorkflowVersionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.eventTriggers?.length) {
      obj.eventTriggers = message.eventTriggers;
    }
    if (message.cronTriggers?.length) {
      obj.cronTriggers = message.cronTriggers;
    }
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => CreateTaskOpts.toJSON(e));
    }
    if (message.concurrency !== undefined) {
      obj.concurrency = Concurrency.toJSON(message.concurrency);
    }
    if (message.cronInput !== undefined) {
      obj.cronInput = message.cronInput;
    }
    if (message.onFailureTask !== undefined) {
      obj.onFailureTask = CreateTaskOpts.toJSON(message.onFailureTask);
    }
    if (message.sticky !== undefined) {
      obj.sticky = stickyStrategyToJSON(message.sticky);
    }
    if (message.concurrencyArr?.length) {
      obj.concurrencyArr = message.concurrencyArr.map((e) => Concurrency.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWorkflowVersionRequest>): CreateWorkflowVersionRequest {
    return CreateWorkflowVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWorkflowVersionRequest>): CreateWorkflowVersionRequest {
    const message = createBaseCreateWorkflowVersionRequest();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.version = object.version ?? "";
    message.eventTriggers = object.eventTriggers?.map((e) => e) || [];
    message.cronTriggers = object.cronTriggers?.map((e) => e) || [];
    message.tasks = object.tasks?.map((e) => CreateTaskOpts.fromPartial(e)) || [];
    message.concurrency = (object.concurrency !== undefined && object.concurrency !== null)
      ? Concurrency.fromPartial(object.concurrency)
      : undefined;
    message.cronInput = object.cronInput ?? undefined;
    message.onFailureTask = (object.onFailureTask !== undefined && object.onFailureTask !== null)
      ? CreateTaskOpts.fromPartial(object.onFailureTask)
      : undefined;
    message.sticky = object.sticky ?? undefined;
    message.concurrencyArr = object.concurrencyArr?.map((e) => Concurrency.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConcurrency(): Concurrency {
  return { expression: "", maxRuns: undefined, limitStrategy: undefined };
}

export const Concurrency: MessageFns<Concurrency> = {
  encode(message: Concurrency, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expression !== "") {
      writer.uint32(10).string(message.expression);
    }
    if (message.maxRuns !== undefined) {
      writer.uint32(16).int32(message.maxRuns);
    }
    if (message.limitStrategy !== undefined) {
      writer.uint32(24).int32(message.limitStrategy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Concurrency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConcurrency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expression = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxRuns = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limitStrategy = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Concurrency {
    return {
      expression: isSet(object.expression) ? globalThis.String(object.expression) : "",
      maxRuns: isSet(object.maxRuns) ? globalThis.Number(object.maxRuns) : undefined,
      limitStrategy: isSet(object.limitStrategy) ? concurrencyLimitStrategyFromJSON(object.limitStrategy) : undefined,
    };
  },

  toJSON(message: Concurrency): unknown {
    const obj: any = {};
    if (message.expression !== "") {
      obj.expression = message.expression;
    }
    if (message.maxRuns !== undefined) {
      obj.maxRuns = Math.round(message.maxRuns);
    }
    if (message.limitStrategy !== undefined) {
      obj.limitStrategy = concurrencyLimitStrategyToJSON(message.limitStrategy);
    }
    return obj;
  },

  create(base?: DeepPartial<Concurrency>): Concurrency {
    return Concurrency.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Concurrency>): Concurrency {
    const message = createBaseConcurrency();
    message.expression = object.expression ?? "";
    message.maxRuns = object.maxRuns ?? undefined;
    message.limitStrategy = object.limitStrategy ?? undefined;
    return message;
  },
};

function createBaseDesiredWorkerLabels(): DesiredWorkerLabels {
  return { strValue: undefined, intValue: undefined, required: undefined, comparator: undefined, weight: undefined };
}

export const DesiredWorkerLabels: MessageFns<DesiredWorkerLabels> = {
  encode(message: DesiredWorkerLabels, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.strValue !== undefined) {
      writer.uint32(10).string(message.strValue);
    }
    if (message.intValue !== undefined) {
      writer.uint32(16).int32(message.intValue);
    }
    if (message.required !== undefined) {
      writer.uint32(24).bool(message.required);
    }
    if (message.comparator !== undefined) {
      writer.uint32(32).int32(message.comparator);
    }
    if (message.weight !== undefined) {
      writer.uint32(40).int32(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DesiredWorkerLabels {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDesiredWorkerLabels();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.strValue = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.intValue = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.comparator = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.weight = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DesiredWorkerLabels {
    return {
      strValue: isSet(object.strValue) ? globalThis.String(object.strValue) : undefined,
      intValue: isSet(object.intValue) ? globalThis.Number(object.intValue) : undefined,
      required: isSet(object.required) ? globalThis.Boolean(object.required) : undefined,
      comparator: isSet(object.comparator) ? workerLabelComparatorFromJSON(object.comparator) : undefined,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : undefined,
    };
  },

  toJSON(message: DesiredWorkerLabels): unknown {
    const obj: any = {};
    if (message.strValue !== undefined) {
      obj.strValue = message.strValue;
    }
    if (message.intValue !== undefined) {
      obj.intValue = Math.round(message.intValue);
    }
    if (message.required !== undefined) {
      obj.required = message.required;
    }
    if (message.comparator !== undefined) {
      obj.comparator = workerLabelComparatorToJSON(message.comparator);
    }
    if (message.weight !== undefined) {
      obj.weight = Math.round(message.weight);
    }
    return obj;
  },

  create(base?: DeepPartial<DesiredWorkerLabels>): DesiredWorkerLabels {
    return DesiredWorkerLabels.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DesiredWorkerLabels>): DesiredWorkerLabels {
    const message = createBaseDesiredWorkerLabels();
    message.strValue = object.strValue ?? undefined;
    message.intValue = object.intValue ?? undefined;
    message.required = object.required ?? undefined;
    message.comparator = object.comparator ?? undefined;
    message.weight = object.weight ?? undefined;
    return message;
  },
};

function createBaseCreateTaskOpts(): CreateTaskOpts {
  return {
    readableId: "",
    action: "",
    timeout: "",
    inputs: "",
    parents: [],
    retries: 0,
    rateLimits: [],
    workerLabels: {},
    backoffFactor: undefined,
    backoffMaxSeconds: undefined,
    concurrency: [],
    conditions: undefined,
    scheduleTimeout: undefined,
  };
}

export const CreateTaskOpts: MessageFns<CreateTaskOpts> = {
  encode(message: CreateTaskOpts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.readableId !== "") {
      writer.uint32(10).string(message.readableId);
    }
    if (message.action !== "") {
      writer.uint32(18).string(message.action);
    }
    if (message.timeout !== "") {
      writer.uint32(26).string(message.timeout);
    }
    if (message.inputs !== "") {
      writer.uint32(34).string(message.inputs);
    }
    for (const v of message.parents) {
      writer.uint32(42).string(v!);
    }
    if (message.retries !== 0) {
      writer.uint32(48).int32(message.retries);
    }
    for (const v of message.rateLimits) {
      CreateTaskRateLimit.encode(v!, writer.uint32(58).fork()).join();
    }
    Object.entries(message.workerLabels).forEach(([key, value]) => {
      CreateTaskOpts_WorkerLabelsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.backoffFactor !== undefined) {
      writer.uint32(77).float(message.backoffFactor);
    }
    if (message.backoffMaxSeconds !== undefined) {
      writer.uint32(80).int32(message.backoffMaxSeconds);
    }
    for (const v of message.concurrency) {
      Concurrency.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.conditions !== undefined) {
      TaskConditions.encode(message.conditions, writer.uint32(98).fork()).join();
    }
    if (message.scheduleTimeout !== undefined) {
      writer.uint32(106).string(message.scheduleTimeout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTaskOpts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTaskOpts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.readableId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timeout = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.inputs = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.parents.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.retries = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rateLimits.push(CreateTaskRateLimit.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = CreateTaskOpts_WorkerLabelsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.workerLabels[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.backoffFactor = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.backoffMaxSeconds = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.concurrency.push(Concurrency.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.conditions = TaskConditions.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.scheduleTimeout = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTaskOpts {
    return {
      readableId: isSet(object.readableId) ? globalThis.String(object.readableId) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      timeout: isSet(object.timeout) ? globalThis.String(object.timeout) : "",
      inputs: isSet(object.inputs) ? globalThis.String(object.inputs) : "",
      parents: globalThis.Array.isArray(object?.parents) ? object.parents.map((e: any) => globalThis.String(e)) : [],
      retries: isSet(object.retries) ? globalThis.Number(object.retries) : 0,
      rateLimits: globalThis.Array.isArray(object?.rateLimits)
        ? object.rateLimits.map((e: any) => CreateTaskRateLimit.fromJSON(e))
        : [],
      workerLabels: isObject(object.workerLabels)
        ? Object.entries(object.workerLabels).reduce<{ [key: string]: DesiredWorkerLabels }>((acc, [key, value]) => {
          acc[key] = DesiredWorkerLabels.fromJSON(value);
          return acc;
        }, {})
        : {},
      backoffFactor: isSet(object.backoffFactor) ? globalThis.Number(object.backoffFactor) : undefined,
      backoffMaxSeconds: isSet(object.backoffMaxSeconds) ? globalThis.Number(object.backoffMaxSeconds) : undefined,
      concurrency: globalThis.Array.isArray(object?.concurrency)
        ? object.concurrency.map((e: any) => Concurrency.fromJSON(e))
        : [],
      conditions: isSet(object.conditions) ? TaskConditions.fromJSON(object.conditions) : undefined,
      scheduleTimeout: isSet(object.scheduleTimeout) ? globalThis.String(object.scheduleTimeout) : undefined,
    };
  },

  toJSON(message: CreateTaskOpts): unknown {
    const obj: any = {};
    if (message.readableId !== "") {
      obj.readableId = message.readableId;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.timeout !== "") {
      obj.timeout = message.timeout;
    }
    if (message.inputs !== "") {
      obj.inputs = message.inputs;
    }
    if (message.parents?.length) {
      obj.parents = message.parents;
    }
    if (message.retries !== 0) {
      obj.retries = Math.round(message.retries);
    }
    if (message.rateLimits?.length) {
      obj.rateLimits = message.rateLimits.map((e) => CreateTaskRateLimit.toJSON(e));
    }
    if (message.workerLabels) {
      const entries = Object.entries(message.workerLabels);
      if (entries.length > 0) {
        obj.workerLabels = {};
        entries.forEach(([k, v]) => {
          obj.workerLabels[k] = DesiredWorkerLabels.toJSON(v);
        });
      }
    }
    if (message.backoffFactor !== undefined) {
      obj.backoffFactor = message.backoffFactor;
    }
    if (message.backoffMaxSeconds !== undefined) {
      obj.backoffMaxSeconds = Math.round(message.backoffMaxSeconds);
    }
    if (message.concurrency?.length) {
      obj.concurrency = message.concurrency.map((e) => Concurrency.toJSON(e));
    }
    if (message.conditions !== undefined) {
      obj.conditions = TaskConditions.toJSON(message.conditions);
    }
    if (message.scheduleTimeout !== undefined) {
      obj.scheduleTimeout = message.scheduleTimeout;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTaskOpts>): CreateTaskOpts {
    return CreateTaskOpts.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTaskOpts>): CreateTaskOpts {
    const message = createBaseCreateTaskOpts();
    message.readableId = object.readableId ?? "";
    message.action = object.action ?? "";
    message.timeout = object.timeout ?? "";
    message.inputs = object.inputs ?? "";
    message.parents = object.parents?.map((e) => e) || [];
    message.retries = object.retries ?? 0;
    message.rateLimits = object.rateLimits?.map((e) => CreateTaskRateLimit.fromPartial(e)) || [];
    message.workerLabels = Object.entries(object.workerLabels ?? {}).reduce<{ [key: string]: DesiredWorkerLabels }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = DesiredWorkerLabels.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.backoffFactor = object.backoffFactor ?? undefined;
    message.backoffMaxSeconds = object.backoffMaxSeconds ?? undefined;
    message.concurrency = object.concurrency?.map((e) => Concurrency.fromPartial(e)) || [];
    message.conditions = (object.conditions !== undefined && object.conditions !== null)
      ? TaskConditions.fromPartial(object.conditions)
      : undefined;
    message.scheduleTimeout = object.scheduleTimeout ?? undefined;
    return message;
  },
};

function createBaseCreateTaskOpts_WorkerLabelsEntry(): CreateTaskOpts_WorkerLabelsEntry {
  return { key: "", value: undefined };
}

export const CreateTaskOpts_WorkerLabelsEntry: MessageFns<CreateTaskOpts_WorkerLabelsEntry> = {
  encode(message: CreateTaskOpts_WorkerLabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DesiredWorkerLabels.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTaskOpts_WorkerLabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTaskOpts_WorkerLabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = DesiredWorkerLabels.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTaskOpts_WorkerLabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? DesiredWorkerLabels.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: CreateTaskOpts_WorkerLabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DesiredWorkerLabels.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTaskOpts_WorkerLabelsEntry>): CreateTaskOpts_WorkerLabelsEntry {
    return CreateTaskOpts_WorkerLabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTaskOpts_WorkerLabelsEntry>): CreateTaskOpts_WorkerLabelsEntry {
    const message = createBaseCreateTaskOpts_WorkerLabelsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DesiredWorkerLabels.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCreateTaskRateLimit(): CreateTaskRateLimit {
  return {
    key: "",
    units: undefined,
    keyExpr: undefined,
    unitsExpr: undefined,
    limitValuesExpr: undefined,
    duration: undefined,
  };
}

export const CreateTaskRateLimit: MessageFns<CreateTaskRateLimit> = {
  encode(message: CreateTaskRateLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.units !== undefined) {
      writer.uint32(16).int32(message.units);
    }
    if (message.keyExpr !== undefined) {
      writer.uint32(26).string(message.keyExpr);
    }
    if (message.unitsExpr !== undefined) {
      writer.uint32(34).string(message.unitsExpr);
    }
    if (message.limitValuesExpr !== undefined) {
      writer.uint32(42).string(message.limitValuesExpr);
    }
    if (message.duration !== undefined) {
      writer.uint32(48).int32(message.duration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTaskRateLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTaskRateLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.units = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keyExpr = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.unitsExpr = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.limitValuesExpr = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.duration = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTaskRateLimit {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      units: isSet(object.units) ? globalThis.Number(object.units) : undefined,
      keyExpr: isSet(object.keyExpr) ? globalThis.String(object.keyExpr) : undefined,
      unitsExpr: isSet(object.unitsExpr) ? globalThis.String(object.unitsExpr) : undefined,
      limitValuesExpr: isSet(object.limitValuesExpr) ? globalThis.String(object.limitValuesExpr) : undefined,
      duration: isSet(object.duration) ? rateLimitDurationFromJSON(object.duration) : undefined,
    };
  },

  toJSON(message: CreateTaskRateLimit): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.units !== undefined) {
      obj.units = Math.round(message.units);
    }
    if (message.keyExpr !== undefined) {
      obj.keyExpr = message.keyExpr;
    }
    if (message.unitsExpr !== undefined) {
      obj.unitsExpr = message.unitsExpr;
    }
    if (message.limitValuesExpr !== undefined) {
      obj.limitValuesExpr = message.limitValuesExpr;
    }
    if (message.duration !== undefined) {
      obj.duration = rateLimitDurationToJSON(message.duration);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTaskRateLimit>): CreateTaskRateLimit {
    return CreateTaskRateLimit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTaskRateLimit>): CreateTaskRateLimit {
    const message = createBaseCreateTaskRateLimit();
    message.key = object.key ?? "";
    message.units = object.units ?? undefined;
    message.keyExpr = object.keyExpr ?? undefined;
    message.unitsExpr = object.unitsExpr ?? undefined;
    message.limitValuesExpr = object.limitValuesExpr ?? undefined;
    message.duration = object.duration ?? undefined;
    return message;
  },
};

function createBaseCreateWorkflowVersionResponse(): CreateWorkflowVersionResponse {
  return { id: "", workflowId: "" };
}

export const CreateWorkflowVersionResponse: MessageFns<CreateWorkflowVersionResponse> = {
  encode(message: CreateWorkflowVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.workflowId !== "") {
      writer.uint32(18).string(message.workflowId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateWorkflowVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWorkflowVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWorkflowVersionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
    };
  },

  toJSON(message: CreateWorkflowVersionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWorkflowVersionResponse>): CreateWorkflowVersionResponse {
    return CreateWorkflowVersionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWorkflowVersionResponse>): CreateWorkflowVersionResponse {
    const message = createBaseCreateWorkflowVersionResponse();
    message.id = object.id ?? "";
    message.workflowId = object.workflowId ?? "";
    return message;
  },
};

/** AdminService represents a set of RPCs for admin management of tasks, workflows, etc. */
export type AdminServiceDefinition = typeof AdminServiceDefinition;
export const AdminServiceDefinition = {
  name: "AdminService",
  fullName: "v1.AdminService",
  methods: {
    putWorkflow: {
      name: "PutWorkflow",
      requestType: CreateWorkflowVersionRequest,
      requestStream: false,
      responseType: CreateWorkflowVersionResponse,
      responseStream: false,
      options: {},
    },
    cancelTasks: {
      name: "CancelTasks",
      requestType: CancelTasksRequest,
      requestStream: false,
      responseType: CancelTasksResponse,
      responseStream: false,
      options: {},
    },
    replayTasks: {
      name: "ReplayTasks",
      requestType: ReplayTasksRequest,
      requestStream: false,
      responseType: ReplayTasksResponse,
      responseStream: false,
      options: {},
    },
    triggerWorkflowRun: {
      name: "TriggerWorkflowRun",
      requestType: TriggerWorkflowRunRequest,
      requestStream: false,
      responseType: TriggerWorkflowRunResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface AdminServiceImplementation<CallContextExt = {}> {
  putWorkflow(
    request: CreateWorkflowVersionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CreateWorkflowVersionResponse>>;
  cancelTasks(
    request: CancelTasksRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CancelTasksResponse>>;
  replayTasks(
    request: ReplayTasksRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ReplayTasksResponse>>;
  triggerWorkflowRun(
    request: TriggerWorkflowRunRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TriggerWorkflowRunResponse>>;
}

export interface AdminServiceClient<CallOptionsExt = {}> {
  putWorkflow(
    request: DeepPartial<CreateWorkflowVersionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CreateWorkflowVersionResponse>;
  cancelTasks(
    request: DeepPartial<CancelTasksRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CancelTasksResponse>;
  replayTasks(
    request: DeepPartial<ReplayTasksRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ReplayTasksResponse>;
  triggerWorkflowRun(
    request: DeepPartial<TriggerWorkflowRunRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TriggerWorkflowRunResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
