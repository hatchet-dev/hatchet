// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: job_runs.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearJobRunLookupData = `-- name: ClearJobRunLookupData :one
WITH for_delete AS (
    SELECT
        jrld2."id" as "id"
    FROM "JobRun" jr2
    LEFT JOIN "JobRunLookupData" jrld2 ON jr2."id" = jrld2."jobRunId"
    WHERE
        jr2."tenantId" = $1::uuid AND
        jr2."deletedAt" IS NOT NULL AND
        jrld2."data" IS NOT NULL
    ORDER BY jr2."deletedAt" ASC
    LIMIT $2 + 1
),
deleted_with_limit AS (
    SELECT
        for_delete."id" as "id"
    FROM for_delete
    LIMIT $2
),
has_more AS (
    SELECT
        CASE
            WHEN COUNT(*) > $2 THEN TRUE
            ELSE FALSE
        END as has_more
    FROM for_delete
)
UPDATE
    "JobRunLookupData"
SET
    "data" = NULL
WHERE
    "id" IN (SELECT "id" FROM deleted_with_limit)
RETURNING
    (SELECT has_more FROM has_more) as has_more
`

type ClearJobRunLookupDataParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Limit    interface{} `json:"limit"`
}

func (q *Queries) ClearJobRunLookupData(ctx context.Context, db DBTX, arg ClearJobRunLookupDataParams) (bool, error) {
	row := db.QueryRow(ctx, clearJobRunLookupData, arg.Tenantid, arg.Limit)
	var has_more bool
	err := row.Scan(&has_more)
	return has_more, err
}

const getJobRunByWorkflowRunIdAndJobId = `-- name: GetJobRunByWorkflowRunIdAndJobId :one
SELECT
    "id",
    "jobId",
    "status"
FROM
    "JobRun" jr
WHERE
    jr."tenantId" = $1::uuid
    AND jr."workflowRunId" = $2::uuid
    AND jr."jobId" = $3::uuid
`

type GetJobRunByWorkflowRunIdAndJobIdParams struct {
	Tenantid      pgtype.UUID `json:"tenantid"`
	Workflowrunid pgtype.UUID `json:"workflowrunid"`
	Jobid         pgtype.UUID `json:"jobid"`
}

type GetJobRunByWorkflowRunIdAndJobIdRow struct {
	ID     pgtype.UUID  `json:"id"`
	JobId  pgtype.UUID  `json:"jobId"`
	Status JobRunStatus `json:"status"`
}

func (q *Queries) GetJobRunByWorkflowRunIdAndJobId(ctx context.Context, db DBTX, arg GetJobRunByWorkflowRunIdAndJobIdParams) (*GetJobRunByWorkflowRunIdAndJobIdRow, error) {
	row := db.QueryRow(ctx, getJobRunByWorkflowRunIdAndJobId, arg.Tenantid, arg.Workflowrunid, arg.Jobid)
	var i GetJobRunByWorkflowRunIdAndJobIdRow
	err := row.Scan(&i.ID, &i.JobId, &i.Status)
	return &i, err
}

const getJobRunsByWorkflowRunId = `-- name: GetJobRunsByWorkflowRunId :many

SELECT
    "id",
    "jobId",
    "status"
FROM
    "JobRun" jr
WHERE
    jr."workflowRunId" = $1::uuid
    AND jr."tenantId" = $2::uuid
`

type GetJobRunsByWorkflowRunIdParams struct {
	Workflowrunid pgtype.UUID `json:"workflowrunid"`
	Tenantid      pgtype.UUID `json:"tenantid"`
}

type GetJobRunsByWorkflowRunIdRow struct {
	ID     pgtype.UUID  `json:"id"`
	JobId  pgtype.UUID  `json:"jobId"`
	Status JobRunStatus `json:"status"`
}

func (q *Queries) GetJobRunsByWorkflowRunId(ctx context.Context, db DBTX, arg GetJobRunsByWorkflowRunIdParams) ([]*GetJobRunsByWorkflowRunIdRow, error) {
	rows, err := db.Query(ctx, getJobRunsByWorkflowRunId, arg.Workflowrunid, arg.Tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetJobRunsByWorkflowRunIdRow
	for rows.Next() {
		var i GetJobRunsByWorkflowRunIdRow
		if err := rows.Scan(&i.ID, &i.JobId, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobRunsForWorkflowRun = `-- name: ListJobRunsForWorkflowRun :many
SELECT
    "id",
    "jobId"
FROM
    "JobRun" jr
WHERE
    jr."workflowRunId" = $1::uuid
`

type ListJobRunsForWorkflowRunRow struct {
	ID    pgtype.UUID `json:"id"`
	JobId pgtype.UUID `json:"jobId"`
}

func (q *Queries) ListJobRunsForWorkflowRun(ctx context.Context, db DBTX, workflowrunid pgtype.UUID) ([]*ListJobRunsForWorkflowRunRow, error) {
	rows, err := db.Query(ctx, listJobRunsForWorkflowRun, workflowrunid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListJobRunsForWorkflowRunRow
	for rows.Next() {
		var i ListJobRunsForWorkflowRunRow
		if err := rows.Scan(&i.ID, &i.JobId); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobRunsForWorkflowRunFull = `-- name: ListJobRunsForWorkflowRunFull :many
WITH steps AS (
    SELECT
        "id",
        "jobId",
        "status"
    FROM
        "JobRun" jr
    WHERE
        jr."workflowRunId" = $1::uuid
)
SELECT
    jr.id, jr."createdAt", jr."updatedAt", jr."deletedAt", jr."tenantId", jr."jobId", jr."tickerId", jr.status, jr.result, jr."startedAt", jr."finishedAt", jr."timeoutAt", jr."cancelledAt", jr."cancelledReason", jr."cancelledError", jr."workflowRunId",
    j.id, j."createdAt", j."updatedAt", j."deletedAt", j."tenantId", j."workflowVersionId", j.name, j.description, j.timeout, j.kind
FROM "JobRun" jr
JOIN "Job" j
    ON jr."jobId" = j."id"
WHERE jr."workflowRunId" = $1::uuid
    AND jr."tenantId" = $2::uuid
`

type ListJobRunsForWorkflowRunFullParams struct {
	Workflowrunid pgtype.UUID `json:"workflowrunid"`
	Tenantid      pgtype.UUID `json:"tenantid"`
}

type ListJobRunsForWorkflowRunFullRow struct {
	ID              pgtype.UUID      `json:"id"`
	CreatedAt       pgtype.Timestamp `json:"createdAt"`
	UpdatedAt       pgtype.Timestamp `json:"updatedAt"`
	DeletedAt       pgtype.Timestamp `json:"deletedAt"`
	TenantId        pgtype.UUID      `json:"tenantId"`
	JobId           pgtype.UUID      `json:"jobId"`
	TickerId        pgtype.UUID      `json:"tickerId"`
	Status          JobRunStatus     `json:"status"`
	Result          []byte           `json:"result"`
	StartedAt       pgtype.Timestamp `json:"startedAt"`
	FinishedAt      pgtype.Timestamp `json:"finishedAt"`
	TimeoutAt       pgtype.Timestamp `json:"timeoutAt"`
	CancelledAt     pgtype.Timestamp `json:"cancelledAt"`
	CancelledReason pgtype.Text      `json:"cancelledReason"`
	CancelledError  pgtype.Text      `json:"cancelledError"`
	WorkflowRunId   pgtype.UUID      `json:"workflowRunId"`
	Job             Job              `json:"job"`
}

func (q *Queries) ListJobRunsForWorkflowRunFull(ctx context.Context, db DBTX, arg ListJobRunsForWorkflowRunFullParams) ([]*ListJobRunsForWorkflowRunFullRow, error) {
	rows, err := db.Query(ctx, listJobRunsForWorkflowRunFull, arg.Workflowrunid, arg.Tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListJobRunsForWorkflowRunFullRow
	for rows.Next() {
		var i ListJobRunsForWorkflowRunFullRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TenantId,
			&i.JobId,
			&i.TickerId,
			&i.Status,
			&i.Result,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TimeoutAt,
			&i.CancelledAt,
			&i.CancelledReason,
			&i.CancelledError,
			&i.WorkflowRunId,
			&i.Job.ID,
			&i.Job.CreatedAt,
			&i.Job.UpdatedAt,
			&i.Job.DeletedAt,
			&i.Job.TenantId,
			&i.Job.WorkflowVersionId,
			&i.Job.Name,
			&i.Job.Description,
			&i.Job.Timeout,
			&i.Job.Kind,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveJobRunStatus = `-- name: ResolveJobRunStatus :many
WITH stepRuns AS (
    SELECT
        runs."jobRunId",
        sum(case when runs."status" IN ('PENDING', 'PENDING_ASSIGNMENT') then 1 else 0 end) AS pendingRuns,
        sum(case when runs."status" = 'BACKOFF' then 1 else 0 end) AS backoffRuns,
        sum(case when runs."status" IN ('RUNNING', 'ASSIGNED') then 1 else 0 end) AS runningRuns,
        sum(case when runs."status" = 'SUCCEEDED' then 1 else 0 end) AS succeededRuns,
        sum(case when runs."status" = 'FAILED' then 1 else 0 end) AS failedRuns,
        sum(case when runs."status" = 'CANCELLED' then 1 else 0 end) AS cancelledRuns
    FROM "StepRun" as runs
    WHERE
        "jobRunId" = ANY(
            SELECT "jobRunId"
            FROM "StepRun"
            WHERE "id" = ANY($1::uuid[])
        )
    GROUP BY runs."jobRunId"
)
UPDATE "JobRun"
SET "status" = CASE
    -- Final states are final, cannot be updated
    WHEN "status" IN ('SUCCEEDED', 'FAILED', 'CANCELLED') THEN "status"
    -- NOTE: Order of the following conditions is important
    -- When one step run is backoff AND no other step runs are running, then the job is backoff
    WHEN s.backoffRuns > 0 AND s.runningRuns = 0 THEN 'BACKOFF'
    -- When one step run is running, then the job is running
    WHEN (s.runningRuns > 0 OR s.pendingRuns > 0) THEN 'RUNNING'
    -- When one step run has failed, then the job is failed
    WHEN s.failedRuns > 0 THEN 'FAILED'
    -- When one step run has been cancelled, then the job is cancelled
    WHEN s.cancelledRuns > 0 THEN 'CANCELLED'
    -- When no step runs exist that are not succeeded, then the job is succeeded
    WHEN s.succeededRuns > 0 AND s.pendingRuns = 0 AND s.runningRuns = 0 AND s.failedRuns = 0 AND s.cancelledRuns = 0 THEN 'SUCCEEDED'
    ELSE "status"
END, "finishedAt" = CASE
    -- Final states are final, cannot be updated
    WHEN "finishedAt" IS NOT NULL THEN "finishedAt"
    WHEN s.runningRuns > 0 THEN NULL
    -- When one step run has failed or been cancelled, then the job is finished
    WHEN s.failedRuns > 0 OR s.cancelledRuns > 0 THEN NOW()
    -- When no step runs exist that are not succeeded, then the job is finished
    WHEN s.succeededRuns > 0 AND s.pendingRuns = 0 AND s.runningRuns = 0 AND s.failedRuns = 0 AND s.cancelledRuns = 0 THEN NOW()
    ELSE "finishedAt"
END, "startedAt" = CASE
    -- Started at is final, cannot be changed
    WHEN "startedAt" IS NOT NULL THEN "startedAt"
    -- If steps are running (or have finished), then set the started at time
    WHEN s.runningRuns > 0 OR s.succeededRuns > 0 OR s.failedRuns > 0 AND s.cancelledRuns > 0 THEN NOW()
    ELSE "startedAt"
END
FROM stepRuns s
WHERE
    "id" = s."jobRunId"
RETURNING "JobRun"."id"
`

func (q *Queries) ResolveJobRunStatus(ctx context.Context, db DBTX, steprunids []pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, resolveJobRunStatus, steprunids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJobRunLookupDataWithStepRun = `-- name: UpdateJobRunLookupDataWithStepRun :exec
WITH readable_id AS (
    SELECT "readableId"
    FROM "Step"
    WHERE "id" = (
        SELECT "stepId"
        FROM "StepRun"
        WHERE "id" = $2::uuid
    )
)
UPDATE "JobRunLookupData"
SET
    "data" = CASE
        WHEN $1::jsonb IS NULL THEN
            jsonb_set(
                "data",
                '{steps}',
                ("data"->'steps') - (SELECT "readableId" FROM readable_id),
                true
            )
        ELSE
            jsonb_set(
                "data",
                ARRAY['steps', (SELECT "readableId" FROM readable_id)],
                $1::jsonb,
                true
            )
    END,
    "updatedAt" = CURRENT_TIMESTAMP
WHERE
    "jobRunId" = (
        SELECT "jobRunId"
        FROM "StepRun"
        WHERE "id" = $2::uuid
    )
    AND "tenantId" = $3::uuid
`

type UpdateJobRunLookupDataWithStepRunParams struct {
	Jsondata  []byte      `json:"jsondata"`
	Steprunid pgtype.UUID `json:"steprunid"`
	Tenantid  pgtype.UUID `json:"tenantid"`
}

func (q *Queries) UpdateJobRunLookupDataWithStepRun(ctx context.Context, db DBTX, arg UpdateJobRunLookupDataWithStepRunParams) error {
	_, err := db.Exec(ctx, updateJobRunLookupDataWithStepRun, arg.Jsondata, arg.Steprunid, arg.Tenantid)
	return err
}

const updateJobRunStatus = `-- name: UpdateJobRunStatus :one
UPDATE "JobRun"
SET "status" = $1::"JobRunStatus"
WHERE "id" = $2::uuid AND "tenantId" = $3::uuid
RETURNING id, "createdAt", "updatedAt", "deletedAt", "tenantId", "jobId", "tickerId", status, result, "startedAt", "finishedAt", "timeoutAt", "cancelledAt", "cancelledReason", "cancelledError", "workflowRunId"
`

type UpdateJobRunStatusParams struct {
	Status   JobRunStatus `json:"status"`
	ID       pgtype.UUID  `json:"id"`
	Tenantid pgtype.UUID  `json:"tenantid"`
}

func (q *Queries) UpdateJobRunStatus(ctx context.Context, db DBTX, arg UpdateJobRunStatusParams) (*JobRun, error) {
	row := db.QueryRow(ctx, updateJobRunStatus, arg.Status, arg.ID, arg.Tenantid)
	var i JobRun
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.JobId,
		&i.TickerId,
		&i.Status,
		&i.Result,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TimeoutAt,
		&i.CancelledAt,
		&i.CancelledReason,
		&i.CancelledError,
		&i.WorkflowRunId,
	)
	return &i, err
}

const upsertJobRunLookupData = `-- name: UpsertJobRunLookupData :exec
INSERT INTO "JobRunLookupData" (
    "id",
    "createdAt",
    "updatedAt",
    "deletedAt",
    "jobRunId",
    "tenantId",
    "data"
) VALUES (
    gen_random_uuid(), -- Generates a new UUID for id
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    NULL,
    $1::uuid,
    $2::uuid,
    jsonb_set('{}', $3::text[], $4::jsonb, true)
) ON CONFLICT ("jobRunId", "tenantId") DO UPDATE
SET
    "data" = jsonb_set("JobRunLookupData"."data", $3::text[], $4::jsonb, true),
    "updatedAt" = CURRENT_TIMESTAMP
`

type UpsertJobRunLookupDataParams struct {
	Jobrunid  pgtype.UUID `json:"jobrunid"`
	Tenantid  pgtype.UUID `json:"tenantid"`
	Fieldpath []string    `json:"fieldpath"`
	Jsondata  []byte      `json:"jsondata"`
}

func (q *Queries) UpsertJobRunLookupData(ctx context.Context, db DBTX, arg UpsertJobRunLookupDataParams) error {
	_, err := db.Exec(ctx, upsertJobRunLookupData,
		arg.Jobrunid,
		arg.Tenantid,
		arg.Fieldpath,
		arg.Jsondata,
	)
	return err
}
