// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO "User" (
    "id",
    "email",
    "emailVerified",
    "name"
) VALUES (
    $1::uuid,
    $2::text,
    COALESCE($3::boolean, FALSE),
    $4::text
) RETURNING id, "createdAt", "updatedAt", "deletedAt", email, "emailVerified", name
`

type CreateUserParams struct {
	ID            pgtype.UUID `json:"id"`
	Email         string      `json:"email"`
	EmailVerified pgtype.Bool `json:"emailVerified"`
	Name          pgtype.Text `json:"name"`
}

func (q *Queries) CreateUser(ctx context.Context, db DBTX, arg CreateUserParams) (*User, error) {
	row := db.QueryRow(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.EmailVerified,
		arg.Name,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Email,
		&i.EmailVerified,
		&i.Name,
	)
	return &i, err
}

const createUserOAuth = `-- name: CreateUserOAuth :one
INSERT INTO "UserOAuth" (
    "id",
    "userId",
    "provider",
    "providerUserId",
    "accessToken",
    "refreshToken",
    "expiresAt"
) VALUES (
    gen_random_uuid(),
    $1::uuid,
    $2::text,
    $3::text,
    $4::bytea,
    $5::bytea,
    $6::timestamp
) RETURNING id, "createdAt", "updatedAt", "userId", provider, "providerUserId", "expiresAt", "accessToken", "refreshToken"
`

type CreateUserOAuthParams struct {
	Userid         pgtype.UUID      `json:"userid"`
	Provider       string           `json:"provider"`
	Provideruserid string           `json:"provideruserid"`
	Accesstoken    []byte           `json:"accesstoken"`
	RefreshToken   []byte           `json:"refreshToken"`
	ExpiresAt      pgtype.Timestamp `json:"expiresAt"`
}

func (q *Queries) CreateUserOAuth(ctx context.Context, db DBTX, arg CreateUserOAuthParams) (*UserOAuth, error) {
	row := db.QueryRow(ctx, createUserOAuth,
		arg.Userid,
		arg.Provider,
		arg.Provideruserid,
		arg.Accesstoken,
		arg.RefreshToken,
		arg.ExpiresAt,
	)
	var i UserOAuth
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserId,
		&i.Provider,
		&i.ProviderUserId,
		&i.ExpiresAt,
		&i.AccessToken,
		&i.RefreshToken,
	)
	return &i, err
}

const createUserPassword = `-- name: CreateUserPassword :one
INSERT INTO "UserPassword" (
    "userId",
    "hash"
) VALUES (
    $1::uuid,
    $2::text
) RETURNING hash, "userId"
`

type CreateUserPasswordParams struct {
	Userid pgtype.UUID `json:"userid"`
	Hash   string      `json:"hash"`
}

func (q *Queries) CreateUserPassword(ctx context.Context, db DBTX, arg CreateUserPasswordParams) (*UserPassword, error) {
	row := db.QueryRow(ctx, createUserPassword, arg.Userid, arg.Hash)
	var i UserPassword
	err := row.Scan(&i.Hash, &i.UserId)
	return &i, err
}

const createUserSession = `-- name: CreateUserSession :one
INSERT INTO "UserSession" (
    "id",
    "expiresAt",
    "userId",
    "data"
) VALUES (
    $1::uuid,
    $2::timestamp,
    $3::uuid,
    $4::jsonb
) RETURNING id, "createdAt", "updatedAt", "userId", data, "expiresAt"
`

type CreateUserSessionParams struct {
	ID        pgtype.UUID      `json:"id"`
	Expiresat pgtype.Timestamp `json:"expiresat"`
	UserId    pgtype.UUID      `json:"userId"`
	Data      []byte           `json:"data"`
}

func (q *Queries) CreateUserSession(ctx context.Context, db DBTX, arg CreateUserSessionParams) (*UserSession, error) {
	row := db.QueryRow(ctx, createUserSession,
		arg.ID,
		arg.Expiresat,
		arg.UserId,
		arg.Data,
	)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserId,
		&i.Data,
		&i.ExpiresAt,
	)
	return &i, err
}

const deleteUserSession = `-- name: DeleteUserSession :one
DELETE FROM
    "UserSession"
WHERE
    "id" = $1::uuid
RETURNING id, "createdAt", "updatedAt", "userId", data, "expiresAt"
`

func (q *Queries) DeleteUserSession(ctx context.Context, db DBTX, id pgtype.UUID) (*UserSession, error) {
	row := db.QueryRow(ctx, deleteUserSession, id)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserId,
		&i.Data,
		&i.ExpiresAt,
	)
	return &i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT
    id, "createdAt", "updatedAt", "deletedAt", email, "emailVerified", name
FROM
    "User"
WHERE
    "email" = $1::text
`

func (q *Queries) GetUserByEmail(ctx context.Context, db DBTX, email string) (*User, error) {
	row := db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Email,
		&i.EmailVerified,
		&i.Name,
	)
	return &i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
    id, "createdAt", "updatedAt", "deletedAt", email, "emailVerified", name
FROM
    "User"
WHERE
    "id" = $1::uuid
`

func (q *Queries) GetUserByID(ctx context.Context, db DBTX, id pgtype.UUID) (*User, error) {
	row := db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Email,
		&i.EmailVerified,
		&i.Name,
	)
	return &i, err
}

const getUserPassword = `-- name: GetUserPassword :one
SELECT
    hash, "userId"
FROM
    "UserPassword"
WHERE
    "userId" = $1::uuid
`

func (q *Queries) GetUserPassword(ctx context.Context, db DBTX, userid pgtype.UUID) (*UserPassword, error) {
	row := db.QueryRow(ctx, getUserPassword, userid)
	var i UserPassword
	err := row.Scan(&i.Hash, &i.UserId)
	return &i, err
}

const getUserSession = `-- name: GetUserSession :one
SELECT
    id, "createdAt", "updatedAt", "userId", data, "expiresAt"
FROM
    "UserSession"
WHERE
    "id" = $1::uuid
`

func (q *Queries) GetUserSession(ctx context.Context, db DBTX, id pgtype.UUID) (*UserSession, error) {
	row := db.QueryRow(ctx, getUserSession, id)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserId,
		&i.Data,
		&i.ExpiresAt,
	)
	return &i, err
}

const listTenantMemberships = `-- name: ListTenantMemberships :many
SELECT
    id, "createdAt", "updatedAt", "tenantId", "userId", role
FROM
    "TenantMember"
WHERE
    "userId" = $1::uuid
`

func (q *Queries) ListTenantMemberships(ctx context.Context, db DBTX, userid pgtype.UUID) ([]*TenantMember, error) {
	rows, err := db.Query(ctx, listTenantMemberships, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*TenantMember
	for rows.Next() {
		var i TenantMember
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TenantId,
			&i.UserId,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :one
UPDATE
    "User"
SET
    "emailVerified" = COALESCE($1::boolean, "emailVerified"),
    "name" = COALESCE($2::text, "name")
WHERE
    "id" = $3::uuid
RETURNING id, "createdAt", "updatedAt", "deletedAt", email, "emailVerified", name
`

type UpdateUserParams struct {
	EmailVerified pgtype.Bool `json:"emailVerified"`
	Name          pgtype.Text `json:"name"`
	ID            pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, db DBTX, arg UpdateUserParams) (*User, error) {
	row := db.QueryRow(ctx, updateUser, arg.EmailVerified, arg.Name, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Email,
		&i.EmailVerified,
		&i.Name,
	)
	return &i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :one
UPDATE
    "UserPassword"
SET
    "hash" = $1::text
WHERE
    "userId" = $2::uuid
RETURNING hash, "userId"
`

type UpdateUserPasswordParams struct {
	Hash   string      `json:"hash"`
	Userid pgtype.UUID `json:"userid"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, db DBTX, arg UpdateUserPasswordParams) (*UserPassword, error) {
	row := db.QueryRow(ctx, updateUserPassword, arg.Hash, arg.Userid)
	var i UserPassword
	err := row.Scan(&i.Hash, &i.UserId)
	return &i, err
}

const updateUserSession = `-- name: UpdateUserSession :one
UPDATE
    "UserSession"
SET
    "userId" = COALESCE($1::uuid, "userId"),
    "data" = COALESCE($2::jsonb, "data")
WHERE
    "id" = $3::uuid
RETURNING id, "createdAt", "updatedAt", "userId", data, "expiresAt"
`

type UpdateUserSessionParams struct {
	UserId pgtype.UUID `json:"userId"`
	Data   []byte      `json:"data"`
	ID     pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateUserSession(ctx context.Context, db DBTX, arg UpdateUserSessionParams) (*UserSession, error) {
	row := db.QueryRow(ctx, updateUserSession, arg.UserId, arg.Data, arg.ID)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserId,
		&i.Data,
		&i.ExpiresAt,
	)
	return &i, err
}

const upsertUserOAuth = `-- name: UpsertUserOAuth :one
INSERT INTO "UserOAuth" (
    "id",
    "userId",
    "provider",
    "providerUserId",
    "accessToken",
    "refreshToken",
    "expiresAt"
) VALUES (
    gen_random_uuid(),
    $1::uuid,
    $2::text,
    $3::text,
    $4::bytea,
    $5::bytea,
    $6::timestamp
) ON CONFLICT ("userId", "provider") DO UPDATE SET
    "providerUserId" = $3::text,
    "accessToken" = $4::bytea,
    "refreshToken" = $5::bytea,
    "expiresAt" = $6::timestamp
RETURNING id, "createdAt", "updatedAt", "userId", provider, "providerUserId", "expiresAt", "accessToken", "refreshToken"
`

type UpsertUserOAuthParams struct {
	Userid         pgtype.UUID      `json:"userid"`
	Provider       string           `json:"provider"`
	Provideruserid string           `json:"provideruserid"`
	Accesstoken    []byte           `json:"accesstoken"`
	RefreshToken   []byte           `json:"refreshToken"`
	ExpiresAt      pgtype.Timestamp `json:"expiresAt"`
}

func (q *Queries) UpsertUserOAuth(ctx context.Context, db DBTX, arg UpsertUserOAuthParams) (*UserOAuth, error) {
	row := db.QueryRow(ctx, upsertUserOAuth,
		arg.Userid,
		arg.Provider,
		arg.Provideruserid,
		arg.Accesstoken,
		arg.RefreshToken,
		arg.ExpiresAt,
	)
	var i UserOAuth
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserId,
		&i.Provider,
		&i.ProviderUserId,
		&i.ExpiresAt,
		&i.AccessToken,
		&i.RefreshToken,
	)
	return &i, err
}
