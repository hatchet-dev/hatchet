// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: slack.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteSlackWebhook = `-- name: DeleteSlackWebhook :exec
DELETE FROM
    "SlackAppWebhook"
WHERE
    "tenantId" = $1::uuid
    AND "id" = $2::uuid
`

type DeleteSlackWebhookParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) DeleteSlackWebhook(ctx context.Context, db DBTX, arg DeleteSlackWebhookParams) error {
	_, err := db.Exec(ctx, deleteSlackWebhook, arg.Tenantid, arg.ID)
	return err
}

const getSlackWebhookById = `-- name: GetSlackWebhookById :one
SELECT
    id, "createdAt", "updatedAt", "deletedAt", "tenantId", "teamId", "teamName", "channelId", "channelName", "webhookURL"
FROM
    "SlackAppWebhook"
WHERE
    "id" = $1::uuid
`

func (q *Queries) GetSlackWebhookById(ctx context.Context, db DBTX, id pgtype.UUID) (*SlackAppWebhook, error) {
	row := db.QueryRow(ctx, getSlackWebhookById, id)
	var i SlackAppWebhook
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.TeamId,
		&i.TeamName,
		&i.ChannelId,
		&i.ChannelName,
		&i.WebhookURL,
	)
	return &i, err
}

const listSlackWebhooks = `-- name: ListSlackWebhooks :many
SELECT
    id, "createdAt", "updatedAt", "deletedAt", "tenantId", "teamId", "teamName", "channelId", "channelName", "webhookURL"
FROM
    "SlackAppWebhook"
WHERE
    "tenantId" = $1::uuid
`

func (q *Queries) ListSlackWebhooks(ctx context.Context, db DBTX, tenantid pgtype.UUID) ([]*SlackAppWebhook, error) {
	rows, err := db.Query(ctx, listSlackWebhooks, tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SlackAppWebhook
	for rows.Next() {
		var i SlackAppWebhook
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TenantId,
			&i.TeamId,
			&i.TeamName,
			&i.ChannelId,
			&i.ChannelName,
			&i.WebhookURL,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertSlackWebhook = `-- name: UpsertSlackWebhook :one
INSERT INTO
    "SlackAppWebhook" (
        "id",
        "tenantId",
        "teamId",
        "teamName",
        "channelId",
        "channelName",
        "webhookURL"
    ) VALUES (
        gen_random_uuid(),
        $1::uuid,
        $2::text,
        $3::text,
        $4::text,
        $5::text,
        $6::bytea
    ) ON CONFLICT ("tenantId", "teamId", "channelId") DO UPDATE SET
        "updatedAt" = CURRENT_TIMESTAMP,
        "teamName" = $3::text,
        "channelName" = $5::text,
        "webhookURL" = $6::bytea
    RETURNING id, "createdAt", "updatedAt", "deletedAt", "tenantId", "teamId", "teamName", "channelId", "channelName", "webhookURL"
`

type UpsertSlackWebhookParams struct {
	Tenantid    pgtype.UUID `json:"tenantid"`
	Teamid      string      `json:"teamid"`
	Teamname    string      `json:"teamname"`
	Channelid   string      `json:"channelid"`
	Channelname string      `json:"channelname"`
	Webhookurl  []byte      `json:"webhookurl"`
}

func (q *Queries) UpsertSlackWebhook(ctx context.Context, db DBTX, arg UpsertSlackWebhookParams) (*SlackAppWebhook, error) {
	row := db.QueryRow(ctx, upsertSlackWebhook,
		arg.Tenantid,
		arg.Teamid,
		arg.Teamname,
		arg.Channelid,
		arg.Channelname,
		arg.Webhookurl,
	)
	var i SlackAppWebhook
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.TeamId,
		&i.TeamName,
		&i.ChannelId,
		&i.ChannelName,
		&i.WebhookURL,
	)
	return &i, err
}
