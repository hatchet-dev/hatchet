// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: api_tokens.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAPIToken = `-- name: CreateAPIToken :one
INSERT INTO "APIToken" (
    "id",
    "createdAt",
    "updatedAt",
    "tenantId",
    "name",
    "expiresAt",
    "internal"
) VALUES (
    coalesce($1::uuid, gen_random_uuid()),
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    $2::uuid,
    $3::text,
    $4::timestamp,
    COALESCE($5::boolean, FALSE)
) RETURNING id, "createdAt", "updatedAt", "expiresAt", revoked, name, "tenantId", "nextAlertAt", internal
`

type CreateAPITokenParams struct {
	ID        pgtype.UUID      `json:"id"`
	TenantId  pgtype.UUID      `json:"tenantId"`
	Name      pgtype.Text      `json:"name"`
	Expiresat pgtype.Timestamp `json:"expiresat"`
	Internal  pgtype.Bool      `json:"internal"`
}

func (q *Queries) CreateAPIToken(ctx context.Context, db DBTX, arg CreateAPITokenParams) (*APIToken, error) {
	row := db.QueryRow(ctx, createAPIToken,
		arg.ID,
		arg.TenantId,
		arg.Name,
		arg.Expiresat,
		arg.Internal,
	)
	var i APIToken
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.Revoked,
		&i.Name,
		&i.TenantId,
		&i.NextAlertAt,
		&i.Internal,
	)
	return &i, err
}

const deleteAPIToken = `-- name: DeleteAPIToken :exec
DELETE FROM
    "APIToken"
WHERE
    "tenantId" = $1::uuid
    AND "id" = $2::uuid
`

type DeleteAPITokenParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) DeleteAPIToken(ctx context.Context, db DBTX, arg DeleteAPITokenParams) error {
	_, err := db.Exec(ctx, deleteAPIToken, arg.Tenantid, arg.ID)
	return err
}

const getAPITokenById = `-- name: GetAPITokenById :one
SELECT
    id, "createdAt", "updatedAt", "expiresAt", revoked, name, "tenantId", "nextAlertAt", internal
FROM
    "APIToken"
WHERE
    "id" = $1::uuid
`

func (q *Queries) GetAPITokenById(ctx context.Context, db DBTX, id pgtype.UUID) (*APIToken, error) {
	row := db.QueryRow(ctx, getAPITokenById, id)
	var i APIToken
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.Revoked,
		&i.Name,
		&i.TenantId,
		&i.NextAlertAt,
		&i.Internal,
	)
	return &i, err
}

const listAPITokensByTenant = `-- name: ListAPITokensByTenant :many
SELECT
    id, "createdAt", "updatedAt", "expiresAt", revoked, name, "tenantId", "nextAlertAt", internal
FROM
    "APIToken"
WHERE
    "tenantId" = $1::uuid
    AND "revoked" = FALSE
    AND "internal" = FALSE
`

func (q *Queries) ListAPITokensByTenant(ctx context.Context, db DBTX, tenantid pgtype.UUID) ([]*APIToken, error) {
	rows, err := db.Query(ctx, listAPITokensByTenant, tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*APIToken
	for rows.Next() {
		var i APIToken
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
			&i.Revoked,
			&i.Name,
			&i.TenantId,
			&i.NextAlertAt,
			&i.Internal,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeAPIToken = `-- name: RevokeAPIToken :exec
UPDATE
    "APIToken"
SET
    "expiresAt" = CURRENT_TIMESTAMP - INTERVAL '1 second',
    "revoked" = TRUE
WHERE
    "id" = $1::uuid
`

func (q *Queries) RevokeAPIToken(ctx context.Context, db DBTX, id pgtype.UUID) error {
	_, err := db.Exec(ctx, revokeAPIToken, id)
	return err
}
