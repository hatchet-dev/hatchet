// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: events.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearEventPayloadData = `-- name: ClearEventPayloadData :one
WITH for_delete AS (
    SELECT
        e1."id" as "id"
    FROM "Event" e1
    WHERE
        e1."tenantId" = $1::uuid AND
        e1."deletedAt" IS NOT NULL -- TODO change this for all clear queries
        AND e1."data" IS NOT NULL
    LIMIT $2 + 1
    FOR UPDATE SKIP LOCKED
), expired_with_limit AS (
    SELECT
        for_delete."id" as "id"
    FROM for_delete
    LIMIT $2
),
has_more AS (
    SELECT
        CASE
            WHEN COUNT(*) > $2 THEN TRUE
            ELSE FALSE
        END as has_more
    FROM for_delete
)
UPDATE
    "Event"
SET
    "data" = NULL
WHERE
    "id" IN (SELECT "id" FROM expired_with_limit)
RETURNING
    (SELECT has_more FROM has_more) as has_more
`

type ClearEventPayloadDataParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Limit    interface{} `json:"limit"`
}

func (q *Queries) ClearEventPayloadData(ctx context.Context, db DBTX, arg ClearEventPayloadDataParams) (bool, error) {
	row := db.QueryRow(ctx, clearEventPayloadData, arg.Tenantid, arg.Limit)
	var has_more bool
	err := row.Scan(&has_more)
	return has_more, err
}

const countEvents = `-- name: CountEvents :one
WITH events AS (
    SELECT
        events."id"
    FROM
        "Event" as events
    LEFT JOIN
        "WorkflowRunTriggeredBy" as runTriggers ON events."id" = runTriggers."eventId"
    LEFT JOIN
        "WorkflowRun" as runs ON runTriggers."parentId" = runs."id"
    LEFT JOIN
        "WorkflowVersion" as workflowVersion ON workflowVersion."id" = runs."workflowVersionId"
    LEFT JOIN
        "Workflow" as workflow ON workflowVersion."workflowId" = workflow."id"
    WHERE
        events."tenantId" = $1 AND
        events."deletedAt" IS NULL AND
        (
            $2::uuid[] IS NULL OR
            events."id" = ANY($2::uuid[])
        ) AND
        (
            $3::text[] IS NULL OR
            events."key" = ANY($3::text[])
        ) AND
        (
            $4::jsonb IS NULL OR
            events."additionalMetadata" @> $4::jsonb
        ) AND
        (
            ($5::text[])::uuid[] IS NULL OR
            (workflow."id" = ANY($5::text[]::uuid[]))
        ) AND
        (
            $6::text IS NULL OR
            workflow.name like concat('%', $6::text, '%') OR
            jsonb_path_exists(events."data", cast(concat('$.** ? (@.type() == "string" && @ like_regex "', $6::text, '")') as jsonpath))
        ) AND
        (
            $7::text[] IS NULL OR
            "status" = ANY(cast($7::text[] as "WorkflowRunStatus"[]))
        )
    ORDER BY
        case when $8 = 'createdAt ASC' THEN events."createdAt" END ASC ,
        case when $8 = 'createdAt DESC' then events."createdAt" END DESC
    LIMIT 10000
)
SELECT
    count(events) AS total
FROM
    events
`

type CountEventsParams struct {
	TenantId           pgtype.UUID   `json:"tenantId"`
	EventIds           []pgtype.UUID `json:"event_ids"`
	Keys               []string      `json:"keys"`
	AdditionalMetadata []byte        `json:"additionalMetadata"`
	Workflows          []string      `json:"workflows"`
	Search             pgtype.Text   `json:"search"`
	Statuses           []string      `json:"statuses"`
	Orderby            interface{}   `json:"orderby"`
}

func (q *Queries) CountEvents(ctx context.Context, db DBTX, arg CountEventsParams) (int64, error) {
	row := db.QueryRow(ctx, countEvents,
		arg.TenantId,
		arg.EventIds,
		arg.Keys,
		arg.AdditionalMetadata,
		arg.Workflows,
		arg.Search,
		arg.Statuses,
		arg.Orderby,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO "Event" (
    "id",
    "createdAt",
    "updatedAt",
    "deletedAt",
    "key",
    "tenantId",
    "replayedFromId",
    "data",
    "additionalMetadata"
) VALUES (
    $1::uuid,
    coalesce($2::timestamp, CURRENT_TIMESTAMP),
    coalesce($3::timestamp, CURRENT_TIMESTAMP),
    $4::timestamp,
    $5::text,
    $6::uuid,
    $7::uuid,
    $8::jsonb,
    $9::jsonb
) RETURNING id, "createdAt", "updatedAt", "deletedAt", key, "tenantId", "replayedFromId", data, "additionalMetadata", "insertOrder"
`

type CreateEventParams struct {
	ID                 pgtype.UUID      `json:"id"`
	CreatedAt          pgtype.Timestamp `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	Deletedat          pgtype.Timestamp `json:"deletedat"`
	Key                string           `json:"key"`
	Tenantid           pgtype.UUID      `json:"tenantid"`
	ReplayedFromId     pgtype.UUID      `json:"replayedFromId"`
	Data               []byte           `json:"data"`
	Additionalmetadata []byte           `json:"additionalmetadata"`
}

func (q *Queries) CreateEvent(ctx context.Context, db DBTX, arg CreateEventParams) (*Event, error) {
	row := db.QueryRow(ctx, createEvent,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Deletedat,
		arg.Key,
		arg.Tenantid,
		arg.ReplayedFromId,
		arg.Data,
		arg.Additionalmetadata,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Key,
		&i.TenantId,
		&i.ReplayedFromId,
		&i.Data,
		&i.AdditionalMetadata,
		&i.InsertOrder,
	)
	return &i, err
}

const createEventKeys = `-- name: CreateEventKeys :exec
INSERT INTO "EventKey" (
    "key",
    "tenantId"
)
SELECT
    unnest($1::text[]) AS "key",
    unnest($2::uuid[]) AS "tenantId"
ON CONFLICT ("key", "tenantId") DO NOTHING
`

type CreateEventKeysParams struct {
	Keys      []string      `json:"keys"`
	Tenantids []pgtype.UUID `json:"tenantids"`
}

func (q *Queries) CreateEventKeys(ctx context.Context, db DBTX, arg CreateEventKeysParams) error {
	_, err := db.Exec(ctx, createEventKeys, arg.Keys, arg.Tenantids)
	return err
}

type CreateEventsParams struct {
	ID                 pgtype.UUID `json:"id"`
	Key                string      `json:"key"`
	TenantId           pgtype.UUID `json:"tenantId"`
	ReplayedFromId     pgtype.UUID `json:"replayedFromId"`
	Data               []byte      `json:"data"`
	AdditionalMetadata []byte      `json:"additionalMetadata"`
	InsertOrder        pgtype.Int4 `json:"insertOrder"`
}

const getEventForEngine = `-- name: GetEventForEngine :one
SELECT
    id, "createdAt", "updatedAt", "deletedAt", key, "tenantId", "replayedFromId", data, "additionalMetadata", "insertOrder"
FROM
    "Event"
WHERE
    "deletedAt" IS NULL AND
    "id" = $1::uuid
`

func (q *Queries) GetEventForEngine(ctx context.Context, db DBTX, id pgtype.UUID) (*Event, error) {
	row := db.QueryRow(ctx, getEventForEngine, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Key,
		&i.TenantId,
		&i.ReplayedFromId,
		&i.Data,
		&i.AdditionalMetadata,
		&i.InsertOrder,
	)
	return &i, err
}

const getEventsForRange = `-- name: GetEventsForRange :many
SELECT
    date_trunc('hour', "createdAt") AS event_hour,
    COUNT(*) AS event_count
FROM
    "Event"
WHERE
    events."deletedAt" IS NOT NULL AND
    "createdAt" >= NOW() - INTERVAL '1 week'
GROUP BY
    event_hour
ORDER BY
    event_hour
`

type GetEventsForRangeRow struct {
	EventHour  pgtype.Interval `json:"event_hour"`
	EventCount int64           `json:"event_count"`
}

func (q *Queries) GetEventsForRange(ctx context.Context, db DBTX) ([]*GetEventsForRangeRow, error) {
	rows, err := db.Query(ctx, getEventsForRange)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetEventsForRangeRow
	for rows.Next() {
		var i GetEventsForRangeRow
		if err := rows.Scan(&i.EventHour, &i.EventCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInsertedEvents = `-- name: GetInsertedEvents :many
SELECT id, "createdAt", "updatedAt", "deletedAt", key, "tenantId", "replayedFromId", data, "additionalMetadata", "insertOrder" FROM "Event"
WHERE "id" = ANY($1::uuid[])
ORDER BY "insertOrder" ASC
`

func (q *Queries) GetInsertedEvents(ctx context.Context, db DBTX, ids []pgtype.UUID) ([]*Event, error) {
	rows, err := db.Query(ctx, getInsertedEvents, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Key,
			&i.TenantId,
			&i.ReplayedFromId,
			&i.Data,
			&i.AdditionalMetadata,
			&i.InsertOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventKeys = `-- name: ListEventKeys :many
SELECT
    "key"
FROM
    "EventKey"
WHERE
    "tenantId" = $1::uuid
ORDER BY "key" ASC
`

func (q *Queries) ListEventKeys(ctx context.Context, db DBTX, tenantid pgtype.UUID) ([]string, error) {
	rows, err := db.Query(ctx, listEventKeys, tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var key string
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEvents = `-- name: ListEvents :many
WITH filtered_events AS (
    SELECT
        events."id"
    FROM
        "Event" as events
    LEFT JOIN
        "WorkflowRunTriggeredBy" as runTriggers ON events."id" = runTriggers."eventId"
    LEFT JOIN
        "WorkflowRun" as runs ON runTriggers."parentId" = runs."id"
    LEFT JOIN
        "WorkflowVersion" as workflowVersion ON workflowVersion."id" = runs."workflowVersionId"
    LEFT JOIN
        "Workflow" as workflow ON workflowVersion."workflowId" = workflow."id"
    WHERE
        events."tenantId" = $1 AND
        events."deletedAt" IS NULL AND
        (
            $3::uuid[] IS NULL OR
            events."id" = ANY($3::uuid[])
        ) AND
        (
            $4::text[] IS NULL OR
            events."key" = ANY($4::text[])
        ) AND
        (
            $5::jsonb IS NULL OR
            events."additionalMetadata" @> $5::jsonb
        ) AND
        (
            ($6::text[])::uuid[] IS NULL OR
            (workflow."id" = ANY($6::text[]::uuid[]))
        ) AND
        (
            $7::text IS NULL OR
            workflow.name like concat('%', $7::text, '%') OR
            jsonb_path_exists(events."data", cast(concat('$.** ? (@.type() == "string" && @ like_regex "', $7::text, '")') as jsonpath))
        ) AND
        (
            $8::text[] IS NULL OR
            runs."status" = ANY(cast($8::text[] as "WorkflowRunStatus"[]))
        )
    GROUP BY events."id"
    ORDER BY
        case when $2 = 'createdAt ASC' THEN MAX(events."createdAt") END ASC,
        case when $2 = 'createdAt DESC' then MAX(events."createdAt") END DESC
    OFFSET
        COALESCE($9, 0)
    LIMIT
        COALESCE($10, 50)
),
event_run_counts AS (
    SELECT
        events."id" as event_id,
        COUNT(CASE WHEN runs."status" = 'PENDING' THEN 1 END) AS pendingRuns,
        COUNT(CASE WHEN runs."status" = 'QUEUED' THEN 1 END) AS queuedRuns,
        COUNT(CASE WHEN runs."status" = 'RUNNING' THEN 1 END) AS runningRuns,
        COUNT(CASE WHEN runs."status" = 'SUCCEEDED' THEN 1 END) AS succeededRuns,
        COUNT(CASE WHEN runs."status" = 'FAILED' THEN 1 END) AS failedRuns,
        COUNT(CASE WHEN runs."status" = 'CANCELLED' THEN 1 END) AS cancelledRuns
    FROM
        filtered_events
    JOIN
        "Event" as events ON events."id" = filtered_events."id"
    LEFT JOIN
        "WorkflowRunTriggeredBy" as runTriggers ON events."id" = runTriggers."eventId"
    LEFT JOIN
        "WorkflowRun" as runs ON runTriggers."parentId" = runs."id"
    GROUP BY
        events."id"
)
SELECT
    events.id, events."createdAt", events."updatedAt", events."deletedAt", events.key, events."tenantId", events."replayedFromId", events.data, events."additionalMetadata", events."insertOrder",
    COALESCE(erc.pendingRuns, 0) AS pendingRuns,
    COALESCE(erc.queuedRuns, 0) AS queuedRuns,
    COALESCE(erc.runningRuns, 0) AS runningRuns,
    COALESCE(erc.succeededRuns, 0) AS succeededRuns,
    COALESCE(erc.failedRuns, 0) AS failedRuns,
    COALESCE(erc.cancelledRuns, 0) AS cancelledRuns
FROM
    filtered_events fe
JOIN
    "Event" as events ON events."id" = fe."id"
LEFT JOIN
    event_run_counts erc ON events."id" = erc.event_id
ORDER BY
    case when $2 = 'createdAt ASC' THEN events."createdAt" END ASC,
    case when $2 = 'createdAt DESC' then events."createdAt" END DESC
`

type ListEventsParams struct {
	TenantId           pgtype.UUID   `json:"tenantId"`
	Orderby            interface{}   `json:"orderby"`
	EventIds           []pgtype.UUID `json:"event_ids"`
	Keys               []string      `json:"keys"`
	AdditionalMetadata []byte        `json:"additionalMetadata"`
	Workflows          []string      `json:"workflows"`
	Search             pgtype.Text   `json:"search"`
	Statuses           []string      `json:"statuses"`
	Offset             interface{}   `json:"offset"`
	Limit              interface{}   `json:"limit"`
}

type ListEventsRow struct {
	Event         Event `json:"event"`
	Pendingruns   int64 `json:"pendingruns"`
	Queuedruns    int64 `json:"queuedruns"`
	Runningruns   int64 `json:"runningruns"`
	Succeededruns int64 `json:"succeededruns"`
	Failedruns    int64 `json:"failedruns"`
	Cancelledruns int64 `json:"cancelledruns"`
}

func (q *Queries) ListEvents(ctx context.Context, db DBTX, arg ListEventsParams) ([]*ListEventsRow, error) {
	rows, err := db.Query(ctx, listEvents,
		arg.TenantId,
		arg.Orderby,
		arg.EventIds,
		arg.Keys,
		arg.AdditionalMetadata,
		arg.Workflows,
		arg.Search,
		arg.Statuses,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListEventsRow
	for rows.Next() {
		var i ListEventsRow
		if err := rows.Scan(
			&i.Event.ID,
			&i.Event.CreatedAt,
			&i.Event.UpdatedAt,
			&i.Event.DeletedAt,
			&i.Event.Key,
			&i.Event.TenantId,
			&i.Event.ReplayedFromId,
			&i.Event.Data,
			&i.Event.AdditionalMetadata,
			&i.Event.InsertOrder,
			&i.Pendingruns,
			&i.Queuedruns,
			&i.Runningruns,
			&i.Succeededruns,
			&i.Failedruns,
			&i.Cancelledruns,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByIDs = `-- name: ListEventsByIDs :many
SELECT
    id, "createdAt", "updatedAt", "deletedAt", key, "tenantId", "replayedFromId", data, "additionalMetadata", "insertOrder"
FROM
    "Event" as events
WHERE
    events."deletedAt" IS NULL AND
    "tenantId" = $1::uuid AND
    "id" = ANY ($2::uuid[])
`

type ListEventsByIDsParams struct {
	Tenantid pgtype.UUID   `json:"tenantid"`
	Ids      []pgtype.UUID `json:"ids"`
}

func (q *Queries) ListEventsByIDs(ctx context.Context, db DBTX, arg ListEventsByIDsParams) ([]*Event, error) {
	rows, err := db.Query(ctx, listEventsByIDs, arg.Tenantid, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Key,
			&i.TenantId,
			&i.ReplayedFromId,
			&i.Data,
			&i.AdditionalMetadata,
			&i.InsertOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteExpiredEvents = `-- name: SoftDeleteExpiredEvents :one
WITH for_delete AS (
    SELECT
        "id"
    FROM "Event" e
    WHERE
        e."tenantId" = $1::uuid AND
        e."createdAt" < $2::timestamp AND
        e."deletedAt" IS NULL
    ORDER BY e."createdAt" ASC
    LIMIT $3 +1
    FOR UPDATE SKIP LOCKED
),expired_with_limit AS (
    SELECT
        for_delete."id" as "id"
    FROM for_delete
    LIMIT $3
), has_more AS (
    SELECT
        CASE
            WHEN COUNT(*) > $3 THEN TRUE
            ELSE FALSE
        END as has_more
    FROM for_delete
)
UPDATE
    "Event"
SET
    "deletedAt" = CURRENT_TIMESTAMP
WHERE
    "id" IN (SELECT "id" FROM expired_with_limit)
RETURNING
    (SELECT has_more FROM has_more) as has_more
`

type SoftDeleteExpiredEventsParams struct {
	Tenantid      pgtype.UUID      `json:"tenantid"`
	Createdbefore pgtype.Timestamp `json:"createdbefore"`
	Limit         interface{}      `json:"limit"`
}

func (q *Queries) SoftDeleteExpiredEvents(ctx context.Context, db DBTX, arg SoftDeleteExpiredEventsParams) (bool, error) {
	row := db.QueryRow(ctx, softDeleteExpiredEvents, arg.Tenantid, arg.Createdbefore, arg.Limit)
	var has_more bool
	err := row.Scan(&has_more)
	return has_more, err
}
