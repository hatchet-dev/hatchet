// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: workflow_runs.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkDeleteScheduledWorkflows = `-- name: BulkDeleteScheduledWorkflows :many
DELETE FROM "WorkflowTriggerScheduledRef" t
USING "WorkflowVersion" v, "Workflow" w
WHERE
    t."parentId" = v."id"
    AND v."workflowId" = w."id"
    AND w."tenantId" = $1::uuid
    AND t."method" = 'API'
    AND t."id" = ANY($2::uuid[])
RETURNING t."id"
`

type BulkDeleteScheduledWorkflowsParams struct {
	Tenantid pgtype.UUID   `json:"tenantid"`
	Ids      []pgtype.UUID `json:"ids"`
}

func (q *Queries) BulkDeleteScheduledWorkflows(ctx context.Context, db DBTX, arg BulkDeleteScheduledWorkflowsParams) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, bulkDeleteScheduledWorkflows, arg.Tenantid, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bulkUpdateScheduledWorkflows = `-- name: BulkUpdateScheduledWorkflows :many
WITH input AS (
    SELECT
        ids.id,
        times."triggerAt"
    FROM unnest($2::uuid[]) WITH ORDINALITY AS ids(id, ord)
    JOIN unnest($3::timestamp[]) WITH ORDINALITY AS times("triggerAt", ord)
        USING (ord)
)
UPDATE "WorkflowTriggerScheduledRef" t
SET "triggerAt" = i."triggerAt"
FROM input i, "WorkflowVersion" v, "Workflow" w
WHERE
    t."id" = i.id
    AND t."parentId" = v."id"
    AND v."workflowId" = w."id"
    AND w."tenantId" = $1::uuid
    AND t."method" = 'API'
    AND NOT EXISTS (
        SELECT 1
        FROM "WorkflowRunTriggeredBy" tb
        WHERE tb."scheduledId" = t."id"
    )
RETURNING t."id"
`

type BulkUpdateScheduledWorkflowsParams struct {
	Tenantid   pgtype.UUID        `json:"tenantid"`
	Ids        []pgtype.UUID      `json:"ids"`
	Triggerats []pgtype.Timestamp `json:"triggerats"`
}

func (q *Queries) BulkUpdateScheduledWorkflows(ctx context.Context, db DBTX, arg BulkUpdateScheduledWorkflowsParams) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, bulkUpdateScheduledWorkflows, arg.Tenantid, arg.Ids, arg.Triggerats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countScheduledWorkflows = `-- name: CountScheduledWorkflows :one
SELECT count(*)
FROM "WorkflowTriggerScheduledRef" t
JOIN "WorkflowVersion" v ON t."parentId" = v."id"
JOIN "Workflow" w on v."workflowId" = w."id"
LEFT JOIN "WorkflowRunTriggeredBy" tb ON t."id" = tb."scheduledId"
LEFT JOIN "WorkflowRun" wr ON tb."parentId" = wr."id"
WHERE v."deletedAt" IS NULL
	AND w."tenantId" = $1::uuid
    AND ($2::uuid IS NULL OR t."id" = $2::uuid)
    AND ($3::uuid IS NULL OR w."id" = $3::uuid)
    AND ($4::uuid IS NULL OR t."id" = $4::uuid)
    AND ($5::uuid IS NULL OR t."parentStepRunId" = $5::uuid)
    AND ($6::jsonb IS NULL OR
        t."additionalMetadata" @> $6::jsonb)
    AND (
        $7::text[] IS NULL OR
        wr."status" = ANY(cast($7::text[] as "WorkflowRunStatus"[]))
        or (
            $8::boolean IS TRUE AND
            wr."status" IS NULL
        )
    )
`

type CountScheduledWorkflowsParams struct {
	Tenantid            pgtype.UUID `json:"tenantid"`
	Scheduleid          pgtype.UUID `json:"scheduleid"`
	Workflowid          pgtype.UUID `json:"workflowid"`
	Parentworkflowrunid pgtype.UUID `json:"parentworkflowrunid"`
	Parentsteprunid     pgtype.UUID `json:"parentsteprunid"`
	AdditionalMetadata  []byte      `json:"additionalMetadata"`
	Statuses            []string    `json:"statuses"`
	Includescheduled    bool        `json:"includescheduled"`
}

func (q *Queries) CountScheduledWorkflows(ctx context.Context, db DBTX, arg CountScheduledWorkflowsParams) (int64, error) {
	row := db.QueryRow(ctx, countScheduledWorkflows,
		arg.Tenantid,
		arg.Scheduleid,
		arg.Workflowid,
		arg.Parentworkflowrunid,
		arg.Parentsteprunid,
		arg.AdditionalMetadata,
		arg.Statuses,
		arg.Includescheduled,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWorkflowRunTriggeredBy = `-- name: CreateWorkflowRunTriggeredBy :one
INSERT INTO "WorkflowRunTriggeredBy" (
    "id",
    "createdAt",
    "updatedAt",
    "deletedAt",
    "tenantId",
    "parentId",
    "eventId",
    "cronParentId",
    "cronSchedule",
    "cronName",
    "scheduledId"
) VALUES (
    gen_random_uuid(),
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    NULL,
    $1::uuid,
    $2::uuid,
    $3::uuid,
    $4::uuid,
    $5::text,
    $6::text,
    $7::uuid
) RETURNING id, "createdAt", "updatedAt", "deletedAt", "tenantId", "eventId", "cronParentId", "cronSchedule", "scheduledId", input, "parentId", "cronName"
`

type CreateWorkflowRunTriggeredByParams struct {
	Tenantid      pgtype.UUID `json:"tenantid"`
	Workflowrunid pgtype.UUID `json:"workflowrunid"`
	EventId       pgtype.UUID `json:"eventId"`
	CronParentId  pgtype.UUID `json:"cronParentId"`
	CronSchedule  pgtype.Text `json:"cronSchedule"`
	CronName      pgtype.Text `json:"cronName"`
	ScheduledId   pgtype.UUID `json:"scheduledId"`
}

func (q *Queries) CreateWorkflowRunTriggeredBy(ctx context.Context, db DBTX, arg CreateWorkflowRunTriggeredByParams) (*WorkflowRunTriggeredBy, error) {
	row := db.QueryRow(ctx, createWorkflowRunTriggeredBy,
		arg.Tenantid,
		arg.Workflowrunid,
		arg.EventId,
		arg.CronParentId,
		arg.CronSchedule,
		arg.CronName,
		arg.ScheduledId,
	)
	var i WorkflowRunTriggeredBy
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.EventId,
		&i.CronParentId,
		&i.CronSchedule,
		&i.ScheduledId,
		&i.Input,
		&i.ParentId,
		&i.CronName,
	)
	return &i, err
}

type CreateWorkflowRunTriggeredBysParams struct {
	ID           pgtype.UUID `json:"id"`
	TenantId     pgtype.UUID `json:"tenantId"`
	ParentId     pgtype.UUID `json:"parentId"`
	EventId      pgtype.UUID `json:"eventId"`
	CronParentId pgtype.UUID `json:"cronParentId"`
	CronSchedule pgtype.Text `json:"cronSchedule"`
	CronName     pgtype.Text `json:"cronName"`
	ScheduledId  pgtype.UUID `json:"scheduledId"`
}

const deleteScheduledWorkflow = `-- name: DeleteScheduledWorkflow :exec
DELETE FROM "WorkflowTriggerScheduledRef"
WHERE
    "id" = $1::uuid
`

func (q *Queries) DeleteScheduledWorkflow(ctx context.Context, db DBTX, scheduleid pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteScheduledWorkflow, scheduleid)
	return err
}

const getScheduledWorkflowMetaByIds = `-- name: GetScheduledWorkflowMetaByIds :many
SELECT
    t."id",
    t."method",
    EXISTS (
        SELECT 1
        FROM "WorkflowRunTriggeredBy" tb
        WHERE tb."scheduledId" = t."id"
    ) AS "hasTriggeredRun"
FROM "WorkflowTriggerScheduledRef" t
JOIN "WorkflowVersion" v ON t."parentId" = v."id"
JOIN "Workflow" w ON v."workflowId" = w."id"
WHERE
    w."tenantId" = $1::uuid
    AND t."id" = ANY($2::uuid[])
`

type GetScheduledWorkflowMetaByIdsParams struct {
	Tenantid pgtype.UUID   `json:"tenantid"`
	Ids      []pgtype.UUID `json:"ids"`
}

type GetScheduledWorkflowMetaByIdsRow struct {
	ID              pgtype.UUID                        `json:"id"`
	Method          WorkflowTriggerScheduledRefMethods `json:"method"`
	HasTriggeredRun bool                               `json:"hasTriggeredRun"`
}

func (q *Queries) GetScheduledWorkflowMetaByIds(ctx context.Context, db DBTX, arg GetScheduledWorkflowMetaByIdsParams) ([]*GetScheduledWorkflowMetaByIdsRow, error) {
	rows, err := db.Query(ctx, getScheduledWorkflowMetaByIds, arg.Tenantid, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetScheduledWorkflowMetaByIdsRow
	for rows.Next() {
		var i GetScheduledWorkflowMetaByIdsRow
		if err := rows.Scan(&i.ID, &i.Method, &i.HasTriggeredRun); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStepsForJobs = `-- name: GetStepsForJobs :many
SELECT
	j."id" as "jobId",
    s.id, s."createdAt", s."updatedAt", s."deletedAt", s."readableId", s."tenantId", s."jobId", s."actionId", s.timeout, s."customUserData", s.retries, s."retryBackoffFactor", s."retryMaxBackoff", s."scheduleTimeout",
    (
        SELECT array_agg(so."A")::uuid[]  -- Casting the array_agg result to uuid[]
        FROM "_StepOrder" so
        WHERE so."B" = s."id"
    ) AS "parents"
FROM "Job" j
JOIN "Step" s ON s."jobId" = j."id"
WHERE
    j."id" = ANY($1::uuid[])
    AND j."tenantId" = $2::uuid
    AND j."deletedAt" IS NULL
`

type GetStepsForJobsParams struct {
	Jobids   []pgtype.UUID `json:"jobids"`
	Tenantid pgtype.UUID   `json:"tenantid"`
}

type GetStepsForJobsRow struct {
	JobId   pgtype.UUID   `json:"jobId"`
	Step    Step          `json:"step"`
	Parents []pgtype.UUID `json:"parents"`
}

func (q *Queries) GetStepsForJobs(ctx context.Context, db DBTX, arg GetStepsForJobsParams) ([]*GetStepsForJobsRow, error) {
	rows, err := db.Query(ctx, getStepsForJobs, arg.Jobids, arg.Tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetStepsForJobsRow
	for rows.Next() {
		var i GetStepsForJobsRow
		if err := rows.Scan(
			&i.JobId,
			&i.Step.ID,
			&i.Step.CreatedAt,
			&i.Step.UpdatedAt,
			&i.Step.DeletedAt,
			&i.Step.ReadableId,
			&i.Step.TenantId,
			&i.Step.JobId,
			&i.Step.ActionId,
			&i.Step.Timeout,
			&i.Step.CustomUserData,
			&i.Step.Retries,
			&i.Step.RetryBackoffFactor,
			&i.Step.RetryMaxBackoff,
			&i.Step.ScheduleTimeout,
			&i.Parents,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkflowRunShape = `-- name: GetWorkflowRunShape :many
SELECT
    s.id AS parentStepId,
    s."readableId" AS stepName,
    array_remove(ARRAY_AGG(so."B"), NULL)::uuid[] AS childrenStepIds
FROM "WorkflowVersion" v
JOIN "Job" j ON v."id" = j."workflowVersionId"
JOIN "Step" s ON j."id" = s."jobId"
LEFT JOIN "_StepOrder" so ON so."A" = s.id
WHERE v.id = $1::uuid
GROUP BY s.id, s."readableId"
`

type GetWorkflowRunShapeRow struct {
	Parentstepid    pgtype.UUID   `json:"parentstepid"`
	Stepname        pgtype.Text   `json:"stepname"`
	Childrenstepids []pgtype.UUID `json:"childrenstepids"`
}

func (q *Queries) GetWorkflowRunShape(ctx context.Context, db DBTX, workflowversionid pgtype.UUID) ([]*GetWorkflowRunShapeRow, error) {
	rows, err := db.Query(ctx, getWorkflowRunShape, workflowversionid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetWorkflowRunShapeRow
	for rows.Next() {
		var i GetWorkflowRunShapeRow
		if err := rows.Scan(&i.Parentstepid, &i.Stepname, &i.Childrenstepids); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkflowRunTrigger = `-- name: GetWorkflowRunTrigger :one
SELECT id, "createdAt", "updatedAt", "deletedAt", "tenantId", "eventId", "cronParentId", "cronSchedule", "scheduledId", input, "parentId", "cronName"
FROM
    "WorkflowRunTriggeredBy"
WHERE
    "parentId" = $1::uuid AND
    "tenantId" = $2::uuid
`

type GetWorkflowRunTriggerParams struct {
	Runid    pgtype.UUID `json:"runid"`
	Tenantid pgtype.UUID `json:"tenantid"`
}

func (q *Queries) GetWorkflowRunTrigger(ctx context.Context, db DBTX, arg GetWorkflowRunTriggerParams) (*WorkflowRunTriggeredBy, error) {
	row := db.QueryRow(ctx, getWorkflowRunTrigger, arg.Runid, arg.Tenantid)
	var i WorkflowRunTriggeredBy
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.EventId,
		&i.CronParentId,
		&i.CronSchedule,
		&i.ScheduledId,
		&i.Input,
		&i.ParentId,
		&i.CronName,
	)
	return &i, err
}

const listScheduledWorkflows = `-- name: ListScheduledWorkflows :many
SELECT
    w."name",
    w."id" as "workflowId",
    v."id" as "workflowVersionId",
    w."tenantId",
    t.id, t."parentId", t."triggerAt", t."tickerId", t.input, t."childIndex", t."childKey", t."parentStepRunId", t."parentWorkflowRunId", t."additionalMetadata", t."createdAt", t."deletedAt", t."updatedAt", t.method, t.priority,
    wr."createdAt" as "workflowRunCreatedAt",
    wr."status" as "workflowRunStatus",
    wr."id" as "workflowRunId",
    wr."displayName" as "workflowRunName"
FROM "WorkflowTriggerScheduledRef" t
JOIN "WorkflowVersion" v ON t."parentId" = v."id"
JOIN "Workflow" w on v."workflowId" = w."id"
LEFT JOIN "WorkflowRunTriggeredBy" tb ON t."id" = tb."scheduledId"
LEFT JOIN "WorkflowRun" wr ON tb."parentId" = wr."id"
WHERE v."deletedAt" IS NULL
	AND w."tenantId" = $1::uuid
    AND ($2::uuid IS NULL OR t."id" = $2::uuid)
    AND ($3::uuid IS NULL OR w."id" = $3::uuid)
    AND ($4::uuid IS NULL OR t."id" = $4::uuid)
    AND ($5::uuid IS NULL OR t."parentStepRunId" = $5::uuid)
    AND ($6::jsonb IS NULL OR
        t."additionalMetadata" @> $6::jsonb)
    AND (
        $7::text[] IS NULL OR
        wr."status" = ANY(cast($7::text[] as "WorkflowRunStatus"[]))
        or (
            $8::boolean IS TRUE AND
            wr."status" IS NULL
        )
    )
ORDER BY
    case when $9 = 'triggerAt ASC' THEN t."triggerAt" END ASC ,
    case when $9 = 'triggerAt DESC' THEN t."triggerAt" END DESC,
    case when $9 = 'createdAt ASC' THEN t."createdAt" END ASC ,
    case when $9 = 'createdAt DESC' THEN t."createdAt" END DESC,
    t."id" ASC
OFFSET
    COALESCE($10, 0)
LIMIT
    COALESCE($11, 50)
`

type ListScheduledWorkflowsParams struct {
	Tenantid            pgtype.UUID `json:"tenantid"`
	Scheduleid          pgtype.UUID `json:"scheduleid"`
	Workflowid          pgtype.UUID `json:"workflowid"`
	Parentworkflowrunid pgtype.UUID `json:"parentworkflowrunid"`
	Parentsteprunid     pgtype.UUID `json:"parentsteprunid"`
	AdditionalMetadata  []byte      `json:"additionalMetadata"`
	Statuses            []string    `json:"statuses"`
	Includescheduled    bool        `json:"includescheduled"`
	Orderby             interface{} `json:"orderby"`
	Offset              interface{} `json:"offset"`
	Limit               interface{} `json:"limit"`
}

type ListScheduledWorkflowsRow struct {
	Name                 string                             `json:"name"`
	WorkflowId           pgtype.UUID                        `json:"workflowId"`
	WorkflowVersionId    pgtype.UUID                        `json:"workflowVersionId"`
	TenantId             pgtype.UUID                        `json:"tenantId"`
	ID                   pgtype.UUID                        `json:"id"`
	ParentId             pgtype.UUID                        `json:"parentId"`
	TriggerAt            pgtype.Timestamp                   `json:"triggerAt"`
	TickerId             pgtype.UUID                        `json:"tickerId"`
	Input                []byte                             `json:"input"`
	ChildIndex           pgtype.Int4                        `json:"childIndex"`
	ChildKey             pgtype.Text                        `json:"childKey"`
	ParentStepRunId      pgtype.UUID                        `json:"parentStepRunId"`
	ParentWorkflowRunId  pgtype.UUID                        `json:"parentWorkflowRunId"`
	AdditionalMetadata   []byte                             `json:"additionalMetadata"`
	CreatedAt            pgtype.Timestamp                   `json:"createdAt"`
	DeletedAt            pgtype.Timestamp                   `json:"deletedAt"`
	UpdatedAt            pgtype.Timestamp                   `json:"updatedAt"`
	Method               WorkflowTriggerScheduledRefMethods `json:"method"`
	Priority             int32                              `json:"priority"`
	WorkflowRunCreatedAt pgtype.Timestamp                   `json:"workflowRunCreatedAt"`
	WorkflowRunStatus    NullWorkflowRunStatus              `json:"workflowRunStatus"`
	WorkflowRunId        pgtype.UUID                        `json:"workflowRunId"`
	WorkflowRunName      pgtype.Text                        `json:"workflowRunName"`
}

func (q *Queries) ListScheduledWorkflows(ctx context.Context, db DBTX, arg ListScheduledWorkflowsParams) ([]*ListScheduledWorkflowsRow, error) {
	rows, err := db.Query(ctx, listScheduledWorkflows,
		arg.Tenantid,
		arg.Scheduleid,
		arg.Workflowid,
		arg.Parentworkflowrunid,
		arg.Parentsteprunid,
		arg.AdditionalMetadata,
		arg.Statuses,
		arg.Includescheduled,
		arg.Orderby,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListScheduledWorkflowsRow
	for rows.Next() {
		var i ListScheduledWorkflowsRow
		if err := rows.Scan(
			&i.Name,
			&i.WorkflowId,
			&i.WorkflowVersionId,
			&i.TenantId,
			&i.ID,
			&i.ParentId,
			&i.TriggerAt,
			&i.TickerId,
			&i.Input,
			&i.ChildIndex,
			&i.ChildKey,
			&i.ParentStepRunId,
			&i.ParentWorkflowRunId,
			&i.AdditionalMetadata,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.UpdatedAt,
			&i.Method,
			&i.Priority,
			&i.WorkflowRunCreatedAt,
			&i.WorkflowRunStatus,
			&i.WorkflowRunId,
			&i.WorkflowRunName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepsForJob = `-- name: ListStepsForJob :many
WITH job_id AS (
    SELECT "jobId"
    FROM "JobRun"
    WHERE "id" = $1::uuid
)
SELECT
    s."id",
    s."actionId"
FROM
    "Step" s, job_id
WHERE
    s."jobId" = job_id."jobId"
`

type ListStepsForJobRow struct {
	ID       pgtype.UUID `json:"id"`
	ActionId string      `json:"actionId"`
}

func (q *Queries) ListStepsForJob(ctx context.Context, db DBTX, jobrunid pgtype.UUID) ([]*ListStepsForJobRow, error) {
	rows, err := db.Query(ctx, listStepsForJob, jobrunid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListStepsForJobRow
	for rows.Next() {
		var i ListStepsForJobRow
		if err := rows.Scan(&i.ID, &i.ActionId); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateScheduledWorkflow = `-- name: UpdateScheduledWorkflow :exec
UPDATE "WorkflowTriggerScheduledRef"
SET "triggerAt" = $1::timestamp
WHERE
    "id" = $2::uuid
`

type UpdateScheduledWorkflowParams struct {
	Triggerat  pgtype.Timestamp `json:"triggerat"`
	Scheduleid pgtype.UUID      `json:"scheduleid"`
}

func (q *Queries) UpdateScheduledWorkflow(ctx context.Context, db DBTX, arg UpdateScheduledWorkflowParams) error {
	_, err := db.Exec(ctx, updateScheduledWorkflow, arg.Triggerat, arg.Scheduleid)
	return err
}
