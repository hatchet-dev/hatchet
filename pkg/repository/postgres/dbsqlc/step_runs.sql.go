// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: step_runs.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const archiveStepRunResultFromStepRun = `-- name: ArchiveStepRunResultFromStepRun :one
WITH step_run_data AS (
    SELECT
        "id" AS step_run_id,
        "createdAt",
        "updatedAt",
        "deletedAt",
        "retryCount",
        "order",
        "input",
        "output",
        "error",
        "startedAt",
        "finishedAt",
        "timeoutAt",
        "cancelledAt",
        "cancelledReason",
        "cancelledError"
    FROM "StepRun"
    WHERE
        "id" = $3::uuid
        AND "tenantId" = $4::uuid
        AND "deletedAt" IS NULL
)
INSERT INTO "StepRunResultArchive" (
    "id",
    "createdAt",
    "updatedAt",
    "deletedAt",
    "stepRunId",
    "retryCount",
    "input",
    "output",
    "error",
    "startedAt",
    "finishedAt",
    "timeoutAt",
    "cancelledAt",
    "cancelledReason",
    "cancelledError"
)
SELECT
    COALESCE($1::uuid, gen_random_uuid()),
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    step_run_data."deletedAt",
    step_run_data.step_run_id,
    step_run_data."retryCount",
    step_run_data."input",
    step_run_data."output",
    COALESCE($2::text, step_run_data."error"),
    step_run_data."startedAt",
    step_run_data."finishedAt",
    step_run_data."timeoutAt",
    step_run_data."cancelledAt",
    step_run_data."cancelledReason",
    step_run_data."cancelledError"
FROM step_run_data
RETURNING id, "createdAt", "updatedAt", "deletedAt", "stepRunId", "order", input, output, error, "startedAt", "finishedAt", "timeoutAt", "cancelledAt", "cancelledReason", "cancelledError", "retryCount"
`

type ArchiveStepRunResultFromStepRunParams struct {
	ID        pgtype.UUID `json:"id"`
	Error     pgtype.Text `json:"error"`
	Steprunid pgtype.UUID `json:"steprunid"`
	Tenantid  pgtype.UUID `json:"tenantid"`
}

func (q *Queries) ArchiveStepRunResultFromStepRun(ctx context.Context, db DBTX, arg ArchiveStepRunResultFromStepRunParams) (*StepRunResultArchive, error) {
	row := db.QueryRow(ctx, archiveStepRunResultFromStepRun,
		arg.ID,
		arg.Error,
		arg.Steprunid,
		arg.Tenantid,
	)
	var i StepRunResultArchive
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.StepRunId,
		&i.Order,
		&i.Input,
		&i.Output,
		&i.Error,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TimeoutAt,
		&i.CancelledAt,
		&i.CancelledReason,
		&i.CancelledError,
		&i.RetryCount,
	)
	return &i, err
}

const bulkBackoffStepRun = `-- name: BulkBackoffStepRun :exec
UPDATE
    "StepRun" sr
SET
    "status" = 'BACKOFF'
FROM (
    SELECT "id"
    FROM "StepRun" sr2
    WHERE sr2."id" = ANY($1::uuid[])
    ORDER BY  sr2."id"
    FOR UPDATE
) upd
WHERE sr."id" = upd."id"
`

func (q *Queries) BulkBackoffStepRun(ctx context.Context, db DBTX, steprunids []pgtype.UUID) error {
	_, err := db.Exec(ctx, bulkBackoffStepRun, steprunids)
	return err
}

const bulkCancelStepRun = `-- name: BulkCancelStepRun :exec
WITH input AS (
    SELECT
        unnest($1::uuid[]) AS "id",
        unnest($2::timestamp[]) AS "finishedAt",
        unnest($3::timestamp[]) AS "cancelledAt",
        unnest($4::text[]) AS "cancelledReason",
        unnest($5::text[]) AS "cancelledError"
)
UPDATE "StepRun"
SET
    "status" = CASE
        -- Final states are final, cannot be updated
        WHEN "status" IN ('SUCCEEDED', 'FAILED', 'CANCELLED') THEN "status"
        ELSE 'CANCELLED'
    END,
    "finishedAt" = input."finishedAt",
    "cancelledAt" = input."cancelledAt",
    "cancelledReason" = input."cancelledReason",
    "cancelledError" = input."cancelledError"
FROM input
WHERE "StepRun"."id" = input."id"
`

type BulkCancelStepRunParams struct {
	Steprunids       []pgtype.UUID      `json:"steprunids"`
	Finishedats      []pgtype.Timestamp `json:"finishedats"`
	Cancelledats     []pgtype.Timestamp `json:"cancelledats"`
	Cancelledreasons []string           `json:"cancelledreasons"`
	Cancellederrors  []string           `json:"cancellederrors"`
}

func (q *Queries) BulkCancelStepRun(ctx context.Context, db DBTX, arg BulkCancelStepRunParams) error {
	_, err := db.Exec(ctx, bulkCancelStepRun,
		arg.Steprunids,
		arg.Finishedats,
		arg.Cancelledats,
		arg.Cancelledreasons,
		arg.Cancellederrors,
	)
	return err
}

const bulkCreateStepRunEvent = `-- name: BulkCreateStepRunEvent :exec
WITH input_values AS (
    SELECT
        unnest($1::timestamp[]) AS "timeFirstSeen",
        unnest($1::timestamp[]) AS "timeLastSeen",
        unnest($2::uuid[]) AS "stepRunId",
        unnest(cast($3::text[] as"StepRunEventReason"[])) AS "reason",
        unnest(cast($4::text[] as "StepRunEventSeverity"[])) AS "severity",
        unnest($5::text[]) AS "message",
        1 AS "count",
        unnest($6::jsonb[]) AS "data"
),
matched_rows AS (
    SELECT DISTINCT ON (sre."stepRunId")
        sre."stepRunId", sre."reason", sre."severity", sre."id"
    FROM "StepRunEvent" sre
    WHERE
        sre."stepRunId" = ANY($2::uuid[])
    ORDER BY sre."stepRunId", sre."id" DESC
),
locked_rows AS (
    SELECT sre."id", iv."timeFirstSeen", iv."timeLastSeen", iv."stepRunId", iv.reason, iv.severity, iv.message, iv.count, iv.data
    FROM "StepRunEvent" sre
    JOIN
        matched_rows mr ON sre."id" = mr."id"
    JOIN
        input_values iv ON sre."stepRunId" = iv."stepRunId" AND sre."reason" = iv."reason" AND sre."severity" = iv."severity"
    ORDER BY "id"
    FOR UPDATE
),
updated AS (
    UPDATE "StepRunEvent"
    SET
        "timeLastSeen" = locked_rows."timeLastSeen",
        "message" = locked_rows."message",
        "count" = "StepRunEvent"."count" + 1,
        "data" = locked_rows."data"
    FROM locked_rows
    WHERE
        "StepRunEvent"."id" = locked_rows."id"
    RETURNING "StepRunEvent".id, "StepRunEvent"."timeFirstSeen", "StepRunEvent"."timeLastSeen", "StepRunEvent"."stepRunId", "StepRunEvent".reason, "StepRunEvent".severity, "StepRunEvent".message, "StepRunEvent".count, "StepRunEvent".data, "StepRunEvent"."workflowRunId"
)
INSERT INTO "StepRunEvent" (
    "timeFirstSeen",
    "timeLastSeen",
    "stepRunId",
    "reason",
    "severity",
    "message",
    "count",
    "data"
)
SELECT
    "timeFirstSeen",
    "timeLastSeen",
    "stepRunId",
    "reason",
    "severity",
    "message",
    "count",
    "data"
FROM input_values
WHERE NOT EXISTS (
    SELECT 1 FROM updated WHERE "stepRunId" = input_values."stepRunId" AND "reason" = input_values."reason" AND "severity" = input_values."severity"
)
`

type BulkCreateStepRunEventParams struct {
	Timeseen   []pgtype.Timestamp `json:"timeseen"`
	Steprunids []pgtype.UUID      `json:"steprunids"`
	Reasons    []string           `json:"reasons"`
	Severities []string           `json:"severities"`
	Messages   []string           `json:"messages"`
	Data       [][]byte           `json:"data"`
}

func (q *Queries) BulkCreateStepRunEvent(ctx context.Context, db DBTX, arg BulkCreateStepRunEventParams) error {
	_, err := db.Exec(ctx, bulkCreateStepRunEvent,
		arg.Timeseen,
		arg.Steprunids,
		arg.Reasons,
		arg.Severities,
		arg.Messages,
		arg.Data,
	)
	return err
}

const bulkFailStepRun = `-- name: BulkFailStepRun :exec
UPDATE
    "StepRun"
SET
    "status" = CASE
        -- Final states are final, cannot be updated
        WHEN "status" IN ('SUCCEEDED', 'FAILED', 'CANCELLED') THEN "status"
        ELSE 'FAILED'
    END,
    "finishedAt" = input."finishedAt",
    "error" = input."error"::text
FROM (
    SELECT
        unnest($1::uuid[]) AS "id",
        unnest($2::timestamp[]) AS "finishedAt",
        unnest($3::text[]) AS "error"
    ) AS input
WHERE
    "StepRun"."id" = input."id"
`

type BulkFailStepRunParams struct {
	Steprunids  []pgtype.UUID      `json:"steprunids"`
	Finishedats []pgtype.Timestamp `json:"finishedats"`
	Errors      []string           `json:"errors"`
}

func (q *Queries) BulkFailStepRun(ctx context.Context, db DBTX, arg BulkFailStepRunParams) error {
	_, err := db.Exec(ctx, bulkFailStepRun, arg.Steprunids, arg.Finishedats, arg.Errors)
	return err
}

const bulkFinishStepRun = `-- name: BulkFinishStepRun :exec
UPDATE
    "StepRun"
SET
    "status" = CASE
        WHEN "status" IN ('SUCCEEDED', 'FAILED', 'CANCELLED') THEN "status"
        ELSE 'SUCCEEDED'
    END,
    "finishedAt" = input."finishedAt",
    "output" = input."output"::jsonb
FROM (
    SELECT
        unnest($1::uuid[]) AS "id",
        unnest($2::timestamp[]) AS "finishedAt",
        unnest($3::jsonb[]) AS "output"
    ) AS input
WHERE
    "StepRun"."id" = input."id"
`

type BulkFinishStepRunParams struct {
	Steprunids  []pgtype.UUID      `json:"steprunids"`
	Finishedats []pgtype.Timestamp `json:"finishedats"`
	Outputs     [][]byte           `json:"outputs"`
}

func (q *Queries) BulkFinishStepRun(ctx context.Context, db DBTX, arg BulkFinishStepRunParams) error {
	_, err := db.Exec(ctx, bulkFinishStepRun, arg.Steprunids, arg.Finishedats, arg.Outputs)
	return err
}

const bulkMarkStepRunsAsCancelling = `-- name: BulkMarkStepRunsAsCancelling :many
UPDATE
    "StepRun" sr
SET
    "status" = CASE
        -- Final states are final, we cannot go from a final state to cancelling
        WHEN "status" IN ('SUCCEEDED', 'FAILED', 'CANCELLED') THEN "status"
        ELSE 'CANCELLING'
    END,
    "updatedAt" = CURRENT_TIMESTAMP
FROM (
    SELECT
        unnest($1::uuid[]) AS "id"
    ) AS input
WHERE
    sr."id" = input."id"
RETURNING sr."id"
`

func (q *Queries) BulkMarkStepRunsAsCancelling(ctx context.Context, db DBTX, steprunids []pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, bulkMarkStepRunsAsCancelling, steprunids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bulkRetryStepRun = `-- name: BulkRetryStepRun :exec
UPDATE
    "StepRun" sr
SET
    "status" = 'PENDING_ASSIGNMENT'
FROM (
    SELECT "id"
    FROM "StepRun" sr2
    WHERE sr2."id" = ANY($1::uuid[])
    ORDER BY  sr2."id"
    FOR UPDATE
) upd
WHERE sr."id" = upd."id"
`

func (q *Queries) BulkRetryStepRun(ctx context.Context, db DBTX, steprunids []pgtype.UUID) error {
	_, err := db.Exec(ctx, bulkRetryStepRun, steprunids)
	return err
}

const bulkStartStepRun = `-- name: BulkStartStepRun :exec
UPDATE
    "StepRun"
SET
    "status" = CASE
        -- Final states are final, cannot be updated, and we cannot go from cancelling to a non-final state
        WHEN "status" IN ('SUCCEEDED', 'FAILED', 'CANCELLED', 'CANCELLING') THEN "status"
        ELSE 'RUNNING'
    END,
    "startedAt" = input."startedAt"
FROM (
    SELECT
        unnest($1::uuid[]) AS "id",
        unnest($2::timestamp[]) AS "startedAt"
    ) AS input
WHERE
    "StepRun"."id" = input."id"
`

type BulkStartStepRunParams struct {
	Steprunids []pgtype.UUID      `json:"steprunids"`
	Startedats []pgtype.Timestamp `json:"startedats"`
}

func (q *Queries) BulkStartStepRun(ctx context.Context, db DBTX, arg BulkStartStepRunParams) error {
	_, err := db.Exec(ctx, bulkStartStepRun, arg.Steprunids, arg.Startedats)
	return err
}

const checkWorker = `-- name: CheckWorker :one
SELECT
    "id"
FROM
    "Worker"
WHERE
    "tenantId" = $1::uuid
    AND "dispatcherId" IS NOT NULL
    AND "isActive" = true
    AND "isPaused" = false
    AND "lastHeartbeatAt" > NOW() - INTERVAL '5 seconds'
    AND "id" = $2::uuid
`

type CheckWorkerParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Workerid pgtype.UUID `json:"workerid"`
}

func (q *Queries) CheckWorker(ctx context.Context, db DBTX, arg CheckWorkerParams) (pgtype.UUID, error) {
	row := db.QueryRow(ctx, checkWorker, arg.Tenantid, arg.Workerid)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const clearStepRunPayloadData = `-- name: ClearStepRunPayloadData :one
WITH for_delete AS (
    SELECT
        sr2."id"
    FROM "StepRun" sr2
    WHERE
        sr2."tenantId" = $1::uuid AND
        sr2."deletedAt" IS NOT NULL AND
        (sr2."input" IS NOT NULL OR sr2."output" IS NOT NULL OR sr2."error" IS NOT NULL)
    ORDER BY "deletedAt" ASC
    LIMIT $2 + 1
),
deleted_with_limit AS (
    SELECT
        for_delete."id" as "id"
    FROM for_delete
    LIMIT $2
),
deleted_archives AS (
    SELECT sra1."id" as "id"
    FROM "StepRunResultArchive" sra1
    WHERE
        sra1."stepRunId" IN (SELECT "id" FROM deleted_with_limit)
        AND (sra1."input" IS NOT NULL OR sra1."output" IS NOT NULL OR sra1."error" IS NOT NULL)
),
has_more AS (
    SELECT
        CASE
            WHEN COUNT(*) > $2 THEN TRUE
            ELSE FALSE
        END as has_more
    FROM for_delete
),
cleared_archives AS (
    UPDATE "StepRunResultArchive"
    SET
        "input" = NULL,
        "output" = NULL,
        "error" = NULL
    WHERE
        "id" IN (SELECT "id" FROM deleted_archives)
)
UPDATE
    "StepRun"
SET
    "input" = NULL,
    "output" = NULL,
    "error" = NULL
WHERE
    "id" IN (SELECT "id" FROM deleted_with_limit)
RETURNING
    (SELECT has_more FROM has_more) as has_more
`

type ClearStepRunPayloadDataParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Limit    interface{} `json:"limit"`
}

func (q *Queries) ClearStepRunPayloadData(ctx context.Context, db DBTX, arg ClearStepRunPayloadDataParams) (bool, error) {
	row := db.QueryRow(ctx, clearStepRunPayloadData, arg.Tenantid, arg.Limit)
	var has_more bool
	err := row.Scan(&has_more)
	return has_more, err
}

const countStepRunArchives = `-- name: CountStepRunArchives :one
SELECT
    count(*) OVER() AS total
FROM
    "StepRunResultArchive"
WHERE
    "stepRunId" = $1::uuid
`

func (q *Queries) CountStepRunArchives(ctx context.Context, db DBTX, steprunid pgtype.UUID) (int64, error) {
	row := db.QueryRow(ctx, countStepRunArchives, steprunid)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countStepRunEvents = `-- name: CountStepRunEvents :one
SELECT
    count(*) OVER() AS total
FROM
    "StepRunEvent"
WHERE
    "stepRunId" = $1::uuid
`

func (q *Queries) CountStepRunEvents(ctx context.Context, db DBTX, steprunid pgtype.UUID) (int64, error) {
	row := db.QueryRow(ctx, countStepRunEvents, steprunid)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createStepRunEvent = `-- name: CreateStepRunEvent :exec
WITH input_values AS (
    SELECT
        CURRENT_TIMESTAMP AS "timeFirstSeen",
        CURRENT_TIMESTAMP AS "timeLastSeen",
        $1::uuid AS "stepRunId",
        $2::uuid AS "jobRunId",
        $3::"StepRunEventReason" AS "reason",
        $4::"StepRunEventSeverity" AS "severity",
        $5::text AS "message",
        1 AS "count",
        $6::jsonb AS "data"
),
updated AS (
    UPDATE "StepRunEvent"
    SET
        "timeLastSeen" = CURRENT_TIMESTAMP,
        "message" = input_values."message",
        "count" = "StepRunEvent"."count" + 1,
        "data" = input_values."data"
    FROM input_values
    WHERE
        "StepRunEvent"."stepRunId" = input_values."stepRunId"
        AND "StepRunEvent"."reason" = input_values."reason"
        AND "StepRunEvent"."severity" = input_values."severity"
        AND "StepRunEvent"."id" = (
            SELECT "id"
            FROM "StepRunEvent"
            WHERE "stepRunId" = input_values."stepRunId"
            ORDER BY "id" DESC
            LIMIT 1
        )
    RETURNING "StepRunEvent".id, "StepRunEvent"."timeFirstSeen", "StepRunEvent"."timeLastSeen", "StepRunEvent"."stepRunId", "StepRunEvent".reason, "StepRunEvent".severity, "StepRunEvent".message, "StepRunEvent".count, "StepRunEvent".data, "StepRunEvent"."workflowRunId"
)
INSERT INTO "StepRunEvent" (
    "timeFirstSeen",
    "timeLastSeen",
    "stepRunId",
    "reason",
    "severity",
    "message",
    "count",
    "data"
)
SELECT
    "timeFirstSeen",
    "timeLastSeen",
    "stepRunId",
    "reason",
    "severity",
    "message",
    "count",
    "data"
FROM input_values
WHERE NOT EXISTS (
    SELECT 1 FROM updated WHERE "stepRunId" = input_values."stepRunId"
)
`

type CreateStepRunEventParams struct {
	Steprunid pgtype.UUID          `json:"steprunid"`
	Jobrunid  pgtype.UUID          `json:"jobrunid"`
	Reason    StepRunEventReason   `json:"reason"`
	Severity  StepRunEventSeverity `json:"severity"`
	Message   string               `json:"message"`
	Data      []byte               `json:"data"`
}

func (q *Queries) CreateStepRunEvent(ctx context.Context, db DBTX, arg CreateStepRunEventParams) error {
	_, err := db.Exec(ctx, createStepRunEvent,
		arg.Steprunid,
		arg.Jobrunid,
		arg.Reason,
		arg.Severity,
		arg.Message,
		arg.Data,
	)
	return err
}

const createStepRunExpressionEvalInts = `-- name: CreateStepRunExpressionEvalInts :exec
INSERT INTO "StepRunExpressionEval" (
    "key",
    "stepRunId",
    "valueInt",
    "kind"
) VALUES (
    unnest($1::text[]),
    $2::uuid,
    unnest($3::int[]),
    unnest(cast($4::text[] as"StepExpressionKind"[]))
) ON CONFLICT ("key", "stepRunId", "kind") DO UPDATE
SET
    "valueStr" = EXCLUDED."valueStr",
    "valueInt" = EXCLUDED."valueInt"
`

type CreateStepRunExpressionEvalIntsParams struct {
	Keys      []string    `json:"keys"`
	Steprunid pgtype.UUID `json:"steprunid"`
	Valuesint []int32     `json:"valuesint"`
	Kinds     []string    `json:"kinds"`
}

func (q *Queries) CreateStepRunExpressionEvalInts(ctx context.Context, db DBTX, arg CreateStepRunExpressionEvalIntsParams) error {
	_, err := db.Exec(ctx, createStepRunExpressionEvalInts,
		arg.Keys,
		arg.Steprunid,
		arg.Valuesint,
		arg.Kinds,
	)
	return err
}

const createStepRunExpressionEvalStrs = `-- name: CreateStepRunExpressionEvalStrs :exec
INSERT INTO "StepRunExpressionEval" (
    "key",
    "stepRunId",
    "valueStr",
    "kind"
) VALUES (
    unnest($1::text[]),
    $2::uuid,
    unnest($3::text[]),
    unnest(cast($4::text[] as"StepExpressionKind"[]))
) ON CONFLICT ("key", "stepRunId", "kind") DO UPDATE
SET
    "valueStr" = EXCLUDED."valueStr",
    "valueInt" = EXCLUDED."valueInt"
`

type CreateStepRunExpressionEvalStrsParams struct {
	Keys      []string    `json:"keys"`
	Steprunid pgtype.UUID `json:"steprunid"`
	Valuesstr []string    `json:"valuesstr"`
	Kinds     []string    `json:"kinds"`
}

func (q *Queries) CreateStepRunExpressionEvalStrs(ctx context.Context, db DBTX, arg CreateStepRunExpressionEvalStrsParams) error {
	_, err := db.Exec(ctx, createStepRunExpressionEvalStrs,
		arg.Keys,
		arg.Steprunid,
		arg.Valuesstr,
		arg.Kinds,
	)
	return err
}

const createWorkerAssignEvents = `-- name: CreateWorkerAssignEvents :exec
INSERT INTO "WorkerAssignEvent" (
    "workerId",
    "assignedStepRuns"
)
SELECT
    input."workerId",
    input."assignedStepRuns"
FROM (
    SELECT
        unnest($1::uuid[]) AS "workerId",
        unnest($2::jsonb[]) AS "assignedStepRuns"
    ) AS input
RETURNING id, "workerId", "assignedStepRuns"
`

type CreateWorkerAssignEventsParams struct {
	Workerids        []pgtype.UUID `json:"workerids"`
	Assignedstepruns [][]byte      `json:"assignedstepruns"`
}

func (q *Queries) CreateWorkerAssignEvents(ctx context.Context, db DBTX, arg CreateWorkerAssignEventsParams) error {
	_, err := db.Exec(ctx, createWorkerAssignEvents, arg.Workerids, arg.Assignedstepruns)
	return err
}

const getDesiredLabels = `-- name: GetDesiredLabels :many
SELECT
    "key",
    "strValue",
    "intValue",
    "required",
    "weight",
    "comparator",
    "stepId"
FROM
    "StepDesiredWorkerLabel"
WHERE
    "stepId" = ANY($1::uuid[])
`

type GetDesiredLabelsRow struct {
	Key        string                `json:"key"`
	StrValue   pgtype.Text           `json:"strValue"`
	IntValue   pgtype.Int4           `json:"intValue"`
	Required   bool                  `json:"required"`
	Weight     int32                 `json:"weight"`
	Comparator WorkerLabelComparator `json:"comparator"`
	StepId     pgtype.UUID           `json:"stepId"`
}

func (q *Queries) GetDesiredLabels(ctx context.Context, db DBTX, stepids []pgtype.UUID) ([]*GetDesiredLabelsRow, error) {
	rows, err := db.Query(ctx, getDesiredLabels, stepids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetDesiredLabelsRow
	for rows.Next() {
		var i GetDesiredLabelsRow
		if err := rows.Scan(
			&i.Key,
			&i.StrValue,
			&i.IntValue,
			&i.Required,
			&i.Weight,
			&i.Comparator,
			&i.StepId,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFinalizedStepRuns = `-- name: GetFinalizedStepRuns :many
SELECT
    "id", "status"
FROM
    "StepRun"
WHERE
    "id" = ANY($1::uuid[])
    AND "status" = ANY(ARRAY['SUCCEEDED', 'FAILED', 'CANCELLED', 'CANCELLING']::"StepRunStatus"[])
`

type GetFinalizedStepRunsRow struct {
	ID     pgtype.UUID   `json:"id"`
	Status StepRunStatus `json:"status"`
}

func (q *Queries) GetFinalizedStepRuns(ctx context.Context, db DBTX, steprunids []pgtype.UUID) ([]*GetFinalizedStepRunsRow, error) {
	rows, err := db.Query(ctx, getFinalizedStepRuns, steprunids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetFinalizedStepRunsRow
	for rows.Next() {
		var i GetFinalizedStepRunsRow
		if err := rows.Scan(&i.ID, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLaterStepRuns = `-- name: GetLaterStepRuns :many
WITH RECURSIVE currStepRun AS (
    SELECT id, "createdAt", "updatedAt", "deletedAt", "tenantId", "jobRunId", "stepId", "order", "workerId", "tickerId", status, input, output, "requeueAfter", "scheduleTimeoutAt", error, "startedAt", "finishedAt", "timeoutAt", "cancelledAt", "cancelledReason", "cancelledError", "inputSchema", "callerFiles", "gitRepoBranch", "retryCount", "semaphoreReleased", queue, priority, "internalRetryCount"
    FROM "StepRun"
    WHERE
        "id" = $1::uuid
), childStepRuns AS (
    SELECT sr."id", sr."status"
    FROM "StepRun" sr
    JOIN "_StepRunOrder" sro ON sr."id" = sro."B"
    WHERE sro."A" = (SELECT "id" FROM currStepRun)

    UNION ALL

    SELECT sr."id", sr."status"
    FROM "StepRun" sr
    JOIN "_StepRunOrder" sro ON sr."id" = sro."B"
    JOIN childStepRuns csr ON sro."A" = csr."id"
)
SELECT
    sr.id, sr."createdAt", sr."updatedAt", sr."deletedAt", sr."tenantId", sr."jobRunId", sr."stepId", sr."order", sr."workerId", sr."tickerId", sr.status, sr.input, sr.output, sr."requeueAfter", sr."scheduleTimeoutAt", sr.error, sr."startedAt", sr."finishedAt", sr."timeoutAt", sr."cancelledAt", sr."cancelledReason", sr."cancelledError", sr."inputSchema", sr."callerFiles", sr."gitRepoBranch", sr."retryCount", sr."semaphoreReleased", sr.queue, sr.priority, sr."internalRetryCount"
FROM
    "StepRun" sr
JOIN
    childStepRuns csr ON sr."id" = csr."id"
`

func (q *Queries) GetLaterStepRuns(ctx context.Context, db DBTX, steprunid pgtype.UUID) ([]*StepRun, error) {
	rows, err := db.Query(ctx, getLaterStepRuns, steprunid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepRun
	for rows.Next() {
		var i StepRun
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TenantId,
			&i.JobRunId,
			&i.StepId,
			&i.Order,
			&i.WorkerId,
			&i.TickerId,
			&i.Status,
			&i.Input,
			&i.Output,
			&i.RequeueAfter,
			&i.ScheduleTimeoutAt,
			&i.Error,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TimeoutAt,
			&i.CancelledAt,
			&i.CancelledReason,
			&i.CancelledError,
			&i.InputSchema,
			&i.CallerFiles,
			&i.GitRepoBranch,
			&i.RetryCount,
			&i.SemaphoreReleased,
			&i.Queue,
			&i.Priority,
			&i.InternalRetryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStepDesiredWorkerLabels = `-- name: GetStepDesiredWorkerLabels :one
SELECT
    jsonb_agg(
        jsonb_build_object(
            'key', dwl."key",
            'strValue', dwl."strValue",
            'intValue', dwl."intValue",
            'required', dwl."required",
            'weight', dwl."weight",
            'comparator', dwl."comparator",
            'is_true', false
        )
    ) AS desired_labels
FROM
    "StepDesiredWorkerLabel" dwl
WHERE
    dwl."stepId" = $1::uuid
`

func (q *Queries) GetStepDesiredWorkerLabels(ctx context.Context, db DBTX, stepid pgtype.UUID) ([]byte, error) {
	row := db.QueryRow(ctx, getStepDesiredWorkerLabels, stepid)
	var desired_labels []byte
	err := row.Scan(&desired_labels)
	return desired_labels, err
}

const getStepExpressions = `-- name: GetStepExpressions :many
SELECT
    key, "stepId", expression, kind
FROM
    "StepExpression"
WHERE
    "stepId" = $1::uuid
`

func (q *Queries) GetStepExpressions(ctx context.Context, db DBTX, stepid pgtype.UUID) ([]*StepExpression, error) {
	rows, err := db.Query(ctx, getStepExpressions, stepid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepExpression
	for rows.Next() {
		var i StepExpression
		if err := rows.Scan(
			&i.Key,
			&i.StepId,
			&i.Expression,
			&i.Kind,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStepRun = `-- name: GetStepRun :one
SELECT
    "StepRun".id, "StepRun"."createdAt", "StepRun"."updatedAt", "StepRun"."deletedAt", "StepRun"."tenantId", "StepRun"."jobRunId", "StepRun"."stepId", "StepRun"."order", "StepRun"."workerId", "StepRun"."tickerId", "StepRun".status, "StepRun".input, "StepRun".output, "StepRun"."requeueAfter", "StepRun"."scheduleTimeoutAt", "StepRun".error, "StepRun"."startedAt", "StepRun"."finishedAt", "StepRun"."timeoutAt", "StepRun"."cancelledAt", "StepRun"."cancelledReason", "StepRun"."cancelledError", "StepRun"."inputSchema", "StepRun"."callerFiles", "StepRun"."gitRepoBranch", "StepRun"."retryCount", "StepRun"."semaphoreReleased", "StepRun".queue, "StepRun".priority, "StepRun"."internalRetryCount"
FROM
    "StepRun"
WHERE
    "id" = $1::uuid AND
    "deletedAt" IS NULL
`

func (q *Queries) GetStepRun(ctx context.Context, db DBTX, id pgtype.UUID) (*StepRun, error) {
	row := db.QueryRow(ctx, getStepRun, id)
	var i StepRun
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.JobRunId,
		&i.StepId,
		&i.Order,
		&i.WorkerId,
		&i.TickerId,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.RequeueAfter,
		&i.ScheduleTimeoutAt,
		&i.Error,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TimeoutAt,
		&i.CancelledAt,
		&i.CancelledReason,
		&i.CancelledError,
		&i.InputSchema,
		&i.CallerFiles,
		&i.GitRepoBranch,
		&i.RetryCount,
		&i.SemaphoreReleased,
		&i.Queue,
		&i.Priority,
		&i.InternalRetryCount,
	)
	return &i, err
}

const getStepRunBulkDataForEngine = `-- name: GetStepRunBulkDataForEngine :many
SELECT
    sr."id" AS "SR_id",
    sr."retryCount" AS "SR_retryCount",
    sr."input",
    sr."output",
    sr."error",
    sr."status",
    COALESCE(sr."priority", 1) AS "priority",
    jr."id" AS "jobRunId",
    jr."status" AS "jobRunStatus",
    jr."status" AS "jobRunStatus",
    jr."workflowRunId" AS "workflowRunId",
    jrld."data" AS "jobRunLookupData",
    wr."additionalMetadata",
    wr."childIndex",
    wr."childKey",
    wr."parentId",
    jr."id" AS "jobRunId",
    s."id" AS "stepId",
    s."retries" AS "stepRetries",
    s."timeout" AS "stepTimeout",
    s."scheduleTimeout" AS "stepScheduleTimeout",
    s."readableId" AS "stepReadableId",
    s."customUserData" AS "stepCustomUserData",
    j."name" AS "jobName",
    j."id" AS "jobId",
    j."kind" AS "jobKind",
    j."workflowVersionId" AS "workflowVersionId",
    a."actionId" AS "actionId"
FROM
    "StepRun" sr
JOIN
    "Step" s ON sr."stepId" = s."id"
JOIN
    "Action" a ON s."actionId" = a."actionId" AND s."tenantId" = a."tenantId"
JOIN
    "JobRun" jr ON sr."jobRunId" = jr."id"
JOIN
    "Job" j ON jr."jobId" = j."id"
JOIN
    "JobRunLookupData" jrld ON jr."id" = jrld."jobRunId"
JOIN
    -- Take advantage of composite index on "JobRun"("workflowRunId", "tenantId")
    "WorkflowRun" wr ON jr."workflowRunId" = wr."id" AND wr."tenantId" = $1::uuid
WHERE
    sr."id" = ANY($2::uuid[])
    AND sr."tenantId" = $1::uuid
`

type GetStepRunBulkDataForEngineParams struct {
	Tenantid pgtype.UUID   `json:"tenantid"`
	Ids      []pgtype.UUID `json:"ids"`
}

type GetStepRunBulkDataForEngineRow struct {
	SRID                pgtype.UUID   `json:"SR_id"`
	SRRetryCount        int32         `json:"SR_retryCount"`
	Input               []byte        `json:"input"`
	Output              []byte        `json:"output"`
	Error               pgtype.Text   `json:"error"`
	Status              StepRunStatus `json:"status"`
	Priority            int32         `json:"priority"`
	JobRunId            pgtype.UUID   `json:"jobRunId"`
	JobRunStatus        JobRunStatus  `json:"jobRunStatus"`
	JobRunStatus_2      JobRunStatus  `json:"jobRunStatus_2"`
	WorkflowRunId       pgtype.UUID   `json:"workflowRunId"`
	JobRunLookupData    []byte        `json:"jobRunLookupData"`
	AdditionalMetadata  []byte        `json:"additionalMetadata"`
	ChildIndex          pgtype.Int4   `json:"childIndex"`
	ChildKey            pgtype.Text   `json:"childKey"`
	ParentId            pgtype.UUID   `json:"parentId"`
	JobRunId_2          pgtype.UUID   `json:"jobRunId_2"`
	StepId              pgtype.UUID   `json:"stepId"`
	StepRetries         int32         `json:"stepRetries"`
	StepTimeout         pgtype.Text   `json:"stepTimeout"`
	StepScheduleTimeout string        `json:"stepScheduleTimeout"`
	StepReadableId      pgtype.Text   `json:"stepReadableId"`
	StepCustomUserData  []byte        `json:"stepCustomUserData"`
	JobName             string        `json:"jobName"`
	JobId               pgtype.UUID   `json:"jobId"`
	JobKind             JobKind       `json:"jobKind"`
	WorkflowVersionId   pgtype.UUID   `json:"workflowVersionId"`
	ActionId            string        `json:"actionId"`
}

func (q *Queries) GetStepRunBulkDataForEngine(ctx context.Context, db DBTX, arg GetStepRunBulkDataForEngineParams) ([]*GetStepRunBulkDataForEngineRow, error) {
	rows, err := db.Query(ctx, getStepRunBulkDataForEngine, arg.Tenantid, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetStepRunBulkDataForEngineRow
	for rows.Next() {
		var i GetStepRunBulkDataForEngineRow
		if err := rows.Scan(
			&i.SRID,
			&i.SRRetryCount,
			&i.Input,
			&i.Output,
			&i.Error,
			&i.Status,
			&i.Priority,
			&i.JobRunId,
			&i.JobRunStatus,
			&i.JobRunStatus_2,
			&i.WorkflowRunId,
			&i.JobRunLookupData,
			&i.AdditionalMetadata,
			&i.ChildIndex,
			&i.ChildKey,
			&i.ParentId,
			&i.JobRunId_2,
			&i.StepId,
			&i.StepRetries,
			&i.StepTimeout,
			&i.StepScheduleTimeout,
			&i.StepReadableId,
			&i.StepCustomUserData,
			&i.JobName,
			&i.JobId,
			&i.JobKind,
			&i.WorkflowVersionId,
			&i.ActionId,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStepRunDataForEngine = `-- name: GetStepRunDataForEngine :one
WITH expr_count AS (
    SELECT
        COUNT(*) AS "exprCount",
        sr."id" AS "id"
    FROM
        "StepRun" sr
    JOIN
        "Step" s ON sr."stepId" = s."id"
    JOIN
        "StepExpression" se ON s."id" = se."stepId"
    WHERE
        sr."id" = $2::uuid
    GROUP BY
        sr."id"
)
SELECT
    sr."input",
    sr."output",
    sr."error",
    jrld."data" AS "jobRunLookupData",
    wr."additionalMetadata",
    wr."childIndex",
    wr."childKey",
    wr."parentId",
    COALESCE(ec."exprCount", 0) AS "exprCount"
FROM
    "StepRun" sr
JOIN
    "JobRun" jr ON sr."jobRunId" = jr."id"
JOIN
    "JobRunLookupData" jrld ON jr."id" = jrld."jobRunId"
JOIN
    -- Take advantage of composite index on "JobRun"("workflowRunId", "tenantId")
    "WorkflowRun" wr ON jr."workflowRunId" = wr."id" AND wr."tenantId" = $1::uuid
LEFT JOIN
    expr_count ec ON sr."id" = ec."id"
WHERE
    sr."id" = $2::uuid AND
    sr."tenantId" = $1::uuid
`

type GetStepRunDataForEngineParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	ID       pgtype.UUID `json:"id"`
}

type GetStepRunDataForEngineRow struct {
	Input              []byte      `json:"input"`
	Output             []byte      `json:"output"`
	Error              pgtype.Text `json:"error"`
	JobRunLookupData   []byte      `json:"jobRunLookupData"`
	AdditionalMetadata []byte      `json:"additionalMetadata"`
	ChildIndex         pgtype.Int4 `json:"childIndex"`
	ChildKey           pgtype.Text `json:"childKey"`
	ParentId           pgtype.UUID `json:"parentId"`
	ExprCount          int64       `json:"exprCount"`
}

func (q *Queries) GetStepRunDataForEngine(ctx context.Context, db DBTX, arg GetStepRunDataForEngineParams) (*GetStepRunDataForEngineRow, error) {
	row := db.QueryRow(ctx, getStepRunDataForEngine, arg.Tenantid, arg.ID)
	var i GetStepRunDataForEngineRow
	err := row.Scan(
		&i.Input,
		&i.Output,
		&i.Error,
		&i.JobRunLookupData,
		&i.AdditionalMetadata,
		&i.ChildIndex,
		&i.ChildKey,
		&i.ParentId,
		&i.ExprCount,
	)
	return &i, err
}

const getStepRunForEngine = `-- name: GetStepRunForEngine :many
WITH child_count AS (
    SELECT
        COUNT(*) AS "childCount",
        sr."id" AS "id"
    FROM
        "StepRun" sr
    LEFT JOIN
        "_StepRunOrder" AS step_run_order ON sr."id" = step_run_order."A"
    WHERE
        sr."id" = ANY($1::uuid[])
        AND step_run_order IS NOT NULL
    GROUP BY
        sr."id"
)
SELECT
    DISTINCT ON (sr."id")
    sr."id" AS "SR_id",
    sr."createdAt" AS "SR_createdAt",
    sr."updatedAt" AS "SR_updatedAt",
    sr."deletedAt" AS "SR_deletedAt",
    sr."tenantId" AS "SR_tenantId",
    sr."queue" AS "SR_queue",
    sr."order" AS "SR_order",
    sqi."workerId" AS "SR_workerId",
    sr."tickerId" AS "SR_tickerId",
    sr."status" AS "SR_status",
    sr."requeueAfter" AS "SR_requeueAfter",
    sr."scheduleTimeoutAt" AS "SR_scheduleTimeoutAt",
    sr."startedAt" AS "SR_startedAt",
    sr."finishedAt" AS "SR_finishedAt",
    sr."timeoutAt" AS "SR_timeoutAt",
    sr."cancelledAt" AS "SR_cancelledAt",
    sr."cancelledReason" AS "SR_cancelledReason",
    sr."cancelledError" AS "SR_cancelledError",
    sr."callerFiles" AS "SR_callerFiles",
    sr."gitRepoBranch" AS "SR_gitRepoBranch",
    sr."retryCount" AS "SR_retryCount",
    sr."semaphoreReleased" AS "SR_semaphoreReleased",
    sr."priority" AS "SR_priority",
    COALESCE(cc."childCount", 0) AS "SR_childCount",
    -- TODO: everything below this line is cacheable and should be moved to a separate query
    jr."id" AS "jobRunId",
    s."id" AS "stepId",
    s."retries" AS "stepRetries",
    s."timeout" AS "stepTimeout",
    s."scheduleTimeout" AS "stepScheduleTimeout",
    s."readableId" AS "stepReadableId",
    s."customUserData" AS "stepCustomUserData",
    s."retryBackoffFactor" AS "stepRetryBackoffFactor",
    s."retryMaxBackoff" AS "stepRetryMaxBackoff",
    j."name" AS "jobName",
    j."id" AS "jobId",
    j."kind" AS "jobKind",
    j."workflowVersionId" AS "workflowVersionId",
    jr."status" AS "jobRunStatus",
    jr."workflowRunId" AS "workflowRunId",
    a."actionId" AS "actionId",
    sticky."strategy" AS "stickyStrategy",
    sticky."desiredWorkerId" AS "desiredWorkerId"
FROM
    "StepRun" sr
LEFT JOIN
    child_count cc ON sr."id" = cc."id"
JOIN
    "Step" s ON sr."stepId" = s."id"
JOIN
    "Action" a ON s."actionId" = a."actionId" AND s."tenantId" = a."tenantId"
JOIN
    "JobRun" jr ON sr."jobRunId" = jr."id"
JOIN
    "Job" j ON jr."jobId" = j."id"
LEFT JOIN
    "SemaphoreQueueItem" sqi ON sr."id" = sqi."stepRunId"
LEFT JOIN
    "WorkflowRunStickyState" sticky ON jr."workflowRunId" = sticky."workflowRunId"
WHERE
    sr."id" = ANY($1::uuid[]) AND
    sr."deletedAt" IS NULL AND
    jr."deletedAt" IS NULL AND
    (
        $2::uuid IS NULL OR
        sr."tenantId" = $2::uuid
    )
`

type GetStepRunForEngineParams struct {
	Ids      []pgtype.UUID `json:"ids"`
	TenantId pgtype.UUID   `json:"tenantId"`
}

type GetStepRunForEngineRow struct {
	SRID                   pgtype.UUID        `json:"SR_id"`
	SRCreatedAt            pgtype.Timestamp   `json:"SR_createdAt"`
	SRUpdatedAt            pgtype.Timestamp   `json:"SR_updatedAt"`
	SRDeletedAt            pgtype.Timestamp   `json:"SR_deletedAt"`
	SRTenantId             pgtype.UUID        `json:"SR_tenantId"`
	SRQueue                string             `json:"SR_queue"`
	SROrder                int64              `json:"SR_order"`
	SRWorkerId             pgtype.UUID        `json:"SR_workerId"`
	SRTickerId             pgtype.UUID        `json:"SR_tickerId"`
	SRStatus               StepRunStatus      `json:"SR_status"`
	SRRequeueAfter         pgtype.Timestamp   `json:"SR_requeueAfter"`
	SRScheduleTimeoutAt    pgtype.Timestamp   `json:"SR_scheduleTimeoutAt"`
	SRStartedAt            pgtype.Timestamp   `json:"SR_startedAt"`
	SRFinishedAt           pgtype.Timestamp   `json:"SR_finishedAt"`
	SRTimeoutAt            pgtype.Timestamp   `json:"SR_timeoutAt"`
	SRCancelledAt          pgtype.Timestamp   `json:"SR_cancelledAt"`
	SRCancelledReason      pgtype.Text        `json:"SR_cancelledReason"`
	SRCancelledError       pgtype.Text        `json:"SR_cancelledError"`
	SRCallerFiles          []byte             `json:"SR_callerFiles"`
	SRGitRepoBranch        pgtype.Text        `json:"SR_gitRepoBranch"`
	SRRetryCount           int32              `json:"SR_retryCount"`
	SRSemaphoreReleased    bool               `json:"SR_semaphoreReleased"`
	SRPriority             pgtype.Int4        `json:"SR_priority"`
	SRChildCount           int64              `json:"SR_childCount"`
	JobRunId               pgtype.UUID        `json:"jobRunId"`
	StepId                 pgtype.UUID        `json:"stepId"`
	StepRetries            int32              `json:"stepRetries"`
	StepTimeout            pgtype.Text        `json:"stepTimeout"`
	StepScheduleTimeout    string             `json:"stepScheduleTimeout"`
	StepReadableId         pgtype.Text        `json:"stepReadableId"`
	StepCustomUserData     []byte             `json:"stepCustomUserData"`
	StepRetryBackoffFactor pgtype.Float8      `json:"stepRetryBackoffFactor"`
	StepRetryMaxBackoff    pgtype.Int4        `json:"stepRetryMaxBackoff"`
	JobName                string             `json:"jobName"`
	JobId                  pgtype.UUID        `json:"jobId"`
	JobKind                JobKind            `json:"jobKind"`
	WorkflowVersionId      pgtype.UUID        `json:"workflowVersionId"`
	JobRunStatus           JobRunStatus       `json:"jobRunStatus"`
	WorkflowRunId          pgtype.UUID        `json:"workflowRunId"`
	ActionId               string             `json:"actionId"`
	StickyStrategy         NullStickyStrategy `json:"stickyStrategy"`
	DesiredWorkerId        pgtype.UUID        `json:"desiredWorkerId"`
}

func (q *Queries) GetStepRunForEngine(ctx context.Context, db DBTX, arg GetStepRunForEngineParams) ([]*GetStepRunForEngineRow, error) {
	rows, err := db.Query(ctx, getStepRunForEngine, arg.Ids, arg.TenantId)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetStepRunForEngineRow
	for rows.Next() {
		var i GetStepRunForEngineRow
		if err := rows.Scan(
			&i.SRID,
			&i.SRCreatedAt,
			&i.SRUpdatedAt,
			&i.SRDeletedAt,
			&i.SRTenantId,
			&i.SRQueue,
			&i.SROrder,
			&i.SRWorkerId,
			&i.SRTickerId,
			&i.SRStatus,
			&i.SRRequeueAfter,
			&i.SRScheduleTimeoutAt,
			&i.SRStartedAt,
			&i.SRFinishedAt,
			&i.SRTimeoutAt,
			&i.SRCancelledAt,
			&i.SRCancelledReason,
			&i.SRCancelledError,
			&i.SRCallerFiles,
			&i.SRGitRepoBranch,
			&i.SRRetryCount,
			&i.SRSemaphoreReleased,
			&i.SRPriority,
			&i.SRChildCount,
			&i.JobRunId,
			&i.StepId,
			&i.StepRetries,
			&i.StepTimeout,
			&i.StepScheduleTimeout,
			&i.StepReadableId,
			&i.StepCustomUserData,
			&i.StepRetryBackoffFactor,
			&i.StepRetryMaxBackoff,
			&i.JobName,
			&i.JobId,
			&i.JobKind,
			&i.WorkflowVersionId,
			&i.JobRunStatus,
			&i.WorkflowRunId,
			&i.ActionId,
			&i.StickyStrategy,
			&i.DesiredWorkerId,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStepRunMeta = `-- name: GetStepRunMeta :one
SELECT
    jr."workflowRunId" AS "workflowRunId",
    sr."retryCount" AS "retryCount",
    s."retries" as "retries"
FROM "StepRun" sr
JOIN "Step" s ON sr."stepId" = s."id"
JOIN "JobRun" jr ON sr."jobRunId" = jr."id"
WHERE sr."id" = $1::uuid
AND sr."tenantId" = $2::uuid
`

type GetStepRunMetaParams struct {
	Steprunid pgtype.UUID `json:"steprunid"`
	Tenantid  pgtype.UUID `json:"tenantid"`
}

type GetStepRunMetaRow struct {
	WorkflowRunId pgtype.UUID `json:"workflowRunId"`
	RetryCount    int32       `json:"retryCount"`
	Retries       int32       `json:"retries"`
}

func (q *Queries) GetStepRunMeta(ctx context.Context, db DBTX, arg GetStepRunMetaParams) (*GetStepRunMetaRow, error) {
	row := db.QueryRow(ctx, getStepRunMeta, arg.Steprunid, arg.Tenantid)
	var i GetStepRunMetaRow
	err := row.Scan(&i.WorkflowRunId, &i.RetryCount, &i.Retries)
	return &i, err
}

const getWorkerDispatcherActions = `-- name: GetWorkerDispatcherActions :many
WITH actions AS (
    SELECT
        "id",
        "actionId"
    FROM
        "Action"
    WHERE
        "tenantId" = $1::uuid AND
        "actionId" = ANY($2::text[])
)
SELECT
    w."id",
    a."actionId",
    w."dispatcherId"
FROM
    "Worker" w
JOIN
    "_ActionToWorker" atw ON w."id" = atw."B"
JOIN
    actions a ON atw."A" = a."id"
WHERE
    w."tenantId" = $1::uuid
    AND w."dispatcherId" IS NOT NULL
    AND w."lastHeartbeatAt" > NOW() - INTERVAL '5 seconds'
    AND w."isActive" = true
    AND w."isPaused" = false
`

type GetWorkerDispatcherActionsParams struct {
	Tenantid  pgtype.UUID `json:"tenantid"`
	Actionids []string    `json:"actionids"`
}

type GetWorkerDispatcherActionsRow struct {
	ID           pgtype.UUID `json:"id"`
	ActionId     string      `json:"actionId"`
	DispatcherId pgtype.UUID `json:"dispatcherId"`
}

func (q *Queries) GetWorkerDispatcherActions(ctx context.Context, db DBTX, arg GetWorkerDispatcherActionsParams) ([]*GetWorkerDispatcherActionsRow, error) {
	rows, err := db.Query(ctx, getWorkerDispatcherActions, arg.Tenantid, arg.Actionids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetWorkerDispatcherActionsRow
	for rows.Next() {
		var i GetWorkerDispatcherActionsRow
		if err := rows.Scan(&i.ID, &i.ActionId, &i.DispatcherId); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkerLabels = `-- name: GetWorkerLabels :many
SELECT
    "key",
    "strValue",
    "intValue"
FROM
    "WorkerLabel"
WHERE
    "workerId" = $1::uuid
`

type GetWorkerLabelsRow struct {
	Key      string      `json:"key"`
	StrValue pgtype.Text `json:"strValue"`
	IntValue pgtype.Int4 `json:"intValue"`
}

func (q *Queries) GetWorkerLabels(ctx context.Context, db DBTX, workerid pgtype.UUID) ([]*GetWorkerLabelsRow, error) {
	rows, err := db.Query(ctx, getWorkerLabels, workerid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetWorkerLabelsRow
	for rows.Next() {
		var i GetWorkerLabelsRow
		if err := rows.Scan(&i.Key, &i.StrValue, &i.IntValue); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasActiveWorkersForActionId = `-- name: HasActiveWorkersForActionId :one
SELECT
    COUNT(DISTINCT w."id") AS "total"
FROM
    "Worker" w
JOIN
    "_ActionToWorker" atw ON w."id" = atw."B"
JOIN
    "Action" a ON atw."A" = a."id"
WHERE
    w."tenantId" = $1::uuid
    AND a."actionId" = $2::text
    AND w."isActive" = true
    AND w."lastHeartbeatAt" > NOW() - INTERVAL '6 seconds'
`

type HasActiveWorkersForActionIdParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Actionid string      `json:"actionid"`
}

func (q *Queries) HasActiveWorkersForActionId(ctx context.Context, db DBTX, arg HasActiveWorkersForActionIdParams) (int64, error) {
	row := db.QueryRow(ctx, hasActiveWorkersForActionId, arg.Tenantid, arg.Actionid)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const internalRetryStepRuns = `-- name: InternalRetryStepRuns :many
WITH step_runs AS (
    SELECT
        sr."id",
        sr."tenantId",
        sr."scheduleTimeoutAt",
        sr."retryCount",
        sr."internalRetryCount",
        s."actionId",
        s."id" AS "stepId",
        s."timeout" AS "stepTimeout",
        s."scheduleTimeout" AS "scheduleTimeout"
    FROM
        "StepRun" sr
    JOIN
        "Step" s ON sr."stepId" = s."id"
    WHERE
        sr."tenantId" = $1::uuid
        AND sr."id" = ANY($2::uuid[])
),
step_runs_to_reassign AS (
    SELECT
        id, "tenantId", "scheduleTimeoutAt", "retryCount", "internalRetryCount", "actionId", "stepId", "stepTimeout", "scheduleTimeout"
    FROM
        step_runs
    WHERE
        "internalRetryCount" < $3::int
),
step_runs_to_fail AS (
    SELECT
        id, "tenantId", "scheduleTimeoutAt", "retryCount", "internalRetryCount", "actionId", "stepId", "stepTimeout", "scheduleTimeout"
    FROM
        step_runs
    WHERE
        "internalRetryCount" >= $3::int
),
deleted_sqis AS (
    DELETE FROM
        "SemaphoreQueueItem" sqi
    USING
        step_runs srs
    WHERE
        sqi."stepRunId" = srs."id"
),
deleted_tqis AS (
    DELETE FROM
        "TimeoutQueueItem" tqi
    -- delete when step run id AND retry count tuples match
    USING
        step_runs srs
    WHERE
        tqi."stepRunId" = srs."id"
        AND tqi."retryCount" = srs."retryCount"
),
inserted_queue_items AS (
    INSERT INTO "QueueItem" (
        "stepRunId",
        "stepId",
        "actionId",
        "scheduleTimeoutAt",
        "stepTimeout",
        "priority",
        "isQueued",
        "tenantId",
        "queue"
    )
    SELECT
        srs."id",
        srs."stepId",
        srs."actionId",
        CURRENT_TIMESTAMP + COALESCE(convert_duration_to_interval(srs."scheduleTimeout"), INTERVAL '5 minutes'),
        srs."stepTimeout",
        -- Queue with priority 4 so that reassignment gets highest priority
        4,
        true,
        srs."tenantId",
        srs."actionId"
    FROM
        step_runs_to_reassign srs
),
updated_step_runs AS (
    UPDATE "StepRun" sr
    SET
        "status" = 'PENDING_ASSIGNMENT',
        "scheduleTimeoutAt" = CURRENT_TIMESTAMP + COALESCE(convert_duration_to_interval(srs."scheduleTimeout"), INTERVAL '5 minutes'),
        "updatedAt" = CURRENT_TIMESTAMP,
        "internalRetryCount" = sr."internalRetryCount" + 1
    FROM step_runs_to_reassign srs
    WHERE sr."id" = srs."id"
    RETURNING sr."id"
)
SELECT
    srs1."id",
    srs1."retryCount",
    'REASSIGNED' AS "operation"
FROM
    step_runs_to_reassign srs1
UNION ALL
SELECT
    srs2."id",
    srs2."retryCount",
    'FAILED' AS "operation"
FROM
    step_runs_to_fail srs2
`

type InternalRetryStepRunsParams struct {
	Tenantid              pgtype.UUID   `json:"tenantid"`
	Steprunids            []pgtype.UUID `json:"steprunids"`
	Maxinternalretrycount int32         `json:"maxinternalretrycount"`
}

type InternalRetryStepRunsRow struct {
	ID         pgtype.UUID `json:"id"`
	RetryCount int32       `json:"retryCount"`
	Operation  string      `json:"operation"`
}

func (q *Queries) InternalRetryStepRuns(ctx context.Context, db DBTX, arg InternalRetryStepRunsParams) ([]*InternalRetryStepRunsRow, error) {
	rows, err := db.Query(ctx, internalRetryStepRuns, arg.Tenantid, arg.Steprunids, arg.Maxinternalretrycount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*InternalRetryStepRunsRow
	for rows.Next() {
		var i InternalRetryStepRunsRow
		if err := rows.Scan(&i.ID, &i.RetryCount, &i.Operation); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChildWorkflowRunIds = `-- name: ListChildWorkflowRunIds :many
SELECT
    "id"
FROM
    "WorkflowRun"
WHERE
    "parentStepRunId" = $1::uuid
    AND "tenantId" = $2::uuid
    AND "deletedAt" IS NULL
`

type ListChildWorkflowRunIdsParams struct {
	Steprun  pgtype.UUID `json:"steprun"`
	Tenantid pgtype.UUID `json:"tenantid"`
}

func (q *Queries) ListChildWorkflowRunIds(ctx context.Context, db DBTX, arg ListChildWorkflowRunIdsParams) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, listChildWorkflowRunIds, arg.Steprun, arg.Tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInitialStepRuns = `-- name: ListInitialStepRuns :many
SELECT
    DISTINCT ON (child_run."id")
    child_run."id" AS "id"
FROM
    "StepRun" AS child_run
LEFT JOIN
    "_StepRunOrder" AS step_run_order ON step_run_order."B" = child_run."id"
WHERE
    child_run."jobRunId" = $1::uuid
    AND (
        child_run."status" = 'PENDING' OR
        child_run."status" = 'BACKOFF'
    )
    AND step_run_order."A" IS NULL
`

func (q *Queries) ListInitialStepRuns(ctx context.Context, db DBTX, jobrunid pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, listInitialStepRuns, jobrunid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNonFinalChildStepRuns = `-- name: ListNonFinalChildStepRuns :many
WITH RECURSIVE currStepRun AS (
    SELECT id, "createdAt", "updatedAt", "deletedAt", "tenantId", "jobRunId", "stepId", "order", "workerId", "tickerId", status, input, output, "requeueAfter", "scheduleTimeoutAt", error, "startedAt", "finishedAt", "timeoutAt", "cancelledAt", "cancelledReason", "cancelledError", "inputSchema", "callerFiles", "gitRepoBranch", "retryCount", "semaphoreReleased", queue, priority, "internalRetryCount"
    FROM "StepRun"
    WHERE
        "id" = $1::uuid
), childStepRuns AS (
    SELECT sr."id", sr."status"
    FROM "StepRun" sr
    JOIN "_StepRunOrder" sro ON sr."id" = sro."B"
    WHERE sro."A" = (SELECT "id" FROM currStepRun)
        AND sr."deletedAt" IS NULL

    UNION ALL

    SELECT sr."id", sr."status"
    FROM "StepRun" sr
    JOIN "_StepRunOrder" sro ON sr."id" = sro."B"
    JOIN childStepRuns csr ON sro."A" = csr."id"
)
SELECT
    sr.id, sr."createdAt", sr."updatedAt", sr."deletedAt", sr."tenantId", sr."jobRunId", sr."stepId", sr."order", sr."workerId", sr."tickerId", sr.status, sr.input, sr.output, sr."requeueAfter", sr."scheduleTimeoutAt", sr.error, sr."startedAt", sr."finishedAt", sr."timeoutAt", sr."cancelledAt", sr."cancelledReason", sr."cancelledError", sr."inputSchema", sr."callerFiles", sr."gitRepoBranch", sr."retryCount", sr."semaphoreReleased", sr.queue, sr.priority, sr."internalRetryCount"
FROM
    "StepRun" sr
JOIN
    childStepRuns csr ON sr."id" = csr."id"
WHERE
    sr."deletedAt" IS NULL AND
    sr."status" NOT IN ('SUCCEEDED', 'FAILED', 'CANCELLED')
`

// Select all child step runs that are not in a final state
func (q *Queries) ListNonFinalChildStepRuns(ctx context.Context, db DBTX, steprunid pgtype.UUID) ([]*StepRun, error) {
	rows, err := db.Query(ctx, listNonFinalChildStepRuns, steprunid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepRun
	for rows.Next() {
		var i StepRun
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TenantId,
			&i.JobRunId,
			&i.StepId,
			&i.Order,
			&i.WorkerId,
			&i.TickerId,
			&i.Status,
			&i.Input,
			&i.Output,
			&i.RequeueAfter,
			&i.ScheduleTimeoutAt,
			&i.Error,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TimeoutAt,
			&i.CancelledAt,
			&i.CancelledReason,
			&i.CancelledError,
			&i.InputSchema,
			&i.CallerFiles,
			&i.GitRepoBranch,
			&i.RetryCount,
			&i.SemaphoreReleased,
			&i.Queue,
			&i.Priority,
			&i.InternalRetryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStartableStepRunsManyParents = `-- name: ListStartableStepRunsManyParents :many
SELECT
    DISTINCT ON (child_run."id")
    child_run."id" AS "id"
FROM
    "StepRun" AS parent_run
LEFT JOIN
    "_StepRunOrder" AS step_run_order ON step_run_order."A" = parent_run."id"
JOIN
    "StepRun" AS child_run ON step_run_order."B" = child_run."id"
WHERE
    parent_run."id" = $1::uuid
    AND (
        child_run."status" = 'PENDING' OR
        child_run."status" = 'BACKOFF'
    )
    -- we look for whether the step run is startable by ensuring that all parent step runs have succeeded
    AND NOT EXISTS (
        SELECT 1
        FROM "_StepRunOrder" AS parent_order
        JOIN "StepRun" AS parent_run ON parent_order."A" = parent_run."id"
        WHERE
            parent_order."B" = child_run."id"
            AND parent_run."status" != 'SUCCEEDED'
    )
    -- AND we ensure that there's at least 2 parent step runs
    AND EXISTS (
        SELECT 1
        FROM "_StepRunOrder" AS parent_order
        JOIN "StepRun" AS parent_run ON parent_order."A" = parent_run."id"
        WHERE
            parent_order."B" = child_run."id"
        OFFSET 1
    )
`

func (q *Queries) ListStartableStepRunsManyParents(ctx context.Context, db DBTX, parentsteprunid pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, listStartableStepRunsManyParents, parentsteprunid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStartableStepRunsSingleParent = `-- name: ListStartableStepRunsSingleParent :many
SELECT
    DISTINCT ON (child_run."id")
    child_run."id" AS "id"
FROM
    "StepRun" AS parent_run
LEFT JOIN
    "_StepRunOrder" AS step_run_order ON step_run_order."A" = parent_run."id"
JOIN
    "StepRun" AS child_run ON step_run_order."B" = child_run."id"
WHERE
    parent_run."id" = $1::uuid
    AND (
        child_run."status" = 'PENDING' OR
        child_run."status" = 'BACKOFF'
    )
    -- we look for whether the step run is startable ASSUMING that parentStepRunId has succeeded,
    -- but we only have one parent step run
    AND NOT EXISTS (
        SELECT 1
        FROM "_StepRunOrder" AS parent_order
        JOIN "StepRun" AS parent_run ON parent_order."A" = parent_run."id"
        WHERE
            parent_order."B" = child_run."id"
            AND parent_run."id" != $1::uuid
    )
`

func (q *Queries) ListStartableStepRunsSingleParent(ctx context.Context, db DBTX, parentsteprunid pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, listStartableStepRunsSingleParent, parentsteprunid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepRunArchives = `-- name: ListStepRunArchives :many
SELECT
    "StepRunResultArchive".id, "StepRunResultArchive"."createdAt", "StepRunResultArchive"."updatedAt", "StepRunResultArchive"."deletedAt", "StepRunResultArchive"."stepRunId", "StepRunResultArchive"."order", "StepRunResultArchive".input, "StepRunResultArchive".output, "StepRunResultArchive".error, "StepRunResultArchive"."startedAt", "StepRunResultArchive"."finishedAt", "StepRunResultArchive"."timeoutAt", "StepRunResultArchive"."cancelledAt", "StepRunResultArchive"."cancelledReason", "StepRunResultArchive"."cancelledError", "StepRunResultArchive"."retryCount"
FROM
    "StepRunResultArchive"
JOIN
    "StepRun" ON "StepRunResultArchive"."stepRunId" = "StepRun"."id"
WHERE
    "StepRunResultArchive"."stepRunId" = $1::uuid AND
    "StepRun"."tenantId" = $2::uuid AND
    "StepRun"."deletedAt" IS NULL
ORDER BY
    "StepRunResultArchive"."createdAt" DESC
OFFSET
    COALESCE($3, 0)
LIMIT
    COALESCE($4, 50)
`

type ListStepRunArchivesParams struct {
	Steprunid pgtype.UUID `json:"steprunid"`
	Tenantid  pgtype.UUID `json:"tenantid"`
	Offset    interface{} `json:"offset"`
	Limit     interface{} `json:"limit"`
}

func (q *Queries) ListStepRunArchives(ctx context.Context, db DBTX, arg ListStepRunArchivesParams) ([]*StepRunResultArchive, error) {
	rows, err := db.Query(ctx, listStepRunArchives,
		arg.Steprunid,
		arg.Tenantid,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepRunResultArchive
	for rows.Next() {
		var i StepRunResultArchive
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.StepRunId,
			&i.Order,
			&i.Input,
			&i.Output,
			&i.Error,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TimeoutAt,
			&i.CancelledAt,
			&i.CancelledReason,
			&i.CancelledError,
			&i.RetryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepRunEvents = `-- name: ListStepRunEvents :many
SELECT
    id, "timeFirstSeen", "timeLastSeen", "stepRunId", reason, severity, message, count, data, "workflowRunId"
FROM
    "StepRunEvent"
WHERE
    "stepRunId" = $1::uuid
ORDER BY
    "id" DESC
OFFSET
    COALESCE($2, 0)
LIMIT
    COALESCE($3, 50)
`

type ListStepRunEventsParams struct {
	Steprunid pgtype.UUID `json:"steprunid"`
	Offset    interface{} `json:"offset"`
	Limit     interface{} `json:"limit"`
}

func (q *Queries) ListStepRunEvents(ctx context.Context, db DBTX, arg ListStepRunEventsParams) ([]*StepRunEvent, error) {
	rows, err := db.Query(ctx, listStepRunEvents, arg.Steprunid, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepRunEvent
	for rows.Next() {
		var i StepRunEvent
		if err := rows.Scan(
			&i.ID,
			&i.TimeFirstSeen,
			&i.TimeLastSeen,
			&i.StepRunId,
			&i.Reason,
			&i.Severity,
			&i.Message,
			&i.Count,
			&i.Data,
			&i.WorkflowRunId,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepRunEventsByWorkflowRunId = `-- name: ListStepRunEventsByWorkflowRunId :many
SELECT
    sre.id, sre."timeFirstSeen", sre."timeLastSeen", sre."stepRunId", sre.reason, sre.severity, sre.message, sre.count, sre.data, sre."workflowRunId"
FROM
    "StepRunEvent" sre
JOIN
    "StepRun" sr ON sr."id" = sre."stepRunId"
JOIN
    "JobRun" jr ON jr."id" = sr."jobRunId"
WHERE
    jr."workflowRunId" = $1::uuid
    AND jr."tenantId" = $2::uuid
    AND sre."id" > COALESCE($3, 0)
    -- / TODO ID > Last ID
ORDER BY
    sre."id" DESC
`

type ListStepRunEventsByWorkflowRunIdParams struct {
	Workflowrunid pgtype.UUID `json:"workflowrunid"`
	Tenantid      pgtype.UUID `json:"tenantid"`
	LastId        pgtype.Int8 `json:"lastId"`
}

func (q *Queries) ListStepRunEventsByWorkflowRunId(ctx context.Context, db DBTX, arg ListStepRunEventsByWorkflowRunIdParams) ([]*StepRunEvent, error) {
	rows, err := db.Query(ctx, listStepRunEventsByWorkflowRunId, arg.Workflowrunid, arg.Tenantid, arg.LastId)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepRunEvent
	for rows.Next() {
		var i StepRunEvent
		if err := rows.Scan(
			&i.ID,
			&i.TimeFirstSeen,
			&i.TimeLastSeen,
			&i.StepRunId,
			&i.Reason,
			&i.Severity,
			&i.Message,
			&i.Count,
			&i.Data,
			&i.WorkflowRunId,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepRunExpressionEvals = `-- name: ListStepRunExpressionEvals :many
SELECT
    key, "stepRunId", "valueStr", "valueInt", kind
FROM
    "StepRunExpressionEval" sre
WHERE
    "stepRunId" = ANY($1::uuid[])
`

func (q *Queries) ListStepRunExpressionEvals(ctx context.Context, db DBTX, steprunids []pgtype.UUID) ([]*StepRunExpressionEval, error) {
	rows, err := db.Query(ctx, listStepRunExpressionEvals, steprunids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepRunExpressionEval
	for rows.Next() {
		var i StepRunExpressionEval
		if err := rows.Scan(
			&i.Key,
			&i.StepRunId,
			&i.ValueStr,
			&i.ValueInt,
			&i.Kind,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepRuns = `-- name: ListStepRuns :many
SELECT
    DISTINCT ON ("StepRun"."order","StepRun"."id")
    "StepRun"."id"
FROM
    "StepRun"
JOIN
    "JobRun" ON "StepRun"."jobRunId" = "JobRun"."id"
WHERE
    "StepRun"."deletedAt" IS NULL AND
    "JobRun"."deletedAt" IS NULL AND
    (
        $1::uuid IS NULL OR
        "StepRun"."tenantId" = $1::uuid
    )
    AND (
        $2::"StepRunStatus" IS NULL OR
        "StepRun"."status" = $2::"StepRunStatus"
    )
    AND (
        $3::uuid[] IS NULL OR
        "JobRun"."workflowRunId" = ANY($3::uuid[])
    )
    AND (
        $4::uuid IS NULL OR
        "StepRun"."jobRunId" = $4::uuid
    )
    AND (
        $5::uuid IS NULL OR
        "StepRun"."tickerId" = $5::uuid
    )

ORDER BY "StepRun"."order" ASC
`

type ListStepRunsParams struct {
	TenantId       pgtype.UUID       `json:"tenantId"`
	Status         NullStepRunStatus `json:"status"`
	WorkflowRunIds []pgtype.UUID     `json:"workflowRunIds"`
	JobRunId       pgtype.UUID       `json:"jobRunId"`
	TickerId       pgtype.UUID       `json:"tickerId"`
}

func (q *Queries) ListStepRuns(ctx context.Context, db DBTX, arg ListStepRunsParams) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, listStepRuns,
		arg.TenantId,
		arg.Status,
		arg.WorkflowRunIds,
		arg.JobRunId,
		arg.TickerId,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepRunsToCancel = `-- name: ListStepRunsToCancel :many
SELECT
    DISTINCT ON ("StepRun"."id")
    "StepRun"."id"
FROM
    "StepRun"
JOIN
    "JobRun" ON "StepRun"."jobRunId" = "JobRun"."id"
WHERE
    "StepRun"."deletedAt" IS NULL AND
    "JobRun"."deletedAt" IS NULL AND
    "StepRun"."tenantId" = $1::uuid AND
    "StepRun"."jobRunId" = $2::uuid AND
    "StepRun"."status" = ANY(ARRAY['PENDING', 'PENDING_ASSIGNMENT', 'ASSIGNED', 'RUNNING', 'CANCELLING', 'BACKOFF']::"StepRunStatus"[])
`

type ListStepRunsToCancelParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Jobrunid pgtype.UUID `json:"jobrunid"`
}

func (q *Queries) ListStepRunsToCancel(ctx context.Context, db DBTX, arg ListStepRunsToCancelParams) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, listStepRunsToCancel, arg.Tenantid, arg.Jobrunid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepRunsToReassign = `-- name: ListStepRunsToReassign :many
WITH step_runs_on_inactive_workers AS (
    SELECT
        sr."id",
        sr."tenantId",
        sr."scheduleTimeoutAt",
        sr."retryCount",
        sr."internalRetryCount",
        sqi."workerId",
        s."actionId",
        s."id" AS "stepId",
        s."timeout" AS "stepTimeout",
        s."scheduleTimeout" AS "scheduleTimeout"
    FROM
        "Worker" w
    LEFT JOIN
        "SemaphoreQueueItem" sqi ON w."id" = sqi."workerId"
    JOIN
        "StepRun" sr ON sr."id" = sqi."stepRunId"
    JOIN
        "Step" s ON sr."stepId" = s."id"
    WHERE
        w."tenantId" = $1::uuid
        AND w."lastHeartbeatAt" < NOW() - INTERVAL '30 seconds'),
step_runs_to_reassign AS (
    SELECT
        id, "tenantId", "scheduleTimeoutAt", "retryCount", "internalRetryCount", "workerId", "actionId", "stepId", "stepTimeout", "scheduleTimeout"
    FROM
        step_runs_on_inactive_workers
    WHERE
        "internalRetryCount" < $2::int
),
step_runs_to_fail AS (
    SELECT
        id, "tenantId", "scheduleTimeoutAt", "retryCount", "internalRetryCount", "workerId", "actionId", "stepId", "stepTimeout", "scheduleTimeout"
    FROM
        step_runs_on_inactive_workers
    WHERE
        "internalRetryCount" >= $2::int
),
deleted_sqis AS (
    DELETE FROM
        "SemaphoreQueueItem" sqi
    -- delete when step run id AND worker id tuples match
    USING
        step_runs_on_inactive_workers srs
    WHERE
        sqi."stepRunId" = srs."id"
        AND sqi."workerId" = srs."workerId"
),
deleted_tqis AS (
    DELETE FROM
        "TimeoutQueueItem" tqi
    -- delete when step run id AND retry count tuples match
    USING
        step_runs_on_inactive_workers srs
    WHERE
        tqi."stepRunId" = srs."id"
        AND tqi."retryCount" = srs."retryCount"
),
inserted_queue_items AS (
    INSERT INTO "QueueItem" (
        "stepRunId",
        "stepId",
        "actionId",
        "scheduleTimeoutAt",
        "stepTimeout",
        "priority",
        "isQueued",
        "tenantId",
        "queue"
    )
    SELECT
        srs."id",
        srs."stepId",
        srs."actionId",
        CURRENT_TIMESTAMP + COALESCE(convert_duration_to_interval(srs."scheduleTimeout"), INTERVAL '5 minutes'),
        srs."stepTimeout",
        -- Queue with priority 4 so that reassignment gets highest priority
        4,
        true,
        srs."tenantId",
        srs."actionId"
    FROM
        step_runs_to_reassign srs
),
updated_step_runs AS (
    UPDATE "StepRun" sr
    SET
        "status" = 'PENDING_ASSIGNMENT',
        "scheduleTimeoutAt" = CURRENT_TIMESTAMP + COALESCE(convert_duration_to_interval(srs."scheduleTimeout"), INTERVAL '5 minutes'),
        "updatedAt" = CURRENT_TIMESTAMP,
        "internalRetryCount" = sr."internalRetryCount" + 1
    FROM step_runs_to_reassign srs
    WHERE sr."id" = srs."id"
    RETURNING sr."id"
)
SELECT
    srs1."id",
    srs1."workerId",
    srs1."retryCount",
    'REASSIGNED' AS "operation"
FROM
    step_runs_to_reassign srs1
UNION ALL
SELECT
    srs2."id",
    srs2."workerId",
    srs2."retryCount",
    'FAILED' AS "operation"
FROM
    step_runs_to_fail srs2
`

type ListStepRunsToReassignParams struct {
	Tenantid              pgtype.UUID `json:"tenantid"`
	Maxinternalretrycount int32       `json:"maxinternalretrycount"`
}

type ListStepRunsToReassignRow struct {
	ID         pgtype.UUID `json:"id"`
	WorkerId   pgtype.UUID `json:"workerId"`
	RetryCount int32       `json:"retryCount"`
	Operation  string      `json:"operation"`
}

func (q *Queries) ListStepRunsToReassign(ctx context.Context, db DBTX, arg ListStepRunsToReassignParams) ([]*ListStepRunsToReassignRow, error) {
	rows, err := db.Query(ctx, listStepRunsToReassign, arg.Tenantid, arg.Maxinternalretrycount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListStepRunsToReassignRow
	for rows.Next() {
		var i ListStepRunsToReassignRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkerId,
			&i.RetryCount,
			&i.Operation,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepRunsToTimeout = `-- name: ListStepRunsToTimeout :many
SELECT "id"
FROM "StepRun"
WHERE
    "status" = ANY(ARRAY['RUNNING', 'ASSIGNED']::"StepRunStatus"[])
    AND "timeoutAt" < NOW()
    AND "tenantId" = $1::uuid
LIMIT 100
`

func (q *Queries) ListStepRunsToTimeout(ctx context.Context, db DBTX, tenantid pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, listStepRunsToTimeout, tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const manualReleaseSemaphore = `-- name: ManualReleaseSemaphore :exec
UPDATE
    "StepRun"
SET
    -- note that workerId has already been removed via SemaphoreQueueItem
    "semaphoreReleased" = true
WHERE
    "id" = $1::uuid AND
    "tenantId" = $2::uuid
`

type ManualReleaseSemaphoreParams struct {
	Steprunid pgtype.UUID `json:"steprunid"`
	Tenantid  pgtype.UUID `json:"tenantid"`
}

func (q *Queries) ManualReleaseSemaphore(ctx context.Context, db DBTX, arg ManualReleaseSemaphoreParams) error {
	_, err := db.Exec(ctx, manualReleaseSemaphore, arg.Steprunid, arg.Tenantid)
	return err
}

const queueStepRun = `-- name: QueueStepRun :exec
UPDATE
    "StepRun"
SET
    "finishedAt" = NULL,
    "status" = 'PENDING_ASSIGNMENT',
    "input" = COALESCE($1::jsonb, "input"),
    "output" = NULL,
    "error" = NULL,
    "cancelledAt" = NULL,
    "cancelledReason" = NULL,
    "retryCount" = CASE
        WHEN $2::boolean IS NOT NULL THEN "retryCount" + 1
        ELSE "retryCount"
    END,
    "semaphoreReleased" = false
WHERE
  "id" = $3::uuid AND
  "tenantId" = $4::uuid
`

type QueueStepRunParams struct {
	Input    []byte      `json:"input"`
	IsRetry  pgtype.Bool `json:"isRetry"`
	ID       pgtype.UUID `json:"id"`
	Tenantid pgtype.UUID `json:"tenantid"`
}

func (q *Queries) QueueStepRun(ctx context.Context, db DBTX, arg QueueStepRunParams) error {
	_, err := db.Exec(ctx, queueStepRun,
		arg.Input,
		arg.IsRetry,
		arg.ID,
		arg.Tenantid,
	)
	return err
}

const queueStepRunBulkNoInput = `-- name: QueueStepRunBulkNoInput :exec
WITH input AS (
    SELECT
        unnest($1::uuid[]) AS "id",
        unnest($2::int[]) AS "retryCount"
)
UPDATE
    "StepRun" sr
SET
    "finishedAt" = NULL,
    "status" = 'PENDING_ASSIGNMENT',
    "output" = NULL,
    "error" = NULL,
    "cancelledAt" = NULL,
    "cancelledReason" = NULL,
    "retryCount" = input."retryCount",
    "semaphoreReleased" = false
FROM
    input
WHERE
    sr."id" = input."id"
`

type QueueStepRunBulkNoInputParams struct {
	Ids         []pgtype.UUID `json:"ids"`
	Retrycounts []int32       `json:"retrycounts"`
}

func (q *Queries) QueueStepRunBulkNoInput(ctx context.Context, db DBTX, arg QueueStepRunBulkNoInputParams) error {
	_, err := db.Exec(ctx, queueStepRunBulkNoInput, arg.Ids, arg.Retrycounts)
	return err
}

const queueStepRunBulkWithInput = `-- name: QueueStepRunBulkWithInput :exec
WITH input AS (
    SELECT
        unnest($1::uuid[]) AS "id",
        unnest($2::jsonb[]) AS "input",
        unnest($3::int[]) AS "retryCount"
)
UPDATE
    "StepRun" sr
SET
    "finishedAt" = NULL,
    "status" = 'PENDING_ASSIGNMENT',
    "input" = COALESCE(input."input", sr."input"),
    "output" = NULL,
    "error" = NULL,
    "cancelledAt" = NULL,
    "cancelledReason" = NULL,
    "retryCount" = input."retryCount",
    "semaphoreReleased" = false
FROM
    input
WHERE
    sr."id" = input."id"
`

type QueueStepRunBulkWithInputParams struct {
	Ids         []pgtype.UUID `json:"ids"`
	Inputs      [][]byte      `json:"inputs"`
	Retrycounts []int32       `json:"retrycounts"`
}

func (q *Queries) QueueStepRunBulkWithInput(ctx context.Context, db DBTX, arg QueueStepRunBulkWithInputParams) error {
	_, err := db.Exec(ctx, queueStepRunBulkWithInput, arg.Ids, arg.Inputs, arg.Retrycounts)
	return err
}

const refreshTimeoutBy = `-- name: RefreshTimeoutBy :one
WITH step_run AS (
    SELECT
        "id",
        "retryCount",
        "tenantId"
    FROM
        "StepRun"
    WHERE
        "id" = $2::uuid AND
        "tenantId" = $3::uuid
)
INSERT INTO
    "TimeoutQueueItem" (
        "stepRunId",
        "retryCount",
        "timeoutAt",
        "tenantId",
        "isQueued"
    )
SELECT
    sr."id",
    sr."retryCount",
    NOW() + convert_duration_to_interval($1::text),
    sr."tenantId",
    true
FROM
    step_run sr
ON CONFLICT ("stepRunId", "retryCount") DO UPDATE
SET
    "timeoutAt" = "TimeoutQueueItem"."timeoutAt" + convert_duration_to_interval($1::text)
RETURNING "TimeoutQueueItem"."timeoutAt"
`

type RefreshTimeoutByParams struct {
	IncrementTimeoutBy pgtype.Text `json:"incrementTimeoutBy"`
	Steprunid          pgtype.UUID `json:"steprunid"`
	Tenantid           pgtype.UUID `json:"tenantid"`
}

func (q *Queries) RefreshTimeoutBy(ctx context.Context, db DBTX, arg RefreshTimeoutByParams) (pgtype.Timestamp, error) {
	row := db.QueryRow(ctx, refreshTimeoutBy, arg.IncrementTimeoutBy, arg.Steprunid, arg.Tenantid)
	var timeoutAt pgtype.Timestamp
	err := row.Scan(&timeoutAt)
	return timeoutAt, err
}

const removeTimeoutQueueItems = `-- name: RemoveTimeoutQueueItems :exec
DELETE FROM
    "TimeoutQueueItem"
WHERE
    "stepRunId" = ANY($1::uuid[])
`

func (q *Queries) RemoveTimeoutQueueItems(ctx context.Context, db DBTX, steprunids []pgtype.UUID) error {
	_, err := db.Exec(ctx, removeTimeoutQueueItems, steprunids)
	return err
}

const replayStepRunResetJobRun = `-- name: ReplayStepRunResetJobRun :one
UPDATE
    "JobRun"
SET
    "status" = 'RUNNING',
    "updatedAt" = CURRENT_TIMESTAMP,
    "startedAt" = NULL,
    "finishedAt" = NULL,
    "timeoutAt" = NULL,
    "cancelledAt" = NULL,
    "cancelledReason" = NULL,
    "cancelledError" = NULL
WHERE
    "id" = $1::uuid
RETURNING id, "createdAt", "updatedAt", "deletedAt", "tenantId", "jobId", "tickerId", status, result, "startedAt", "finishedAt", "timeoutAt", "cancelledAt", "cancelledReason", "cancelledError", "workflowRunId"
`

func (q *Queries) ReplayStepRunResetJobRun(ctx context.Context, db DBTX, jobrunid pgtype.UUID) (*JobRun, error) {
	row := db.QueryRow(ctx, replayStepRunResetJobRun, jobrunid)
	var i JobRun
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.JobId,
		&i.TickerId,
		&i.Status,
		&i.Result,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TimeoutAt,
		&i.CancelledAt,
		&i.CancelledReason,
		&i.CancelledError,
		&i.WorkflowRunId,
	)
	return &i, err
}

const replayStepRunResetStepRuns = `-- name: ReplayStepRunResetStepRuns :many
WITH RECURSIVE currStepRun AS (
    SELECT id, "createdAt", "updatedAt", "deletedAt", "tenantId", "jobRunId", "stepId", "order", "workerId", "tickerId", status, input, output, "requeueAfter", "scheduleTimeoutAt", error, "startedAt", "finishedAt", "timeoutAt", "cancelledAt", "cancelledReason", "cancelledError", "inputSchema", "callerFiles", "gitRepoBranch", "retryCount", "semaphoreReleased", queue, priority, "internalRetryCount"
    FROM "StepRun"
    WHERE
        "id" = $1::uuid
), childStepRuns AS (
    SELECT sr."id", sr."status"
    FROM "StepRun" sr
    JOIN "_StepRunOrder" sro ON sr."id" = sro."B"
    WHERE sro."A" = (SELECT "id" FROM currStepRun)

    UNION ALL

    SELECT sr."id", sr."status"
    FROM "StepRun" sr
    JOIN "_StepRunOrder" sro ON sr."id" = sro."B"
    JOIN childStepRuns csr ON sro."A" = csr."id"
)
UPDATE
    "StepRun" as sr
SET
    "status" = 'PENDING',
    "scheduleTimeoutAt" = NULL,
    "finishedAt" = NULL,
    "startedAt" = NULL,
    "output" = NULL,
    "error" = NULL,
    "cancelledAt" = NULL,
    "cancelledReason" = NULL,
    "input" = CASE
        WHEN sr."id" = $1::uuid THEN COALESCE($2::jsonb, "input")
        ELSE NULL
    END,
    "retryCount" = 0
FROM
    childStepRuns csr
WHERE
    sr."id" = csr."id" OR
    sr."id" = $1::uuid
RETURNING sr.id, sr."createdAt", sr."updatedAt", sr."deletedAt", sr."tenantId", sr."jobRunId", sr."stepId", sr."order", sr."workerId", sr."tickerId", sr.status, sr.input, sr.output, sr."requeueAfter", sr."scheduleTimeoutAt", sr.error, sr."startedAt", sr."finishedAt", sr."timeoutAt", sr."cancelledAt", sr."cancelledReason", sr."cancelledError", sr."inputSchema", sr."callerFiles", sr."gitRepoBranch", sr."retryCount", sr."semaphoreReleased", sr.queue, sr.priority, sr."internalRetryCount"
`

type ReplayStepRunResetStepRunsParams struct {
	Steprunid pgtype.UUID `json:"steprunid"`
	Input     []byte      `json:"input"`
}

func (q *Queries) ReplayStepRunResetStepRuns(ctx context.Context, db DBTX, arg ReplayStepRunResetStepRunsParams) ([]*StepRun, error) {
	rows, err := db.Query(ctx, replayStepRunResetStepRuns, arg.Steprunid, arg.Input)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepRun
	for rows.Next() {
		var i StepRun
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TenantId,
			&i.JobRunId,
			&i.StepId,
			&i.Order,
			&i.WorkerId,
			&i.TickerId,
			&i.Status,
			&i.Input,
			&i.Output,
			&i.RequeueAfter,
			&i.ScheduleTimeoutAt,
			&i.Error,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TimeoutAt,
			&i.CancelledAt,
			&i.CancelledReason,
			&i.CancelledError,
			&i.InputSchema,
			&i.CallerFiles,
			&i.GitRepoBranch,
			&i.RetryCount,
			&i.SemaphoreReleased,
			&i.Queue,
			&i.Priority,
			&i.InternalRetryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const replayStepRunResetWorkflowRun = `-- name: ReplayStepRunResetWorkflowRun :one
UPDATE
    "WorkflowRun"
SET
    "status" = 'PENDING',
    "updatedAt" = CURRENT_TIMESTAMP,
    "startedAt" = NULL,
    "finishedAt" = NULL,
    "duration" = NULL,
    "concurrencyGroupId" = NULL,
    "error" = NULL
WHERE
    "id" =  $1::uuid
RETURNING "createdAt", "updatedAt", "deletedAt", "tenantId", "workflowVersionId", status, error, "startedAt", "finishedAt", "concurrencyGroupId", "displayName", id, "childIndex", "childKey", "parentId", "parentStepRunId", "additionalMetadata", duration, priority, "insertOrder"
`

func (q *Queries) ReplayStepRunResetWorkflowRun(ctx context.Context, db DBTX, workflowrunid pgtype.UUID) (*WorkflowRun, error) {
	row := db.QueryRow(ctx, replayStepRunResetWorkflowRun, workflowrunid)
	var i WorkflowRun
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.WorkflowVersionId,
		&i.Status,
		&i.Error,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ConcurrencyGroupId,
		&i.DisplayName,
		&i.ID,
		&i.ChildIndex,
		&i.ChildKey,
		&i.ParentId,
		&i.ParentStepRunId,
		&i.AdditionalMetadata,
		&i.Duration,
		&i.Priority,
		&i.InsertOrder,
	)
	return &i, err
}

const replayWorkflowRunResetGetGroupKeyRun = `-- name: ReplayWorkflowRunResetGetGroupKeyRun :one
UPDATE
    "GetGroupKeyRun"
SET
    "status" = 'PENDING',
    "scheduleTimeoutAt" = NULL,
    "finishedAt" = NULL,
    "startedAt" = NULL,
    "timeoutAt" = NULL,
    "output" = NULL,
    "error" = NULL,
    "cancelledAt" = NULL,
    "cancelledReason" = NULL,
    "cancelledError" = NULL
WHERE
    "workflowRunId" = $1::uuid
RETURNING id, "createdAt", "updatedAt", "deletedAt", "tenantId", "workerId", "tickerId", status, input, output, "requeueAfter", error, "startedAt", "finishedAt", "timeoutAt", "cancelledAt", "cancelledReason", "cancelledError", "workflowRunId", "scheduleTimeoutAt"
`

func (q *Queries) ReplayWorkflowRunResetGetGroupKeyRun(ctx context.Context, db DBTX, workflowrunid pgtype.UUID) (*GetGroupKeyRun, error) {
	row := db.QueryRow(ctx, replayWorkflowRunResetGetGroupKeyRun, workflowrunid)
	var i GetGroupKeyRun
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.WorkerId,
		&i.TickerId,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.RequeueAfter,
		&i.Error,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TimeoutAt,
		&i.CancelledAt,
		&i.CancelledReason,
		&i.CancelledError,
		&i.WorkflowRunId,
		&i.ScheduleTimeoutAt,
	)
	return &i, err
}

const resetStepRunsByIds = `-- name: ResetStepRunsByIds :many
UPDATE
    "StepRun" as sr
SET
    "status" = 'PENDING',
    "scheduleTimeoutAt" = NULL,
    "finishedAt" = NULL,
    "startedAt" = NULL,
    "output" = NULL,
    "error" = NULL,
    "cancelledAt" = NULL,
    "cancelledReason" = NULL,
    "input" = NULL,
    "retryCount" = 0
WHERE
    sr."id" = ANY($1::uuid[]) AND
    sr."tenantId" = $2::uuid
RETURNING sr.id, sr."createdAt", sr."updatedAt", sr."deletedAt", sr."tenantId", sr."jobRunId", sr."stepId", sr."order", sr."workerId", sr."tickerId", sr.status, sr.input, sr.output, sr."requeueAfter", sr."scheduleTimeoutAt", sr.error, sr."startedAt", sr."finishedAt", sr."timeoutAt", sr."cancelledAt", sr."cancelledReason", sr."cancelledError", sr."inputSchema", sr."callerFiles", sr."gitRepoBranch", sr."retryCount", sr."semaphoreReleased", sr.queue, sr.priority, sr."internalRetryCount"
`

type ResetStepRunsByIdsParams struct {
	Ids      []pgtype.UUID `json:"ids"`
	Tenantid pgtype.UUID   `json:"tenantid"`
}

func (q *Queries) ResetStepRunsByIds(ctx context.Context, db DBTX, arg ResetStepRunsByIdsParams) ([]*StepRun, error) {
	rows, err := db.Query(ctx, resetStepRunsByIds, arg.Ids, arg.Tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepRun
	for rows.Next() {
		var i StepRun
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TenantId,
			&i.JobRunId,
			&i.StepId,
			&i.Order,
			&i.WorkerId,
			&i.TickerId,
			&i.Status,
			&i.Input,
			&i.Output,
			&i.RequeueAfter,
			&i.ScheduleTimeoutAt,
			&i.Error,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TimeoutAt,
			&i.CancelledAt,
			&i.CancelledReason,
			&i.CancelledError,
			&i.InputSchema,
			&i.CallerFiles,
			&i.GitRepoBranch,
			&i.RetryCount,
			&i.SemaphoreReleased,
			&i.Queue,
			&i.Priority,
			&i.InternalRetryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveLaterStepRuns = `-- name: ResolveLaterStepRuns :many
WITH RECURSIVE currStepRun AS (
  SELECT "id", "status", "cancelledReason"
  FROM "StepRun"
  WHERE
    "id" = $2::uuid
), childStepRuns AS (
  SELECT sr."id", sr."status"
  FROM "StepRun" sr
  JOIN "_StepRunOrder" sro ON sr."id" = sro."B"
  WHERE sro."A" = (SELECT "id" FROM currStepRun)

  UNION ALL

  SELECT sr."id", sr."status"
  FROM "StepRun" sr
  JOIN "_StepRunOrder" sro ON sr."id" = sro."B"
  JOIN childStepRuns csr ON sro."A" = csr."id"
)
UPDATE
    "StepRun" as sr
SET  "status" = CASE
    -- When the step is in a final state, it cannot be updated
    WHEN sr."status" IN ('SUCCEEDED', 'FAILED', 'CANCELLED') THEN sr."status"
    -- When the given step run has failed or been cancelled, then all child step runs are cancelled
    WHEN $1::"StepRunStatus" IN ('FAILED', 'CANCELLED') THEN 'CANCELLED'
    ELSE sr."status"
    END,
    -- When the previous step run timed out, the cancelled reason is set
    "cancelledReason" = CASE
    -- When the step is in a final state, it cannot be updated
    WHEN sr."status" IN ('SUCCEEDED', 'FAILED', 'CANCELLED') THEN sr."cancelledReason"
    WHEN $1::"StepRunStatus" = 'CANCELLED' AND (SELECT "cancelledReason" FROM currStepRun) = 'TIMED_OUT'::text THEN 'PREVIOUS_STEP_TIMED_OUT'
    WHEN $1::"StepRunStatus" = 'FAILED' THEN 'PREVIOUS_STEP_FAILED'
    WHEN $1::"StepRunStatus" = 'CANCELLED' THEN 'PREVIOUS_STEP_CANCELLED'
    ELSE NULL
    END
FROM
    childStepRuns csr
WHERE
    sr."id" = csr."id"
RETURNING sr.id, sr."createdAt", sr."updatedAt", sr."deletedAt", sr."tenantId", sr."jobRunId", sr."stepId", sr."order", sr."workerId", sr."tickerId", sr.status, sr.input, sr.output, sr."requeueAfter", sr."scheduleTimeoutAt", sr.error, sr."startedAt", sr."finishedAt", sr."timeoutAt", sr."cancelledAt", sr."cancelledReason", sr."cancelledError", sr."inputSchema", sr."callerFiles", sr."gitRepoBranch", sr."retryCount", sr."semaphoreReleased", sr.queue, sr.priority, sr."internalRetryCount"
`

type ResolveLaterStepRunsParams struct {
	Status    StepRunStatus `json:"status"`
	Steprunid pgtype.UUID   `json:"steprunid"`
}

func (q *Queries) ResolveLaterStepRuns(ctx context.Context, db DBTX, arg ResolveLaterStepRunsParams) ([]*StepRun, error) {
	rows, err := db.Query(ctx, resolveLaterStepRuns, arg.Status, arg.Steprunid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepRun
	for rows.Next() {
		var i StepRun
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TenantId,
			&i.JobRunId,
			&i.StepId,
			&i.Order,
			&i.WorkerId,
			&i.TickerId,
			&i.Status,
			&i.Input,
			&i.Output,
			&i.RequeueAfter,
			&i.ScheduleTimeoutAt,
			&i.Error,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TimeoutAt,
			&i.CancelledAt,
			&i.CancelledReason,
			&i.CancelledError,
			&i.InputSchema,
			&i.CallerFiles,
			&i.GitRepoBranch,
			&i.RetryCount,
			&i.SemaphoreReleased,
			&i.Queue,
			&i.Priority,
			&i.InternalRetryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStepRunInputSchema = `-- name: UpdateStepRunInputSchema :one
UPDATE
    "StepRun" sr
SET
    "inputSchema" = coalesce($1::jsonb, '{}'),
    "updatedAt" = CURRENT_TIMESTAMP
WHERE
    sr."tenantId" = $2::uuid AND
    sr."id" = $3::uuid
RETURNING "inputSchema"
`

type UpdateStepRunInputSchemaParams struct {
	InputSchema []byte      `json:"inputSchema"`
	Tenantid    pgtype.UUID `json:"tenantid"`
	Steprunid   pgtype.UUID `json:"steprunid"`
}

func (q *Queries) UpdateStepRunInputSchema(ctx context.Context, db DBTX, arg UpdateStepRunInputSchemaParams) ([]byte, error) {
	row := db.QueryRow(ctx, updateStepRunInputSchema, arg.InputSchema, arg.Tenantid, arg.Steprunid)
	var inputSchema []byte
	err := row.Scan(&inputSchema)
	return inputSchema, err
}

const updateStepRunOverridesData = `-- name: UpdateStepRunOverridesData :one
UPDATE
    "StepRun" AS sr
SET
    "updatedAt" = CURRENT_TIMESTAMP,
    "input" = jsonb_set("input", $1::text[], $2::jsonb, true),
    "callerFiles" = jsonb_set("callerFiles", $3::text[], to_jsonb($4::text), true)
WHERE
    sr."tenantId" = $5::uuid AND
    sr."id" = $6::uuid
RETURNING "input"
`

type UpdateStepRunOverridesDataParams struct {
	Fieldpath    []string    `json:"fieldpath"`
	Jsondata     []byte      `json:"jsondata"`
	Overrideskey []string    `json:"overrideskey"`
	Callerfile   string      `json:"callerfile"`
	Tenantid     pgtype.UUID `json:"tenantid"`
	Steprunid    pgtype.UUID `json:"steprunid"`
}

func (q *Queries) UpdateStepRunOverridesData(ctx context.Context, db DBTX, arg UpdateStepRunOverridesDataParams) ([]byte, error) {
	row := db.QueryRow(ctx, updateStepRunOverridesData,
		arg.Fieldpath,
		arg.Jsondata,
		arg.Overrideskey,
		arg.Callerfile,
		arg.Tenantid,
		arg.Steprunid,
	)
	var input []byte
	err := row.Scan(&input)
	return input, err
}

const updateStepRunUnsetWorkerId = `-- name: UpdateStepRunUnsetWorkerId :one
WITH oldsr AS (
    SELECT
        "id",
        "retryCount"
    FROM
        "StepRun"
    WHERE
        "id" = $1::uuid AND
        "tenantId" = $2::uuid
), deleted_sqi AS (
    DELETE FROM
        "SemaphoreQueueItem" sqi
    WHERE
        sqi."stepRunId" = $1::uuid
    RETURNING sqi."workerId"
)
SELECT
    deleted_sqi."workerId" AS "workerId",
    oldsr."retryCount" AS "retryCount"
FROM
    deleted_sqi, oldsr
`

type UpdateStepRunUnsetWorkerIdParams struct {
	Steprunid pgtype.UUID `json:"steprunid"`
	Tenantid  pgtype.UUID `json:"tenantid"`
}

type UpdateStepRunUnsetWorkerIdRow struct {
	WorkerId   pgtype.UUID `json:"workerId"`
	RetryCount int32       `json:"retryCount"`
}

func (q *Queries) UpdateStepRunUnsetWorkerId(ctx context.Context, db DBTX, arg UpdateStepRunUnsetWorkerIdParams) (*UpdateStepRunUnsetWorkerIdRow, error) {
	row := db.QueryRow(ctx, updateStepRunUnsetWorkerId, arg.Steprunid, arg.Tenantid)
	var i UpdateStepRunUnsetWorkerIdRow
	err := row.Scan(&i.WorkerId, &i.RetryCount)
	return &i, err
}

const updateStepRunUnsetWorkerIdBulk = `-- name: UpdateStepRunUnsetWorkerIdBulk :exec
DELETE FROM
    "SemaphoreQueueItem"
WHERE
    "stepRunId" = ANY($1::uuid[])
`

func (q *Queries) UpdateStepRunUnsetWorkerIdBulk(ctx context.Context, db DBTX, steprunids []pgtype.UUID) error {
	_, err := db.Exec(ctx, updateStepRunUnsetWorkerIdBulk, steprunids)
	return err
}

const updateStepRunsToAssigned = `-- name: UpdateStepRunsToAssigned :many
WITH input AS (
    SELECT
        "id",
        "stepTimeout",
        "workerId"
    FROM
        (
            SELECT
                unnest($1::uuid[]) AS "id",
                unnest($2::text[]) AS "stepTimeout",
                unnest($3::uuid[]) AS "workerId"
        ) AS subquery
    ORDER BY "id"
), updated_step_runs AS (
    SELECT
        sr."id",
        sr."retryCount",
        sr."tenantId",
        CURRENT_TIMESTAMP + convert_duration_to_interval(input."stepTimeout") AS "timeoutAt"
    FROM
        input
    JOIN
        "StepRun" sr ON sr."id" = input."id"
    ORDER BY sr."id"
), assigned_step_runs AS (
    INSERT INTO "SemaphoreQueueItem" (
        "stepRunId",
        "workerId",
        "tenantId"
    )
    SELECT
        input."id",
        input."workerId",
        $4::uuid
    FROM
        input
    ON CONFLICT ("stepRunId") DO NOTHING
    -- only return the step run ids that were successfully assigned
    RETURNING "stepRunId", "workerId"
), timeout_insert AS (
    -- bulk insert into timeout queue items
    INSERT INTO
        "TimeoutQueueItem" (
            "stepRunId",
            "retryCount",
            "timeoutAt",
            "tenantId",
            "isQueued"
        )
    SELECT
        sr."id",
        sr."retryCount",
        sr."timeoutAt",
        sr."tenantId",
        true
    FROM
        updated_step_runs sr
    JOIN
        assigned_step_runs asr ON sr."id" = asr."stepRunId"
    ON CONFLICT ("stepRunId", "retryCount") DO UPDATE
    SET
        "timeoutAt" = EXCLUDED."timeoutAt"
    RETURNING
        "stepRunId"
)
SELECT
    asr."stepRunId",
    asr."workerId"
FROM
    assigned_step_runs asr
`

type UpdateStepRunsToAssignedParams struct {
	Steprunids      []pgtype.UUID `json:"steprunids"`
	Stepruntimeouts []string      `json:"stepruntimeouts"`
	Workerids       []pgtype.UUID `json:"workerids"`
	Tenantid        pgtype.UUID   `json:"tenantid"`
}

type UpdateStepRunsToAssignedRow struct {
	StepRunId pgtype.UUID `json:"stepRunId"`
	WorkerId  pgtype.UUID `json:"workerId"`
}

func (q *Queries) UpdateStepRunsToAssigned(ctx context.Context, db DBTX, arg UpdateStepRunsToAssignedParams) ([]*UpdateStepRunsToAssignedRow, error) {
	rows, err := db.Query(ctx, updateStepRunsToAssigned,
		arg.Steprunids,
		arg.Stepruntimeouts,
		arg.Workerids,
		arg.Tenantid,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UpdateStepRunsToAssignedRow
	for rows.Next() {
		var i UpdateStepRunsToAssignedRow
		if err := rows.Scan(&i.StepRunId, &i.WorkerId); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertDesiredWorkerLabel = `-- name: UpsertDesiredWorkerLabel :one
INSERT INTO "StepDesiredWorkerLabel" (
    "createdAt",
    "updatedAt",
    "stepId",
    "key",
    "intValue",
    "strValue",
    "required",
    "weight",
    "comparator"
) VALUES (
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    $1::uuid,
    $2::text,
    COALESCE($3::int, NULL),
    COALESCE($4::text, NULL),
    COALESCE($5::boolean, false),
    COALESCE($6::int, 100),
    COALESCE($7::"WorkerLabelComparator", 'EQUAL')
) ON CONFLICT ("stepId", "key") DO UPDATE
SET
    "updatedAt" = CURRENT_TIMESTAMP,
    "intValue" = COALESCE($3::int, null),
    "strValue" = COALESCE($4::text, null),
    "required" = COALESCE($5::boolean, false),
    "weight" = COALESCE($6::int, 100),
    "comparator" = COALESCE($7::"WorkerLabelComparator", 'EQUAL')
RETURNING id, "createdAt", "updatedAt", "stepId", key, "strValue", "intValue", required, comparator, weight
`

type UpsertDesiredWorkerLabelParams struct {
	Stepid     pgtype.UUID               `json:"stepid"`
	Key        string                    `json:"key"`
	IntValue   pgtype.Int4               `json:"intValue"`
	StrValue   pgtype.Text               `json:"strValue"`
	Required   pgtype.Bool               `json:"required"`
	Weight     pgtype.Int4               `json:"weight"`
	Comparator NullWorkerLabelComparator `json:"comparator"`
}

func (q *Queries) UpsertDesiredWorkerLabel(ctx context.Context, db DBTX, arg UpsertDesiredWorkerLabelParams) (*StepDesiredWorkerLabel, error) {
	row := db.QueryRow(ctx, upsertDesiredWorkerLabel,
		arg.Stepid,
		arg.Key,
		arg.IntValue,
		arg.StrValue,
		arg.Required,
		arg.Weight,
		arg.Comparator,
	)
	var i StepDesiredWorkerLabel
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StepId,
		&i.Key,
		&i.StrValue,
		&i.IntValue,
		&i.Required,
		&i.Comparator,
		&i.Weight,
	)
	return &i, err
}

const validatesAsJson = `-- name: ValidatesAsJson :exec
SELECT $1::jsonb AS "is_valid"
`

func (q *Queries) ValidatesAsJson(ctx context.Context, db DBTX, input []byte) error {
	_, err := db.Exec(ctx, validatesAsJson, input)
	return err
}

const verifiedStepRunTenantIds = `-- name: VerifiedStepRunTenantIds :many
WITH input AS (
    SELECT
        unnest($1::uuid[]) AS "id",
        unnest($2::uuid[]) AS "tenantId"
)
SELECT
    sr."id"
FROM "StepRun" sr
JOIN input ON sr."id" = input."id" AND sr."tenantId" = input."tenantId"
ORDER BY sr."id"
`

type VerifiedStepRunTenantIdsParams struct {
	Steprunids []pgtype.UUID `json:"steprunids"`
	Tenantids  []pgtype.UUID `json:"tenantids"`
}

// stable ordering as it minimizes the chance of deadlocks
func (q *Queries) VerifiedStepRunTenantIds(ctx context.Context, db DBTX, arg VerifiedStepRunTenantIdsParams) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, verifiedStepRunTenantIds, arg.Steprunids, arg.Tenantids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
