// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sns.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSNSIntegration = `-- name: CreateSNSIntegration :one
INSERT INTO "SNSIntegration" (
    "id",
    "tenantId",
    "topicArn"
) VALUES (
    gen_random_uuid(),
    $1::uuid,
    $2::text
) ON CONFLICT ("tenantId", "topicArn") DO NOTHING
RETURNING id, "createdAt", "updatedAt", "tenantId", "topicArn"
`

type CreateSNSIntegrationParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Topicarn string      `json:"topicarn"`
}

func (q *Queries) CreateSNSIntegration(ctx context.Context, db DBTX, arg CreateSNSIntegrationParams) (*SNSIntegration, error) {
	row := db.QueryRow(ctx, createSNSIntegration, arg.Tenantid, arg.Topicarn)
	var i SNSIntegration
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantId,
		&i.TopicArn,
	)
	return &i, err
}

const deleteSNSIntegration = `-- name: DeleteSNSIntegration :exec
DELETE FROM
    "SNSIntegration"
WHERE
    "tenantId" = $1::uuid
    AND "id" = $2::uuid
`

type DeleteSNSIntegrationParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) DeleteSNSIntegration(ctx context.Context, db DBTX, arg DeleteSNSIntegrationParams) error {
	_, err := db.Exec(ctx, deleteSNSIntegration, arg.Tenantid, arg.ID)
	return err
}

const getSNSIntegration = `-- name: GetSNSIntegration :one
SELECT
    id, "createdAt", "updatedAt", "tenantId", "topicArn"
FROM
    "SNSIntegration"
WHERE
    "tenantId" = $1::uuid
    AND "topicArn" = $2::text
`

type GetSNSIntegrationParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Topicarn string      `json:"topicarn"`
}

func (q *Queries) GetSNSIntegration(ctx context.Context, db DBTX, arg GetSNSIntegrationParams) (*SNSIntegration, error) {
	row := db.QueryRow(ctx, getSNSIntegration, arg.Tenantid, arg.Topicarn)
	var i SNSIntegration
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantId,
		&i.TopicArn,
	)
	return &i, err
}

const getSNSIntegrationById = `-- name: GetSNSIntegrationById :one
SELECT
    id, "createdAt", "updatedAt", "tenantId", "topicArn"
FROM
    "SNSIntegration"
WHERE
    "id" = $1::uuid
`

func (q *Queries) GetSNSIntegrationById(ctx context.Context, db DBTX, id pgtype.UUID) (*SNSIntegration, error) {
	row := db.QueryRow(ctx, getSNSIntegrationById, id)
	var i SNSIntegration
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantId,
		&i.TopicArn,
	)
	return &i, err
}

const listSNSIntegrations = `-- name: ListSNSIntegrations :many
SELECT
    id, "createdAt", "updatedAt", "tenantId", "topicArn"
FROM
    "SNSIntegration"
WHERE
    "tenantId" = $1::uuid
`

func (q *Queries) ListSNSIntegrations(ctx context.Context, db DBTX, tenantid pgtype.UUID) ([]*SNSIntegration, error) {
	rows, err := db.Query(ctx, listSNSIntegrations, tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SNSIntegration
	for rows.Next() {
		var i SNSIntegration
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TenantId,
			&i.TopicArn,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
