// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: step_runs.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const archiveStepRunResultFromStepRun = `-- name: ArchiveStepRunResultFromStepRun :one
WITH step_run_data AS (
    SELECT
        "id" AS step_run_id,
        "createdAt",
        "updatedAt",
        "deletedAt",
        "order",
        "input",
        "output",
        "error",
        "startedAt",
        "finishedAt",
        "timeoutAt",
        "cancelledAt",
        "cancelledReason",
        "cancelledError"
    FROM "StepRun"
    WHERE
        "id" = $2::uuid
        AND "tenantId" = $3::uuid
        AND "deletedAt" IS NULL
)
INSERT INTO "StepRunResultArchive" (
    "id",
    "createdAt",
    "updatedAt",
    "deletedAt",
    "stepRunId",
    "input",
    "output",
    "error",
    "startedAt",
    "finishedAt",
    "timeoutAt",
    "cancelledAt",
    "cancelledReason",
    "cancelledError"
)
SELECT
    COALESCE($1::uuid, gen_random_uuid()),
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    step_run_data."deletedAt",
    step_run_data.step_run_id,
    step_run_data."input",
    step_run_data."output",
    step_run_data."error",
    step_run_data."startedAt",
    step_run_data."finishedAt",
    step_run_data."timeoutAt",
    step_run_data."cancelledAt",
    step_run_data."cancelledReason",
    step_run_data."cancelledError"
FROM step_run_data
RETURNING id, "createdAt", "updatedAt", "deletedAt", "stepRunId", "order", input, output, error, "startedAt", "finishedAt", "timeoutAt", "cancelledAt", "cancelledReason", "cancelledError"
`

type ArchiveStepRunResultFromStepRunParams struct {
	ID        pgtype.UUID `json:"id"`
	Steprunid pgtype.UUID `json:"steprunid"`
	Tenantid  pgtype.UUID `json:"tenantid"`
}

func (q *Queries) ArchiveStepRunResultFromStepRun(ctx context.Context, db DBTX, arg ArchiveStepRunResultFromStepRunParams) (*StepRunResultArchive, error) {
	row := db.QueryRow(ctx, archiveStepRunResultFromStepRun, arg.ID, arg.Steprunid, arg.Tenantid)
	var i StepRunResultArchive
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.StepRunId,
		&i.Order,
		&i.Input,
		&i.Output,
		&i.Error,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TimeoutAt,
		&i.CancelledAt,
		&i.CancelledReason,
		&i.CancelledError,
	)
	return &i, err
}

const bulkAssignStepRunsToWorkers = `-- name: BulkAssignStepRunsToWorkers :many
WITH already_assigned_step_runs AS (
    SELECT
        input."id",
        wss."id" AS "slotId"
    FROM
        (
            SELECT
                unnest($1::uuid[]) AS "id"
        ) AS input
    JOIN
        "WorkerSemaphoreSlot" wss ON input."id" = wss."stepRunId"
), already_assigned_slots AS (
    SELECT
        wss."id"
    FROM
        (
            SELECT
                unnest($2::uuid[]) AS "id"
        ) AS input
    JOIN
        "WorkerSemaphoreSlot" wss ON input."id" = wss."id"
    WHERE
        wss."stepRunId" IS NOT NULL
), updated_step_runs AS (
    UPDATE
        "StepRun" sr
    SET
        "status" = 'ASSIGNED',
        "workerId" = input."workerId",
        "tickerId" = NULL,
        "updatedAt" = CURRENT_TIMESTAMP,
        "timeoutAt" = CURRENT_TIMESTAMP + convert_duration_to_interval(input."stepTimeout")
    FROM (
        SELECT
            "id",
            "stepTimeout",
            "workerId",
            "slotId"
        FROM
            (
                SELECT
                    unnest($1::uuid[]) AS "id",
                    unnest($3::text[]) AS "stepTimeout",
                    unnest($4::uuid[]) AS "workerId",
                    unnest($2::uuid[]) AS "slotId"
            ) AS subquery
        WHERE
            "id" NOT IN (SELECT "id" FROM already_assigned_step_runs)
            AND "slotId" NOT IN (SELECT "id" FROM already_assigned_slots)
    ) AS input
    WHERE
        sr."id" = input."id"
    RETURNING input."id", input."slotId"
)
UPDATE
    "WorkerSemaphoreSlot" wss
SET
    "stepRunId" = updated_step_runs."id"
FROM updated_step_runs
WHERE
    wss."id" = updated_step_runs."slotId"
RETURNING wss."id"
`

type BulkAssignStepRunsToWorkersParams struct {
	Steprunids      []pgtype.UUID `json:"steprunids"`
	Slotids         []pgtype.UUID `json:"slotids"`
	Stepruntimeouts []string      `json:"stepruntimeouts"`
	Workerids       []pgtype.UUID `json:"workerids"`
}

func (q *Queries) BulkAssignStepRunsToWorkers(ctx context.Context, db DBTX, arg BulkAssignStepRunsToWorkersParams) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, bulkAssignStepRunsToWorkers,
		arg.Steprunids,
		arg.Slotids,
		arg.Stepruntimeouts,
		arg.Workerids,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bulkCreateStepRunEvent = `-- name: BulkCreateStepRunEvent :exec
WITH input_values AS (
    SELECT
        CURRENT_TIMESTAMP AS "timeFirstSeen",
        CURRENT_TIMESTAMP AS "timeLastSeen",
        unnest($1::uuid[]) AS "stepRunId",
        unnest(cast($2::text[] as"StepRunEventReason"[])) AS "reason",
        unnest(cast($3::text[] as "StepRunEventSeverity"[])) AS "severity",
        unnest($4::text[]) AS "message",
        1 AS "count",
        unnest($5::jsonb[]) AS "data"
),
updated AS (
    UPDATE "StepRunEvent"
    SET
        "timeLastSeen" = CURRENT_TIMESTAMP,
        "message" = input_values."message",
        "count" = "StepRunEvent"."count" + 1,
        "data" = input_values."data"
    FROM input_values
    WHERE
        "StepRunEvent"."stepRunId" = input_values."stepRunId"
        AND "StepRunEvent"."reason" = input_values."reason"
        AND "StepRunEvent"."severity" = input_values."severity"
        AND "StepRunEvent"."id" = (
            SELECT "id"
            FROM "StepRunEvent"
            WHERE "stepRunId" = input_values."stepRunId"
            ORDER BY "id" DESC
            LIMIT 1
        )
    RETURNING "StepRunEvent".id, "StepRunEvent"."timeFirstSeen", "StepRunEvent"."timeLastSeen", "StepRunEvent"."stepRunId", "StepRunEvent".reason, "StepRunEvent".severity, "StepRunEvent".message, "StepRunEvent".count, "StepRunEvent".data
)
INSERT INTO "StepRunEvent" (
    "timeFirstSeen",
    "timeLastSeen",
    "stepRunId",
    "reason",
    "severity",
    "message",
    "count",
    "data"
)
SELECT
    "timeFirstSeen",
    "timeLastSeen",
    "stepRunId",
    "reason",
    "severity",
    "message",
    "count",
    "data"
FROM input_values
WHERE NOT EXISTS (
    SELECT 1 FROM updated WHERE "stepRunId" = input_values."stepRunId"
)
`

type BulkCreateStepRunEventParams struct {
	Steprunids []pgtype.UUID `json:"steprunids"`
	Reasons    []string      `json:"reasons"`
	Severities []string      `json:"severities"`
	Messages   []string      `json:"messages"`
	Data       [][]byte      `json:"data"`
}

func (q *Queries) BulkCreateStepRunEvent(ctx context.Context, db DBTX, arg BulkCreateStepRunEventParams) error {
	_, err := db.Exec(ctx, bulkCreateStepRunEvent,
		arg.Steprunids,
		arg.Reasons,
		arg.Severities,
		arg.Messages,
		arg.Data,
	)
	return err
}

const bulkMarkStepRunsAsCancelling = `-- name: BulkMarkStepRunsAsCancelling :many
UPDATE
    "StepRun" sr
SET
    "status" = 'CANCELLING',
    "updatedAt" = CURRENT_TIMESTAMP
FROM (
    SELECT
        unnest($1::uuid[]) AS "id"
    ) AS input
WHERE
    sr."id" = input."id"
RETURNING sr."id"
`

func (q *Queries) BulkMarkStepRunsAsCancelling(ctx context.Context, db DBTX, steprunids []pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, bulkMarkStepRunsAsCancelling, steprunids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkWorker = `-- name: CheckWorker :one
SELECT
    "id"
FROM
    "Worker"
WHERE
    "tenantId" = $1::uuid
    AND "dispatcherId" IS NOT NULL
    AND "isActive" = true
    AND "isPaused" = false
    AND "lastHeartbeatAt" > NOW() - INTERVAL '5 seconds'
    AND "id" = $2::uuid
`

type CheckWorkerParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Workerid pgtype.UUID `json:"workerid"`
}

func (q *Queries) CheckWorker(ctx context.Context, db DBTX, arg CheckWorkerParams) (pgtype.UUID, error) {
	row := db.QueryRow(ctx, checkWorker, arg.Tenantid, arg.Workerid)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const clearStepRunPayloadData = `-- name: ClearStepRunPayloadData :one
WITH for_delete AS (
    SELECT
        sr2."id"
    FROM "StepRun" sr2
    WHERE
        sr2."tenantId" = $1::uuid AND
        sr2."deletedAt" IS NOT NULL AND
        (sr2."input" IS NOT NULL OR sr2."output" IS NOT NULL OR sr2."error" IS NOT NULL)
    ORDER BY "deletedAt" ASC
    LIMIT $2 + 1
    FOR UPDATE SKIP LOCKED
),
deleted_with_limit AS (
    SELECT
        for_delete."id" as "id"
    FROM for_delete
    LIMIT $2
),
deleted_archives AS (
    SELECT sra1."id" as "id"
    FROM "StepRunResultArchive" sra1
    WHERE
        sra1."stepRunId" IN (SELECT "id" FROM deleted_with_limit)
        AND (sra1."input" IS NOT NULL OR sra1."output" IS NOT NULL OR sra1."error" IS NOT NULL)
),
has_more AS (
    SELECT
        CASE
            WHEN COUNT(*) > $2 THEN TRUE
            ELSE FALSE
        END as has_more
    FROM for_delete
),
cleared_archives AS (
    UPDATE "StepRunResultArchive"
    SET
        "input" = NULL,
        "output" = NULL,
        "error" = NULL
    WHERE
        "id" IN (SELECT "id" FROM deleted_archives)
)
UPDATE
    "StepRun"
SET
    "input" = NULL,
    "output" = NULL,
    "error" = NULL
WHERE
    "id" IN (SELECT "id" FROM deleted_with_limit)
RETURNING
    (SELECT has_more FROM has_more) as has_more
`

type ClearStepRunPayloadDataParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Limit    interface{} `json:"limit"`
}

func (q *Queries) ClearStepRunPayloadData(ctx context.Context, db DBTX, arg ClearStepRunPayloadDataParams) (bool, error) {
	row := db.QueryRow(ctx, clearStepRunPayloadData, arg.Tenantid, arg.Limit)
	var has_more bool
	err := row.Scan(&has_more)
	return has_more, err
}

const countStepRunArchives = `-- name: CountStepRunArchives :one
SELECT
    count(*) OVER() AS total
FROM
    "StepRunResultArchive"
WHERE
    "stepRunId" = $1::uuid
`

func (q *Queries) CountStepRunArchives(ctx context.Context, db DBTX, steprunid pgtype.UUID) (int64, error) {
	row := db.QueryRow(ctx, countStepRunArchives, steprunid)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countStepRunEvents = `-- name: CountStepRunEvents :one
SELECT
    count(*) OVER() AS total
FROM
    "StepRunEvent"
WHERE
    "stepRunId" = $1::uuid
`

func (q *Queries) CountStepRunEvents(ctx context.Context, db DBTX, steprunid pgtype.UUID) (int64, error) {
	row := db.QueryRow(ctx, countStepRunEvents, steprunid)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createStepRunEvent = `-- name: CreateStepRunEvent :exec
WITH input_values AS (
    SELECT
        CURRENT_TIMESTAMP AS "timeFirstSeen",
        CURRENT_TIMESTAMP AS "timeLastSeen",
        $1::uuid AS "stepRunId",
        $2::"StepRunEventReason" AS "reason",
        $3::"StepRunEventSeverity" AS "severity",
        $4::text AS "message",
        1 AS "count",
        $5::jsonb AS "data"
),
updated AS (
    UPDATE "StepRunEvent"
    SET
        "timeLastSeen" = CURRENT_TIMESTAMP,
        "message" = input_values."message",
        "count" = "StepRunEvent"."count" + 1,
        "data" = input_values."data"
    FROM input_values
    WHERE
        "StepRunEvent"."stepRunId" = input_values."stepRunId"
        AND "StepRunEvent"."reason" = input_values."reason"
        AND "StepRunEvent"."severity" = input_values."severity"
        AND "StepRunEvent"."id" = (
            SELECT "id"
            FROM "StepRunEvent"
            WHERE "stepRunId" = input_values."stepRunId"
            ORDER BY "id" DESC
            LIMIT 1
        )
    RETURNING "StepRunEvent".id, "StepRunEvent"."timeFirstSeen", "StepRunEvent"."timeLastSeen", "StepRunEvent"."stepRunId", "StepRunEvent".reason, "StepRunEvent".severity, "StepRunEvent".message, "StepRunEvent".count, "StepRunEvent".data
)
INSERT INTO "StepRunEvent" (
    "timeFirstSeen",
    "timeLastSeen",
    "stepRunId",
    "reason",
    "severity",
    "message",
    "count",
    "data"
)
SELECT
    "timeFirstSeen",
    "timeLastSeen",
    "stepRunId",
    "reason",
    "severity",
    "message",
    "count",
    "data"
FROM input_values
WHERE NOT EXISTS (
    SELECT 1 FROM updated WHERE "stepRunId" = input_values."stepRunId"
)
`

type CreateStepRunEventParams struct {
	Steprunid pgtype.UUID          `json:"steprunid"`
	Reason    StepRunEventReason   `json:"reason"`
	Severity  StepRunEventSeverity `json:"severity"`
	Message   string               `json:"message"`
	Data      []byte               `json:"data"`
}

func (q *Queries) CreateStepRunEvent(ctx context.Context, db DBTX, arg CreateStepRunEventParams) error {
	_, err := db.Exec(ctx, createStepRunEvent,
		arg.Steprunid,
		arg.Reason,
		arg.Severity,
		arg.Message,
		arg.Data,
	)
	return err
}

const getDesiredLabels = `-- name: GetDesiredLabels :many
SELECT
    "key",
    "strValue",
    "intValue",
    "required",
    "weight",
    "comparator"
FROM
    "StepDesiredWorkerLabel"
WHERE
    "stepId" = $1::uuid
`

type GetDesiredLabelsRow struct {
	Key        string                `json:"key"`
	StrValue   pgtype.Text           `json:"strValue"`
	IntValue   pgtype.Int4           `json:"intValue"`
	Required   bool                  `json:"required"`
	Weight     int32                 `json:"weight"`
	Comparator WorkerLabelComparator `json:"comparator"`
}

func (q *Queries) GetDesiredLabels(ctx context.Context, db DBTX, stepid pgtype.UUID) ([]*GetDesiredLabelsRow, error) {
	rows, err := db.Query(ctx, getDesiredLabels, stepid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetDesiredLabelsRow
	for rows.Next() {
		var i GetDesiredLabelsRow
		if err := rows.Scan(
			&i.Key,
			&i.StrValue,
			&i.IntValue,
			&i.Required,
			&i.Weight,
			&i.Comparator,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLaterStepRunsForReplay = `-- name: GetLaterStepRunsForReplay :many
WITH RECURSIVE currStepRun AS (
    SELECT id, "createdAt", "updatedAt", "deletedAt", "tenantId", "jobRunId", "stepId", "order", "workerId", "tickerId", status, input, output, "requeueAfter", "scheduleTimeoutAt", error, "startedAt", "finishedAt", "timeoutAt", "cancelledAt", "cancelledReason", "cancelledError", "inputSchema", "callerFiles", "gitRepoBranch", "retryCount", "semaphoreReleased", queue
    FROM "StepRun"
    WHERE
        "id" = $2::uuid AND
        "tenantId" = $1::uuid
), childStepRuns AS (
    SELECT sr."id", sr."status"
    FROM "StepRun" sr
    JOIN "_StepRunOrder" sro ON sr."id" = sro."B"
    WHERE sro."A" = (SELECT "id" FROM currStepRun)

    UNION ALL

    SELECT sr."id", sr."status"
    FROM "StepRun" sr
    JOIN "_StepRunOrder" sro ON sr."id" = sro."B"
    JOIN childStepRuns csr ON sro."A" = csr."id"
)
SELECT
    sr.id, sr."createdAt", sr."updatedAt", sr."deletedAt", sr."tenantId", sr."jobRunId", sr."stepId", sr."order", sr."workerId", sr."tickerId", sr.status, sr.input, sr.output, sr."requeueAfter", sr."scheduleTimeoutAt", sr.error, sr."startedAt", sr."finishedAt", sr."timeoutAt", sr."cancelledAt", sr."cancelledReason", sr."cancelledError", sr."inputSchema", sr."callerFiles", sr."gitRepoBranch", sr."retryCount", sr."semaphoreReleased", sr.queue
FROM
    "StepRun" sr
JOIN
    childStepRuns csr ON sr."id" = csr."id"
WHERE
    sr."tenantId" = $1::uuid
`

type GetLaterStepRunsForReplayParams struct {
	Tenantid  pgtype.UUID `json:"tenantid"`
	Steprunid pgtype.UUID `json:"steprunid"`
}

func (q *Queries) GetLaterStepRunsForReplay(ctx context.Context, db DBTX, arg GetLaterStepRunsForReplayParams) ([]*StepRun, error) {
	rows, err := db.Query(ctx, getLaterStepRunsForReplay, arg.Tenantid, arg.Steprunid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepRun
	for rows.Next() {
		var i StepRun
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TenantId,
			&i.JobRunId,
			&i.StepId,
			&i.Order,
			&i.WorkerId,
			&i.TickerId,
			&i.Status,
			&i.Input,
			&i.Output,
			&i.RequeueAfter,
			&i.ScheduleTimeoutAt,
			&i.Error,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TimeoutAt,
			&i.CancelledAt,
			&i.CancelledReason,
			&i.CancelledError,
			&i.InputSchema,
			&i.CallerFiles,
			&i.GitRepoBranch,
			&i.RetryCount,
			&i.SemaphoreReleased,
			&i.Queue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaxRunsLimit = `-- name: GetMaxRunsLimit :one
WITH valid_workers AS (
    SELECT
        w."id",
        COALESCE(w."maxRuns", 100) - COUNT(wss."id") AS "remainingSlots"
    FROM
        "Worker" w
    LEFT JOIN
        "WorkerSemaphoreSlot" wss ON w."id" = wss."workerId" AND wss."stepRunId" IS NOT NULL
    WHERE
        w."tenantId" = $1::uuid
        AND w."lastHeartbeatAt" > NOW() - INTERVAL '5 seconds'
        -- necessary because isActive is set to false immediately when the stream closes
        AND w."isActive" = true
        AND w."isPaused" = false
    GROUP BY
        w."id", w."maxRuns"
    HAVING
        COALESCE(w."maxRuns", 100) - COUNT(wss."stepRunId") > 0
),
total_max_runs AS (
    SELECT
        SUM("remainingSlots") AS "totalMaxRuns"
    FROM
        valid_workers
)
SELECT
    GREATEST("totalMaxRuns", 100)::int AS "limitMaxRuns"
FROM
    total_max_runs
`

// Count the total number of maxRuns - runningStepRuns across all workers
func (q *Queries) GetMaxRunsLimit(ctx context.Context, db DBTX, tenantid pgtype.UUID) (int32, error) {
	row := db.QueryRow(ctx, getMaxRunsLimit, tenantid)
	var limitMaxRuns int32
	err := row.Scan(&limitMaxRuns)
	return limitMaxRuns, err
}

const getStepDesiredWorkerLabels = `-- name: GetStepDesiredWorkerLabels :one
SELECT
    jsonb_agg(
        jsonb_build_object(
            'key', dwl."key",
            'strValue', dwl."strValue",
            'intValue', dwl."intValue",
            'required', dwl."required",
            'weight', dwl."weight",
            'comparator', dwl."comparator",
            'is_true', false
        )
    ) AS desired_labels
FROM
    "StepDesiredWorkerLabel" dwl
WHERE
    dwl."stepId" = $1::uuid
`

func (q *Queries) GetStepDesiredWorkerLabels(ctx context.Context, db DBTX, stepid pgtype.UUID) ([]byte, error) {
	row := db.QueryRow(ctx, getStepDesiredWorkerLabels, stepid)
	var desired_labels []byte
	err := row.Scan(&desired_labels)
	return desired_labels, err
}

const getStepRun = `-- name: GetStepRun :one
SELECT
    "StepRun".id, "StepRun"."createdAt", "StepRun"."updatedAt", "StepRun"."deletedAt", "StepRun"."tenantId", "StepRun"."jobRunId", "StepRun"."stepId", "StepRun"."order", "StepRun"."workerId", "StepRun"."tickerId", "StepRun".status, "StepRun".input, "StepRun".output, "StepRun"."requeueAfter", "StepRun"."scheduleTimeoutAt", "StepRun".error, "StepRun"."startedAt", "StepRun"."finishedAt", "StepRun"."timeoutAt", "StepRun"."cancelledAt", "StepRun"."cancelledReason", "StepRun"."cancelledError", "StepRun"."inputSchema", "StepRun"."callerFiles", "StepRun"."gitRepoBranch", "StepRun"."retryCount", "StepRun"."semaphoreReleased", "StepRun".queue
FROM
    "StepRun"
WHERE
    "id" = $1::uuid AND
    "deletedAt" IS NULL AND
    "tenantId" = $2::uuid
`

type GetStepRunParams struct {
	ID       pgtype.UUID `json:"id"`
	Tenantid pgtype.UUID `json:"tenantid"`
}

func (q *Queries) GetStepRun(ctx context.Context, db DBTX, arg GetStepRunParams) (*StepRun, error) {
	row := db.QueryRow(ctx, getStepRun, arg.ID, arg.Tenantid)
	var i StepRun
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.JobRunId,
		&i.StepId,
		&i.Order,
		&i.WorkerId,
		&i.TickerId,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.RequeueAfter,
		&i.ScheduleTimeoutAt,
		&i.Error,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TimeoutAt,
		&i.CancelledAt,
		&i.CancelledReason,
		&i.CancelledError,
		&i.InputSchema,
		&i.CallerFiles,
		&i.GitRepoBranch,
		&i.RetryCount,
		&i.SemaphoreReleased,
		&i.Queue,
	)
	return &i, err
}

const getStepRunDataForEngine = `-- name: GetStepRunDataForEngine :one
SELECT
    sr."input",
    sr."output",
    sr."error",
    jrld."data" AS "jobRunLookupData",
    wr."additionalMetadata",
    wr."childIndex",
    wr."childKey",
    wr."parentId"
FROM
    "StepRun" sr
JOIN
    "JobRun" jr ON sr."jobRunId" = jr."id"
JOIN
    "JobRunLookupData" jrld ON jr."id" = jrld."jobRunId"
JOIN
    -- Take advantage of composite index on "JobRun"("workflowRunId", "tenantId")
    "WorkflowRun" wr ON jr."workflowRunId" = wr."id" AND wr."tenantId" = $1::uuid
WHERE
    sr."id" = $2::uuid AND
    sr."tenantId" = $1::uuid
`

type GetStepRunDataForEngineParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	ID       pgtype.UUID `json:"id"`
}

type GetStepRunDataForEngineRow struct {
	Input              []byte      `json:"input"`
	Output             []byte      `json:"output"`
	Error              pgtype.Text `json:"error"`
	JobRunLookupData   []byte      `json:"jobRunLookupData"`
	AdditionalMetadata []byte      `json:"additionalMetadata"`
	ChildIndex         pgtype.Int4 `json:"childIndex"`
	ChildKey           pgtype.Text `json:"childKey"`
	ParentId           pgtype.UUID `json:"parentId"`
}

func (q *Queries) GetStepRunDataForEngine(ctx context.Context, db DBTX, arg GetStepRunDataForEngineParams) (*GetStepRunDataForEngineRow, error) {
	row := db.QueryRow(ctx, getStepRunDataForEngine, arg.Tenantid, arg.ID)
	var i GetStepRunDataForEngineRow
	err := row.Scan(
		&i.Input,
		&i.Output,
		&i.Error,
		&i.JobRunLookupData,
		&i.AdditionalMetadata,
		&i.ChildIndex,
		&i.ChildKey,
		&i.ParentId,
	)
	return &i, err
}

const getStepRunForEngine = `-- name: GetStepRunForEngine :many
SELECT
    DISTINCT ON (sr."id")
    sr."id" AS "SR_id",
    sr."createdAt" AS "SR_createdAt",
    sr."updatedAt" AS "SR_updatedAt",
    sr."deletedAt" AS "SR_deletedAt",
    sr."tenantId" AS "SR_tenantId",
    sr."queue" AS "SR_queue",
    sr."order" AS "SR_order",
    sr."workerId" AS "SR_workerId",
    sr."tickerId" AS "SR_tickerId",
    sr."status" AS "SR_status",
    sr."requeueAfter" AS "SR_requeueAfter",
    sr."scheduleTimeoutAt" AS "SR_scheduleTimeoutAt",
    sr."startedAt" AS "SR_startedAt",
    sr."finishedAt" AS "SR_finishedAt",
    sr."timeoutAt" AS "SR_timeoutAt",
    sr."cancelledAt" AS "SR_cancelledAt",
    sr."cancelledReason" AS "SR_cancelledReason",
    sr."cancelledError" AS "SR_cancelledError",
    sr."callerFiles" AS "SR_callerFiles",
    sr."gitRepoBranch" AS "SR_gitRepoBranch",
    sr."retryCount" AS "SR_retryCount",
    sr."semaphoreReleased" AS "SR_semaphoreReleased",
    -- TODO: everything below this line is cacheable and should be moved to a separate query
    jr."id" AS "jobRunId",
    s."id" AS "stepId",
    s."retries" AS "stepRetries",
    s."timeout" AS "stepTimeout",
    s."scheduleTimeout" AS "stepScheduleTimeout",
    s."readableId" AS "stepReadableId",
    s."customUserData" AS "stepCustomUserData",
    j."name" AS "jobName",
    j."id" AS "jobId",
    j."kind" AS "jobKind",
    j."workflowVersionId" AS "workflowVersionId",
    jr."status" AS "jobRunStatus",
    jr."workflowRunId" AS "workflowRunId",
    a."actionId" AS "actionId",
    sticky."strategy" AS "stickyStrategy",
    sticky."desiredWorkerId" AS "desiredWorkerId"
FROM
    "StepRun" sr
JOIN
    "Step" s ON sr."stepId" = s."id"
JOIN
    "Action" a ON s."actionId" = a."actionId" AND s."tenantId" = a."tenantId"
JOIN
    "JobRun" jr ON sr."jobRunId" = jr."id"
JOIN
    "Job" j ON jr."jobId" = j."id"
LEFT JOIN
    "WorkflowRunStickyState" sticky ON jr."workflowRunId" = sticky."workflowRunId"
WHERE
    sr."id" = ANY($1::uuid[]) AND
    sr."deletedAt" IS NULL AND
    jr."deletedAt" IS NULL AND
    (
        $2::uuid IS NULL OR
        sr."tenantId" = $2::uuid
    )
`

type GetStepRunForEngineParams struct {
	Ids      []pgtype.UUID `json:"ids"`
	TenantId pgtype.UUID   `json:"tenantId"`
}

type GetStepRunForEngineRow struct {
	SRID                pgtype.UUID        `json:"SR_id"`
	SRCreatedAt         pgtype.Timestamp   `json:"SR_createdAt"`
	SRUpdatedAt         pgtype.Timestamp   `json:"SR_updatedAt"`
	SRDeletedAt         pgtype.Timestamp   `json:"SR_deletedAt"`
	SRTenantId          pgtype.UUID        `json:"SR_tenantId"`
	SRQueue             string             `json:"SR_queue"`
	SROrder             int64              `json:"SR_order"`
	SRWorkerId          pgtype.UUID        `json:"SR_workerId"`
	SRTickerId          pgtype.UUID        `json:"SR_tickerId"`
	SRStatus            StepRunStatus      `json:"SR_status"`
	SRRequeueAfter      pgtype.Timestamp   `json:"SR_requeueAfter"`
	SRScheduleTimeoutAt pgtype.Timestamp   `json:"SR_scheduleTimeoutAt"`
	SRStartedAt         pgtype.Timestamp   `json:"SR_startedAt"`
	SRFinishedAt        pgtype.Timestamp   `json:"SR_finishedAt"`
	SRTimeoutAt         pgtype.Timestamp   `json:"SR_timeoutAt"`
	SRCancelledAt       pgtype.Timestamp   `json:"SR_cancelledAt"`
	SRCancelledReason   pgtype.Text        `json:"SR_cancelledReason"`
	SRCancelledError    pgtype.Text        `json:"SR_cancelledError"`
	SRCallerFiles       []byte             `json:"SR_callerFiles"`
	SRGitRepoBranch     pgtype.Text        `json:"SR_gitRepoBranch"`
	SRRetryCount        int32              `json:"SR_retryCount"`
	SRSemaphoreReleased bool               `json:"SR_semaphoreReleased"`
	JobRunId            pgtype.UUID        `json:"jobRunId"`
	StepId              pgtype.UUID        `json:"stepId"`
	StepRetries         int32              `json:"stepRetries"`
	StepTimeout         pgtype.Text        `json:"stepTimeout"`
	StepScheduleTimeout string             `json:"stepScheduleTimeout"`
	StepReadableId      pgtype.Text        `json:"stepReadableId"`
	StepCustomUserData  []byte             `json:"stepCustomUserData"`
	JobName             string             `json:"jobName"`
	JobId               pgtype.UUID        `json:"jobId"`
	JobKind             JobKind            `json:"jobKind"`
	WorkflowVersionId   pgtype.UUID        `json:"workflowVersionId"`
	JobRunStatus        JobRunStatus       `json:"jobRunStatus"`
	WorkflowRunId       pgtype.UUID        `json:"workflowRunId"`
	ActionId            string             `json:"actionId"`
	StickyStrategy      NullStickyStrategy `json:"stickyStrategy"`
	DesiredWorkerId     pgtype.UUID        `json:"desiredWorkerId"`
}

func (q *Queries) GetStepRunForEngine(ctx context.Context, db DBTX, arg GetStepRunForEngineParams) ([]*GetStepRunForEngineRow, error) {
	rows, err := db.Query(ctx, getStepRunForEngine, arg.Ids, arg.TenantId)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetStepRunForEngineRow
	for rows.Next() {
		var i GetStepRunForEngineRow
		if err := rows.Scan(
			&i.SRID,
			&i.SRCreatedAt,
			&i.SRUpdatedAt,
			&i.SRDeletedAt,
			&i.SRTenantId,
			&i.SRQueue,
			&i.SROrder,
			&i.SRWorkerId,
			&i.SRTickerId,
			&i.SRStatus,
			&i.SRRequeueAfter,
			&i.SRScheduleTimeoutAt,
			&i.SRStartedAt,
			&i.SRFinishedAt,
			&i.SRTimeoutAt,
			&i.SRCancelledAt,
			&i.SRCancelledReason,
			&i.SRCancelledError,
			&i.SRCallerFiles,
			&i.SRGitRepoBranch,
			&i.SRRetryCount,
			&i.SRSemaphoreReleased,
			&i.JobRunId,
			&i.StepId,
			&i.StepRetries,
			&i.StepTimeout,
			&i.StepScheduleTimeout,
			&i.StepReadableId,
			&i.StepCustomUserData,
			&i.JobName,
			&i.JobId,
			&i.JobKind,
			&i.WorkflowVersionId,
			&i.JobRunStatus,
			&i.WorkflowRunId,
			&i.ActionId,
			&i.StickyStrategy,
			&i.DesiredWorkerId,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStepRunMeta = `-- name: GetStepRunMeta :one
SELECT
    jr."workflowRunId" AS "workflowRunId",
    sr."retryCount" AS "retryCount",
    s."retries" as "retries"
FROM "StepRun" sr
JOIN "Step" s ON sr."stepId" = s."id"
JOIN "JobRun" jr ON sr."jobRunId" = jr."id"
WHERE sr."id" = $1::uuid
AND sr."tenantId" = $2::uuid
`

type GetStepRunMetaParams struct {
	Steprunid pgtype.UUID `json:"steprunid"`
	Tenantid  pgtype.UUID `json:"tenantid"`
}

type GetStepRunMetaRow struct {
	WorkflowRunId pgtype.UUID `json:"workflowRunId"`
	RetryCount    int32       `json:"retryCount"`
	Retries       int32       `json:"retries"`
}

func (q *Queries) GetStepRunMeta(ctx context.Context, db DBTX, arg GetStepRunMetaParams) (*GetStepRunMetaRow, error) {
	row := db.QueryRow(ctx, getStepRunMeta, arg.Steprunid, arg.Tenantid)
	var i GetStepRunMetaRow
	err := row.Scan(&i.WorkflowRunId, &i.RetryCount, &i.Retries)
	return &i, err
}

const getWorkerLabels = `-- name: GetWorkerLabels :many
SELECT
    "key",
    "strValue",
    "intValue"
FROM
    "WorkerLabel"
WHERE
    "workerId" = $1::uuid
`

type GetWorkerLabelsRow struct {
	Key      string      `json:"key"`
	StrValue pgtype.Text `json:"strValue"`
	IntValue pgtype.Int4 `json:"intValue"`
}

func (q *Queries) GetWorkerLabels(ctx context.Context, db DBTX, workerid pgtype.UUID) ([]*GetWorkerLabelsRow, error) {
	rows, err := db.Query(ctx, getWorkerLabels, workerid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetWorkerLabelsRow
	for rows.Next() {
		var i GetWorkerLabelsRow
		if err := rows.Scan(&i.Key, &i.StrValue, &i.IntValue); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNonFinalChildStepRuns = `-- name: ListNonFinalChildStepRuns :many
WITH RECURSIVE currStepRun AS (
    SELECT id, "createdAt", "updatedAt", "deletedAt", "tenantId", "jobRunId", "stepId", "order", "workerId", "tickerId", status, input, output, "requeueAfter", "scheduleTimeoutAt", error, "startedAt", "finishedAt", "timeoutAt", "cancelledAt", "cancelledReason", "cancelledError", "inputSchema", "callerFiles", "gitRepoBranch", "retryCount", "semaphoreReleased", queue
    FROM "StepRun"
    WHERE
        "id" = $2::uuid AND
        "tenantId" = $1::uuid
), childStepRuns AS (
    SELECT sr."id", sr."status"
    FROM "StepRun" sr
    JOIN "_StepRunOrder" sro ON sr."id" = sro."B"
    WHERE sro."A" = (SELECT "id" FROM currStepRun)
        AND sr."deletedAt" IS NULL

    UNION ALL

    SELECT sr."id", sr."status"
    FROM "StepRun" sr
    JOIN "_StepRunOrder" sro ON sr."id" = sro."B"
    JOIN childStepRuns csr ON sro."A" = csr."id"
)
SELECT
    sr.id, sr."createdAt", sr."updatedAt", sr."deletedAt", sr."tenantId", sr."jobRunId", sr."stepId", sr."order", sr."workerId", sr."tickerId", sr.status, sr.input, sr.output, sr."requeueAfter", sr."scheduleTimeoutAt", sr.error, sr."startedAt", sr."finishedAt", sr."timeoutAt", sr."cancelledAt", sr."cancelledReason", sr."cancelledError", sr."inputSchema", sr."callerFiles", sr."gitRepoBranch", sr."retryCount", sr."semaphoreReleased", sr.queue
FROM
    "StepRun" sr
JOIN
    childStepRuns csr ON sr."id" = csr."id"
WHERE
    sr."tenantId" = $1::uuid AND
    sr."deletedAt" IS NULL AND
    sr."status" NOT IN ('SUCCEEDED', 'FAILED', 'CANCELLED')
`

type ListNonFinalChildStepRunsParams struct {
	Tenantid  pgtype.UUID `json:"tenantid"`
	Steprunid pgtype.UUID `json:"steprunid"`
}

// Select all child step runs that are not in a final state
func (q *Queries) ListNonFinalChildStepRuns(ctx context.Context, db DBTX, arg ListNonFinalChildStepRunsParams) ([]*StepRun, error) {
	rows, err := db.Query(ctx, listNonFinalChildStepRuns, arg.Tenantid, arg.Steprunid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepRun
	for rows.Next() {
		var i StepRun
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TenantId,
			&i.JobRunId,
			&i.StepId,
			&i.Order,
			&i.WorkerId,
			&i.TickerId,
			&i.Status,
			&i.Input,
			&i.Output,
			&i.RequeueAfter,
			&i.ScheduleTimeoutAt,
			&i.Error,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TimeoutAt,
			&i.CancelledAt,
			&i.CancelledReason,
			&i.CancelledError,
			&i.InputSchema,
			&i.CallerFiles,
			&i.GitRepoBranch,
			&i.RetryCount,
			&i.SemaphoreReleased,
			&i.Queue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSemaphoreSlotsToAssign = `-- name: ListSemaphoreSlotsToAssign :many
WITH actions AS (
    SELECT
        "id",
        "actionId"
    FROM
        "Action"
    WHERE
        "tenantId" = $1::uuid AND
        "actionId" = ANY($2::text[])
), valid_workers AS (
    SELECT
        w."id",
        a."actionId",
        w."dispatcherId"
    FROM
        "Worker" w
    JOIN
        "_ActionToWorker" atw ON w."id" = atw."B"
    JOIN
        actions a ON atw."A" = a."id"
    WHERE
        w."tenantId" = $1::uuid
        AND w."dispatcherId" IS NOT NULL
        AND w."lastHeartbeatAt" > NOW() - INTERVAL '5 seconds'
        AND w."isActive" = true
        AND w."isPaused" = false
)
SELECT
    wss."id",
    vw."id" AS "workerId",
    vw."dispatcherId",
    vw."actionId"
FROM
    "WorkerSemaphoreSlot" wss
JOIN
    valid_workers vw ON wss."workerId" = vw."id"
WHERE
    wss."stepRunId" IS NULL
FOR UPDATE SKIP LOCKED
`

type ListSemaphoreSlotsToAssignParams struct {
	Tenantid  pgtype.UUID `json:"tenantid"`
	Actionids []string    `json:"actionids"`
}

type ListSemaphoreSlotsToAssignRow struct {
	ID           pgtype.UUID `json:"id"`
	WorkerId     pgtype.UUID `json:"workerId"`
	DispatcherId pgtype.UUID `json:"dispatcherId"`
	ActionId     string      `json:"actionId"`
}

func (q *Queries) ListSemaphoreSlotsToAssign(ctx context.Context, db DBTX, arg ListSemaphoreSlotsToAssignParams) ([]*ListSemaphoreSlotsToAssignRow, error) {
	rows, err := db.Query(ctx, listSemaphoreSlotsToAssign, arg.Tenantid, arg.Actionids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListSemaphoreSlotsToAssignRow
	for rows.Next() {
		var i ListSemaphoreSlotsToAssignRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkerId,
			&i.DispatcherId,
			&i.ActionId,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStartableStepRuns = `-- name: ListStartableStepRuns :many
WITH job_run AS (
    SELECT "status", "deletedAt"
    FROM "JobRun"
    WHERE "id" = $1::uuid
)
SELECT
    DISTINCT ON (child_run."id")
    child_run."id" AS "id"
FROM
    "StepRun" AS child_run
LEFT JOIN
    "_StepRunOrder" AS step_run_order ON step_run_order."B" = child_run."id"
JOIN
    job_run ON true
WHERE
    child_run."jobRunId" = $1::uuid
    AND child_run."deletedAt" IS NULL
    AND job_run."deletedAt" IS NULL
    AND child_run."status" = 'PENDING'
    AND job_run."status" = 'RUNNING'
    -- case on whether parentStepRunId is null
    AND (
        ($2::uuid IS NULL AND step_run_order."A" IS NULL) OR
        (
            step_run_order."A" = $2::uuid
            AND NOT EXISTS (
                SELECT 1
                FROM "_StepRunOrder" AS parent_order
                JOIN "StepRun" AS parent_run ON parent_order."A" = parent_run."id"
                WHERE
                    parent_order."B" = child_run."id"
                    AND parent_run."status" != 'SUCCEEDED'
            )
        )
    )
`

type ListStartableStepRunsParams struct {
	Jobrunid        pgtype.UUID `json:"jobrunid"`
	ParentStepRunId pgtype.UUID `json:"parentStepRunId"`
}

func (q *Queries) ListStartableStepRuns(ctx context.Context, db DBTX, arg ListStartableStepRunsParams) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, listStartableStepRuns, arg.Jobrunid, arg.ParentStepRunId)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepRunArchives = `-- name: ListStepRunArchives :many
SELECT
    "StepRunResultArchive".id, "StepRunResultArchive"."createdAt", "StepRunResultArchive"."updatedAt", "StepRunResultArchive"."deletedAt", "StepRunResultArchive"."stepRunId", "StepRunResultArchive"."order", "StepRunResultArchive".input, "StepRunResultArchive".output, "StepRunResultArchive".error, "StepRunResultArchive"."startedAt", "StepRunResultArchive"."finishedAt", "StepRunResultArchive"."timeoutAt", "StepRunResultArchive"."cancelledAt", "StepRunResultArchive"."cancelledReason", "StepRunResultArchive"."cancelledError"
FROM
    "StepRunResultArchive"
JOIN
    "StepRun" ON "StepRunResultArchive"."stepRunId" = "StepRun"."id"
WHERE
    "StepRunResultArchive"."stepRunId" = $1::uuid AND
    "StepRun"."tenantId" = $2::uuid AND
    "StepRun"."deletedAt" IS NULL
ORDER BY
    "StepRunResultArchive"."createdAt"
OFFSET
    COALESCE($3, 0)
LIMIT
    COALESCE($4, 50)
`

type ListStepRunArchivesParams struct {
	Steprunid pgtype.UUID `json:"steprunid"`
	Tenantid  pgtype.UUID `json:"tenantid"`
	Offset    interface{} `json:"offset"`
	Limit     interface{} `json:"limit"`
}

func (q *Queries) ListStepRunArchives(ctx context.Context, db DBTX, arg ListStepRunArchivesParams) ([]*StepRunResultArchive, error) {
	rows, err := db.Query(ctx, listStepRunArchives,
		arg.Steprunid,
		arg.Tenantid,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepRunResultArchive
	for rows.Next() {
		var i StepRunResultArchive
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.StepRunId,
			&i.Order,
			&i.Input,
			&i.Output,
			&i.Error,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TimeoutAt,
			&i.CancelledAt,
			&i.CancelledReason,
			&i.CancelledError,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepRunEvents = `-- name: ListStepRunEvents :many
SELECT
    id, "timeFirstSeen", "timeLastSeen", "stepRunId", reason, severity, message, count, data
FROM
    "StepRunEvent"
WHERE
    "stepRunId" = $1::uuid
ORDER BY
    "id" DESC
OFFSET
    COALESCE($2, 0)
LIMIT
    COALESCE($3, 50)
`

type ListStepRunEventsParams struct {
	Steprunid pgtype.UUID `json:"steprunid"`
	Offset    interface{} `json:"offset"`
	Limit     interface{} `json:"limit"`
}

func (q *Queries) ListStepRunEvents(ctx context.Context, db DBTX, arg ListStepRunEventsParams) ([]*StepRunEvent, error) {
	rows, err := db.Query(ctx, listStepRunEvents, arg.Steprunid, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepRunEvent
	for rows.Next() {
		var i StepRunEvent
		if err := rows.Scan(
			&i.ID,
			&i.TimeFirstSeen,
			&i.TimeLastSeen,
			&i.StepRunId,
			&i.Reason,
			&i.Severity,
			&i.Message,
			&i.Count,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepRuns = `-- name: ListStepRuns :many
SELECT
    DISTINCT ON ("StepRun"."id")
    "StepRun"."id"
FROM
    "StepRun"
JOIN
    "JobRun" ON "StepRun"."jobRunId" = "JobRun"."id"
WHERE
    "StepRun"."deletedAt" IS NULL AND
    "JobRun"."deletedAt" IS NULL AND
    (
        $1::uuid IS NULL OR
        "StepRun"."tenantId" = $1::uuid
    )
    AND (
        $2::"StepRunStatus" IS NULL OR
        "StepRun"."status" = $2::"StepRunStatus"
    )
    AND (
        $3::uuid[] IS NULL OR
        "JobRun"."workflowRunId" = ANY($3::uuid[])
    )
    AND (
        $4::uuid IS NULL OR
        "StepRun"."jobRunId" = $4::uuid
    )
    AND (
        $5::uuid IS NULL OR
        "StepRun"."tickerId" = $5::uuid
    )
`

type ListStepRunsParams struct {
	TenantId       pgtype.UUID       `json:"tenantId"`
	Status         NullStepRunStatus `json:"status"`
	WorkflowRunIds []pgtype.UUID     `json:"workflowRunIds"`
	JobRunId       pgtype.UUID       `json:"jobRunId"`
	TickerId       pgtype.UUID       `json:"tickerId"`
}

func (q *Queries) ListStepRuns(ctx context.Context, db DBTX, arg ListStepRunsParams) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, listStepRuns,
		arg.TenantId,
		arg.Status,
		arg.WorkflowRunIds,
		arg.JobRunId,
		arg.TickerId,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepRunsToReassign = `-- name: ListStepRunsToReassign :many
WITH inactive_workers AS (
    SELECT
        w."id"
    FROM
        "Worker" w
    WHERE
        w."tenantId" = $1::uuid
        AND w."lastHeartbeatAt" < NOW() - INTERVAL '30 seconds'
),
step_runs_to_reassign AS (
    SELECT "stepRunId"
    FROM "WorkerSemaphoreSlot"
    WHERE
        "workerId" = ANY(SELECT "id" FROM inactive_workers)
        AND "stepRunId" IS NOT NULL
    FOR UPDATE SKIP LOCKED
),
update_semaphore_steps AS (
    UPDATE "WorkerSemaphoreSlot" wss
    SET "stepRunId" = NULL
    FROM step_runs_to_reassign
    WHERE wss."stepRunId" = step_runs_to_reassign."stepRunId"
),
step_runs_with_data AS (
    SELECT
        sr."id",
        sr."tenantId",
        sr."scheduleTimeoutAt",
        s."actionId",
        s."id" AS "stepId",
        s."timeout" AS "stepTimeout"
    FROM
        "StepRun" sr
    JOIN
        "Step" s ON sr."stepId" = s."id"
    WHERE
        sr."id" = ANY(SELECT "stepRunId" FROM step_runs_to_reassign)
),
inserted_queue_items AS (
    INSERT INTO "QueueItem" (
        "stepRunId",
        "stepId",
        "actionId",
        "scheduleTimeoutAt",
        "stepTimeout",
        "priority",
        "isQueued",
        "tenantId",
        "queue"
    )
    SELECT
        srs."id",
        srs."stepId",
        srs."actionId",
        -- FIXME: this should be configurable. It doesn't make sense to use the existing scheduleTimeoutAt
        -- as we might be well past that time.
        NOW() + INTERVAL '5 minutes',
        srs."stepTimeout",
        -- Queue with priority 4 so that reassignment gets highest priority
        4,
        true,
        srs."tenantId",
        srs."actionId"
    FROM
        step_runs_with_data srs
)
SELECT
    srs."id"
FROM
    step_runs_with_data srs
`

func (q *Queries) ListStepRunsToReassign(ctx context.Context, db DBTX, tenantid pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, listStepRunsToReassign, tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepRunsToTimeout = `-- name: ListStepRunsToTimeout :many
SELECT "id"
FROM "StepRun"
WHERE
    "status" = ANY(ARRAY['RUNNING', 'ASSIGNED']::"StepRunStatus"[])
    AND "timeoutAt" < NOW()
    AND "tenantId" = $1::uuid
LIMIT 100
`

func (q *Queries) ListStepRunsToTimeout(ctx context.Context, db DBTX, tenantid pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, listStepRunsToTimeout, tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshTimeoutBy = `-- name: RefreshTimeoutBy :one
UPDATE
    "StepRun" sr
SET
    "timeoutAt" = CASE
        -- Only update timeoutAt if the step run is currently in RUNNING status
        WHEN sr."status" = 'RUNNING' THEN
            COALESCE(sr."timeoutAt", CURRENT_TIMESTAMP) + convert_duration_to_interval($1::text)
            ELSE sr."timeoutAt"
        END,
    "updatedAt" = CURRENT_TIMESTAMP
WHERE
    "id" = $2::uuid AND
    "tenantId" = $3::uuid
RETURNING id, "createdAt", "updatedAt", "deletedAt", "tenantId", "jobRunId", "stepId", "order", "workerId", "tickerId", status, input, output, "requeueAfter", "scheduleTimeoutAt", error, "startedAt", "finishedAt", "timeoutAt", "cancelledAt", "cancelledReason", "cancelledError", "inputSchema", "callerFiles", "gitRepoBranch", "retryCount", "semaphoreReleased", queue
`

type RefreshTimeoutByParams struct {
	IncrementTimeoutBy pgtype.Text `json:"incrementTimeoutBy"`
	Steprunid          pgtype.UUID `json:"steprunid"`
	Tenantid           pgtype.UUID `json:"tenantid"`
}

func (q *Queries) RefreshTimeoutBy(ctx context.Context, db DBTX, arg RefreshTimeoutByParams) (*StepRun, error) {
	row := db.QueryRow(ctx, refreshTimeoutBy, arg.IncrementTimeoutBy, arg.Steprunid, arg.Tenantid)
	var i StepRun
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.JobRunId,
		&i.StepId,
		&i.Order,
		&i.WorkerId,
		&i.TickerId,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.RequeueAfter,
		&i.ScheduleTimeoutAt,
		&i.Error,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TimeoutAt,
		&i.CancelledAt,
		&i.CancelledReason,
		&i.CancelledError,
		&i.InputSchema,
		&i.CallerFiles,
		&i.GitRepoBranch,
		&i.RetryCount,
		&i.SemaphoreReleased,
		&i.Queue,
	)
	return &i, err
}

const releaseWorkerSemaphoreSlot = `-- name: ReleaseWorkerSemaphoreSlot :one
WITH step_run as (
  SELECT "workerId"
  FROM "StepRun"
  WHERE "id" = $1::uuid AND "tenantId" = $2::uuid
)
UPDATE "WorkerSemaphoreSlot"
    SET "stepRunId" = NULL
WHERE "stepRunId" = $1::uuid
  AND "workerId" = (SELECT "workerId" FROM step_run)
RETURNING id, "workerId", "stepRunId"
`

type ReleaseWorkerSemaphoreSlotParams struct {
	Steprunid pgtype.UUID `json:"steprunid"`
	Tenantid  pgtype.UUID `json:"tenantid"`
}

func (q *Queries) ReleaseWorkerSemaphoreSlot(ctx context.Context, db DBTX, arg ReleaseWorkerSemaphoreSlotParams) (*WorkerSemaphoreSlot, error) {
	row := db.QueryRow(ctx, releaseWorkerSemaphoreSlot, arg.Steprunid, arg.Tenantid)
	var i WorkerSemaphoreSlot
	err := row.Scan(&i.ID, &i.WorkerId, &i.StepRunId)
	return &i, err
}

const replayStepRunResetJobRun = `-- name: ReplayStepRunResetJobRun :one
UPDATE
    "JobRun"
SET
    "status" = 'RUNNING',
    "updatedAt" = CURRENT_TIMESTAMP,
    "startedAt" = NULL,
    "finishedAt" = NULL,
    "timeoutAt" = NULL,
    "cancelledAt" = NULL,
    "cancelledReason" = NULL,
    "cancelledError" = NULL
WHERE
    "id" = $1::uuid
RETURNING id, "createdAt", "updatedAt", "deletedAt", "tenantId", "jobId", "tickerId", status, result, "startedAt", "finishedAt", "timeoutAt", "cancelledAt", "cancelledReason", "cancelledError", "workflowRunId"
`

func (q *Queries) ReplayStepRunResetJobRun(ctx context.Context, db DBTX, jobrunid pgtype.UUID) (*JobRun, error) {
	row := db.QueryRow(ctx, replayStepRunResetJobRun, jobrunid)
	var i JobRun
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.JobId,
		&i.TickerId,
		&i.Status,
		&i.Result,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TimeoutAt,
		&i.CancelledAt,
		&i.CancelledReason,
		&i.CancelledError,
		&i.WorkflowRunId,
	)
	return &i, err
}

const replayStepRunResetLaterStepRuns = `-- name: ReplayStepRunResetLaterStepRuns :many
WITH RECURSIVE currStepRun AS (
    SELECT id, "createdAt", "updatedAt", "deletedAt", "tenantId", "jobRunId", "stepId", "order", "workerId", "tickerId", status, input, output, "requeueAfter", "scheduleTimeoutAt", error, "startedAt", "finishedAt", "timeoutAt", "cancelledAt", "cancelledReason", "cancelledError", "inputSchema", "callerFiles", "gitRepoBranch", "retryCount", "semaphoreReleased", queue
    FROM "StepRun"
    WHERE
        "id" = $2::uuid AND
        "tenantId" = $1::uuid
), childStepRuns AS (
    SELECT sr."id", sr."status"
    FROM "StepRun" sr
    JOIN "_StepRunOrder" sro ON sr."id" = sro."B"
    WHERE sro."A" = (SELECT "id" FROM currStepRun)

    UNION ALL

    SELECT sr."id", sr."status"
    FROM "StepRun" sr
    JOIN "_StepRunOrder" sro ON sr."id" = sro."B"
    JOIN childStepRuns csr ON sro."A" = csr."id"
)
UPDATE
    "StepRun" as sr
SET
    "status" = 'PENDING',
    "scheduleTimeoutAt" = NULL,
    "finishedAt" = NULL,
    "startedAt" = NULL,
    "output" = NULL,
    "error" = NULL,
    "cancelledAt" = NULL,
    "cancelledReason" = NULL,
    "input" = NULL
FROM
    childStepRuns csr
WHERE
    sr."id" = csr."id" AND
    sr."tenantId" = $1::uuid
RETURNING sr.id, sr."createdAt", sr."updatedAt", sr."deletedAt", sr."tenantId", sr."jobRunId", sr."stepId", sr."order", sr."workerId", sr."tickerId", sr.status, sr.input, sr.output, sr."requeueAfter", sr."scheduleTimeoutAt", sr.error, sr."startedAt", sr."finishedAt", sr."timeoutAt", sr."cancelledAt", sr."cancelledReason", sr."cancelledError", sr."inputSchema", sr."callerFiles", sr."gitRepoBranch", sr."retryCount", sr."semaphoreReleased", sr.queue
`

type ReplayStepRunResetLaterStepRunsParams struct {
	Tenantid  pgtype.UUID `json:"tenantid"`
	Steprunid pgtype.UUID `json:"steprunid"`
}

func (q *Queries) ReplayStepRunResetLaterStepRuns(ctx context.Context, db DBTX, arg ReplayStepRunResetLaterStepRunsParams) ([]*StepRun, error) {
	rows, err := db.Query(ctx, replayStepRunResetLaterStepRuns, arg.Tenantid, arg.Steprunid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepRun
	for rows.Next() {
		var i StepRun
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TenantId,
			&i.JobRunId,
			&i.StepId,
			&i.Order,
			&i.WorkerId,
			&i.TickerId,
			&i.Status,
			&i.Input,
			&i.Output,
			&i.RequeueAfter,
			&i.ScheduleTimeoutAt,
			&i.Error,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TimeoutAt,
			&i.CancelledAt,
			&i.CancelledReason,
			&i.CancelledError,
			&i.InputSchema,
			&i.CallerFiles,
			&i.GitRepoBranch,
			&i.RetryCount,
			&i.SemaphoreReleased,
			&i.Queue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const replayStepRunResetWorkflowRun = `-- name: ReplayStepRunResetWorkflowRun :one
UPDATE
    "WorkflowRun"
SET
    "status" = 'PENDING',
    "updatedAt" = CURRENT_TIMESTAMP,
    "startedAt" = NULL,
    "finishedAt" = NULL,
    "duration" = NULL
WHERE
    "id" =  $1::uuid
RETURNING "createdAt", "updatedAt", "deletedAt", "tenantId", "workflowVersionId", status, error, "startedAt", "finishedAt", "concurrencyGroupId", "displayName", id, "childIndex", "childKey", "parentId", "parentStepRunId", "additionalMetadata", duration
`

func (q *Queries) ReplayStepRunResetWorkflowRun(ctx context.Context, db DBTX, workflowrunid pgtype.UUID) (*WorkflowRun, error) {
	row := db.QueryRow(ctx, replayStepRunResetWorkflowRun, workflowrunid)
	var i WorkflowRun
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.WorkflowVersionId,
		&i.Status,
		&i.Error,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ConcurrencyGroupId,
		&i.DisplayName,
		&i.ID,
		&i.ChildIndex,
		&i.ChildKey,
		&i.ParentId,
		&i.ParentStepRunId,
		&i.AdditionalMetadata,
		&i.Duration,
	)
	return &i, err
}

const resetStepRunsByIds = `-- name: ResetStepRunsByIds :many
UPDATE
    "StepRun" as sr
SET
    "status" = 'PENDING',
    "scheduleTimeoutAt" = NULL,
    "finishedAt" = NULL,
    "startedAt" = NULL,
    "output" = NULL,
    "error" = NULL,
    "cancelledAt" = NULL,
    "cancelledReason" = NULL,
    "input" = NULL
WHERE
    sr."id" = ANY($1::uuid[]) AND
    sr."tenantId" = $2::uuid
RETURNING sr.id, sr."createdAt", sr."updatedAt", sr."deletedAt", sr."tenantId", sr."jobRunId", sr."stepId", sr."order", sr."workerId", sr."tickerId", sr.status, sr.input, sr.output, sr."requeueAfter", sr."scheduleTimeoutAt", sr.error, sr."startedAt", sr."finishedAt", sr."timeoutAt", sr."cancelledAt", sr."cancelledReason", sr."cancelledError", sr."inputSchema", sr."callerFiles", sr."gitRepoBranch", sr."retryCount", sr."semaphoreReleased", sr.queue
`

type ResetStepRunsByIdsParams struct {
	Ids      []pgtype.UUID `json:"ids"`
	Tenantid pgtype.UUID   `json:"tenantid"`
}

func (q *Queries) ResetStepRunsByIds(ctx context.Context, db DBTX, arg ResetStepRunsByIdsParams) ([]*StepRun, error) {
	rows, err := db.Query(ctx, resetStepRunsByIds, arg.Ids, arg.Tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepRun
	for rows.Next() {
		var i StepRun
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TenantId,
			&i.JobRunId,
			&i.StepId,
			&i.Order,
			&i.WorkerId,
			&i.TickerId,
			&i.Status,
			&i.Input,
			&i.Output,
			&i.RequeueAfter,
			&i.ScheduleTimeoutAt,
			&i.Error,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TimeoutAt,
			&i.CancelledAt,
			&i.CancelledReason,
			&i.CancelledError,
			&i.InputSchema,
			&i.CallerFiles,
			&i.GitRepoBranch,
			&i.RetryCount,
			&i.SemaphoreReleased,
			&i.Queue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveLaterStepRuns = `-- name: ResolveLaterStepRuns :many
WITH RECURSIVE currStepRun AS (
  SELECT id, "createdAt", "updatedAt", "deletedAt", "tenantId", "jobRunId", "stepId", "order", "workerId", "tickerId", status, input, output, "requeueAfter", "scheduleTimeoutAt", error, "startedAt", "finishedAt", "timeoutAt", "cancelledAt", "cancelledReason", "cancelledError", "inputSchema", "callerFiles", "gitRepoBranch", "retryCount", "semaphoreReleased", queue
  FROM "StepRun"
  WHERE
    "id" = $2::uuid AND
    "tenantId" = $1::uuid
), childStepRuns AS (
  SELECT sr."id", sr."status"
  FROM "StepRun" sr
  JOIN "_StepRunOrder" sro ON sr."id" = sro."B"
  WHERE sro."A" = (SELECT "id" FROM currStepRun)

  UNION ALL

  SELECT sr."id", sr."status"
  FROM "StepRun" sr
  JOIN "_StepRunOrder" sro ON sr."id" = sro."B"
  JOIN childStepRuns csr ON sro."A" = csr."id"
)
UPDATE
    "StepRun" as sr
SET  "status" = CASE
    -- When the step is in a final state, it cannot be updated
    WHEN sr."status" IN ('SUCCEEDED', 'FAILED', 'CANCELLED') THEN sr."status"
    -- When the given step run has failed or been cancelled, then all child step runs are cancelled
    WHEN (SELECT "status" FROM currStepRun) IN ('FAILED', 'CANCELLED') THEN 'CANCELLED'
    ELSE sr."status"
    END,
    -- When the previous step run timed out, the cancelled reason is set
    "cancelledReason" = CASE
    -- When the step is in a final state, it cannot be updated
    WHEN sr."status" IN ('SUCCEEDED', 'FAILED', 'CANCELLED') THEN sr."cancelledReason"
    WHEN (SELECT "status" FROM currStepRun) = 'CANCELLED' AND (SELECT "cancelledReason" FROM currStepRun) = 'TIMED_OUT'::text THEN 'PREVIOUS_STEP_TIMED_OUT'
    WHEN (SELECT "status" FROM currStepRun) = 'FAILED' THEN 'PREVIOUS_STEP_FAILED'
    WHEN (SELECT "status" FROM currStepRun) = 'CANCELLED' THEN 'PREVIOUS_STEP_CANCELLED'
    ELSE NULL
    END
FROM
    childStepRuns csr
WHERE
    sr."id" = csr."id" AND
    sr."tenantId" = $1::uuid
RETURNING sr.id, sr."createdAt", sr."updatedAt", sr."deletedAt", sr."tenantId", sr."jobRunId", sr."stepId", sr."order", sr."workerId", sr."tickerId", sr.status, sr.input, sr.output, sr."requeueAfter", sr."scheduleTimeoutAt", sr.error, sr."startedAt", sr."finishedAt", sr."timeoutAt", sr."cancelledAt", sr."cancelledReason", sr."cancelledError", sr."inputSchema", sr."callerFiles", sr."gitRepoBranch", sr."retryCount", sr."semaphoreReleased", sr.queue
`

type ResolveLaterStepRunsParams struct {
	Tenantid  pgtype.UUID `json:"tenantid"`
	Steprunid pgtype.UUID `json:"steprunid"`
}

func (q *Queries) ResolveLaterStepRuns(ctx context.Context, db DBTX, arg ResolveLaterStepRunsParams) ([]*StepRun, error) {
	rows, err := db.Query(ctx, resolveLaterStepRuns, arg.Tenantid, arg.Steprunid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepRun
	for rows.Next() {
		var i StepRun
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TenantId,
			&i.JobRunId,
			&i.StepId,
			&i.Order,
			&i.WorkerId,
			&i.TickerId,
			&i.Status,
			&i.Input,
			&i.Output,
			&i.RequeueAfter,
			&i.ScheduleTimeoutAt,
			&i.Error,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TimeoutAt,
			&i.CancelledAt,
			&i.CancelledReason,
			&i.CancelledError,
			&i.InputSchema,
			&i.CallerFiles,
			&i.GitRepoBranch,
			&i.RetryCount,
			&i.SemaphoreReleased,
			&i.Queue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unlinkStepRunFromWorker = `-- name: UnlinkStepRunFromWorker :one
UPDATE
    "StepRun"
SET
    "workerId" = NULL
WHERE
    "id" = $1::uuid AND
    "tenantId" = $2::uuid
RETURNING id, "createdAt", "updatedAt", "deletedAt", "tenantId", "jobRunId", "stepId", "order", "workerId", "tickerId", status, input, output, "requeueAfter", "scheduleTimeoutAt", error, "startedAt", "finishedAt", "timeoutAt", "cancelledAt", "cancelledReason", "cancelledError", "inputSchema", "callerFiles", "gitRepoBranch", "retryCount", "semaphoreReleased", queue
`

type UnlinkStepRunFromWorkerParams struct {
	Steprunid pgtype.UUID `json:"steprunid"`
	Tenantid  pgtype.UUID `json:"tenantid"`
}

func (q *Queries) UnlinkStepRunFromWorker(ctx context.Context, db DBTX, arg UnlinkStepRunFromWorkerParams) (*StepRun, error) {
	row := db.QueryRow(ctx, unlinkStepRunFromWorker, arg.Steprunid, arg.Tenantid)
	var i StepRun
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.JobRunId,
		&i.StepId,
		&i.Order,
		&i.WorkerId,
		&i.TickerId,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.RequeueAfter,
		&i.ScheduleTimeoutAt,
		&i.Error,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TimeoutAt,
		&i.CancelledAt,
		&i.CancelledReason,
		&i.CancelledError,
		&i.InputSchema,
		&i.CallerFiles,
		&i.GitRepoBranch,
		&i.RetryCount,
		&i.SemaphoreReleased,
		&i.Queue,
	)
	return &i, err
}

const updateStepRun = `-- name: UpdateStepRun :one
UPDATE
    "StepRun"
SET
    "requeueAfter" = COALESCE($1::timestamp, "requeueAfter"),
    "scheduleTimeoutAt" = CASE
        -- if this is a rerun, we clear the scheduleTimeoutAt
        WHEN $2::boolean THEN NULL
        ELSE COALESCE($3::timestamp, "scheduleTimeoutAt")
    END,
    "startedAt" = COALESCE($4::timestamp, "startedAt"),
    "finishedAt" = CASE
        -- if this is a rerun, we clear the finishedAt
        WHEN $2::boolean THEN NULL
        ELSE  COALESCE($5::timestamp, "finishedAt")
    END,
    "status" = CASE
        -- if this is a rerun, we permit status updates
        WHEN $2::boolean THEN COALESCE($6, "status")
        -- Final states are final, cannot be updated
        WHEN "status" IN ('SUCCEEDED', 'FAILED', 'CANCELLED') THEN "status"
        ELSE COALESCE($6, "status")
    END,
    "input" = COALESCE($7::jsonb, "input"),
    "output" = CASE
        -- if this is a rerun, we clear the output
        WHEN $2::boolean THEN NULL
        ELSE COALESCE($8::jsonb, "output")
    END,
    "error" = CASE
        -- if this is a rerun, we clear the error
        WHEN $2::boolean THEN NULL
        ELSE COALESCE($9::text, "error")
    END,
    "cancelledAt" = CASE
        -- if this is a rerun, we clear the cancelledAt
        WHEN $2::boolean THEN NULL
        ELSE COALESCE($10::timestamp, "cancelledAt")
    END,
    "cancelledReason" = CASE
        -- if this is a rerun, we clear the cancelledReason
        WHEN $2::boolean THEN NULL
        ELSE COALESCE($11::text, "cancelledReason")
    END,
    "retryCount" = COALESCE($12::int, "retryCount"),
    "semaphoreReleased" = COALESCE($13::boolean, "semaphoreReleased")
WHERE
  "id" = $14::uuid AND
  "tenantId" = $15::uuid
RETURNING "StepRun".id, "StepRun"."createdAt", "StepRun"."updatedAt", "StepRun"."deletedAt", "StepRun"."tenantId", "StepRun"."jobRunId", "StepRun"."stepId", "StepRun"."order", "StepRun"."workerId", "StepRun"."tickerId", "StepRun".status, "StepRun".input, "StepRun".output, "StepRun"."requeueAfter", "StepRun"."scheduleTimeoutAt", "StepRun".error, "StepRun"."startedAt", "StepRun"."finishedAt", "StepRun"."timeoutAt", "StepRun"."cancelledAt", "StepRun"."cancelledReason", "StepRun"."cancelledError", "StepRun"."inputSchema", "StepRun"."callerFiles", "StepRun"."gitRepoBranch", "StepRun"."retryCount", "StepRun"."semaphoreReleased", "StepRun".queue
`

type UpdateStepRunParams struct {
	RequeueAfter      pgtype.Timestamp  `json:"requeueAfter"`
	Rerun             pgtype.Bool       `json:"rerun"`
	ScheduleTimeoutAt pgtype.Timestamp  `json:"scheduleTimeoutAt"`
	StartedAt         pgtype.Timestamp  `json:"startedAt"`
	FinishedAt        pgtype.Timestamp  `json:"finishedAt"`
	Status            NullStepRunStatus `json:"status"`
	Input             []byte            `json:"input"`
	Output            []byte            `json:"output"`
	Error             pgtype.Text       `json:"error"`
	CancelledAt       pgtype.Timestamp  `json:"cancelledAt"`
	CancelledReason   pgtype.Text       `json:"cancelledReason"`
	RetryCount        pgtype.Int4       `json:"retryCount"`
	SemaphoreReleased pgtype.Bool       `json:"semaphoreReleased"`
	ID                pgtype.UUID       `json:"id"`
	Tenantid          pgtype.UUID       `json:"tenantid"`
}

func (q *Queries) UpdateStepRun(ctx context.Context, db DBTX, arg UpdateStepRunParams) (*StepRun, error) {
	row := db.QueryRow(ctx, updateStepRun,
		arg.RequeueAfter,
		arg.Rerun,
		arg.ScheduleTimeoutAt,
		arg.StartedAt,
		arg.FinishedAt,
		arg.Status,
		arg.Input,
		arg.Output,
		arg.Error,
		arg.CancelledAt,
		arg.CancelledReason,
		arg.RetryCount,
		arg.SemaphoreReleased,
		arg.ID,
		arg.Tenantid,
	)
	var i StepRun
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.JobRunId,
		&i.StepId,
		&i.Order,
		&i.WorkerId,
		&i.TickerId,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.RequeueAfter,
		&i.ScheduleTimeoutAt,
		&i.Error,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TimeoutAt,
		&i.CancelledAt,
		&i.CancelledReason,
		&i.CancelledError,
		&i.InputSchema,
		&i.CallerFiles,
		&i.GitRepoBranch,
		&i.RetryCount,
		&i.SemaphoreReleased,
		&i.Queue,
	)
	return &i, err
}

const updateStepRunInputSchema = `-- name: UpdateStepRunInputSchema :one
UPDATE
    "StepRun" sr
SET
    "inputSchema" = coalesce($1::jsonb, '{}'),
    "updatedAt" = CURRENT_TIMESTAMP
WHERE
    sr."tenantId" = $2::uuid AND
    sr."id" = $3::uuid
RETURNING "inputSchema"
`

type UpdateStepRunInputSchemaParams struct {
	InputSchema []byte      `json:"inputSchema"`
	Tenantid    pgtype.UUID `json:"tenantid"`
	Steprunid   pgtype.UUID `json:"steprunid"`
}

func (q *Queries) UpdateStepRunInputSchema(ctx context.Context, db DBTX, arg UpdateStepRunInputSchemaParams) ([]byte, error) {
	row := db.QueryRow(ctx, updateStepRunInputSchema, arg.InputSchema, arg.Tenantid, arg.Steprunid)
	var inputSchema []byte
	err := row.Scan(&inputSchema)
	return inputSchema, err
}

const updateStepRunOverridesData = `-- name: UpdateStepRunOverridesData :one
UPDATE
    "StepRun" AS sr
SET
    "updatedAt" = CURRENT_TIMESTAMP,
    "input" = jsonb_set("input", $1::text[], $2::jsonb, true),
    "callerFiles" = jsonb_set("callerFiles", $3::text[], to_jsonb($4::text), true)
WHERE
    sr."tenantId" = $5::uuid AND
    sr."id" = $6::uuid
RETURNING "input"
`

type UpdateStepRunOverridesDataParams struct {
	Fieldpath    []string    `json:"fieldpath"`
	Jsondata     []byte      `json:"jsondata"`
	Overrideskey []string    `json:"overrideskey"`
	Callerfile   string      `json:"callerfile"`
	Tenantid     pgtype.UUID `json:"tenantid"`
	Steprunid    pgtype.UUID `json:"steprunid"`
}

func (q *Queries) UpdateStepRunOverridesData(ctx context.Context, db DBTX, arg UpdateStepRunOverridesDataParams) ([]byte, error) {
	row := db.QueryRow(ctx, updateStepRunOverridesData,
		arg.Fieldpath,
		arg.Jsondata,
		arg.Overrideskey,
		arg.Callerfile,
		arg.Tenantid,
		arg.Steprunid,
	)
	var input []byte
	err := row.Scan(&input)
	return input, err
}

const upsertDesiredWorkerLabel = `-- name: UpsertDesiredWorkerLabel :one
INSERT INTO "StepDesiredWorkerLabel" (
    "createdAt",
    "updatedAt",
    "stepId",
    "key",
    "intValue",
    "strValue",
    "required",
    "weight",
    "comparator"
) VALUES (
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    $1::uuid,
    $2::text,
    COALESCE($3::int, NULL),
    COALESCE($4::text, NULL),
    COALESCE($5::boolean, false),
    COALESCE($6::int, 100),
    COALESCE($7::"WorkerLabelComparator", 'EQUAL')
) ON CONFLICT ("stepId", "key") DO UPDATE
SET
    "updatedAt" = CURRENT_TIMESTAMP,
    "intValue" = COALESCE($3::int, null),
    "strValue" = COALESCE($4::text, null),
    "required" = COALESCE($5::boolean, false),
    "weight" = COALESCE($6::int, 100),
    "comparator" = COALESCE($7::"WorkerLabelComparator", 'EQUAL')
RETURNING id, "createdAt", "updatedAt", "stepId", key, "strValue", "intValue", required, comparator, weight
`

type UpsertDesiredWorkerLabelParams struct {
	Stepid     pgtype.UUID               `json:"stepid"`
	Key        string                    `json:"key"`
	IntValue   pgtype.Int4               `json:"intValue"`
	StrValue   pgtype.Text               `json:"strValue"`
	Required   pgtype.Bool               `json:"required"`
	Weight     pgtype.Int4               `json:"weight"`
	Comparator NullWorkerLabelComparator `json:"comparator"`
}

func (q *Queries) UpsertDesiredWorkerLabel(ctx context.Context, db DBTX, arg UpsertDesiredWorkerLabelParams) (*StepDesiredWorkerLabel, error) {
	row := db.QueryRow(ctx, upsertDesiredWorkerLabel,
		arg.Stepid,
		arg.Key,
		arg.IntValue,
		arg.StrValue,
		arg.Required,
		arg.Weight,
		arg.Comparator,
	)
	var i StepDesiredWorkerLabel
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StepId,
		&i.Key,
		&i.StrValue,
		&i.IntValue,
		&i.Required,
		&i.Comparator,
		&i.Weight,
	)
	return &i, err
}
