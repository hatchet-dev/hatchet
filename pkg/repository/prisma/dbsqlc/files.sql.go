// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: files.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFile = `-- name: CreateFile :one
INSERT INTO "File" (
    "id",
    "createdAt",
    "updatedAt",
    "deletedAt",
    "fileName",
    "filePath",
    "tenantId",
    "additionalMetadata"
) VALUES (
    $1::uuid,
    coalesce($2::timestamp, CURRENT_TIMESTAMP),
    coalesce($3::timestamp, CURRENT_TIMESTAMP),
    $4::timestamp,
    $5::text,
    $6::text,
    $7::uuid,
    $8::jsonb
) RETURNING id, "createdAt", "updatedAt", "deletedAt", "tenantId", "additionalMetadata", "fileName", "filePath"
`

type CreateFileParams struct {
	ID                 pgtype.UUID      `json:"id"`
	CreatedAt          pgtype.Timestamp `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	Deletedat          pgtype.Timestamp `json:"deletedat"`
	Filename           string           `json:"filename"`
	Filepath           string           `json:"filepath"`
	Tenantid           pgtype.UUID      `json:"tenantid"`
	Additionalmetadata []byte           `json:"additionalmetadata"`
}

func (q *Queries) CreateFile(ctx context.Context, db DBTX, arg CreateFileParams) (*File, error) {
	row := db.QueryRow(ctx, createFile,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Deletedat,
		arg.Filename,
		arg.Filepath,
		arg.Tenantid,
		arg.Additionalmetadata,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.AdditionalMetadata,
		&i.FileName,
		&i.FilePath,
	)
	return &i, err
}

const getFileByID = `-- name: GetFileByID :one
SELECT
    id, "createdAt", "updatedAt", "deletedAt", "tenantId", "additionalMetadata", "fileName", "filePath"
FROM
    "File"
WHERE
    "deletedAt" IS NOT NULL AND
    "id" = $1::uuid
`

func (q *Queries) GetFileByID(ctx context.Context, db DBTX, id pgtype.UUID) (*File, error) {
	row := db.QueryRow(ctx, getFileByID, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.AdditionalMetadata,
		&i.FileName,
		&i.FilePath,
	)
	return &i, err
}

const listFilesByIDs = `-- name: ListFilesByIDs :many
SELECT
    id, "createdAt", "updatedAt", "deletedAt", "tenantId", "additionalMetadata", "fileName", "filePath"
FROM
    "File" as files
WHERE
    files."deletedAt" IS NOT NULL AND
    "tenantId" = $1::uuid AND
    "id" = ANY ($2::uuid[])
`

type ListFilesByIDsParams struct {
	Tenantid pgtype.UUID   `json:"tenantid"`
	Ids      []pgtype.UUID `json:"ids"`
}

func (q *Queries) ListFilesByIDs(ctx context.Context, db DBTX, arg ListFilesByIDsParams) ([]*File, error) {
	rows, err := db.Query(ctx, listFilesByIDs, arg.Tenantid, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TenantId,
			&i.AdditionalMetadata,
			&i.FileName,
			&i.FilePath,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
