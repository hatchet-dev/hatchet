// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: dispatchers.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDispatcher = `-- name: CreateDispatcher :one
INSERT INTO
    "Dispatcher" ("id", "lastHeartbeatAt", "isActive")
VALUES
    ($1::uuid, CURRENT_TIMESTAMP, 't')
RETURNING id, "createdAt", "updatedAt", "deletedAt", "lastHeartbeatAt", "isActive"
`

func (q *Queries) CreateDispatcher(ctx context.Context, db DBTX, id pgtype.UUID) (*Dispatcher, error) {
	row := db.QueryRow(ctx, createDispatcher, id)
	var i Dispatcher
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.LastHeartbeatAt,
		&i.IsActive,
	)
	return &i, err
}

const deleteDispatcher = `-- name: DeleteDispatcher :one
DELETE FROM
    "Dispatcher" as dispatchers
WHERE
    "id" = $1::uuid
RETURNING id, "createdAt", "updatedAt", "deletedAt", "lastHeartbeatAt", "isActive"
`

func (q *Queries) DeleteDispatcher(ctx context.Context, db DBTX, id pgtype.UUID) (*Dispatcher, error) {
	row := db.QueryRow(ctx, deleteDispatcher, id)
	var i Dispatcher
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.LastHeartbeatAt,
		&i.IsActive,
	)
	return &i, err
}

const listActiveDispatchers = `-- name: ListActiveDispatchers :many
SELECT
    dispatchers.id, dispatchers."createdAt", dispatchers."updatedAt", dispatchers."deletedAt", dispatchers."lastHeartbeatAt", dispatchers."isActive"
FROM "Dispatcher" as dispatchers
WHERE
    -- last heartbeat greater than 15 seconds
    "lastHeartbeatAt" > NOW () - INTERVAL '15 seconds'
    -- active
    AND "isActive" = true
`

type ListActiveDispatchersRow struct {
	Dispatcher Dispatcher `json:"dispatcher"`
}

func (q *Queries) ListActiveDispatchers(ctx context.Context, db DBTX) ([]*ListActiveDispatchersRow, error) {
	rows, err := db.Query(ctx, listActiveDispatchers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListActiveDispatchersRow
	for rows.Next() {
		var i ListActiveDispatchersRow
		if err := rows.Scan(
			&i.Dispatcher.ID,
			&i.Dispatcher.CreatedAt,
			&i.Dispatcher.UpdatedAt,
			&i.Dispatcher.DeletedAt,
			&i.Dispatcher.LastHeartbeatAt,
			&i.Dispatcher.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDispatchers = `-- name: ListDispatchers :many
SELECT
    dispatchers.id, dispatchers."createdAt", dispatchers."updatedAt", dispatchers."deletedAt", dispatchers."lastHeartbeatAt", dispatchers."isActive"
FROM
    "Dispatcher" as dispatchers
`

type ListDispatchersRow struct {
	Dispatcher Dispatcher `json:"dispatcher"`
}

func (q *Queries) ListDispatchers(ctx context.Context, db DBTX) ([]*ListDispatchersRow, error) {
	rows, err := db.Query(ctx, listDispatchers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListDispatchersRow
	for rows.Next() {
		var i ListDispatchersRow
		if err := rows.Scan(
			&i.Dispatcher.ID,
			&i.Dispatcher.CreatedAt,
			&i.Dispatcher.UpdatedAt,
			&i.Dispatcher.DeletedAt,
			&i.Dispatcher.LastHeartbeatAt,
			&i.Dispatcher.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaleDispatchers = `-- name: ListStaleDispatchers :many
SELECT
    dispatchers.id, dispatchers."createdAt", dispatchers."updatedAt", dispatchers."deletedAt", dispatchers."lastHeartbeatAt", dispatchers."isActive"
FROM "Dispatcher" as dispatchers
WHERE
    -- last heartbeat older than 15 seconds
    "lastHeartbeatAt" < NOW () - INTERVAL '15 seconds'
    -- not active
    AND "isActive" = false
`

type ListStaleDispatchersRow struct {
	Dispatcher Dispatcher `json:"dispatcher"`
}

func (q *Queries) ListStaleDispatchers(ctx context.Context, db DBTX) ([]*ListStaleDispatchersRow, error) {
	rows, err := db.Query(ctx, listStaleDispatchers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListStaleDispatchersRow
	for rows.Next() {
		var i ListStaleDispatchersRow
		if err := rows.Scan(
			&i.Dispatcher.ID,
			&i.Dispatcher.CreatedAt,
			&i.Dispatcher.UpdatedAt,
			&i.Dispatcher.DeletedAt,
			&i.Dispatcher.LastHeartbeatAt,
			&i.Dispatcher.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDispatchersInactive = `-- name: SetDispatchersInactive :many
UPDATE
    "Dispatcher" as dispatchers
SET
    "isActive" = false
WHERE
    "id" = ANY ($1::uuid[])
RETURNING
    dispatchers.id, dispatchers."createdAt", dispatchers."updatedAt", dispatchers."deletedAt", dispatchers."lastHeartbeatAt", dispatchers."isActive"
`

type SetDispatchersInactiveRow struct {
	Dispatcher Dispatcher `json:"dispatcher"`
}

func (q *Queries) SetDispatchersInactive(ctx context.Context, db DBTX, ids []pgtype.UUID) ([]*SetDispatchersInactiveRow, error) {
	rows, err := db.Query(ctx, setDispatchersInactive, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SetDispatchersInactiveRow
	for rows.Next() {
		var i SetDispatchersInactiveRow
		if err := rows.Scan(
			&i.Dispatcher.ID,
			&i.Dispatcher.CreatedAt,
			&i.Dispatcher.UpdatedAt,
			&i.Dispatcher.DeletedAt,
			&i.Dispatcher.LastHeartbeatAt,
			&i.Dispatcher.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDispatcher = `-- name: UpdateDispatcher :one
UPDATE
    "Dispatcher" as dispatchers
SET
    "lastHeartbeatAt" = $1::timestamp
WHERE
    "id" = $2::uuid
RETURNING id, "createdAt", "updatedAt", "deletedAt", "lastHeartbeatAt", "isActive"
`

type UpdateDispatcherParams struct {
	LastHeartbeatAt pgtype.Timestamp `json:"lastHeartbeatAt"`
	ID              pgtype.UUID      `json:"id"`
}

func (q *Queries) UpdateDispatcher(ctx context.Context, db DBTX, arg UpdateDispatcherParams) (*Dispatcher, error) {
	row := db.QueryRow(ctx, updateDispatcher, arg.LastHeartbeatAt, arg.ID)
	var i Dispatcher
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.LastHeartbeatAt,
		&i.IsActive,
	)
	return &i, err
}
