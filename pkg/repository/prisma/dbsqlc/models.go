// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0

package dbsqlc

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type ConcurrencyLimitStrategy string

const (
	ConcurrencyLimitStrategyCANCELINPROGRESS ConcurrencyLimitStrategy = "CANCEL_IN_PROGRESS"
	ConcurrencyLimitStrategyDROPNEWEST       ConcurrencyLimitStrategy = "DROP_NEWEST"
	ConcurrencyLimitStrategyQUEUENEWEST      ConcurrencyLimitStrategy = "QUEUE_NEWEST"
	ConcurrencyLimitStrategyGROUPROUNDROBIN  ConcurrencyLimitStrategy = "GROUP_ROUND_ROBIN"
	ConcurrencyLimitStrategyCANCELNEWEST     ConcurrencyLimitStrategy = "CANCEL_NEWEST"
)

func (e *ConcurrencyLimitStrategy) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ConcurrencyLimitStrategy(s)
	case string:
		*e = ConcurrencyLimitStrategy(s)
	default:
		return fmt.Errorf("unsupported scan type for ConcurrencyLimitStrategy: %T", src)
	}
	return nil
}

type NullConcurrencyLimitStrategy struct {
	ConcurrencyLimitStrategy ConcurrencyLimitStrategy `json:"ConcurrencyLimitStrategy"`
	Valid                    bool                     `json:"valid"` // Valid is true if ConcurrencyLimitStrategy is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullConcurrencyLimitStrategy) Scan(value interface{}) error {
	if value == nil {
		ns.ConcurrencyLimitStrategy, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ConcurrencyLimitStrategy.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullConcurrencyLimitStrategy) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ConcurrencyLimitStrategy), nil
}

type InternalQueue string

const (
	InternalQueueWORKERSEMAPHORECOUNT InternalQueue = "WORKER_SEMAPHORE_COUNT"
	InternalQueueSTEPRUNUPDATE        InternalQueue = "STEP_RUN_UPDATE"
	InternalQueueWORKFLOWRUNUPDATE    InternalQueue = "WORKFLOW_RUN_UPDATE"
	InternalQueueWORKFLOWRUNPAUSED    InternalQueue = "WORKFLOW_RUN_PAUSED"
	InternalQueueSTEPRUNUPDATEV2      InternalQueue = "STEP_RUN_UPDATE_V2"
)

func (e *InternalQueue) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InternalQueue(s)
	case string:
		*e = InternalQueue(s)
	default:
		return fmt.Errorf("unsupported scan type for InternalQueue: %T", src)
	}
	return nil
}

type NullInternalQueue struct {
	InternalQueue InternalQueue `json:"InternalQueue"`
	Valid         bool          `json:"valid"` // Valid is true if InternalQueue is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInternalQueue) Scan(value interface{}) error {
	if value == nil {
		ns.InternalQueue, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InternalQueue.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInternalQueue) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InternalQueue), nil
}

type InviteLinkStatus string

const (
	InviteLinkStatusPENDING  InviteLinkStatus = "PENDING"
	InviteLinkStatusACCEPTED InviteLinkStatus = "ACCEPTED"
	InviteLinkStatusREJECTED InviteLinkStatus = "REJECTED"
)

func (e *InviteLinkStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InviteLinkStatus(s)
	case string:
		*e = InviteLinkStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for InviteLinkStatus: %T", src)
	}
	return nil
}

type NullInviteLinkStatus struct {
	InviteLinkStatus InviteLinkStatus `json:"InviteLinkStatus"`
	Valid            bool             `json:"valid"` // Valid is true if InviteLinkStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInviteLinkStatus) Scan(value interface{}) error {
	if value == nil {
		ns.InviteLinkStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InviteLinkStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInviteLinkStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InviteLinkStatus), nil
}

type JobKind string

const (
	JobKindDEFAULT   JobKind = "DEFAULT"
	JobKindONFAILURE JobKind = "ON_FAILURE"
)

func (e *JobKind) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = JobKind(s)
	case string:
		*e = JobKind(s)
	default:
		return fmt.Errorf("unsupported scan type for JobKind: %T", src)
	}
	return nil
}

type NullJobKind struct {
	JobKind JobKind `json:"JobKind"`
	Valid   bool    `json:"valid"` // Valid is true if JobKind is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullJobKind) Scan(value interface{}) error {
	if value == nil {
		ns.JobKind, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.JobKind.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullJobKind) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.JobKind), nil
}

type JobRunStatus string

const (
	JobRunStatusPENDING   JobRunStatus = "PENDING"
	JobRunStatusRUNNING   JobRunStatus = "RUNNING"
	JobRunStatusSUCCEEDED JobRunStatus = "SUCCEEDED"
	JobRunStatusFAILED    JobRunStatus = "FAILED"
	JobRunStatusCANCELLED JobRunStatus = "CANCELLED"
)

func (e *JobRunStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = JobRunStatus(s)
	case string:
		*e = JobRunStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for JobRunStatus: %T", src)
	}
	return nil
}

type NullJobRunStatus struct {
	JobRunStatus JobRunStatus `json:"JobRunStatus"`
	Valid        bool         `json:"valid"` // Valid is true if JobRunStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullJobRunStatus) Scan(value interface{}) error {
	if value == nil {
		ns.JobRunStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.JobRunStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullJobRunStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.JobRunStatus), nil
}

type LeaseKind string

const (
	LeaseKindWORKER LeaseKind = "WORKER"
	LeaseKindQUEUE  LeaseKind = "QUEUE"
)

func (e *LeaseKind) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LeaseKind(s)
	case string:
		*e = LeaseKind(s)
	default:
		return fmt.Errorf("unsupported scan type for LeaseKind: %T", src)
	}
	return nil
}

type NullLeaseKind struct {
	LeaseKind LeaseKind `json:"LeaseKind"`
	Valid     bool      `json:"valid"` // Valid is true if LeaseKind is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLeaseKind) Scan(value interface{}) error {
	if value == nil {
		ns.LeaseKind, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LeaseKind.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLeaseKind) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LeaseKind), nil
}

type LimitResource string

const (
	LimitResourceWORKFLOWRUN LimitResource = "WORKFLOW_RUN"
	LimitResourceEVENT       LimitResource = "EVENT"
	LimitResourceWORKER      LimitResource = "WORKER"
	LimitResourceCRON        LimitResource = "CRON"
	LimitResourceSCHEDULE    LimitResource = "SCHEDULE"
)

func (e *LimitResource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LimitResource(s)
	case string:
		*e = LimitResource(s)
	default:
		return fmt.Errorf("unsupported scan type for LimitResource: %T", src)
	}
	return nil
}

type NullLimitResource struct {
	LimitResource LimitResource `json:"LimitResource"`
	Valid         bool          `json:"valid"` // Valid is true if LimitResource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLimitResource) Scan(value interface{}) error {
	if value == nil {
		ns.LimitResource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LimitResource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLimitResource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LimitResource), nil
}

type LogLineLevel string

const (
	LogLineLevelDEBUG LogLineLevel = "DEBUG"
	LogLineLevelINFO  LogLineLevel = "INFO"
	LogLineLevelWARN  LogLineLevel = "WARN"
	LogLineLevelERROR LogLineLevel = "ERROR"
)

func (e *LogLineLevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LogLineLevel(s)
	case string:
		*e = LogLineLevel(s)
	default:
		return fmt.Errorf("unsupported scan type for LogLineLevel: %T", src)
	}
	return nil
}

type NullLogLineLevel struct {
	LogLineLevel LogLineLevel `json:"LogLineLevel"`
	Valid        bool         `json:"valid"` // Valid is true if LogLineLevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLogLineLevel) Scan(value interface{}) error {
	if value == nil {
		ns.LogLineLevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LogLineLevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLogLineLevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LogLineLevel), nil
}

type MessageQueueItemStatus string

const (
	MessageQueueItemStatusPENDING  MessageQueueItemStatus = "PENDING"
	MessageQueueItemStatusASSIGNED MessageQueueItemStatus = "ASSIGNED"
)

func (e *MessageQueueItemStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MessageQueueItemStatus(s)
	case string:
		*e = MessageQueueItemStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for MessageQueueItemStatus: %T", src)
	}
	return nil
}

type NullMessageQueueItemStatus struct {
	MessageQueueItemStatus MessageQueueItemStatus `json:"MessageQueueItemStatus"`
	Valid                  bool                   `json:"valid"` // Valid is true if MessageQueueItemStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMessageQueueItemStatus) Scan(value interface{}) error {
	if value == nil {
		ns.MessageQueueItemStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MessageQueueItemStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMessageQueueItemStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MessageQueueItemStatus), nil
}

type StepExpressionKind string

const (
	StepExpressionKindDYNAMICRATELIMITKEY    StepExpressionKind = "DYNAMIC_RATE_LIMIT_KEY"
	StepExpressionKindDYNAMICRATELIMITVALUE  StepExpressionKind = "DYNAMIC_RATE_LIMIT_VALUE"
	StepExpressionKindDYNAMICRATELIMITUNITS  StepExpressionKind = "DYNAMIC_RATE_LIMIT_UNITS"
	StepExpressionKindDYNAMICRATELIMITWINDOW StepExpressionKind = "DYNAMIC_RATE_LIMIT_WINDOW"
)

func (e *StepExpressionKind) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StepExpressionKind(s)
	case string:
		*e = StepExpressionKind(s)
	default:
		return fmt.Errorf("unsupported scan type for StepExpressionKind: %T", src)
	}
	return nil
}

type NullStepExpressionKind struct {
	StepExpressionKind StepExpressionKind `json:"StepExpressionKind"`
	Valid              bool               `json:"valid"` // Valid is true if StepExpressionKind is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStepExpressionKind) Scan(value interface{}) error {
	if value == nil {
		ns.StepExpressionKind, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StepExpressionKind.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStepExpressionKind) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StepExpressionKind), nil
}

type StepRateLimitKind string

const (
	StepRateLimitKindSTATIC  StepRateLimitKind = "STATIC"
	StepRateLimitKindDYNAMIC StepRateLimitKind = "DYNAMIC"
)

func (e *StepRateLimitKind) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StepRateLimitKind(s)
	case string:
		*e = StepRateLimitKind(s)
	default:
		return fmt.Errorf("unsupported scan type for StepRateLimitKind: %T", src)
	}
	return nil
}

type NullStepRateLimitKind struct {
	StepRateLimitKind StepRateLimitKind `json:"StepRateLimitKind"`
	Valid             bool              `json:"valid"` // Valid is true if StepRateLimitKind is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStepRateLimitKind) Scan(value interface{}) error {
	if value == nil {
		ns.StepRateLimitKind, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StepRateLimitKind.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStepRateLimitKind) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StepRateLimitKind), nil
}

type StepRunEventReason string

const (
	StepRunEventReasonREQUEUEDNOWORKER             StepRunEventReason = "REQUEUED_NO_WORKER"
	StepRunEventReasonREQUEUEDRATELIMIT            StepRunEventReason = "REQUEUED_RATE_LIMIT"
	StepRunEventReasonSCHEDULINGTIMEDOUT           StepRunEventReason = "SCHEDULING_TIMED_OUT"
	StepRunEventReasonASSIGNED                     StepRunEventReason = "ASSIGNED"
	StepRunEventReasonSTARTED                      StepRunEventReason = "STARTED"
	StepRunEventReasonFINISHED                     StepRunEventReason = "FINISHED"
	StepRunEventReasonFAILED                       StepRunEventReason = "FAILED"
	StepRunEventReasonRETRYING                     StepRunEventReason = "RETRYING"
	StepRunEventReasonCANCELLED                    StepRunEventReason = "CANCELLED"
	StepRunEventReasonTIMEDOUT                     StepRunEventReason = "TIMED_OUT"
	StepRunEventReasonREASSIGNED                   StepRunEventReason = "REASSIGNED"
	StepRunEventReasonSLOTRELEASED                 StepRunEventReason = "SLOT_RELEASED"
	StepRunEventReasonTIMEOUTREFRESHED             StepRunEventReason = "TIMEOUT_REFRESHED"
	StepRunEventReasonRETRIEDBYUSER                StepRunEventReason = "RETRIED_BY_USER"
	StepRunEventReasonSENTTOWORKER                 StepRunEventReason = "SENT_TO_WORKER"
	StepRunEventReasonWORKFLOWRUNGROUPKEYSUCCEEDED StepRunEventReason = "WORKFLOW_RUN_GROUP_KEY_SUCCEEDED"
	StepRunEventReasonWORKFLOWRUNGROUPKEYFAILED    StepRunEventReason = "WORKFLOW_RUN_GROUP_KEY_FAILED"
	StepRunEventReasonRATELIMITERROR               StepRunEventReason = "RATE_LIMIT_ERROR"
	StepRunEventReasonACKNOWLEDGED                 StepRunEventReason = "ACKNOWLEDGED"
)

func (e *StepRunEventReason) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StepRunEventReason(s)
	case string:
		*e = StepRunEventReason(s)
	default:
		return fmt.Errorf("unsupported scan type for StepRunEventReason: %T", src)
	}
	return nil
}

type NullStepRunEventReason struct {
	StepRunEventReason StepRunEventReason `json:"StepRunEventReason"`
	Valid              bool               `json:"valid"` // Valid is true if StepRunEventReason is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStepRunEventReason) Scan(value interface{}) error {
	if value == nil {
		ns.StepRunEventReason, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StepRunEventReason.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStepRunEventReason) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StepRunEventReason), nil
}

type StepRunEventSeverity string

const (
	StepRunEventSeverityINFO     StepRunEventSeverity = "INFO"
	StepRunEventSeverityWARNING  StepRunEventSeverity = "WARNING"
	StepRunEventSeverityCRITICAL StepRunEventSeverity = "CRITICAL"
)

func (e *StepRunEventSeverity) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StepRunEventSeverity(s)
	case string:
		*e = StepRunEventSeverity(s)
	default:
		return fmt.Errorf("unsupported scan type for StepRunEventSeverity: %T", src)
	}
	return nil
}

type NullStepRunEventSeverity struct {
	StepRunEventSeverity StepRunEventSeverity `json:"StepRunEventSeverity"`
	Valid                bool                 `json:"valid"` // Valid is true if StepRunEventSeverity is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStepRunEventSeverity) Scan(value interface{}) error {
	if value == nil {
		ns.StepRunEventSeverity, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StepRunEventSeverity.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStepRunEventSeverity) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StepRunEventSeverity), nil
}

type StepRunStatus string

const (
	StepRunStatusPENDING           StepRunStatus = "PENDING"
	StepRunStatusPENDINGASSIGNMENT StepRunStatus = "PENDING_ASSIGNMENT"
	StepRunStatusASSIGNED          StepRunStatus = "ASSIGNED"
	StepRunStatusRUNNING           StepRunStatus = "RUNNING"
	StepRunStatusSUCCEEDED         StepRunStatus = "SUCCEEDED"
	StepRunStatusFAILED            StepRunStatus = "FAILED"
	StepRunStatusCANCELLED         StepRunStatus = "CANCELLED"
	StepRunStatusCANCELLING        StepRunStatus = "CANCELLING"
)

func (e *StepRunStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StepRunStatus(s)
	case string:
		*e = StepRunStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for StepRunStatus: %T", src)
	}
	return nil
}

type NullStepRunStatus struct {
	StepRunStatus StepRunStatus `json:"StepRunStatus"`
	Valid         bool          `json:"valid"` // Valid is true if StepRunStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStepRunStatus) Scan(value interface{}) error {
	if value == nil {
		ns.StepRunStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StepRunStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStepRunStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StepRunStatus), nil
}

type StickyStrategy string

const (
	StickyStrategySOFT StickyStrategy = "SOFT"
	StickyStrategyHARD StickyStrategy = "HARD"
)

func (e *StickyStrategy) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StickyStrategy(s)
	case string:
		*e = StickyStrategy(s)
	default:
		return fmt.Errorf("unsupported scan type for StickyStrategy: %T", src)
	}
	return nil
}

type NullStickyStrategy struct {
	StickyStrategy StickyStrategy `json:"StickyStrategy"`
	Valid          bool           `json:"valid"` // Valid is true if StickyStrategy is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStickyStrategy) Scan(value interface{}) error {
	if value == nil {
		ns.StickyStrategy, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StickyStrategy.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStickyStrategy) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StickyStrategy), nil
}

type TenantMemberRole string

const (
	TenantMemberRoleOWNER  TenantMemberRole = "OWNER"
	TenantMemberRoleADMIN  TenantMemberRole = "ADMIN"
	TenantMemberRoleMEMBER TenantMemberRole = "MEMBER"
)

func (e *TenantMemberRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TenantMemberRole(s)
	case string:
		*e = TenantMemberRole(s)
	default:
		return fmt.Errorf("unsupported scan type for TenantMemberRole: %T", src)
	}
	return nil
}

type NullTenantMemberRole struct {
	TenantMemberRole TenantMemberRole `json:"TenantMemberRole"`
	Valid            bool             `json:"valid"` // Valid is true if TenantMemberRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTenantMemberRole) Scan(value interface{}) error {
	if value == nil {
		ns.TenantMemberRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TenantMemberRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTenantMemberRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TenantMemberRole), nil
}

type TenantResourceLimitAlertType string

const (
	TenantResourceLimitAlertTypeAlarm     TenantResourceLimitAlertType = "Alarm"
	TenantResourceLimitAlertTypeExhausted TenantResourceLimitAlertType = "Exhausted"
)

func (e *TenantResourceLimitAlertType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TenantResourceLimitAlertType(s)
	case string:
		*e = TenantResourceLimitAlertType(s)
	default:
		return fmt.Errorf("unsupported scan type for TenantResourceLimitAlertType: %T", src)
	}
	return nil
}

type NullTenantResourceLimitAlertType struct {
	TenantResourceLimitAlertType TenantResourceLimitAlertType `json:"TenantResourceLimitAlertType"`
	Valid                        bool                         `json:"valid"` // Valid is true if TenantResourceLimitAlertType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTenantResourceLimitAlertType) Scan(value interface{}) error {
	if value == nil {
		ns.TenantResourceLimitAlertType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TenantResourceLimitAlertType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTenantResourceLimitAlertType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TenantResourceLimitAlertType), nil
}

type V2EventType string

const (
	V2EventTypeUSER     V2EventType = "USER"
	V2EventTypeINTERNAL V2EventType = "INTERNAL"
)

func (e *V2EventType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V2EventType(s)
	case string:
		*e = V2EventType(s)
	default:
		return fmt.Errorf("unsupported scan type for V2EventType: %T", src)
	}
	return nil
}

type NullV2EventType struct {
	V2EventType V2EventType `json:"v2_event_type"`
	Valid       bool        `json:"valid"` // Valid is true if V2EventType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV2EventType) Scan(value interface{}) error {
	if value == nil {
		ns.V2EventType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V2EventType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV2EventType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V2EventType), nil
}

type V2MatchConditionAction string

const (
	V2MatchConditionActionCREATE V2MatchConditionAction = "CREATE"
	V2MatchConditionActionCANCEL V2MatchConditionAction = "CANCEL"
	V2MatchConditionActionSKIP   V2MatchConditionAction = "SKIP"
)

func (e *V2MatchConditionAction) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V2MatchConditionAction(s)
	case string:
		*e = V2MatchConditionAction(s)
	default:
		return fmt.Errorf("unsupported scan type for V2MatchConditionAction: %T", src)
	}
	return nil
}

type NullV2MatchConditionAction struct {
	V2MatchConditionAction V2MatchConditionAction `json:"v2_match_condition_action"`
	Valid                  bool                   `json:"valid"` // Valid is true if V2MatchConditionAction is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV2MatchConditionAction) Scan(value interface{}) error {
	if value == nil {
		ns.V2MatchConditionAction, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V2MatchConditionAction.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV2MatchConditionAction) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V2MatchConditionAction), nil
}

type V2MatchKind string

const (
	V2MatchKindTRIGGER V2MatchKind = "TRIGGER"
	V2MatchKindSIGNAL  V2MatchKind = "SIGNAL"
)

func (e *V2MatchKind) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V2MatchKind(s)
	case string:
		*e = V2MatchKind(s)
	default:
		return fmt.Errorf("unsupported scan type for V2MatchKind: %T", src)
	}
	return nil
}

type NullV2MatchKind struct {
	V2MatchKind V2MatchKind `json:"v2_match_kind"`
	Valid       bool        `json:"valid"` // Valid is true if V2MatchKind is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV2MatchKind) Scan(value interface{}) error {
	if value == nil {
		ns.V2MatchKind, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V2MatchKind.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV2MatchKind) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V2MatchKind), nil
}

type V2StickyStrategy string

const (
	V2StickyStrategyNONE V2StickyStrategy = "NONE"
	V2StickyStrategySOFT V2StickyStrategy = "SOFT"
	V2StickyStrategyHARD V2StickyStrategy = "HARD"
)

func (e *V2StickyStrategy) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V2StickyStrategy(s)
	case string:
		*e = V2StickyStrategy(s)
	default:
		return fmt.Errorf("unsupported scan type for V2StickyStrategy: %T", src)
	}
	return nil
}

type NullV2StickyStrategy struct {
	V2StickyStrategy V2StickyStrategy `json:"v2_sticky_strategy"`
	Valid            bool             `json:"valid"` // Valid is true if V2StickyStrategy is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV2StickyStrategy) Scan(value interface{}) error {
	if value == nil {
		ns.V2StickyStrategy, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V2StickyStrategy.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV2StickyStrategy) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V2StickyStrategy), nil
}

type V2TaskEventType string

const (
	V2TaskEventTypeCOMPLETED       V2TaskEventType = "COMPLETED"
	V2TaskEventTypeFAILED          V2TaskEventType = "FAILED"
	V2TaskEventTypeCANCELLED       V2TaskEventType = "CANCELLED"
	V2TaskEventTypeSIGNALCREATED   V2TaskEventType = "SIGNAL_CREATED"
	V2TaskEventTypeSIGNALCOMPLETED V2TaskEventType = "SIGNAL_COMPLETED"
)

func (e *V2TaskEventType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V2TaskEventType(s)
	case string:
		*e = V2TaskEventType(s)
	default:
		return fmt.Errorf("unsupported scan type for V2TaskEventType: %T", src)
	}
	return nil
}

type NullV2TaskEventType struct {
	V2TaskEventType V2TaskEventType `json:"v2_task_event_type"`
	Valid           bool            `json:"valid"` // Valid is true if V2TaskEventType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV2TaskEventType) Scan(value interface{}) error {
	if value == nil {
		ns.V2TaskEventType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V2TaskEventType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV2TaskEventType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V2TaskEventType), nil
}

type V2TaskInitialState string

const (
	V2TaskInitialStateQUEUED    V2TaskInitialState = "QUEUED"
	V2TaskInitialStateCANCELLED V2TaskInitialState = "CANCELLED"
	V2TaskInitialStateSKIPPED   V2TaskInitialState = "SKIPPED"
)

func (e *V2TaskInitialState) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V2TaskInitialState(s)
	case string:
		*e = V2TaskInitialState(s)
	default:
		return fmt.Errorf("unsupported scan type for V2TaskInitialState: %T", src)
	}
	return nil
}

type NullV2TaskInitialState struct {
	V2TaskInitialState V2TaskInitialState `json:"v2_task_initial_state"`
	Valid              bool               `json:"valid"` // Valid is true if V2TaskInitialState is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV2TaskInitialState) Scan(value interface{}) error {
	if value == nil {
		ns.V2TaskInitialState, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V2TaskInitialState.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV2TaskInitialState) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V2TaskInitialState), nil
}

type VcsProvider string

const (
	VcsProviderGITHUB VcsProvider = "GITHUB"
)

func (e *VcsProvider) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = VcsProvider(s)
	case string:
		*e = VcsProvider(s)
	default:
		return fmt.Errorf("unsupported scan type for VcsProvider: %T", src)
	}
	return nil
}

type NullVcsProvider struct {
	VcsProvider VcsProvider `json:"VcsProvider"`
	Valid       bool        `json:"valid"` // Valid is true if VcsProvider is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullVcsProvider) Scan(value interface{}) error {
	if value == nil {
		ns.VcsProvider, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.VcsProvider.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullVcsProvider) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.VcsProvider), nil
}

type WebhookWorkerRequestMethod string

const (
	WebhookWorkerRequestMethodGET  WebhookWorkerRequestMethod = "GET"
	WebhookWorkerRequestMethodPOST WebhookWorkerRequestMethod = "POST"
	WebhookWorkerRequestMethodPUT  WebhookWorkerRequestMethod = "PUT"
)

func (e *WebhookWorkerRequestMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WebhookWorkerRequestMethod(s)
	case string:
		*e = WebhookWorkerRequestMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for WebhookWorkerRequestMethod: %T", src)
	}
	return nil
}

type NullWebhookWorkerRequestMethod struct {
	WebhookWorkerRequestMethod WebhookWorkerRequestMethod `json:"WebhookWorkerRequestMethod"`
	Valid                      bool                       `json:"valid"` // Valid is true if WebhookWorkerRequestMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWebhookWorkerRequestMethod) Scan(value interface{}) error {
	if value == nil {
		ns.WebhookWorkerRequestMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WebhookWorkerRequestMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWebhookWorkerRequestMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WebhookWorkerRequestMethod), nil
}

type WorkerLabelComparator string

const (
	WorkerLabelComparatorEQUAL              WorkerLabelComparator = "EQUAL"
	WorkerLabelComparatorNOTEQUAL           WorkerLabelComparator = "NOT_EQUAL"
	WorkerLabelComparatorGREATERTHAN        WorkerLabelComparator = "GREATER_THAN"
	WorkerLabelComparatorGREATERTHANOREQUAL WorkerLabelComparator = "GREATER_THAN_OR_EQUAL"
	WorkerLabelComparatorLESSTHAN           WorkerLabelComparator = "LESS_THAN"
	WorkerLabelComparatorLESSTHANOREQUAL    WorkerLabelComparator = "LESS_THAN_OR_EQUAL"
)

func (e *WorkerLabelComparator) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkerLabelComparator(s)
	case string:
		*e = WorkerLabelComparator(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkerLabelComparator: %T", src)
	}
	return nil
}

type NullWorkerLabelComparator struct {
	WorkerLabelComparator WorkerLabelComparator `json:"WorkerLabelComparator"`
	Valid                 bool                  `json:"valid"` // Valid is true if WorkerLabelComparator is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkerLabelComparator) Scan(value interface{}) error {
	if value == nil {
		ns.WorkerLabelComparator, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkerLabelComparator.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkerLabelComparator) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkerLabelComparator), nil
}

type WorkerSDKS string

const (
	WorkerSDKSUNKNOWN    WorkerSDKS = "UNKNOWN"
	WorkerSDKSGO         WorkerSDKS = "GO"
	WorkerSDKSPYTHON     WorkerSDKS = "PYTHON"
	WorkerSDKSTYPESCRIPT WorkerSDKS = "TYPESCRIPT"
)

func (e *WorkerSDKS) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkerSDKS(s)
	case string:
		*e = WorkerSDKS(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkerSDKS: %T", src)
	}
	return nil
}

type NullWorkerSDKS struct {
	WorkerSDKS WorkerSDKS `json:"WorkerSDKS"`
	Valid      bool       `json:"valid"` // Valid is true if WorkerSDKS is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkerSDKS) Scan(value interface{}) error {
	if value == nil {
		ns.WorkerSDKS, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkerSDKS.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkerSDKS) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkerSDKS), nil
}

type WorkerType string

const (
	WorkerTypeWEBHOOK    WorkerType = "WEBHOOK"
	WorkerTypeMANAGED    WorkerType = "MANAGED"
	WorkerTypeSELFHOSTED WorkerType = "SELFHOSTED"
)

func (e *WorkerType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkerType(s)
	case string:
		*e = WorkerType(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkerType: %T", src)
	}
	return nil
}

type NullWorkerType struct {
	WorkerType WorkerType `json:"WorkerType"`
	Valid      bool       `json:"valid"` // Valid is true if WorkerType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkerType) Scan(value interface{}) error {
	if value == nil {
		ns.WorkerType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkerType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkerType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkerType), nil
}

type WorkflowKind string

const (
	WorkflowKindFUNCTION WorkflowKind = "FUNCTION"
	WorkflowKindDURABLE  WorkflowKind = "DURABLE"
	WorkflowKindDAG      WorkflowKind = "DAG"
)

func (e *WorkflowKind) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkflowKind(s)
	case string:
		*e = WorkflowKind(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkflowKind: %T", src)
	}
	return nil
}

type NullWorkflowKind struct {
	WorkflowKind WorkflowKind `json:"WorkflowKind"`
	Valid        bool         `json:"valid"` // Valid is true if WorkflowKind is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkflowKind) Scan(value interface{}) error {
	if value == nil {
		ns.WorkflowKind, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkflowKind.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkflowKind) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkflowKind), nil
}

type WorkflowRunStatus string

const (
	WorkflowRunStatusPENDING    WorkflowRunStatus = "PENDING"
	WorkflowRunStatusRUNNING    WorkflowRunStatus = "RUNNING"
	WorkflowRunStatusSUCCEEDED  WorkflowRunStatus = "SUCCEEDED"
	WorkflowRunStatusFAILED     WorkflowRunStatus = "FAILED"
	WorkflowRunStatusQUEUED     WorkflowRunStatus = "QUEUED"
	WorkflowRunStatusCANCELLING WorkflowRunStatus = "CANCELLING"
	WorkflowRunStatusCANCELLED  WorkflowRunStatus = "CANCELLED"
)

func (e *WorkflowRunStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkflowRunStatus(s)
	case string:
		*e = WorkflowRunStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkflowRunStatus: %T", src)
	}
	return nil
}

type NullWorkflowRunStatus struct {
	WorkflowRunStatus WorkflowRunStatus `json:"WorkflowRunStatus"`
	Valid             bool              `json:"valid"` // Valid is true if WorkflowRunStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkflowRunStatus) Scan(value interface{}) error {
	if value == nil {
		ns.WorkflowRunStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkflowRunStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkflowRunStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkflowRunStatus), nil
}

type WorkflowTriggerCronRefMethods string

const (
	WorkflowTriggerCronRefMethodsDEFAULT WorkflowTriggerCronRefMethods = "DEFAULT"
	WorkflowTriggerCronRefMethodsAPI     WorkflowTriggerCronRefMethods = "API"
)

func (e *WorkflowTriggerCronRefMethods) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkflowTriggerCronRefMethods(s)
	case string:
		*e = WorkflowTriggerCronRefMethods(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkflowTriggerCronRefMethods: %T", src)
	}
	return nil
}

type NullWorkflowTriggerCronRefMethods struct {
	WorkflowTriggerCronRefMethods WorkflowTriggerCronRefMethods `json:"WorkflowTriggerCronRefMethods"`
	Valid                         bool                          `json:"valid"` // Valid is true if WorkflowTriggerCronRefMethods is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkflowTriggerCronRefMethods) Scan(value interface{}) error {
	if value == nil {
		ns.WorkflowTriggerCronRefMethods, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkflowTriggerCronRefMethods.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkflowTriggerCronRefMethods) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkflowTriggerCronRefMethods), nil
}

type WorkflowTriggerScheduledRefMethods string

const (
	WorkflowTriggerScheduledRefMethodsDEFAULT WorkflowTriggerScheduledRefMethods = "DEFAULT"
	WorkflowTriggerScheduledRefMethodsAPI     WorkflowTriggerScheduledRefMethods = "API"
)

func (e *WorkflowTriggerScheduledRefMethods) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkflowTriggerScheduledRefMethods(s)
	case string:
		*e = WorkflowTriggerScheduledRefMethods(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkflowTriggerScheduledRefMethods: %T", src)
	}
	return nil
}

type NullWorkflowTriggerScheduledRefMethods struct {
	WorkflowTriggerScheduledRefMethods WorkflowTriggerScheduledRefMethods `json:"WorkflowTriggerScheduledRefMethods"`
	Valid                              bool                               `json:"valid"` // Valid is true if WorkflowTriggerScheduledRefMethods is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkflowTriggerScheduledRefMethods) Scan(value interface{}) error {
	if value == nil {
		ns.WorkflowTriggerScheduledRefMethods, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkflowTriggerScheduledRefMethods.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkflowTriggerScheduledRefMethods) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkflowTriggerScheduledRefMethods), nil
}

type APIToken struct {
	ID          pgtype.UUID      `json:"id"`
	CreatedAt   pgtype.Timestamp `json:"createdAt"`
	UpdatedAt   pgtype.Timestamp `json:"updatedAt"`
	ExpiresAt   pgtype.Timestamp `json:"expiresAt"`
	Revoked     bool             `json:"revoked"`
	Name        pgtype.Text      `json:"name"`
	TenantId    pgtype.UUID      `json:"tenantId"`
	NextAlertAt pgtype.Timestamp `json:"nextAlertAt"`
	Internal    bool             `json:"internal"`
}

type Action struct {
	Description pgtype.Text `json:"description"`
	TenantId    pgtype.UUID `json:"tenantId"`
	ActionId    string      `json:"actionId"`
	ID          pgtype.UUID `json:"id"`
}

type ActionToWorker struct {
	B pgtype.UUID `json:"B"`
	A pgtype.UUID `json:"A"`
}

type ControllerPartition struct {
	ID            string           `json:"id"`
	CreatedAt     pgtype.Timestamp `json:"createdAt"`
	UpdatedAt     pgtype.Timestamp `json:"updatedAt"`
	LastHeartbeat pgtype.Timestamp `json:"lastHeartbeat"`
	Name          pgtype.Text      `json:"name"`
}

type Dispatcher struct {
	ID              pgtype.UUID      `json:"id"`
	CreatedAt       pgtype.Timestamp `json:"createdAt"`
	UpdatedAt       pgtype.Timestamp `json:"updatedAt"`
	DeletedAt       pgtype.Timestamp `json:"deletedAt"`
	LastHeartbeatAt pgtype.Timestamp `json:"lastHeartbeatAt"`
	IsActive        bool             `json:"isActive"`
}

type Event struct {
	ID                 pgtype.UUID      `json:"id"`
	CreatedAt          pgtype.Timestamp `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	DeletedAt          pgtype.Timestamp `json:"deletedAt"`
	Key                string           `json:"key"`
	TenantId           pgtype.UUID      `json:"tenantId"`
	ReplayedFromId     pgtype.UUID      `json:"replayedFromId"`
	Data               []byte           `json:"data"`
	AdditionalMetadata []byte           `json:"additionalMetadata"`
	InsertOrder        pgtype.Int4      `json:"insertOrder"`
}

type EventKey struct {
	Key      string      `json:"key"`
	TenantId pgtype.UUID `json:"tenantId"`
	ID       int64       `json:"id"`
}

type GetGroupKeyRun struct {
	ID                pgtype.UUID      `json:"id"`
	CreatedAt         pgtype.Timestamp `json:"createdAt"`
	UpdatedAt         pgtype.Timestamp `json:"updatedAt"`
	DeletedAt         pgtype.Timestamp `json:"deletedAt"`
	TenantId          pgtype.UUID      `json:"tenantId"`
	WorkerId          pgtype.UUID      `json:"workerId"`
	TickerId          pgtype.UUID      `json:"tickerId"`
	Status            StepRunStatus    `json:"status"`
	Input             []byte           `json:"input"`
	Output            pgtype.Text      `json:"output"`
	RequeueAfter      pgtype.Timestamp `json:"requeueAfter"`
	Error             pgtype.Text      `json:"error"`
	StartedAt         pgtype.Timestamp `json:"startedAt"`
	FinishedAt        pgtype.Timestamp `json:"finishedAt"`
	TimeoutAt         pgtype.Timestamp `json:"timeoutAt"`
	CancelledAt       pgtype.Timestamp `json:"cancelledAt"`
	CancelledReason   pgtype.Text      `json:"cancelledReason"`
	CancelledError    pgtype.Text      `json:"cancelledError"`
	WorkflowRunId     pgtype.UUID      `json:"workflowRunId"`
	ScheduleTimeoutAt pgtype.Timestamp `json:"scheduleTimeoutAt"`
}

type InternalQueueItem struct {
	ID        int64         `json:"id"`
	Queue     InternalQueue `json:"queue"`
	IsQueued  bool          `json:"isQueued"`
	Data      []byte        `json:"data"`
	TenantId  pgtype.UUID   `json:"tenantId"`
	Priority  int32         `json:"priority"`
	UniqueKey pgtype.Text   `json:"uniqueKey"`
}

type Job struct {
	ID                pgtype.UUID      `json:"id"`
	CreatedAt         pgtype.Timestamp `json:"createdAt"`
	UpdatedAt         pgtype.Timestamp `json:"updatedAt"`
	DeletedAt         pgtype.Timestamp `json:"deletedAt"`
	TenantId          pgtype.UUID      `json:"tenantId"`
	WorkflowVersionId pgtype.UUID      `json:"workflowVersionId"`
	Name              string           `json:"name"`
	Description       pgtype.Text      `json:"description"`
	Timeout           pgtype.Text      `json:"timeout"`
	Kind              JobKind          `json:"kind"`
}

type JobRun struct {
	ID              pgtype.UUID      `json:"id"`
	CreatedAt       pgtype.Timestamp `json:"createdAt"`
	UpdatedAt       pgtype.Timestamp `json:"updatedAt"`
	DeletedAt       pgtype.Timestamp `json:"deletedAt"`
	TenantId        pgtype.UUID      `json:"tenantId"`
	JobId           pgtype.UUID      `json:"jobId"`
	TickerId        pgtype.UUID      `json:"tickerId"`
	Status          JobRunStatus     `json:"status"`
	Result          []byte           `json:"result"`
	StartedAt       pgtype.Timestamp `json:"startedAt"`
	FinishedAt      pgtype.Timestamp `json:"finishedAt"`
	TimeoutAt       pgtype.Timestamp `json:"timeoutAt"`
	CancelledAt     pgtype.Timestamp `json:"cancelledAt"`
	CancelledReason pgtype.Text      `json:"cancelledReason"`
	CancelledError  pgtype.Text      `json:"cancelledError"`
	WorkflowRunId   pgtype.UUID      `json:"workflowRunId"`
}

type JobRunLookupData struct {
	ID        pgtype.UUID      `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	DeletedAt pgtype.Timestamp `json:"deletedAt"`
	JobRunId  pgtype.UUID      `json:"jobRunId"`
	TenantId  pgtype.UUID      `json:"tenantId"`
	Data      []byte           `json:"data"`
}

type Lease struct {
	ID         int64            `json:"id"`
	ExpiresAt  pgtype.Timestamp `json:"expiresAt"`
	TenantId   pgtype.UUID      `json:"tenantId"`
	ResourceId string           `json:"resourceId"`
	Kind       LeaseKind        `json:"kind"`
}

type LogLine struct {
	ID        int64            `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	TenantId  pgtype.UUID      `json:"tenantId"`
	StepRunId pgtype.UUID      `json:"stepRunId"`
	Message   string           `json:"message"`
	Level     LogLineLevel     `json:"level"`
	Metadata  []byte           `json:"metadata"`
}

type MessageQueue struct {
	Name                string           `json:"name"`
	LastActive          pgtype.Timestamp `json:"lastActive"`
	Durable             bool             `json:"durable"`
	AutoDeleted         bool             `json:"autoDeleted"`
	Exclusive           bool             `json:"exclusive"`
	ExclusiveConsumerId pgtype.UUID      `json:"exclusiveConsumerId"`
}

type MessageQueueItem struct {
	ID        int64                  `json:"id"`
	Payload   []byte                 `json:"payload"`
	ReadAfter pgtype.Timestamp       `json:"readAfter"`
	ExpiresAt pgtype.Timestamp       `json:"expiresAt"`
	QueueId   pgtype.Text            `json:"queueId"`
	Status    MessageQueueItemStatus `json:"status"`
}

type Queue struct {
	ID         int64            `json:"id"`
	TenantId   pgtype.UUID      `json:"tenantId"`
	Name       string           `json:"name"`
	LastActive pgtype.Timestamp `json:"lastActive"`
}

type QueueItem struct {
	ID                int64              `json:"id"`
	StepRunId         pgtype.UUID        `json:"stepRunId"`
	StepId            pgtype.UUID        `json:"stepId"`
	ActionId          pgtype.Text        `json:"actionId"`
	ScheduleTimeoutAt pgtype.Timestamp   `json:"scheduleTimeoutAt"`
	StepTimeout       pgtype.Text        `json:"stepTimeout"`
	Priority          int32              `json:"priority"`
	IsQueued          bool               `json:"isQueued"`
	TenantId          pgtype.UUID        `json:"tenantId"`
	Queue             string             `json:"queue"`
	Sticky            NullStickyStrategy `json:"sticky"`
	DesiredWorkerId   pgtype.UUID        `json:"desiredWorkerId"`
}

type RateLimit struct {
	TenantId   pgtype.UUID      `json:"tenantId"`
	Key        string           `json:"key"`
	LimitValue int32            `json:"limitValue"`
	Value      int32            `json:"value"`
	Window     string           `json:"window"`
	LastRefill pgtype.Timestamp `json:"lastRefill"`
}

type RetryQueueItem struct {
	ID         int64            `json:"id"`
	RetryAfter pgtype.Timestamp `json:"retryAfter"`
	StepRunId  pgtype.UUID      `json:"stepRunId"`
	TenantId   pgtype.UUID      `json:"tenantId"`
	IsQueued   bool             `json:"isQueued"`
}

type SNSIntegration struct {
	ID        pgtype.UUID      `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	TenantId  pgtype.UUID      `json:"tenantId"`
	TopicArn  string           `json:"topicArn"`
}

type SchedulerPartition struct {
	ID            string           `json:"id"`
	CreatedAt     pgtype.Timestamp `json:"createdAt"`
	UpdatedAt     pgtype.Timestamp `json:"updatedAt"`
	LastHeartbeat pgtype.Timestamp `json:"lastHeartbeat"`
	Name          pgtype.Text      `json:"name"`
}

type SecurityCheckIdent struct {
	ID pgtype.UUID `json:"id"`
}

type SemaphoreQueueItem struct {
	StepRunId pgtype.UUID `json:"stepRunId"`
	WorkerId  pgtype.UUID `json:"workerId"`
	TenantId  pgtype.UUID `json:"tenantId"`
}

type Service struct {
	ID          pgtype.UUID      `json:"id"`
	CreatedAt   pgtype.Timestamp `json:"createdAt"`
	UpdatedAt   pgtype.Timestamp `json:"updatedAt"`
	DeletedAt   pgtype.Timestamp `json:"deletedAt"`
	Name        string           `json:"name"`
	Description pgtype.Text      `json:"description"`
	TenantId    pgtype.UUID      `json:"tenantId"`
}

type ServiceToWorker struct {
	A pgtype.UUID `json:"A"`
	B pgtype.UUID `json:"B"`
}

type SlackAppWebhook struct {
	ID          pgtype.UUID      `json:"id"`
	CreatedAt   pgtype.Timestamp `json:"createdAt"`
	UpdatedAt   pgtype.Timestamp `json:"updatedAt"`
	DeletedAt   pgtype.Timestamp `json:"deletedAt"`
	TenantId    pgtype.UUID      `json:"tenantId"`
	TeamId      string           `json:"teamId"`
	TeamName    string           `json:"teamName"`
	ChannelId   string           `json:"channelId"`
	ChannelName string           `json:"channelName"`
	WebhookURL  []byte           `json:"webhookURL"`
}

type Step struct {
	ID                 pgtype.UUID      `json:"id"`
	CreatedAt          pgtype.Timestamp `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	DeletedAt          pgtype.Timestamp `json:"deletedAt"`
	ReadableId         pgtype.Text      `json:"readableId"`
	TenantId           pgtype.UUID      `json:"tenantId"`
	JobId              pgtype.UUID      `json:"jobId"`
	ActionId           string           `json:"actionId"`
	Timeout            pgtype.Text      `json:"timeout"`
	CustomUserData     []byte           `json:"customUserData"`
	Retries            int32            `json:"retries"`
	RetryBackoffFactor pgtype.Float8    `json:"retryBackoffFactor"`
	RetryMaxBackoff    pgtype.Int4      `json:"retryMaxBackoff"`
	ScheduleTimeout    string           `json:"scheduleTimeout"`
}

type StepDesiredWorkerLabel struct {
	ID         int64                 `json:"id"`
	CreatedAt  pgtype.Timestamp      `json:"createdAt"`
	UpdatedAt  pgtype.Timestamp      `json:"updatedAt"`
	StepId     pgtype.UUID           `json:"stepId"`
	Key        string                `json:"key"`
	StrValue   pgtype.Text           `json:"strValue"`
	IntValue   pgtype.Int4           `json:"intValue"`
	Required   bool                  `json:"required"`
	Comparator WorkerLabelComparator `json:"comparator"`
	Weight     int32                 `json:"weight"`
}

type StepExpression struct {
	Key        string             `json:"key"`
	StepId     pgtype.UUID        `json:"stepId"`
	Expression string             `json:"expression"`
	Kind       StepExpressionKind `json:"kind"`
}

type StepOrder struct {
	A pgtype.UUID `json:"A"`
	B pgtype.UUID `json:"B"`
}

type StepRateLimit struct {
	Units        int32             `json:"units"`
	StepId       pgtype.UUID       `json:"stepId"`
	RateLimitKey string            `json:"rateLimitKey"`
	TenantId     pgtype.UUID       `json:"tenantId"`
	Kind         StepRateLimitKind `json:"kind"`
}

type StepRun struct {
	ID                 pgtype.UUID      `json:"id"`
	CreatedAt          pgtype.Timestamp `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	DeletedAt          pgtype.Timestamp `json:"deletedAt"`
	TenantId           pgtype.UUID      `json:"tenantId"`
	JobRunId           pgtype.UUID      `json:"jobRunId"`
	StepId             pgtype.UUID      `json:"stepId"`
	Order              int64            `json:"order"`
	WorkerId           pgtype.UUID      `json:"workerId"`
	TickerId           pgtype.UUID      `json:"tickerId"`
	Status             StepRunStatus    `json:"status"`
	Input              []byte           `json:"input"`
	Output             []byte           `json:"output"`
	RequeueAfter       pgtype.Timestamp `json:"requeueAfter"`
	ScheduleTimeoutAt  pgtype.Timestamp `json:"scheduleTimeoutAt"`
	Error              pgtype.Text      `json:"error"`
	StartedAt          pgtype.Timestamp `json:"startedAt"`
	FinishedAt         pgtype.Timestamp `json:"finishedAt"`
	TimeoutAt          pgtype.Timestamp `json:"timeoutAt"`
	CancelledAt        pgtype.Timestamp `json:"cancelledAt"`
	CancelledReason    pgtype.Text      `json:"cancelledReason"`
	CancelledError     pgtype.Text      `json:"cancelledError"`
	InputSchema        []byte           `json:"inputSchema"`
	CallerFiles        []byte           `json:"callerFiles"`
	GitRepoBranch      pgtype.Text      `json:"gitRepoBranch"`
	RetryCount         int32            `json:"retryCount"`
	SemaphoreReleased  bool             `json:"semaphoreReleased"`
	Queue              string           `json:"queue"`
	Priority           pgtype.Int4      `json:"priority"`
	InternalRetryCount int32            `json:"internalRetryCount"`
}

type StepRunEvent struct {
	ID            int64                `json:"id"`
	TimeFirstSeen pgtype.Timestamp     `json:"timeFirstSeen"`
	TimeLastSeen  pgtype.Timestamp     `json:"timeLastSeen"`
	StepRunId     pgtype.UUID          `json:"stepRunId"`
	Reason        StepRunEventReason   `json:"reason"`
	Severity      StepRunEventSeverity `json:"severity"`
	Message       string               `json:"message"`
	Count         int32                `json:"count"`
	Data          []byte               `json:"data"`
	WorkflowRunId pgtype.UUID          `json:"workflowRunId"`
}

type StepRunExpressionEval struct {
	Key       string             `json:"key"`
	StepRunId pgtype.UUID        `json:"stepRunId"`
	ValueStr  pgtype.Text        `json:"valueStr"`
	ValueInt  pgtype.Int4        `json:"valueInt"`
	Kind      StepExpressionKind `json:"kind"`
}

type StepRunOrder struct {
	A pgtype.UUID `json:"A"`
	B pgtype.UUID `json:"B"`
}

type StepRunResultArchive struct {
	ID              pgtype.UUID      `json:"id"`
	CreatedAt       pgtype.Timestamp `json:"createdAt"`
	UpdatedAt       pgtype.Timestamp `json:"updatedAt"`
	DeletedAt       pgtype.Timestamp `json:"deletedAt"`
	StepRunId       pgtype.UUID      `json:"stepRunId"`
	Order           int64            `json:"order"`
	Input           []byte           `json:"input"`
	Output          []byte           `json:"output"`
	Error           pgtype.Text      `json:"error"`
	StartedAt       pgtype.Timestamp `json:"startedAt"`
	FinishedAt      pgtype.Timestamp `json:"finishedAt"`
	TimeoutAt       pgtype.Timestamp `json:"timeoutAt"`
	CancelledAt     pgtype.Timestamp `json:"cancelledAt"`
	CancelledReason pgtype.Text      `json:"cancelledReason"`
	CancelledError  pgtype.Text      `json:"cancelledError"`
	RetryCount      int32            `json:"retryCount"`
}

type StreamEvent struct {
	ID        int64            `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	TenantId  pgtype.UUID      `json:"tenantId"`
	StepRunId pgtype.UUID      `json:"stepRunId"`
	Message   []byte           `json:"message"`
	Metadata  []byte           `json:"metadata"`
}

type Tenant struct {
	ID                    pgtype.UUID      `json:"id"`
	CreatedAt             pgtype.Timestamp `json:"createdAt"`
	UpdatedAt             pgtype.Timestamp `json:"updatedAt"`
	DeletedAt             pgtype.Timestamp `json:"deletedAt"`
	Name                  string           `json:"name"`
	Slug                  string           `json:"slug"`
	AnalyticsOptOut       bool             `json:"analyticsOptOut"`
	AlertMemberEmails     bool             `json:"alertMemberEmails"`
	ControllerPartitionId pgtype.Text      `json:"controllerPartitionId"`
	WorkerPartitionId     pgtype.Text      `json:"workerPartitionId"`
	DataRetentionPeriod   string           `json:"dataRetentionPeriod"`
	SchedulerPartitionId  pgtype.Text      `json:"schedulerPartitionId"`
}

type TenantAlertEmailGroup struct {
	ID        pgtype.UUID      `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	DeletedAt pgtype.Timestamp `json:"deletedAt"`
	TenantId  pgtype.UUID      `json:"tenantId"`
	Emails    string           `json:"emails"`
}

type TenantAlertingSettings struct {
	ID                              pgtype.UUID      `json:"id"`
	CreatedAt                       pgtype.Timestamp `json:"createdAt"`
	UpdatedAt                       pgtype.Timestamp `json:"updatedAt"`
	DeletedAt                       pgtype.Timestamp `json:"deletedAt"`
	TenantId                        pgtype.UUID      `json:"tenantId"`
	MaxFrequency                    string           `json:"maxFrequency"`
	LastAlertedAt                   pgtype.Timestamp `json:"lastAlertedAt"`
	TickerId                        pgtype.UUID      `json:"tickerId"`
	EnableExpiringTokenAlerts       bool             `json:"enableExpiringTokenAlerts"`
	EnableWorkflowRunFailureAlerts  bool             `json:"enableWorkflowRunFailureAlerts"`
	EnableTenantResourceLimitAlerts bool             `json:"enableTenantResourceLimitAlerts"`
}

type TenantInviteLink struct {
	ID           pgtype.UUID      `json:"id"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	UpdatedAt    pgtype.Timestamp `json:"updatedAt"`
	TenantId     pgtype.UUID      `json:"tenantId"`
	InviterEmail string           `json:"inviterEmail"`
	InviteeEmail string           `json:"inviteeEmail"`
	Expires      pgtype.Timestamp `json:"expires"`
	Status       InviteLinkStatus `json:"status"`
	Role         TenantMemberRole `json:"role"`
}

type TenantMember struct {
	ID        pgtype.UUID      `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	TenantId  pgtype.UUID      `json:"tenantId"`
	UserId    pgtype.UUID      `json:"userId"`
	Role      TenantMemberRole `json:"role"`
}

type TenantResourceLimit struct {
	ID               pgtype.UUID      `json:"id"`
	CreatedAt        pgtype.Timestamp `json:"createdAt"`
	UpdatedAt        pgtype.Timestamp `json:"updatedAt"`
	Resource         LimitResource    `json:"resource"`
	TenantId         pgtype.UUID      `json:"tenantId"`
	LimitValue       int32            `json:"limitValue"`
	AlarmValue       pgtype.Int4      `json:"alarmValue"`
	Value            int32            `json:"value"`
	Window           pgtype.Text      `json:"window"`
	LastRefill       pgtype.Timestamp `json:"lastRefill"`
	CustomValueMeter bool             `json:"customValueMeter"`
}

type TenantResourceLimitAlert struct {
	ID              pgtype.UUID                  `json:"id"`
	CreatedAt       pgtype.Timestamp             `json:"createdAt"`
	UpdatedAt       pgtype.Timestamp             `json:"updatedAt"`
	ResourceLimitId pgtype.UUID                  `json:"resourceLimitId"`
	TenantId        pgtype.UUID                  `json:"tenantId"`
	Resource        LimitResource                `json:"resource"`
	AlertType       TenantResourceLimitAlertType `json:"alertType"`
	Value           int32                        `json:"value"`
	Limit           int32                        `json:"limit"`
}

type TenantVcsProvider struct {
	ID          pgtype.UUID      `json:"id"`
	CreatedAt   pgtype.Timestamp `json:"createdAt"`
	UpdatedAt   pgtype.Timestamp `json:"updatedAt"`
	DeletedAt   pgtype.Timestamp `json:"deletedAt"`
	TenantId    pgtype.UUID      `json:"tenantId"`
	VcsProvider VcsProvider      `json:"vcsProvider"`
	Config      []byte           `json:"config"`
}

type TenantWorkerPartition struct {
	ID            string           `json:"id"`
	CreatedAt     pgtype.Timestamp `json:"createdAt"`
	UpdatedAt     pgtype.Timestamp `json:"updatedAt"`
	LastHeartbeat pgtype.Timestamp `json:"lastHeartbeat"`
	Name          pgtype.Text      `json:"name"`
}

type Ticker struct {
	ID              pgtype.UUID      `json:"id"`
	CreatedAt       pgtype.Timestamp `json:"createdAt"`
	UpdatedAt       pgtype.Timestamp `json:"updatedAt"`
	LastHeartbeatAt pgtype.Timestamp `json:"lastHeartbeatAt"`
	IsActive        bool             `json:"isActive"`
}

type TimeoutQueueItem struct {
	ID         int64            `json:"id"`
	StepRunId  pgtype.UUID      `json:"stepRunId"`
	RetryCount int32            `json:"retryCount"`
	TimeoutAt  pgtype.Timestamp `json:"timeoutAt"`
	TenantId   pgtype.UUID      `json:"tenantId"`
	IsQueued   bool             `json:"isQueued"`
}

type User struct {
	ID            pgtype.UUID      `json:"id"`
	CreatedAt     pgtype.Timestamp `json:"createdAt"`
	UpdatedAt     pgtype.Timestamp `json:"updatedAt"`
	DeletedAt     pgtype.Timestamp `json:"deletedAt"`
	Email         string           `json:"email"`
	EmailVerified bool             `json:"emailVerified"`
	Name          pgtype.Text      `json:"name"`
}

type UserOAuth struct {
	ID             pgtype.UUID      `json:"id"`
	CreatedAt      pgtype.Timestamp `json:"createdAt"`
	UpdatedAt      pgtype.Timestamp `json:"updatedAt"`
	UserId         pgtype.UUID      `json:"userId"`
	Provider       string           `json:"provider"`
	ProviderUserId string           `json:"providerUserId"`
	ExpiresAt      pgtype.Timestamp `json:"expiresAt"`
	AccessToken    []byte           `json:"accessToken"`
	RefreshToken   []byte           `json:"refreshToken"`
}

type UserPassword struct {
	Hash   string      `json:"hash"`
	UserId pgtype.UUID `json:"userId"`
}

type UserSession struct {
	ID        pgtype.UUID      `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	UserId    pgtype.UUID      `json:"userId"`
	Data      []byte           `json:"data"`
	ExpiresAt pgtype.Timestamp `json:"expiresAt"`
}

type V2Dag struct {
	ID                int64              `json:"id"`
	InsertedAt        pgtype.Timestamptz `json:"inserted_at"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	ExternalID        pgtype.UUID        `json:"external_id"`
	DisplayName       string             `json:"display_name"`
	WorkflowID        pgtype.UUID        `json:"workflow_id"`
	WorkflowVersionID pgtype.UUID        `json:"workflow_version_id"`
}

type V2DagData struct {
	DagID              int64              `json:"dag_id"`
	DagInsertedAt      pgtype.Timestamptz `json:"dag_inserted_at"`
	Input              []byte             `json:"input"`
	AdditionalMetadata []byte             `json:"additional_metadata"`
}

type V2DagToTask struct {
	DagID          int64              `json:"dag_id"`
	DagInsertedAt  pgtype.Timestamptz `json:"dag_inserted_at"`
	TaskID         int64              `json:"task_id"`
	TaskInsertedAt pgtype.Timestamptz `json:"task_inserted_at"`
}

type V2Match struct {
	ID                   int64              `json:"id"`
	TenantID             pgtype.UUID        `json:"tenant_id"`
	Kind                 V2MatchKind        `json:"kind"`
	IsSatisfied          bool               `json:"is_satisfied"`
	SignalTargetID       pgtype.Int8        `json:"signal_target_id"`
	SignalKey            pgtype.Text        `json:"signal_key"`
	TriggerDagID         pgtype.Int8        `json:"trigger_dag_id"`
	TriggerDagInsertedAt pgtype.Timestamptz `json:"trigger_dag_inserted_at"`
	TriggerStepID        pgtype.UUID        `json:"trigger_step_id"`
	TriggerExternalID    pgtype.UUID        `json:"trigger_external_id"`
}

type V2MatchCondition struct {
	V2MatchID    int64                  `json:"v2_match_id"`
	ID           int64                  `json:"id"`
	TenantID     pgtype.UUID            `json:"tenant_id"`
	RegisteredAt pgtype.Timestamptz     `json:"registered_at"`
	EventType    V2EventType            `json:"event_type"`
	EventKey     string                 `json:"event_key"`
	IsSatisfied  bool                   `json:"is_satisfied"`
	Action       V2MatchConditionAction `json:"action"`
	OrGroupID    pgtype.UUID            `json:"or_group_id"`
	Expression   pgtype.Text            `json:"expression"`
	Data         []byte                 `json:"data"`
}

type V2Queue struct {
	TenantID   pgtype.UUID      `json:"tenant_id"`
	Name       string           `json:"name"`
	LastActive pgtype.Timestamp `json:"last_active"`
}

type V2QueueItem struct {
	ID                int64            `json:"id"`
	TenantID          pgtype.UUID      `json:"tenant_id"`
	Queue             string           `json:"queue"`
	TaskID            int64            `json:"task_id"`
	ActionID          string           `json:"action_id"`
	StepID            pgtype.UUID      `json:"step_id"`
	WorkflowID        pgtype.UUID      `json:"workflow_id"`
	ScheduleTimeoutAt pgtype.Timestamp `json:"schedule_timeout_at"`
	StepTimeout       pgtype.Text      `json:"step_timeout"`
	Priority          int32            `json:"priority"`
	Sticky            V2StickyStrategy `json:"sticky"`
	DesiredWorkerID   pgtype.UUID      `json:"desired_worker_id"`
	IsQueued          bool             `json:"is_queued"`
	RetryCount        int32            `json:"retry_count"`
}

type V2Task struct {
	ID                 int64              `json:"id"`
	InsertedAt         pgtype.Timestamptz `json:"inserted_at"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	Queue              string             `json:"queue"`
	ActionID           string             `json:"action_id"`
	StepID             pgtype.UUID        `json:"step_id"`
	StepReadableID     string             `json:"step_readable_id"`
	WorkflowID         pgtype.UUID        `json:"workflow_id"`
	ScheduleTimeout    string             `json:"schedule_timeout"`
	StepTimeout        pgtype.Text        `json:"step_timeout"`
	Priority           pgtype.Int4        `json:"priority"`
	Sticky             V2StickyStrategy   `json:"sticky"`
	DesiredWorkerID    pgtype.UUID        `json:"desired_worker_id"`
	ExternalID         pgtype.UUID        `json:"external_id"`
	DisplayName        string             `json:"display_name"`
	Input              []byte             `json:"input"`
	RetryCount         int32              `json:"retry_count"`
	InternalRetryCount int32              `json:"internal_retry_count"`
	AppRetryCount      int32              `json:"app_retry_count"`
	AdditionalMetadata []byte             `json:"additional_metadata"`
	DagID              pgtype.Int8        `json:"dag_id"`
	DagInsertedAt      pgtype.Timestamptz `json:"dag_inserted_at"`
	ParentExternalID   pgtype.UUID        `json:"parent_external_id"`
	ChildIndex         pgtype.Int4        `json:"child_index"`
	ChildKey           pgtype.Text        `json:"child_key"`
	InitialState       V2TaskInitialState `json:"initial_state"`
}

type V2TaskEvent struct {
	ID         int64            `json:"id"`
	TenantID   pgtype.UUID      `json:"tenant_id"`
	TaskID     int64            `json:"task_id"`
	RetryCount int32            `json:"retry_count"`
	EventType  V2TaskEventType  `json:"event_type"`
	EventKey   pgtype.Text      `json:"event_key"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	Data       []byte           `json:"data"`
}

type V2TaskRuntime struct {
	TaskID     int64            `json:"task_id"`
	RetryCount int32            `json:"retry_count"`
	WorkerID   pgtype.UUID      `json:"worker_id"`
	TenantID   pgtype.UUID      `json:"tenant_id"`
	TimeoutAt  pgtype.Timestamp `json:"timeout_at"`
}

type WebhookWorker struct {
	ID         pgtype.UUID      `json:"id"`
	CreatedAt  pgtype.Timestamp `json:"createdAt"`
	UpdatedAt  pgtype.Timestamp `json:"updatedAt"`
	Name       string           `json:"name"`
	Secret     string           `json:"secret"`
	Url        string           `json:"url"`
	TokenValue pgtype.Text      `json:"tokenValue"`
	Deleted    bool             `json:"deleted"`
	TokenId    pgtype.UUID      `json:"tokenId"`
	TenantId   pgtype.UUID      `json:"tenantId"`
}

type WebhookWorkerRequest struct {
	ID              pgtype.UUID                `json:"id"`
	CreatedAt       pgtype.Timestamp           `json:"createdAt"`
	WebhookWorkerId pgtype.UUID                `json:"webhookWorkerId"`
	Method          WebhookWorkerRequestMethod `json:"method"`
	StatusCode      int32                      `json:"statusCode"`
}

type WebhookWorkerWorkflow struct {
	ID              pgtype.UUID `json:"id"`
	WebhookWorkerId pgtype.UUID `json:"webhookWorkerId"`
	WorkflowId      pgtype.UUID `json:"workflowId"`
}

type Worker struct {
	ID                      pgtype.UUID      `json:"id"`
	CreatedAt               pgtype.Timestamp `json:"createdAt"`
	UpdatedAt               pgtype.Timestamp `json:"updatedAt"`
	DeletedAt               pgtype.Timestamp `json:"deletedAt"`
	TenantId                pgtype.UUID      `json:"tenantId"`
	LastHeartbeatAt         pgtype.Timestamp `json:"lastHeartbeatAt"`
	Name                    string           `json:"name"`
	DispatcherId            pgtype.UUID      `json:"dispatcherId"`
	MaxRuns                 int32            `json:"maxRuns"`
	IsActive                bool             `json:"isActive"`
	LastListenerEstablished pgtype.Timestamp `json:"lastListenerEstablished"`
	IsPaused                bool             `json:"isPaused"`
	Type                    WorkerType       `json:"type"`
	WebhookId               pgtype.UUID      `json:"webhookId"`
	Language                NullWorkerSDKS   `json:"language"`
	LanguageVersion         pgtype.Text      `json:"languageVersion"`
	Os                      pgtype.Text      `json:"os"`
	RuntimeExtra            pgtype.Text      `json:"runtimeExtra"`
	SdkVersion              pgtype.Text      `json:"sdkVersion"`
}

type WorkerAssignEvent struct {
	ID               int64       `json:"id"`
	WorkerId         pgtype.UUID `json:"workerId"`
	AssignedStepRuns []byte      `json:"assignedStepRuns"`
}

type WorkerLabel struct {
	ID        int64            `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	WorkerId  pgtype.UUID      `json:"workerId"`
	Key       string           `json:"key"`
	StrValue  pgtype.Text      `json:"strValue"`
	IntValue  pgtype.Int4      `json:"intValue"`
}

type Workflow struct {
	ID          pgtype.UUID      `json:"id"`
	CreatedAt   pgtype.Timestamp `json:"createdAt"`
	UpdatedAt   pgtype.Timestamp `json:"updatedAt"`
	DeletedAt   pgtype.Timestamp `json:"deletedAt"`
	TenantId    pgtype.UUID      `json:"tenantId"`
	Name        string           `json:"name"`
	Description pgtype.Text      `json:"description"`
	IsPaused    pgtype.Bool      `json:"isPaused"`
}

type WorkflowConcurrency struct {
	ID                         pgtype.UUID              `json:"id"`
	CreatedAt                  pgtype.Timestamp         `json:"createdAt"`
	UpdatedAt                  pgtype.Timestamp         `json:"updatedAt"`
	WorkflowVersionId          pgtype.UUID              `json:"workflowVersionId"`
	GetConcurrencyGroupId      pgtype.UUID              `json:"getConcurrencyGroupId"`
	MaxRuns                    int32                    `json:"maxRuns"`
	LimitStrategy              ConcurrencyLimitStrategy `json:"limitStrategy"`
	ConcurrencyGroupExpression pgtype.Text              `json:"concurrencyGroupExpression"`
}

type WorkflowRun struct {
	CreatedAt          pgtype.Timestamp  `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp  `json:"updatedAt"`
	DeletedAt          pgtype.Timestamp  `json:"deletedAt"`
	TenantId           pgtype.UUID       `json:"tenantId"`
	WorkflowVersionId  pgtype.UUID       `json:"workflowVersionId"`
	Status             WorkflowRunStatus `json:"status"`
	Error              pgtype.Text       `json:"error"`
	StartedAt          pgtype.Timestamp  `json:"startedAt"`
	FinishedAt         pgtype.Timestamp  `json:"finishedAt"`
	ConcurrencyGroupId pgtype.Text       `json:"concurrencyGroupId"`
	DisplayName        pgtype.Text       `json:"displayName"`
	ID                 pgtype.UUID       `json:"id"`
	ChildIndex         pgtype.Int4       `json:"childIndex"`
	ChildKey           pgtype.Text       `json:"childKey"`
	ParentId           pgtype.UUID       `json:"parentId"`
	ParentStepRunId    pgtype.UUID       `json:"parentStepRunId"`
	AdditionalMetadata []byte            `json:"additionalMetadata"`
	Duration           pgtype.Int8       `json:"duration"`
	Priority           pgtype.Int4       `json:"priority"`
	InsertOrder        pgtype.Int4       `json:"insertOrder"`
}

type WorkflowRunDedupe struct {
	ID            int64            `json:"id"`
	CreatedAt     pgtype.Timestamp `json:"createdAt"`
	UpdatedAt     pgtype.Timestamp `json:"updatedAt"`
	TenantId      pgtype.UUID      `json:"tenantId"`
	WorkflowId    pgtype.UUID      `json:"workflowId"`
	WorkflowRunId pgtype.UUID      `json:"workflowRunId"`
	Value         string           `json:"value"`
}

type WorkflowRunStickyState struct {
	ID              int64            `json:"id"`
	CreatedAt       pgtype.Timestamp `json:"createdAt"`
	UpdatedAt       pgtype.Timestamp `json:"updatedAt"`
	TenantId        pgtype.UUID      `json:"tenantId"`
	WorkflowRunId   pgtype.UUID      `json:"workflowRunId"`
	DesiredWorkerId pgtype.UUID      `json:"desiredWorkerId"`
	Strategy        StickyStrategy   `json:"strategy"`
}

type WorkflowRunTriggeredBy struct {
	ID           pgtype.UUID      `json:"id"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	UpdatedAt    pgtype.Timestamp `json:"updatedAt"`
	DeletedAt    pgtype.Timestamp `json:"deletedAt"`
	TenantId     pgtype.UUID      `json:"tenantId"`
	EventId      pgtype.UUID      `json:"eventId"`
	CronParentId pgtype.UUID      `json:"cronParentId"`
	CronSchedule pgtype.Text      `json:"cronSchedule"`
	ScheduledId  pgtype.UUID      `json:"scheduledId"`
	Input        []byte           `json:"input"`
	ParentId     pgtype.UUID      `json:"parentId"`
	CronName     pgtype.Text      `json:"cronName"`
}

type WorkflowTag struct {
	ID        pgtype.UUID      `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	TenantId  pgtype.UUID      `json:"tenantId"`
	Name      string           `json:"name"`
	Color     string           `json:"color"`
}

type WorkflowToWorkflowTag struct {
	A pgtype.UUID `json:"A"`
	B pgtype.UUID `json:"B"`
}

type WorkflowTriggerCronRef struct {
	ParentId           pgtype.UUID                   `json:"parentId"`
	Cron               string                        `json:"cron"`
	TickerId           pgtype.UUID                   `json:"tickerId"`
	Input              []byte                        `json:"input"`
	Enabled            bool                          `json:"enabled"`
	AdditionalMetadata []byte                        `json:"additionalMetadata"`
	CreatedAt          pgtype.Timestamp              `json:"createdAt"`
	DeletedAt          pgtype.Timestamp              `json:"deletedAt"`
	UpdatedAt          pgtype.Timestamp              `json:"updatedAt"`
	Name               pgtype.Text                   `json:"name"`
	ID                 pgtype.UUID                   `json:"id"`
	Method             WorkflowTriggerCronRefMethods `json:"method"`
}

type WorkflowTriggerEventRef struct {
	ParentId pgtype.UUID `json:"parentId"`
	EventKey string      `json:"eventKey"`
}

type WorkflowTriggerScheduledRef struct {
	ID                  pgtype.UUID                        `json:"id"`
	ParentId            pgtype.UUID                        `json:"parentId"`
	TriggerAt           pgtype.Timestamp                   `json:"triggerAt"`
	TickerId            pgtype.UUID                        `json:"tickerId"`
	Input               []byte                             `json:"input"`
	ChildIndex          pgtype.Int4                        `json:"childIndex"`
	ChildKey            pgtype.Text                        `json:"childKey"`
	ParentStepRunId     pgtype.UUID                        `json:"parentStepRunId"`
	ParentWorkflowRunId pgtype.UUID                        `json:"parentWorkflowRunId"`
	AdditionalMetadata  []byte                             `json:"additionalMetadata"`
	CreatedAt           pgtype.Timestamp                   `json:"createdAt"`
	DeletedAt           pgtype.Timestamp                   `json:"deletedAt"`
	UpdatedAt           pgtype.Timestamp                   `json:"updatedAt"`
	Method              WorkflowTriggerScheduledRefMethods `json:"method"`
}

type WorkflowTriggers struct {
	ID                pgtype.UUID      `json:"id"`
	CreatedAt         pgtype.Timestamp `json:"createdAt"`
	UpdatedAt         pgtype.Timestamp `json:"updatedAt"`
	DeletedAt         pgtype.Timestamp `json:"deletedAt"`
	WorkflowVersionId pgtype.UUID      `json:"workflowVersionId"`
	TenantId          pgtype.UUID      `json:"tenantId"`
}

type WorkflowVersion struct {
	ID              pgtype.UUID        `json:"id"`
	CreatedAt       pgtype.Timestamp   `json:"createdAt"`
	UpdatedAt       pgtype.Timestamp   `json:"updatedAt"`
	DeletedAt       pgtype.Timestamp   `json:"deletedAt"`
	Version         pgtype.Text        `json:"version"`
	Order           int64              `json:"order"`
	WorkflowId      pgtype.UUID        `json:"workflowId"`
	Checksum        string             `json:"checksum"`
	ScheduleTimeout string             `json:"scheduleTimeout"`
	OnFailureJobId  pgtype.UUID        `json:"onFailureJobId"`
	Sticky          NullStickyStrategy `json:"sticky"`
	Kind            WorkflowKind       `json:"kind"`
	DefaultPriority pgtype.Int4        `json:"defaultPriority"`
}
