// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: logs.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countLogLines = `-- name: CountLogLines :one
SELECT COUNT(*) AS total
FROM "LogLine"
WHERE
  "tenantId" = $1::uuid AND
  ($2::uuid IS NULL OR "stepRunId" = $2::uuid) AND
  ($3::text IS NULL OR "message" LIKE concat('%', $3::text, '%')) AND
  ($4::"LogLineLevel"[] IS NULL OR "level" = ANY($4::"LogLineLevel"[]))
`

type CountLogLinesParams struct {
	Tenantid  pgtype.UUID    `json:"tenantid"`
	StepRunId pgtype.UUID    `json:"stepRunId"`
	Search    pgtype.Text    `json:"search"`
	Levels    []LogLineLevel `json:"levels"`
}

func (q *Queries) CountLogLines(ctx context.Context, db DBTX, arg CountLogLinesParams) (int64, error) {
	row := db.QueryRow(ctx, countLogLines,
		arg.Tenantid,
		arg.StepRunId,
		arg.Search,
		arg.Levels,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createLogLine = `-- name: CreateLogLine :one
INSERT INTO "LogLine" (
    "createdAt",
    "tenantId",
    "stepRunId",
    "message",
    "level",
    "metadata"
)
SELECT
    coalesce($1::timestamp, now()),
    $2::uuid,
    $3::uuid,
    $4::text,
    coalesce($5::"LogLineLevel", 'INFO'::"LogLineLevel"),
    coalesce($6::jsonb, '{}'::jsonb)
FROM "StepRun"
WHERE "StepRun"."id" = $3::uuid
AND "StepRun"."tenantId" = $2::uuid
RETURNING id, "createdAt", "tenantId", "stepRunId", message, level, metadata
`

type CreateLogLineParams struct {
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	Tenantid  pgtype.UUID      `json:"tenantid"`
	Steprunid pgtype.UUID      `json:"steprunid"`
	Message   string           `json:"message"`
	Level     NullLogLineLevel `json:"level"`
	Metadata  []byte           `json:"metadata"`
}

func (q *Queries) CreateLogLine(ctx context.Context, db DBTX, arg CreateLogLineParams) (*LogLine, error) {
	row := db.QueryRow(ctx, createLogLine,
		arg.CreatedAt,
		arg.Tenantid,
		arg.Steprunid,
		arg.Message,
		arg.Level,
		arg.Metadata,
	)
	var i LogLine
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.TenantId,
		&i.StepRunId,
		&i.Message,
		&i.Level,
		&i.Metadata,
	)
	return &i, err
}

const listLogLines = `-- name: ListLogLines :many
SELECT id, "createdAt", "tenantId", "stepRunId", message, level, metadata FROM "LogLine"
WHERE
  "tenantId" = $1::uuid AND
  ($2::uuid IS NULL OR "stepRunId" = $2::uuid) AND
  ($3::text IS NULL OR "message" LIKE concat('%', $3::text, '%')) AND
  ($4::"LogLineLevel"[] IS NULL OR "level" = ANY($4::"LogLineLevel"[]))
ORDER BY
  CASE WHEN $5::text = 'createdAt ASC' THEN "createdAt" END ASC,
  CASE WHEN $5::text = 'createdAt DESC' THEN "createdAt" END DESC,
  -- add order by id to make sure the order is deterministic
  CASE WHEN $5::text = 'createdAt ASC' THEN "id" END ASC,
  CASE WHEN $5::text = 'createdAt DESC' THEN "id" END DESC
LIMIT COALESCE($7, 50)
OFFSET COALESCE($6, 0)
`

type ListLogLinesParams struct {
	Tenantid  pgtype.UUID    `json:"tenantid"`
	StepRunId pgtype.UUID    `json:"stepRunId"`
	Search    pgtype.Text    `json:"search"`
	Levels    []LogLineLevel `json:"levels"`
	OrderBy   pgtype.Text    `json:"orderBy"`
	Offset    interface{}    `json:"offset"`
	Limit     interface{}    `json:"limit"`
}

func (q *Queries) ListLogLines(ctx context.Context, db DBTX, arg ListLogLinesParams) ([]*LogLine, error) {
	rows, err := db.Query(ctx, listLogLines,
		arg.Tenantid,
		arg.StepRunId,
		arg.Search,
		arg.Levels,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*LogLine
	for rows.Next() {
		var i LogLine
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.TenantId,
			&i.StepRunId,
			&i.Message,
			&i.Level,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
