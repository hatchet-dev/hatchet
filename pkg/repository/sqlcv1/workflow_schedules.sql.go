// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: workflow_schedules.sql

package sqlcv1

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const bulkDeleteScheduledWorkflows = `-- name: BulkDeleteScheduledWorkflows :many
DELETE FROM "WorkflowTriggerScheduledRef" t
USING "WorkflowVersion" v, "Workflow" w
WHERE
    t."parentId" = v."id"
    AND v."workflowId" = w."id"
    AND w."tenantId" = $1::uuid
    AND t."method" = 'API'
    AND t."id" = ANY($2::uuid[])
RETURNING t."id"
`

type BulkDeleteScheduledWorkflowsParams struct {
	Tenantid uuid.UUID   `json:"tenantid"`
	Ids      []uuid.UUID `json:"ids"`
}

func (q *Queries) BulkDeleteScheduledWorkflows(ctx context.Context, db DBTX, arg BulkDeleteScheduledWorkflowsParams) ([]uuid.UUID, error) {
	rows, err := db.Query(ctx, bulkDeleteScheduledWorkflows, arg.Tenantid, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bulkUpdateScheduledWorkflows = `-- name: BulkUpdateScheduledWorkflows :many
WITH input AS (
    SELECT
        ids.id,
        times."triggerAt"
    FROM unnest($2::uuid[]) WITH ORDINALITY AS ids(id, ord)
    JOIN unnest($3::timestamp[]) WITH ORDINALITY AS times("triggerAt", ord)
        USING (ord)
)
UPDATE "WorkflowTriggerScheduledRef" t
SET "triggerAt" = i."triggerAt"
FROM input i, "WorkflowVersion" v, "Workflow" w
WHERE
    t."id" = i.id
    AND t."parentId" = v."id"
    AND v."workflowId" = w."id"
    AND w."tenantId" = $1::uuid
    AND t."method" = 'API'
    AND NOT EXISTS (
        SELECT 1
        FROM "WorkflowRunTriggeredBy" tb
        WHERE tb."scheduledId" = t."id"
    )
RETURNING t."id"
`

type BulkUpdateScheduledWorkflowsParams struct {
	Tenantid   uuid.UUID          `json:"tenantid"`
	Ids        []uuid.UUID        `json:"ids"`
	Triggerats []pgtype.Timestamp `json:"triggerats"`
}

func (q *Queries) BulkUpdateScheduledWorkflows(ctx context.Context, db DBTX, arg BulkUpdateScheduledWorkflowsParams) ([]uuid.UUID, error) {
	rows, err := db.Query(ctx, bulkUpdateScheduledWorkflows, arg.Tenantid, arg.Ids, arg.Triggerats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countCronWorkflows = `-- name: CountCronWorkflows :one
WITH latest_versions AS (
    SELECT DISTINCT ON("workflowId")
        workflowVersions."id" AS "workflowVersionId",
        workflowVersions."workflowId"
    FROM
        "WorkflowVersion" as workflowVersions
    JOIN
        "Workflow" as workflow ON workflow."id" = workflowVersions."workflowId"
    WHERE
        workflow."tenantId" = $1::uuid
        AND workflowVersions."deletedAt" IS NULL
    ORDER BY "workflowId", "order" DESC
)
SELECT
    count(c.*)
FROM
    latest_versions
JOIN
    "WorkflowTriggers" as t ON t."workflowVersionId" = latest_versions."workflowVersionId"
JOIN
    "WorkflowTriggerCronRef" as c ON c."parentId" = t."id"
JOIN
    "Workflow" w on w."id" = latest_versions."workflowId"
WHERE
    t."deletedAt" IS NULL
    AND w."tenantId" = $1::uuid
    AND ($2::uuid IS NULL OR c."id" = $2::uuid)
    AND ($3::uuid IS NULL OR w."id" = $3::uuid)
    AND ($4::jsonb IS NULL OR
        c."additionalMetadata" @> $4::jsonb)
    AND ($5::TEXT IS NULL OR c."name" = $5::TEXT)
    AND ($6::TEXT IS NULL OR w."name" = $6::TEXT)
`

type CountCronWorkflowsParams struct {
	Tenantid           uuid.UUID   `json:"tenantid"`
	CronTriggerId      *uuid.UUID  `json:"cronTriggerId"`
	WorkflowId         *uuid.UUID  `json:"workflowId"`
	AdditionalMetadata []byte      `json:"additionalMetadata"`
	CronName           pgtype.Text `json:"cronName"`
	WorkflowName       pgtype.Text `json:"workflowName"`
}

// Get all of the latest workflow versions for the tenant
func (q *Queries) CountCronWorkflows(ctx context.Context, db DBTX, arg CountCronWorkflowsParams) (int64, error) {
	row := db.QueryRow(ctx, countCronWorkflows,
		arg.Tenantid,
		arg.CronTriggerId,
		arg.WorkflowId,
		arg.AdditionalMetadata,
		arg.CronName,
		arg.WorkflowName,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countScheduledWorkflows = `-- name: CountScheduledWorkflows :one
SELECT count(*)
FROM "WorkflowTriggerScheduledRef" t
JOIN "WorkflowVersion" v ON t."parentId" = v."id"
JOIN "Workflow" w on v."workflowId" = w."id"
LEFT JOIN "WorkflowRunTriggeredBy" tb ON t."id" = tb."scheduledId"
LEFT JOIN "WorkflowRun" wr ON tb."parentId" = wr."id"
WHERE v."deletedAt" IS NULL
	AND w."tenantId" = $1::uuid
    AND ($2::uuid IS NULL OR t."id" = $2::uuid)
    AND ($3::uuid IS NULL OR w."id" = $3::uuid)
    AND ($4::uuid IS NULL OR t."id" = $4::uuid)
    AND ($5::uuid IS NULL OR t."parentStepRunId" = $5::uuid)
    AND ($6::jsonb IS NULL OR
        t."additionalMetadata" @> $6::jsonb)
    AND (
        $7::text[] IS NULL OR
        wr."status" = ANY(cast($7::text[] as "WorkflowRunStatus"[]))
        or (
            $8::boolean IS TRUE AND
            wr."status" IS NULL
        )
    )
`

type CountScheduledWorkflowsParams struct {
	Tenantid            uuid.UUID  `json:"tenantid"`
	ScheduleId          *uuid.UUID `json:"scheduleId"`
	WorkflowId          *uuid.UUID `json:"workflowId"`
	ParentWorkflowRunId *uuid.UUID `json:"parentWorkflowRunId"`
	ParentStepRunId     *uuid.UUID `json:"parentStepRunId"`
	AdditionalMetadata  []byte     `json:"additionalMetadata"`
	Statuses            []string   `json:"statuses"`
	Includescheduled    bool       `json:"includescheduled"`
}

func (q *Queries) CountScheduledWorkflows(ctx context.Context, db DBTX, arg CountScheduledWorkflowsParams) (int64, error) {
	row := db.QueryRow(ctx, countScheduledWorkflows,
		arg.Tenantid,
		arg.ScheduleId,
		arg.WorkflowId,
		arg.ParentWorkflowRunId,
		arg.ParentStepRunId,
		arg.AdditionalMetadata,
		arg.Statuses,
		arg.Includescheduled,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWorkflowTriggerScheduledRefForWorkflow = `-- name: CreateWorkflowTriggerScheduledRefForWorkflow :one
WITH latest_version AS (
    SELECT "id" FROM "WorkflowVersion"
    WHERE "workflowId" = $6::uuid
    ORDER BY "order" DESC
    LIMIT 1
),
latest_trigger AS (
    SELECT "id" FROM "WorkflowTriggers"
    WHERE "workflowVersionId" = (SELECT "id" FROM latest_version)
    ORDER BY "createdAt" DESC
    LIMIT 1
)
INSERT INTO "WorkflowTriggerScheduledRef" (
    "id",
    "parentId",
    "triggerAt",
    "input",
    "additionalMetadata",
    "method",
    "priority"
) VALUES (
    gen_random_uuid(),
    (SELECT "id" FROM latest_version),
    $1::timestamp,
    $2::jsonb,
    $3::jsonb,
    COALESCE($4::"WorkflowTriggerScheduledRefMethods", 'DEFAULT'),
    COALESCE($5::integer, 1)
) RETURNING id, "parentId", "triggerAt", "tickerId", input, "childIndex", "childKey", "parentStepRunId", "parentWorkflowRunId", "additionalMetadata", "createdAt", "deletedAt", "updatedAt", method, priority
`

type CreateWorkflowTriggerScheduledRefForWorkflowParams struct {
	Scheduledtrigger   pgtype.Timestamp                       `json:"scheduledtrigger"`
	Input              []byte                                 `json:"input"`
	Additionalmetadata []byte                                 `json:"additionalmetadata"`
	Method             NullWorkflowTriggerScheduledRefMethods `json:"method"`
	Priority           pgtype.Int4                            `json:"priority"`
	Workflowid         uuid.UUID                              `json:"workflowid"`
}

func (q *Queries) CreateWorkflowTriggerScheduledRefForWorkflow(ctx context.Context, db DBTX, arg CreateWorkflowTriggerScheduledRefForWorkflowParams) (*WorkflowTriggerScheduledRef, error) {
	row := db.QueryRow(ctx, createWorkflowTriggerScheduledRefForWorkflow,
		arg.Scheduledtrigger,
		arg.Input,
		arg.Additionalmetadata,
		arg.Method,
		arg.Priority,
		arg.Workflowid,
	)
	var i WorkflowTriggerScheduledRef
	err := row.Scan(
		&i.ID,
		&i.ParentId,
		&i.TriggerAt,
		&i.TickerId,
		&i.Input,
		&i.ChildIndex,
		&i.ChildKey,
		&i.ParentStepRunId,
		&i.ParentWorkflowRunId,
		&i.AdditionalMetadata,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UpdatedAt,
		&i.Method,
		&i.Priority,
	)
	return &i, err
}

const deleteScheduledWorkflow = `-- name: DeleteScheduledWorkflow :exec
DELETE FROM "WorkflowTriggerScheduledRef"
WHERE
    "id" = $1::uuid
`

func (q *Queries) DeleteScheduledWorkflow(ctx context.Context, db DBTX, scheduleid uuid.UUID) error {
	_, err := db.Exec(ctx, deleteScheduledWorkflow, scheduleid)
	return err
}

const deleteWorkflowTriggerCronRef = `-- name: DeleteWorkflowTriggerCronRef :exec
DELETE FROM "WorkflowTriggerCronRef"
WHERE
    "id" = $1::uuid
`

func (q *Queries) DeleteWorkflowTriggerCronRef(ctx context.Context, db DBTX, id uuid.UUID) error {
	_, err := db.Exec(ctx, deleteWorkflowTriggerCronRef, id)
	return err
}

const getScheduledWorkflowMetaByIds = `-- name: GetScheduledWorkflowMetaByIds :many
SELECT
    t."id",
    t."method",
    EXISTS (
        SELECT 1
        FROM "WorkflowRunTriggeredBy" tb
        WHERE tb."scheduledId" = t."id"
    ) AS "hasTriggeredRun"
FROM "WorkflowTriggerScheduledRef" t
JOIN "WorkflowVersion" v ON t."parentId" = v."id"
JOIN "Workflow" w ON v."workflowId" = w."id"
WHERE
    w."tenantId" = $1::uuid
    AND t."id" = ANY($2::uuid[])
`

type GetScheduledWorkflowMetaByIdsParams struct {
	Tenantid uuid.UUID   `json:"tenantid"`
	Ids      []uuid.UUID `json:"ids"`
}

type GetScheduledWorkflowMetaByIdsRow struct {
	ID              uuid.UUID                          `json:"id"`
	Method          WorkflowTriggerScheduledRefMethods `json:"method"`
	HasTriggeredRun bool                               `json:"hasTriggeredRun"`
}

func (q *Queries) GetScheduledWorkflowMetaByIds(ctx context.Context, db DBTX, arg GetScheduledWorkflowMetaByIdsParams) ([]*GetScheduledWorkflowMetaByIdsRow, error) {
	rows, err := db.Query(ctx, getScheduledWorkflowMetaByIds, arg.Tenantid, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetScheduledWorkflowMetaByIdsRow
	for rows.Next() {
		var i GetScheduledWorkflowMetaByIdsRow
		if err := rows.Scan(&i.ID, &i.Method, &i.HasTriggeredRun); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCronWorkflows = `-- name: ListCronWorkflows :many
WITH latest_versions AS (
    SELECT DISTINCT ON("workflowId")
        workflowVersions."id" AS "workflowVersionId",
        workflowVersions."workflowId"
    FROM
        "WorkflowVersion" as workflowVersions
    JOIN
        "Workflow" as workflow ON workflow."id" = workflowVersions."workflowId"
    WHERE
        workflow."tenantId" = $1::uuid
        AND workflowVersions."deletedAt" IS NULL
    ORDER BY "workflowId", "order" DESC
)
SELECT
    latest_versions."workflowVersionId",
    w."name" as "workflowName",
    w."id" as "workflowId",
    w."tenantId",
    t."id" as "triggerId",
    c."id" as "cronId",
    t.id, t."createdAt", t."updatedAt", t."deletedAt", t."workflowVersionId", t."tenantId",
    c."parentId", c.cron, c."tickerId", c.input, c.enabled, c."additionalMetadata", c."createdAt", c."deletedAt", c."updatedAt", c.name, c.id, c.method, c.priority
FROM
    latest_versions
JOIN
    "WorkflowTriggers" as t ON t."workflowVersionId" = latest_versions."workflowVersionId"
JOIN
    "WorkflowTriggerCronRef" as c ON c."parentId" = t."id"
JOIN
    "Workflow" w on w."id" = latest_versions."workflowId"
WHERE
    t."deletedAt" IS NULL
    AND w."tenantId" = $1::uuid
    AND ($2::uuid IS NULL OR c."id" = $2::uuid)
    AND ($3::uuid IS NULL OR w."id" = $3::uuid)
    AND ($4::jsonb IS NULL OR
        c."additionalMetadata" @> $4::jsonb)
    AND ($5::TEXT IS NULL OR c."name" = $5::TEXT)
    AND ($6::TEXT IS NULL OR w."name" = $6::TEXT)
ORDER BY
    case when $7 = 'name ASC' THEN w."name" END ASC,
    case when $7 = 'name DESC' THEN w."name" END DESC,
    case when $7 = 'createdAt ASC' THEN c."createdAt" END ASC ,
    case when $7 = 'createdAt DESC' THEN c."createdAt" END DESC,
    t."id" ASC
OFFSET
    COALESCE($8, 0)
LIMIT
    COALESCE($9, 50)
`

type ListCronWorkflowsParams struct {
	Tenantid           uuid.UUID   `json:"tenantid"`
	CronTriggerId      *uuid.UUID  `json:"cronTriggerId"`
	WorkflowId         *uuid.UUID  `json:"workflowId"`
	AdditionalMetadata []byte      `json:"additionalMetadata"`
	CronName           pgtype.Text `json:"cronName"`
	WorkflowName       pgtype.Text `json:"workflowName"`
	Orderby            interface{} `json:"orderby"`
	Offset             interface{} `json:"offset"`
	Limit              interface{} `json:"limit"`
}

type ListCronWorkflowsRow struct {
	WorkflowVersionId   uuid.UUID                     `json:"workflowVersionId"`
	WorkflowName        string                        `json:"workflowName"`
	WorkflowId          uuid.UUID                     `json:"workflowId"`
	TenantId            uuid.UUID                     `json:"tenantId"`
	TriggerId           uuid.UUID                     `json:"triggerId"`
	CronId              uuid.UUID                     `json:"cronId"`
	ID                  uuid.UUID                     `json:"id"`
	CreatedAt           pgtype.Timestamp              `json:"createdAt"`
	UpdatedAt           pgtype.Timestamp              `json:"updatedAt"`
	DeletedAt           pgtype.Timestamp              `json:"deletedAt"`
	WorkflowVersionId_2 uuid.UUID                     `json:"workflowVersionId_2"`
	TenantId_2          uuid.UUID                     `json:"tenantId_2"`
	ParentId            uuid.UUID                     `json:"parentId"`
	Cron                string                        `json:"cron"`
	TickerId            *uuid.UUID                    `json:"tickerId"`
	Input               []byte                        `json:"input"`
	Enabled             bool                          `json:"enabled"`
	AdditionalMetadata  []byte                        `json:"additionalMetadata"`
	CreatedAt_2         pgtype.Timestamp              `json:"createdAt_2"`
	DeletedAt_2         pgtype.Timestamp              `json:"deletedAt_2"`
	UpdatedAt_2         pgtype.Timestamp              `json:"updatedAt_2"`
	Name                pgtype.Text                   `json:"name"`
	ID_2                uuid.UUID                     `json:"id_2"`
	Method              WorkflowTriggerCronRefMethods `json:"method"`
	Priority            int32                         `json:"priority"`
}

// Get all of the latest workflow versions for the tenant
func (q *Queries) ListCronWorkflows(ctx context.Context, db DBTX, arg ListCronWorkflowsParams) ([]*ListCronWorkflowsRow, error) {
	rows, err := db.Query(ctx, listCronWorkflows,
		arg.Tenantid,
		arg.CronTriggerId,
		arg.WorkflowId,
		arg.AdditionalMetadata,
		arg.CronName,
		arg.WorkflowName,
		arg.Orderby,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListCronWorkflowsRow
	for rows.Next() {
		var i ListCronWorkflowsRow
		if err := rows.Scan(
			&i.WorkflowVersionId,
			&i.WorkflowName,
			&i.WorkflowId,
			&i.TenantId,
			&i.TriggerId,
			&i.CronId,
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.WorkflowVersionId_2,
			&i.TenantId_2,
			&i.ParentId,
			&i.Cron,
			&i.TickerId,
			&i.Input,
			&i.Enabled,
			&i.AdditionalMetadata,
			&i.CreatedAt_2,
			&i.DeletedAt_2,
			&i.UpdatedAt_2,
			&i.Name,
			&i.ID_2,
			&i.Method,
			&i.Priority,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScheduledWorkflows = `-- name: ListScheduledWorkflows :many
SELECT
    w."name",
    w."id" as "workflowId",
    v."id" as "workflowVersionId",
    w."tenantId",
    t.id, t."parentId", t."triggerAt", t."tickerId", t.input, t."childIndex", t."childKey", t."parentStepRunId", t."parentWorkflowRunId", t."additionalMetadata", t."createdAt", t."deletedAt", t."updatedAt", t.method, t.priority,
    wr."createdAt" as "workflowRunCreatedAt",
    wr."status" as "workflowRunStatus",
    wr."id" as "workflowRunId",
    wr."displayName" as "workflowRunName"
FROM "WorkflowTriggerScheduledRef" t
JOIN "WorkflowVersion" v ON t."parentId" = v."id"
JOIN "Workflow" w on v."workflowId" = w."id"
LEFT JOIN "WorkflowRunTriggeredBy" tb ON t."id" = tb."scheduledId"
LEFT JOIN "WorkflowRun" wr ON tb."parentId" = wr."id"
WHERE v."deletedAt" IS NULL
	AND w."tenantId" = $1::uuid
    AND ($2::uuid IS NULL OR t."id" = $2::uuid)
    AND ($3::uuid IS NULL OR w."id" = $3::uuid)
    AND ($4::uuid IS NULL OR t."id" = $4::uuid)
    AND ($5::uuid IS NULL OR t."parentStepRunId" = $5::uuid)
    AND ($6::jsonb IS NULL OR
        t."additionalMetadata" @> $6::jsonb)
    AND (
        $7::text[] IS NULL OR
        wr."status" = ANY(cast($7::text[] as "WorkflowRunStatus"[]))
        or (
            $8::boolean IS TRUE AND
            wr."status" IS NULL
        )
    )
ORDER BY
    case when $9 = 'triggerAt ASC' THEN t."triggerAt" END ASC ,
    case when $9 = 'triggerAt DESC' THEN t."triggerAt" END DESC,
    case when $9 = 'createdAt ASC' THEN t."createdAt" END ASC ,
    case when $9 = 'createdAt DESC' THEN t."createdAt" END DESC,
    t."id" ASC
OFFSET
    COALESCE($10, 0)
LIMIT
    COALESCE($11, 50)
`

type ListScheduledWorkflowsParams struct {
	Tenantid            uuid.UUID   `json:"tenantid"`
	ScheduleId          *uuid.UUID  `json:"scheduleId"`
	WorkflowId          *uuid.UUID  `json:"workflowId"`
	ParentWorkflowRunId *uuid.UUID  `json:"parentWorkflowRunId"`
	ParentStepRunId     *uuid.UUID  `json:"parentStepRunId"`
	AdditionalMetadata  []byte      `json:"additionalMetadata"`
	Statuses            []string    `json:"statuses"`
	Includescheduled    bool        `json:"includescheduled"`
	Orderby             interface{} `json:"orderby"`
	Offset              interface{} `json:"offset"`
	Limit               interface{} `json:"limit"`
}

type ListScheduledWorkflowsRow struct {
	Name                 string                             `json:"name"`
	WorkflowId           uuid.UUID                          `json:"workflowId"`
	WorkflowVersionId    uuid.UUID                          `json:"workflowVersionId"`
	TenantId             uuid.UUID                          `json:"tenantId"`
	ID                   uuid.UUID                          `json:"id"`
	ParentId             uuid.UUID                          `json:"parentId"`
	TriggerAt            pgtype.Timestamp                   `json:"triggerAt"`
	TickerId             *uuid.UUID                         `json:"tickerId"`
	Input                []byte                             `json:"input"`
	ChildIndex           pgtype.Int4                        `json:"childIndex"`
	ChildKey             pgtype.Text                        `json:"childKey"`
	ParentStepRunId      *uuid.UUID                         `json:"parentStepRunId"`
	ParentWorkflowRunId  *uuid.UUID                         `json:"parentWorkflowRunId"`
	AdditionalMetadata   []byte                             `json:"additionalMetadata"`
	CreatedAt            pgtype.Timestamp                   `json:"createdAt"`
	DeletedAt            pgtype.Timestamp                   `json:"deletedAt"`
	UpdatedAt            pgtype.Timestamp                   `json:"updatedAt"`
	Method               WorkflowTriggerScheduledRefMethods `json:"method"`
	Priority             int32                              `json:"priority"`
	WorkflowRunCreatedAt pgtype.Timestamp                   `json:"workflowRunCreatedAt"`
	WorkflowRunStatus    NullWorkflowRunStatus              `json:"workflowRunStatus"`
	WorkflowRunId        *uuid.UUID                         `json:"workflowRunId"`
	WorkflowRunName      pgtype.Text                        `json:"workflowRunName"`
}

func (q *Queries) ListScheduledWorkflows(ctx context.Context, db DBTX, arg ListScheduledWorkflowsParams) ([]*ListScheduledWorkflowsRow, error) {
	rows, err := db.Query(ctx, listScheduledWorkflows,
		arg.Tenantid,
		arg.ScheduleId,
		arg.WorkflowId,
		arg.ParentWorkflowRunId,
		arg.ParentStepRunId,
		arg.AdditionalMetadata,
		arg.Statuses,
		arg.Includescheduled,
		arg.Orderby,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListScheduledWorkflowsRow
	for rows.Next() {
		var i ListScheduledWorkflowsRow
		if err := rows.Scan(
			&i.Name,
			&i.WorkflowId,
			&i.WorkflowVersionId,
			&i.TenantId,
			&i.ID,
			&i.ParentId,
			&i.TriggerAt,
			&i.TickerId,
			&i.Input,
			&i.ChildIndex,
			&i.ChildKey,
			&i.ParentStepRunId,
			&i.ParentWorkflowRunId,
			&i.AdditionalMetadata,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.UpdatedAt,
			&i.Method,
			&i.Priority,
			&i.WorkflowRunCreatedAt,
			&i.WorkflowRunStatus,
			&i.WorkflowRunId,
			&i.WorkflowRunName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateScheduledWorkflow = `-- name: UpdateScheduledWorkflow :exec
UPDATE "WorkflowTriggerScheduledRef"
SET "triggerAt" = $1::timestamp
WHERE
    "id" = $2::uuid
`

type UpdateScheduledWorkflowParams struct {
	Triggerat  pgtype.Timestamp `json:"triggerat"`
	Scheduleid uuid.UUID        `json:"scheduleid"`
}

func (q *Queries) UpdateScheduledWorkflow(ctx context.Context, db DBTX, arg UpdateScheduledWorkflowParams) error {
	_, err := db.Exec(ctx, updateScheduledWorkflow, arg.Triggerat, arg.Scheduleid)
	return err
}
