// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: workers.sql

package sqlcv1

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createWorker = `-- name: CreateWorker :one
INSERT INTO "Worker" (
    "id",
    "createdAt",
    "updatedAt",
    "tenantId",
    "name",
    "dispatcherId",
    "webhookId",
    "type",
    "sdkVersion",
    "language",
    "languageVersion",
    "os",
    "runtimeExtra"
) VALUES (
    gen_random_uuid(),
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    $1::uuid,
    $2::text,
    $3::uuid,
    $4::uuid,
    $5::"WorkerType",
    $6::text,
    $7::"WorkerSDKS",
    $8::text,
    $9::text,
    $10::text
) RETURNING id, "createdAt", "updatedAt", "deletedAt", "tenantId", "lastHeartbeatAt", name, "dispatcherId", "isActive", "lastListenerEstablished", "isPaused", type, "webhookId", language, "languageVersion", os, "runtimeExtra", "sdkVersion"
`

type CreateWorkerParams struct {
	Tenantid        uuid.UUID      `json:"tenantid"`
	Name            string         `json:"name"`
	Dispatcherid    uuid.UUID      `json:"dispatcherid"`
	WebhookId       *uuid.UUID     `json:"webhookId"`
	Type            NullWorkerType `json:"type"`
	SdkVersion      pgtype.Text    `json:"sdkVersion"`
	Language        NullWorkerSDKS `json:"language"`
	LanguageVersion pgtype.Text    `json:"languageVersion"`
	Os              pgtype.Text    `json:"os"`
	RuntimeExtra    pgtype.Text    `json:"runtimeExtra"`
}

func (q *Queries) CreateWorker(ctx context.Context, db DBTX, arg CreateWorkerParams) (*Worker, error) {
	row := db.QueryRow(ctx, createWorker,
		arg.Tenantid,
		arg.Name,
		arg.Dispatcherid,
		arg.WebhookId,
		arg.Type,
		arg.SdkVersion,
		arg.Language,
		arg.LanguageVersion,
		arg.Os,
		arg.RuntimeExtra,
	)
	var i Worker
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.LastHeartbeatAt,
		&i.Name,
		&i.DispatcherId,
		&i.IsActive,
		&i.LastListenerEstablished,
		&i.IsPaused,
		&i.Type,
		&i.WebhookId,
		&i.Language,
		&i.LanguageVersion,
		&i.Os,
		&i.RuntimeExtra,
		&i.SdkVersion,
	)
	return &i, err
}

const deleteOldWorkers = `-- name: DeleteOldWorkers :one
WITH for_delete AS (
    SELECT
        "id"
    FROM "Worker" w
    WHERE
        w."tenantId" = $1::uuid AND
        w."lastHeartbeatAt" < $2::timestamp
    LIMIT $3 + 1
), expired_with_limit AS (
    SELECT
        for_delete."id" as "id"
    FROM for_delete
    LIMIT $3
), has_more AS (
    SELECT
        CASE
            WHEN COUNT(*) > $3 THEN TRUE
            ELSE FALSE
        END as has_more
    FROM for_delete
), delete_events AS (
    DELETE FROM "WorkerAssignEvent" wae
    WHERE wae."workerId" IN (SELECT "id" FROM expired_with_limit)
    RETURNING wae."id"
)
DELETE FROM "Worker" w
WHERE w."id" IN (SELECT "id" FROM expired_with_limit)
RETURNING
    (SELECT has_more FROM has_more) as has_more
`

type DeleteOldWorkersParams struct {
	Tenantid            uuid.UUID        `json:"tenantid"`
	Lastheartbeatbefore pgtype.Timestamp `json:"lastheartbeatbefore"`
	Limit               interface{}      `json:"limit"`
}

func (q *Queries) DeleteOldWorkers(ctx context.Context, db DBTX, arg DeleteOldWorkersParams) (bool, error) {
	row := db.QueryRow(ctx, deleteOldWorkers, arg.Tenantid, arg.Lastheartbeatbefore, arg.Limit)
	var has_more bool
	err := row.Scan(&has_more)
	return has_more, err
}

const deleteWorker = `-- name: DeleteWorker :one
DELETE FROM
  "Worker"
WHERE
  "id" = $1::uuid
RETURNING id, "createdAt", "updatedAt", "deletedAt", "tenantId", "lastHeartbeatAt", name, "dispatcherId", "isActive", "lastListenerEstablished", "isPaused", type, "webhookId", language, "languageVersion", os, "runtimeExtra", "sdkVersion"
`

func (q *Queries) DeleteWorker(ctx context.Context, db DBTX, id uuid.UUID) (*Worker, error) {
	row := db.QueryRow(ctx, deleteWorker, id)
	var i Worker
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.LastHeartbeatAt,
		&i.Name,
		&i.DispatcherId,
		&i.IsActive,
		&i.LastListenerEstablished,
		&i.IsPaused,
		&i.Type,
		&i.WebhookId,
		&i.Language,
		&i.LanguageVersion,
		&i.Os,
		&i.RuntimeExtra,
		&i.SdkVersion,
	)
	return &i, err
}

const getWorkerActionsByWorkerId = `-- name: GetWorkerActionsByWorkerId :many
WITH inputs AS (
    SELECT UNNEST($2::UUID[]) AS "workerId"
)

SELECT
    w."id" AS "workerId",
    a."actionId" AS actionId
FROM "Worker" w
JOIN inputs i ON w."id" = i."workerId"
LEFT JOIN "_ActionToWorker" aw ON w.id = aw."B"
LEFT JOIN "Action" a ON aw."A" = a.id
WHERE
    a."tenantId" = $1::UUID
`

type GetWorkerActionsByWorkerIdParams struct {
	Tenantid  uuid.UUID   `json:"tenantid"`
	Workerids []uuid.UUID `json:"workerids"`
}

type GetWorkerActionsByWorkerIdRow struct {
	WorkerId uuid.UUID   `json:"workerId"`
	Actionid pgtype.Text `json:"actionid"`
}

func (q *Queries) GetWorkerActionsByWorkerId(ctx context.Context, db DBTX, arg GetWorkerActionsByWorkerIdParams) ([]*GetWorkerActionsByWorkerIdRow, error) {
	rows, err := db.Query(ctx, getWorkerActionsByWorkerId, arg.Tenantid, arg.Workerids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetWorkerActionsByWorkerIdRow
	for rows.Next() {
		var i GetWorkerActionsByWorkerIdRow
		if err := rows.Scan(&i.WorkerId, &i.Actionid); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkerById = `-- name: GetWorkerById :one
SELECT
    w.id, w."createdAt", w."updatedAt", w."deletedAt", w."tenantId", w."lastHeartbeatAt", w.name, w."dispatcherId", w."isActive", w."lastListenerEstablished", w."isPaused", w.type, w."webhookId", w.language, w."languageVersion", w.os, w."runtimeExtra", w."sdkVersion",
    ww."url" AS "webhookUrl",
    COALESCE((
        SELECT COALESCE(cap.max_units, 0)
        FROM v1_worker_slot_config cap
        WHERE
            cap.tenant_id = w."tenantId"
            AND cap.worker_id = w."id"
            AND cap.slot_type = 'default'::text
    ) - (
        SELECT COALESCE(SUM(runtime.units), 0)
        FROM v1_task_runtime_slot runtime
        WHERE
            runtime.tenant_id = w."tenantId" AND
            runtime.worker_id = w."id" AND
            runtime.slot_type = 'default'::text
    ), 0)::int AS "remainingSlots"
    ,
    COALESCE((
        (
            SELECT COALESCE(cap.max_units, 0)
            FROM v1_worker_slot_config cap
            WHERE
                cap.tenant_id = w."tenantId"
                AND cap.worker_id = w."id"
                AND cap.slot_type = 'durable'::text
        ) - (
            SELECT COALESCE(SUM(runtime.units), 0)
            FROM v1_task_runtime_slot runtime
            WHERE
                runtime.tenant_id = w."tenantId" AND
                runtime.worker_id = w."id" AND
                runtime.slot_type = 'durable'::text
        )
    ), 0)::int AS "remainingDurableSlots"
FROM
    "Worker" w
LEFT JOIN
    "WebhookWorker" ww ON w."webhookId" = ww."id"
WHERE
    w."id" = $1::uuid
`

type GetWorkerByIdRow struct {
	Worker                Worker      `json:"worker"`
	WebhookUrl            pgtype.Text `json:"webhookUrl"`
	RemainingSlots        int32       `json:"remainingSlots"`
	RemainingDurableSlots int32       `json:"remainingDurableSlots"`
}

func (q *Queries) GetWorkerById(ctx context.Context, db DBTX, id uuid.UUID) (*GetWorkerByIdRow, error) {
	row := db.QueryRow(ctx, getWorkerById, id)
	var i GetWorkerByIdRow
	err := row.Scan(
		&i.Worker.ID,
		&i.Worker.CreatedAt,
		&i.Worker.UpdatedAt,
		&i.Worker.DeletedAt,
		&i.Worker.TenantId,
		&i.Worker.LastHeartbeatAt,
		&i.Worker.Name,
		&i.Worker.DispatcherId,
		&i.Worker.IsActive,
		&i.Worker.LastListenerEstablished,
		&i.Worker.IsPaused,
		&i.Worker.Type,
		&i.Worker.WebhookId,
		&i.Worker.Language,
		&i.Worker.LanguageVersion,
		&i.Worker.Os,
		&i.Worker.RuntimeExtra,
		&i.Worker.SdkVersion,
		&i.WebhookUrl,
		&i.RemainingSlots,
		&i.RemainingDurableSlots,
	)
	return &i, err
}

const getWorkerForEngine = `-- name: GetWorkerForEngine :one
SELECT
    w."id" AS "id",
    w."tenantId" AS "tenantId",
    w."dispatcherId" AS "dispatcherId",
    d."lastHeartbeatAt" AS "dispatcherLastHeartbeatAt",
    w."isActive" AS "isActive",
    w."lastListenerEstablished" AS "lastListenerEstablished"
FROM
    "Worker" w
LEFT JOIN
    "Dispatcher" d ON w."dispatcherId" = d."id"
WHERE
    w."tenantId" = $1
    AND w."id" = $2
`

type GetWorkerForEngineParams struct {
	Tenantid uuid.UUID `json:"tenantid"`
	ID       uuid.UUID `json:"id"`
}

type GetWorkerForEngineRow struct {
	ID                        uuid.UUID        `json:"id"`
	TenantId                  uuid.UUID        `json:"tenantId"`
	DispatcherId              *uuid.UUID       `json:"dispatcherId"`
	DispatcherLastHeartbeatAt pgtype.Timestamp `json:"dispatcherLastHeartbeatAt"`
	IsActive                  bool             `json:"isActive"`
	LastListenerEstablished   pgtype.Timestamp `json:"lastListenerEstablished"`
}

func (q *Queries) GetWorkerForEngine(ctx context.Context, db DBTX, arg GetWorkerForEngineParams) (*GetWorkerForEngineRow, error) {
	row := db.QueryRow(ctx, getWorkerForEngine, arg.Tenantid, arg.ID)
	var i GetWorkerForEngineRow
	err := row.Scan(
		&i.ID,
		&i.TenantId,
		&i.DispatcherId,
		&i.DispatcherLastHeartbeatAt,
		&i.IsActive,
		&i.LastListenerEstablished,
	)
	return &i, err
}

const getWorkerWorkflowsByWorkerId = `-- name: GetWorkerWorkflowsByWorkerId :many
SELECT wf.id, wf."createdAt", wf."updatedAt", wf."deletedAt", wf."tenantId", wf.name, wf.description, wf."isPaused"
FROM "Worker" w
JOIN "_ActionToWorker" aw ON w.id = aw."B"
JOIN "Action" a ON aw."A" = a.id
JOIN "Step" s ON s."actionId" = a."actionId" AND s."tenantId" = a."tenantId"
JOIN "Job" j ON j."id" = s."jobId" AND j."tenantId" = a."tenantId"
JOIN "WorkflowVersion" wv ON wv."id" = j."workflowVersionId"
JOIN "Workflow" wf ON wf."id" = wv."workflowId" AND wf."tenantId" = a."tenantId"
WHERE
    w."id" = $1::UUID
    AND w."tenantId" = $2::UUID
`

type GetWorkerWorkflowsByWorkerIdParams struct {
	Workerid uuid.UUID `json:"workerid"`
	Tenantid uuid.UUID `json:"tenantid"`
}

func (q *Queries) GetWorkerWorkflowsByWorkerId(ctx context.Context, db DBTX, arg GetWorkerWorkflowsByWorkerIdParams) ([]*Workflow, error) {
	rows, err := db.Query(ctx, getWorkerWorkflowsByWorkerId, arg.Workerid, arg.Tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Workflow
	for rows.Next() {
		var i Workflow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TenantId,
			&i.Name,
			&i.Description,
			&i.IsPaused,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkActionsToWorker = `-- name: LinkActionsToWorker :exec
INSERT INTO "_ActionToWorker" (
    "A",
    "B"
) SELECT
    unnest($1::uuid[]),
    $2::uuid
ON CONFLICT DO NOTHING
`

type LinkActionsToWorkerParams struct {
	Actionids []uuid.UUID `json:"actionids"`
	Workerid  uuid.UUID   `json:"workerid"`
}

func (q *Queries) LinkActionsToWorker(ctx context.Context, db DBTX, arg LinkActionsToWorkerParams) error {
	_, err := db.Exec(ctx, linkActionsToWorker, arg.Actionids, arg.Workerid)
	return err
}

const linkServicesToWorker = `-- name: LinkServicesToWorker :exec
INSERT INTO "_ServiceToWorker" (
    "A",
    "B"
)
VALUES (
    unnest($1::uuid[]),
    $2::uuid
)
ON CONFLICT DO NOTHING
`

type LinkServicesToWorkerParams struct {
	Services []uuid.UUID `json:"services"`
	Workerid uuid.UUID   `json:"workerid"`
}

func (q *Queries) LinkServicesToWorker(ctx context.Context, db DBTX, arg LinkServicesToWorkerParams) error {
	_, err := db.Exec(ctx, linkServicesToWorker, arg.Services, arg.Workerid)
	return err
}

const listActiveSDKsPerTenant = `-- name: ListActiveSDKsPerTenant :many
SELECT
    "tenantId",
    COALESCE("language"::TEXT, 'unknown')::TEXT AS "language",
    COALESCE("languageVersion", 'unknown') AS "languageVersion",
    COALESCE("sdkVersion", 'unknown') AS "sdkVersion",
    COALESCE("os", 'unknown') AS "os",
    COUNT(*) AS "count"
FROM "Worker"
WHERE
    "dispatcherId" IS NOT NULL
    AND "lastHeartbeatAt" > NOW() - INTERVAL '5 seconds'
    AND "isActive" = true
    AND "isPaused" = false
GROUP BY "tenantId", "language", "languageVersion", "sdkVersion", "os"
`

type ListActiveSDKsPerTenantRow struct {
	TenantId        uuid.UUID `json:"tenantId"`
	Language        string    `json:"language"`
	LanguageVersion string    `json:"languageVersion"`
	SdkVersion      string    `json:"sdkVersion"`
	Os              string    `json:"os"`
	Count           int64     `json:"count"`
}

func (q *Queries) ListActiveSDKsPerTenant(ctx context.Context, db DBTX) ([]*ListActiveSDKsPerTenantRow, error) {
	rows, err := db.Query(ctx, listActiveSDKsPerTenant)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListActiveSDKsPerTenantRow
	for rows.Next() {
		var i ListActiveSDKsPerTenantRow
		if err := rows.Scan(
			&i.TenantId,
			&i.Language,
			&i.LanguageVersion,
			&i.SdkVersion,
			&i.Os,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveSlotsPerTenantAndSlotType = `-- name: ListActiveSlotsPerTenantAndSlotType :many
SELECT
    wc.tenant_id AS "tenantId",
    wc.slot_type AS "slotType",
    SUM(wc.max_units) AS "activeSlots"
FROM v1_worker_slot_config wc
JOIN "Worker" w ON w."id" = wc.worker_id AND w."tenantId" = wc.tenant_id
WHERE
    w."dispatcherId" IS NOT NULL
    AND w."lastHeartbeatAt" > NOW() - INTERVAL '5 seconds'
    AND w."isActive" = true
    AND w."isPaused" = false
GROUP BY wc.tenant_id, wc.slot_type
`

type ListActiveSlotsPerTenantAndSlotTypeRow struct {
	TenantId    uuid.UUID `json:"tenantId"`
	SlotType    string    `json:"slotType"`
	ActiveSlots int64     `json:"activeSlots"`
}

func (q *Queries) ListActiveSlotsPerTenantAndSlotType(ctx context.Context, db DBTX) ([]*ListActiveSlotsPerTenantAndSlotTypeRow, error) {
	rows, err := db.Query(ctx, listActiveSlotsPerTenantAndSlotType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListActiveSlotsPerTenantAndSlotTypeRow
	for rows.Next() {
		var i ListActiveSlotsPerTenantAndSlotTypeRow
		if err := rows.Scan(&i.TenantId, &i.SlotType, &i.ActiveSlots); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveWorkersPerTenant = `-- name: ListActiveWorkersPerTenant :many
SELECT "tenantId", COUNT(*)
FROM "Worker"
WHERE
    "dispatcherId" IS NOT NULL
    AND "lastHeartbeatAt" > NOW() - INTERVAL '5 seconds'
    AND "isActive" = true
    AND "isPaused" = false
GROUP BY "tenantId"
`

type ListActiveWorkersPerTenantRow struct {
	TenantId uuid.UUID `json:"tenantId"`
	Count    int64     `json:"count"`
}

func (q *Queries) ListActiveWorkersPerTenant(ctx context.Context, db DBTX) ([]*ListActiveWorkersPerTenantRow, error) {
	rows, err := db.Query(ctx, listActiveWorkersPerTenant)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListActiveWorkersPerTenantRow
	for rows.Next() {
		var i ListActiveWorkersPerTenantRow
		if err := rows.Scan(&i.TenantId, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDispatcherIdsForWorkers = `-- name: ListDispatcherIdsForWorkers :many
SELECT
    "id" as "workerId",
    "dispatcherId"
FROM
    "Worker"
WHERE
    "tenantId" = $1::uuid
    AND "id" = ANY($2::uuid[])
`

type ListDispatcherIdsForWorkersParams struct {
	Tenantid  uuid.UUID   `json:"tenantid"`
	Workerids []uuid.UUID `json:"workerids"`
}

type ListDispatcherIdsForWorkersRow struct {
	WorkerId     uuid.UUID  `json:"workerId"`
	DispatcherId *uuid.UUID `json:"dispatcherId"`
}

func (q *Queries) ListDispatcherIdsForWorkers(ctx context.Context, db DBTX, arg ListDispatcherIdsForWorkersParams) ([]*ListDispatcherIdsForWorkersRow, error) {
	rows, err := db.Query(ctx, listDispatcherIdsForWorkers, arg.Tenantid, arg.Workerids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListDispatcherIdsForWorkersRow
	for rows.Next() {
		var i ListDispatcherIdsForWorkersRow
		if err := rows.Scan(&i.WorkerId, &i.DispatcherId); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listManyWorkerLabels = `-- name: ListManyWorkerLabels :many
SELECT
    "id",
    "key",
    "intValue",
    "strValue",
    "createdAt",
    "updatedAt",
    "workerId"
FROM "WorkerLabel" wl
WHERE wl."workerId" = ANY($1::uuid[])
`

type ListManyWorkerLabelsRow struct {
	ID        int64            `json:"id"`
	Key       string           `json:"key"`
	IntValue  pgtype.Int4      `json:"intValue"`
	StrValue  pgtype.Text      `json:"strValue"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	WorkerId  uuid.UUID        `json:"workerId"`
}

func (q *Queries) ListManyWorkerLabels(ctx context.Context, db DBTX, workerids []uuid.UUID) ([]*ListManyWorkerLabelsRow, error) {
	rows, err := db.Query(ctx, listManyWorkerLabels, workerids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListManyWorkerLabelsRow
	for rows.Next() {
		var i ListManyWorkerLabelsRow
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.IntValue,
			&i.StrValue,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WorkerId,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSemaphoreSlotsWithStateForWorker = `-- name: ListSemaphoreSlotsWithStateForWorker :many
SELECT
    task_id, task_inserted_at, runtime.retry_count, worker_id, runtime.tenant_id, timeout_at, id, inserted_at, v1_task.tenant_id, queue, action_id, step_id, step_readable_id, workflow_id, workflow_version_id, workflow_run_id, schedule_timeout, step_timeout, priority, sticky, desired_worker_id, external_id, display_name, input, v1_task.retry_count, internal_retry_count, app_retry_count, step_index, additional_metadata, dag_id, dag_inserted_at, parent_task_external_id, parent_task_id, parent_task_inserted_at, child_index, child_key, initial_state, initial_state_reason, concurrency_parent_strategy_ids, concurrency_strategy_ids, concurrency_keys, retry_backoff_factor, retry_max_backoff
FROM
    v1_task_runtime runtime
JOIN
    v1_task ON runtime.task_id = v1_task.id AND runtime.task_inserted_at = v1_task.inserted_at
WHERE
    runtime.tenant_id = $1::uuid
    AND runtime.worker_id = $2::uuid
LIMIT
    COALESCE($3::int, 100)
`

type ListSemaphoreSlotsWithStateForWorkerParams struct {
	Tenantid uuid.UUID   `json:"tenantid"`
	Workerid uuid.UUID   `json:"workerid"`
	Limit    pgtype.Int4 `json:"limit"`
}

type ListSemaphoreSlotsWithStateForWorkerRow struct {
	TaskID                       int64              `json:"task_id"`
	TaskInsertedAt               pgtype.Timestamptz `json:"task_inserted_at"`
	RetryCount                   int32              `json:"retry_count"`
	WorkerID                     *uuid.UUID         `json:"worker_id"`
	TenantID                     uuid.UUID          `json:"tenant_id"`
	TimeoutAt                    pgtype.Timestamp   `json:"timeout_at"`
	ID                           int64              `json:"id"`
	InsertedAt                   pgtype.Timestamptz `json:"inserted_at"`
	TenantID_2                   uuid.UUID          `json:"tenant_id_2"`
	Queue                        string             `json:"queue"`
	ActionID                     string             `json:"action_id"`
	StepID                       uuid.UUID          `json:"step_id"`
	StepReadableID               string             `json:"step_readable_id"`
	WorkflowID                   uuid.UUID          `json:"workflow_id"`
	WorkflowVersionID            uuid.UUID          `json:"workflow_version_id"`
	WorkflowRunID                uuid.UUID          `json:"workflow_run_id"`
	ScheduleTimeout              string             `json:"schedule_timeout"`
	StepTimeout                  pgtype.Text        `json:"step_timeout"`
	Priority                     pgtype.Int4        `json:"priority"`
	Sticky                       V1StickyStrategy   `json:"sticky"`
	DesiredWorkerID              *uuid.UUID         `json:"desired_worker_id"`
	ExternalID                   uuid.UUID          `json:"external_id"`
	DisplayName                  string             `json:"display_name"`
	Input                        []byte             `json:"input"`
	RetryCount_2                 int32              `json:"retry_count_2"`
	InternalRetryCount           int32              `json:"internal_retry_count"`
	AppRetryCount                int32              `json:"app_retry_count"`
	StepIndex                    int64              `json:"step_index"`
	AdditionalMetadata           []byte             `json:"additional_metadata"`
	DagID                        pgtype.Int8        `json:"dag_id"`
	DagInsertedAt                pgtype.Timestamptz `json:"dag_inserted_at"`
	ParentTaskExternalID         *uuid.UUID         `json:"parent_task_external_id"`
	ParentTaskID                 pgtype.Int8        `json:"parent_task_id"`
	ParentTaskInsertedAt         pgtype.Timestamptz `json:"parent_task_inserted_at"`
	ChildIndex                   pgtype.Int8        `json:"child_index"`
	ChildKey                     pgtype.Text        `json:"child_key"`
	InitialState                 V1TaskInitialState `json:"initial_state"`
	InitialStateReason           pgtype.Text        `json:"initial_state_reason"`
	ConcurrencyParentStrategyIds []pgtype.Int8      `json:"concurrency_parent_strategy_ids"`
	ConcurrencyStrategyIds       []int64            `json:"concurrency_strategy_ids"`
	ConcurrencyKeys              []string           `json:"concurrency_keys"`
	RetryBackoffFactor           pgtype.Float8      `json:"retry_backoff_factor"`
	RetryMaxBackoff              pgtype.Int4        `json:"retry_max_backoff"`
}

func (q *Queries) ListSemaphoreSlotsWithStateForWorker(ctx context.Context, db DBTX, arg ListSemaphoreSlotsWithStateForWorkerParams) ([]*ListSemaphoreSlotsWithStateForWorkerRow, error) {
	rows, err := db.Query(ctx, listSemaphoreSlotsWithStateForWorker, arg.Tenantid, arg.Workerid, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListSemaphoreSlotsWithStateForWorkerRow
	for rows.Next() {
		var i ListSemaphoreSlotsWithStateForWorkerRow
		if err := rows.Scan(
			&i.TaskID,
			&i.TaskInsertedAt,
			&i.RetryCount,
			&i.WorkerID,
			&i.TenantID,
			&i.TimeoutAt,
			&i.ID,
			&i.InsertedAt,
			&i.TenantID_2,
			&i.Queue,
			&i.ActionID,
			&i.StepID,
			&i.StepReadableID,
			&i.WorkflowID,
			&i.WorkflowVersionID,
			&i.WorkflowRunID,
			&i.ScheduleTimeout,
			&i.StepTimeout,
			&i.Priority,
			&i.Sticky,
			&i.DesiredWorkerID,
			&i.ExternalID,
			&i.DisplayName,
			&i.Input,
			&i.RetryCount_2,
			&i.InternalRetryCount,
			&i.AppRetryCount,
			&i.StepIndex,
			&i.AdditionalMetadata,
			&i.DagID,
			&i.DagInsertedAt,
			&i.ParentTaskExternalID,
			&i.ParentTaskID,
			&i.ParentTaskInsertedAt,
			&i.ChildIndex,
			&i.ChildKey,
			&i.InitialState,
			&i.InitialStateReason,
			&i.ConcurrencyParentStrategyIds,
			&i.ConcurrencyStrategyIds,
			&i.ConcurrencyKeys,
			&i.RetryBackoffFactor,
			&i.RetryMaxBackoff,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTotalActiveSlotsPerTenant = `-- name: ListTotalActiveSlotsPerTenant :many
SELECT
    wc.tenant_id AS "tenantId",
    SUM(wc.max_units) AS "totalActiveSlots"
FROM v1_worker_slot_config wc
JOIN "Worker" w ON w."id" = wc.worker_id AND w."tenantId" = wc.tenant_id
WHERE
    w."dispatcherId" IS NOT NULL
    AND w."lastHeartbeatAt" > NOW() - INTERVAL '5 seconds'
    AND w."isActive" = true
    AND w."isPaused" = false
GROUP BY wc.tenant_id
`

type ListTotalActiveSlotsPerTenantRow struct {
	TenantId         uuid.UUID `json:"tenantId"`
	TotalActiveSlots int64     `json:"totalActiveSlots"`
}

func (q *Queries) ListTotalActiveSlotsPerTenant(ctx context.Context, db DBTX) ([]*ListTotalActiveSlotsPerTenantRow, error) {
	rows, err := db.Query(ctx, listTotalActiveSlotsPerTenant)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListTotalActiveSlotsPerTenantRow
	for rows.Next() {
		var i ListTotalActiveSlotsPerTenantRow
		if err := rows.Scan(&i.TenantId, &i.TotalActiveSlots); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkerLabels = `-- name: ListWorkerLabels :many
SELECT
    "id",
    "key",
    "intValue",
    "strValue",
    "createdAt",
    "updatedAt"
FROM "WorkerLabel" wl
WHERE wl."workerId" = $1::uuid
`

type ListWorkerLabelsRow struct {
	ID        int64            `json:"id"`
	Key       string           `json:"key"`
	IntValue  pgtype.Int4      `json:"intValue"`
	StrValue  pgtype.Text      `json:"strValue"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
}

func (q *Queries) ListWorkerLabels(ctx context.Context, db DBTX, workerid uuid.UUID) ([]*ListWorkerLabelsRow, error) {
	rows, err := db.Query(ctx, listWorkerLabels, workerid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListWorkerLabelsRow
	for rows.Next() {
		var i ListWorkerLabelsRow
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.IntValue,
			&i.StrValue,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkerSlotConfigs = `-- name: ListWorkerSlotConfigs :many
SELECT
    worker_id,
    slot_type,
    max_units
FROM
    v1_worker_slot_config
WHERE
    tenant_id = $1::uuid
    AND worker_id = ANY($2::uuid[])
`

type ListWorkerSlotConfigsParams struct {
	Tenantid  uuid.UUID   `json:"tenantid"`
	Workerids []uuid.UUID `json:"workerids"`
}

type ListWorkerSlotConfigsRow struct {
	WorkerID uuid.UUID `json:"worker_id"`
	SlotType string    `json:"slot_type"`
	MaxUnits int32     `json:"max_units"`
}

func (q *Queries) ListWorkerSlotConfigs(ctx context.Context, db DBTX, arg ListWorkerSlotConfigsParams) ([]*ListWorkerSlotConfigsRow, error) {
	rows, err := db.Query(ctx, listWorkerSlotConfigs, arg.Tenantid, arg.Workerids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListWorkerSlotConfigsRow
	for rows.Next() {
		var i ListWorkerSlotConfigsRow
		if err := rows.Scan(&i.WorkerID, &i.SlotType, &i.MaxUnits); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkersWithSlotCount = `-- name: ListWorkersWithSlotCount :many
SELECT
    workers.id, workers."createdAt", workers."updatedAt", workers."deletedAt", workers."tenantId", workers."lastHeartbeatAt", workers.name, workers."dispatcherId", workers."isActive", workers."lastListenerEstablished", workers."isPaused", workers.type, workers."webhookId", workers.language, workers."languageVersion", workers.os, workers."runtimeExtra", workers."sdkVersion",
    ww."url" AS "webhookUrl",
    ww."id" AS "webhookId",
    -- TODO do we still need this?
    COALESCE((
        SELECT COALESCE(cap.max_units, 0)
        FROM v1_worker_slot_config cap
        WHERE
            cap.tenant_id = workers."tenantId"
            AND cap.worker_id = workers."id"
            AND cap.slot_type = 'default'::text
    ) - (
        SELECT COALESCE(SUM(runtime.units), 0)
        FROM v1_task_runtime_slot runtime
        WHERE
            runtime.tenant_id = workers."tenantId" AND
            runtime.worker_id = workers."id" AND
            runtime.slot_type = 'default'::text
    ), 0)::int AS "remainingSlots"
    ,
    COALESCE((
        (
            SELECT COALESCE(cap.max_units, 0)
            FROM v1_worker_slot_config cap
            WHERE
                cap.tenant_id = workers."tenantId"
                AND cap.worker_id = workers."id"
                AND cap.slot_type = 'durable'::text
        ) - (
            SELECT COALESCE(SUM(runtime.units), 0)
            FROM v1_task_runtime_slot runtime
            WHERE
                runtime.tenant_id = workers."tenantId" AND
                runtime.worker_id = workers."id" AND
                runtime.slot_type = 'durable'::text
        )
    ), 0)::int AS "remainingDurableSlots"
FROM
    "Worker" workers
LEFT JOIN
    "WebhookWorker" ww ON workers."webhookId" = ww."id"
WHERE
    workers."tenantId" = $1
    AND (
        $2::text IS NULL OR
        workers."id" IN (
            SELECT "_ActionToWorker"."B"
            FROM "_ActionToWorker"
            INNER JOIN "Action" ON "Action"."id" = "_ActionToWorker"."A"
            WHERE "Action"."tenantId" = $1 AND "Action"."actionId" = $2::text
        )
    )
    AND (
        $3::timestamp IS NULL OR
        workers."lastHeartbeatAt" > $3::timestamp
    )
    AND (
        $4::boolean IS NULL OR
        ($4::boolean AND (
            SELECT COALESCE(SUM(cap.max_units), 0)
            FROM v1_worker_slot_config cap
            WHERE cap.tenant_id = workers."tenantId" AND cap.worker_id = workers."id"
        ) > (
            SELECT COALESCE(SUM(runtime.units), 0)
            FROM v1_task_runtime_slot runtime
            WHERE runtime.tenant_id = workers."tenantId" AND runtime.worker_id = workers."id"
        ))
    )
GROUP BY
    workers."id", ww."url", ww."id"
`

type ListWorkersWithSlotCountParams struct {
	Tenantid           uuid.UUID        `json:"tenantid"`
	ActionId           pgtype.Text      `json:"actionId"`
	LastHeartbeatAfter pgtype.Timestamp `json:"lastHeartbeatAfter"`
	Assignable         pgtype.Bool      `json:"assignable"`
}

type ListWorkersWithSlotCountRow struct {
	Worker                Worker      `json:"worker"`
	WebhookUrl            pgtype.Text `json:"webhookUrl"`
	WebhookId             *uuid.UUID  `json:"webhookId"`
	RemainingSlots        int32       `json:"remainingSlots"`
	RemainingDurableSlots int32       `json:"remainingDurableSlots"`
}

func (q *Queries) ListWorkersWithSlotCount(ctx context.Context, db DBTX, arg ListWorkersWithSlotCountParams) ([]*ListWorkersWithSlotCountRow, error) {
	rows, err := db.Query(ctx, listWorkersWithSlotCount,
		arg.Tenantid,
		arg.ActionId,
		arg.LastHeartbeatAfter,
		arg.Assignable,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListWorkersWithSlotCountRow
	for rows.Next() {
		var i ListWorkersWithSlotCountRow
		if err := rows.Scan(
			&i.Worker.ID,
			&i.Worker.CreatedAt,
			&i.Worker.UpdatedAt,
			&i.Worker.DeletedAt,
			&i.Worker.TenantId,
			&i.Worker.LastHeartbeatAt,
			&i.Worker.Name,
			&i.Worker.DispatcherId,
			&i.Worker.IsActive,
			&i.Worker.LastListenerEstablished,
			&i.Worker.IsPaused,
			&i.Worker.Type,
			&i.Worker.WebhookId,
			&i.Worker.Language,
			&i.Worker.LanguageVersion,
			&i.Worker.Os,
			&i.Worker.RuntimeExtra,
			&i.Worker.SdkVersion,
			&i.WebhookUrl,
			&i.WebhookId,
			&i.RemainingSlots,
			&i.RemainingDurableSlots,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWorker = `-- name: UpdateWorker :one
UPDATE
    "Worker"
SET
    "updatedAt" = CURRENT_TIMESTAMP,
    "dispatcherId" = coalesce($1::uuid, "dispatcherId"),
    "lastHeartbeatAt" = coalesce($2::timestamp, "lastHeartbeatAt"),
    "isActive" = coalesce($3::boolean, "isActive"),
    "isPaused" = coalesce($4::boolean, "isPaused")
WHERE
    "id" = $5::uuid
RETURNING id, "createdAt", "updatedAt", "deletedAt", "tenantId", "lastHeartbeatAt", name, "dispatcherId", "isActive", "lastListenerEstablished", "isPaused", type, "webhookId", language, "languageVersion", os, "runtimeExtra", "sdkVersion"
`

type UpdateWorkerParams struct {
	DispatcherId    *uuid.UUID       `json:"dispatcherId"`
	LastHeartbeatAt pgtype.Timestamp `json:"lastHeartbeatAt"`
	IsActive        pgtype.Bool      `json:"isActive"`
	IsPaused        pgtype.Bool      `json:"isPaused"`
	ID              uuid.UUID        `json:"id"`
}

func (q *Queries) UpdateWorker(ctx context.Context, db DBTX, arg UpdateWorkerParams) (*Worker, error) {
	row := db.QueryRow(ctx, updateWorker,
		arg.DispatcherId,
		arg.LastHeartbeatAt,
		arg.IsActive,
		arg.IsPaused,
		arg.ID,
	)
	var i Worker
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.LastHeartbeatAt,
		&i.Name,
		&i.DispatcherId,
		&i.IsActive,
		&i.LastListenerEstablished,
		&i.IsPaused,
		&i.Type,
		&i.WebhookId,
		&i.Language,
		&i.LanguageVersion,
		&i.Os,
		&i.RuntimeExtra,
		&i.SdkVersion,
	)
	return &i, err
}

const updateWorkerActiveStatus = `-- name: UpdateWorkerActiveStatus :one
UPDATE "Worker"
SET
    "isActive" = $1::boolean,
    "lastListenerEstablished" = $2::timestamp
WHERE
    "id" = $3::uuid
    AND (
        "lastListenerEstablished" IS NULL
        OR "lastListenerEstablished" <= $2::timestamp
        )
RETURNING id, "createdAt", "updatedAt", "deletedAt", "tenantId", "lastHeartbeatAt", name, "dispatcherId", "isActive", "lastListenerEstablished", "isPaused", type, "webhookId", language, "languageVersion", os, "runtimeExtra", "sdkVersion"
`

type UpdateWorkerActiveStatusParams struct {
	Isactive                bool             `json:"isactive"`
	LastListenerEstablished pgtype.Timestamp `json:"lastListenerEstablished"`
	ID                      uuid.UUID        `json:"id"`
}

func (q *Queries) UpdateWorkerActiveStatus(ctx context.Context, db DBTX, arg UpdateWorkerActiveStatusParams) (*Worker, error) {
	row := db.QueryRow(ctx, updateWorkerActiveStatus, arg.Isactive, arg.LastListenerEstablished, arg.ID)
	var i Worker
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.LastHeartbeatAt,
		&i.Name,
		&i.DispatcherId,
		&i.IsActive,
		&i.LastListenerEstablished,
		&i.IsPaused,
		&i.Type,
		&i.WebhookId,
		&i.Language,
		&i.LanguageVersion,
		&i.Os,
		&i.RuntimeExtra,
		&i.SdkVersion,
	)
	return &i, err
}

const updateWorkerHeartbeat = `-- name: UpdateWorkerHeartbeat :one
UPDATE
    "Worker"
SET
    "updatedAt" = CURRENT_TIMESTAMP,
    "lastHeartbeatAt" = $1::timestamp
WHERE
    "id" = $2::uuid
RETURNING id, "createdAt", "updatedAt", "deletedAt", "tenantId", "lastHeartbeatAt", name, "dispatcherId", "isActive", "lastListenerEstablished", "isPaused", type, "webhookId", language, "languageVersion", os, "runtimeExtra", "sdkVersion"
`

type UpdateWorkerHeartbeatParams struct {
	LastHeartbeatAt pgtype.Timestamp `json:"lastHeartbeatAt"`
	ID              uuid.UUID        `json:"id"`
}

func (q *Queries) UpdateWorkerHeartbeat(ctx context.Context, db DBTX, arg UpdateWorkerHeartbeatParams) (*Worker, error) {
	row := db.QueryRow(ctx, updateWorkerHeartbeat, arg.LastHeartbeatAt, arg.ID)
	var i Worker
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TenantId,
		&i.LastHeartbeatAt,
		&i.Name,
		&i.DispatcherId,
		&i.IsActive,
		&i.LastListenerEstablished,
		&i.IsPaused,
		&i.Type,
		&i.WebhookId,
		&i.Language,
		&i.LanguageVersion,
		&i.Os,
		&i.RuntimeExtra,
		&i.SdkVersion,
	)
	return &i, err
}

const upsertService = `-- name: UpsertService :one
INSERT INTO "Service" (
    "id",
    "createdAt",
    "updatedAt",
    "name",
    "tenantId"
)
VALUES (
    gen_random_uuid(),
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    $1::text,
    $2::uuid
)
ON CONFLICT ("tenantId", "name") DO UPDATE
SET
    "updatedAt" = CURRENT_TIMESTAMP
WHERE
    "Service"."tenantId" = $2 AND "Service"."name" = $1::text
RETURNING id, "createdAt", "updatedAt", "deletedAt", name, description, "tenantId"
`

type UpsertServiceParams struct {
	Name     string    `json:"name"`
	Tenantid uuid.UUID `json:"tenantid"`
}

func (q *Queries) UpsertService(ctx context.Context, db DBTX, arg UpsertServiceParams) (*Service, error) {
	row := db.QueryRow(ctx, upsertService, arg.Name, arg.Tenantid)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
		&i.Description,
		&i.TenantId,
	)
	return &i, err
}

const upsertWorkerLabel = `-- name: UpsertWorkerLabel :one
INSERT INTO "WorkerLabel" (
    "createdAt",
    "updatedAt",
    "workerId",
    "key",
    "intValue",
    "strValue"
) VALUES (
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    $1::uuid,
    $2::text,
    $3::int,
    $4::text
) ON CONFLICT ("workerId", "key") DO UPDATE
SET
    "updatedAt" = CURRENT_TIMESTAMP,
    "intValue" = $3::int,
    "strValue" = $4::text
RETURNING id, "createdAt", "updatedAt", "workerId", key, "strValue", "intValue"
`

type UpsertWorkerLabelParams struct {
	Workerid uuid.UUID   `json:"workerid"`
	Key      string      `json:"key"`
	IntValue pgtype.Int4 `json:"intValue"`
	StrValue pgtype.Text `json:"strValue"`
}

func (q *Queries) UpsertWorkerLabel(ctx context.Context, db DBTX, arg UpsertWorkerLabelParams) (*WorkerLabel, error) {
	row := db.QueryRow(ctx, upsertWorkerLabel,
		arg.Workerid,
		arg.Key,
		arg.IntValue,
		arg.StrValue,
	)
	var i WorkerLabel
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WorkerId,
		&i.Key,
		&i.StrValue,
		&i.IntValue,
	)
	return &i, err
}

const upsertWorkerSlotConfigs = `-- name: UpsertWorkerSlotConfigs :exec
INSERT INTO v1_worker_slot_config (
    tenant_id,
    worker_id,
    slot_type,
    max_units,
    created_at,
    updated_at
)
SELECT
    $1::uuid,
    $2::uuid,
    unnest($3::text[]),
    unnest($4::integer[]),
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP
ON CONFLICT (tenant_id, worker_id, slot_type) DO UPDATE
SET
    max_units = EXCLUDED.max_units,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertWorkerSlotConfigsParams struct {
	Tenantid  uuid.UUID `json:"tenantid"`
	Workerid  uuid.UUID `json:"workerid"`
	Slottypes []string  `json:"slottypes"`
	Maxunits  []int32   `json:"maxunits"`
}

func (q *Queries) UpsertWorkerSlotConfigs(ctx context.Context, db DBTX, arg UpsertWorkerSlotConfigsParams) error {
	_, err := db.Exec(ctx, upsertWorkerSlotConfigs,
		arg.Tenantid,
		arg.Workerid,
		arg.Slottypes,
		arg.Maxunits,
	)
	return err
}
