// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queue.sql

package sqlcv1

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const bulkQueueItems = `-- name: BulkQueueItems :many
WITH locked_qis AS (
    SELECT
        id
    FROM
        v1_queue_item
    WHERE
        id = ANY($1::bigint[])
    ORDER BY
        id ASC
    FOR UPDATE
)
DELETE FROM
    v1_queue_item
WHERE
    id = ANY($1::bigint[])
RETURNING
    id
`

func (q *Queries) BulkQueueItems(ctx context.Context, db DBTX, ids []int64) ([]int64, error) {
	rows, err := db.Query(ctx, bulkQueueItems, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cleanupV1QueueItem = `-- name: CleanupV1QueueItem :execresult
WITH locked_qis as (
    SELECT qi.task_id, qi.task_inserted_at, qi.retry_count
    FROM v1_queue_item qi
    WHERE NOT EXISTS (
        SELECT 1
        FROM v1_task vt
        WHERE qi.task_id = vt.id
            AND qi.task_inserted_at = vt.inserted_at
    )
    ORDER BY qi.id ASC
    LIMIT $1::int
    FOR UPDATE SKIP LOCKED
)
DELETE FROM v1_queue_item
WHERE (task_id, task_inserted_at, retry_count) IN (
    SELECT task_id, task_inserted_at, retry_count
    FROM locked_qis
)
`

func (q *Queries) CleanupV1QueueItem(ctx context.Context, db DBTX, batchsize int32) (pgconn.CommandTag, error) {
	return db.Exec(ctx, cleanupV1QueueItem, batchsize)
}

const cleanupV1RateLimitedQueueItem = `-- name: CleanupV1RateLimitedQueueItem :execresult
WITH locked_qis as (
    SELECT qi.task_id, qi.task_inserted_at, qi.retry_count
    FROM v1_rate_limited_queue_items qi
    WHERE NOT EXISTS (
        SELECT 1
        FROM v1_task vt
        WHERE qi.task_id = vt.id
        AND qi.task_inserted_at = vt.inserted_at
    )
    ORDER BY qi.task_id, qi.task_inserted_at, qi.retry_count
    LIMIT $1::int
    FOR UPDATE SKIP LOCKED
)
DELETE FROM v1_rate_limited_queue_items
WHERE (task_id, task_inserted_at) IN (
    SELECT task_id, task_inserted_at
    FROM locked_qis
)
`

func (q *Queries) CleanupV1RateLimitedQueueItem(ctx context.Context, db DBTX, batchsize int32) (pgconn.CommandTag, error) {
	return db.Exec(ctx, cleanupV1RateLimitedQueueItem, batchsize)
}

const cleanupV1RetryQueueItem = `-- name: CleanupV1RetryQueueItem :execresult
WITH locked_qis as (
    SELECT qi.task_id, qi.task_inserted_at, qi.task_retry_count
    FROM v1_retry_queue_item qi
    WHERE NOT EXISTS (
        SELECT 1
        FROM v1_task vt
        WHERE qi.task_id = vt.id
        AND qi.task_inserted_at = vt.inserted_at
    )
    ORDER BY qi.task_id, qi.task_inserted_at, qi.task_retry_count
    LIMIT $1::int
    FOR UPDATE SKIP LOCKED
)
DELETE FROM v1_retry_queue_item
WHERE (task_id, task_inserted_at) IN (
    SELECT task_id, task_inserted_at
    FROM locked_qis
)
`

func (q *Queries) CleanupV1RetryQueueItem(ctx context.Context, db DBTX, batchsize int32) (pgconn.CommandTag, error) {
	return db.Exec(ctx, cleanupV1RetryQueueItem, batchsize)
}

const deleteBatchedQueueItems = `-- name: DeleteBatchedQueueItems :exec
DELETE FROM
    v1_batched_queue_item
WHERE
    id = ANY($1::bigint[])
`

func (q *Queries) DeleteBatchedQueueItems(ctx context.Context, db DBTX, ids []int64) error {
	_, err := db.Exec(ctx, deleteBatchedQueueItems, ids)
	return err
}

const deleteTasksFromQueue = `-- name: DeleteTasksFromQueue :exec
WITH input AS (
    SELECT
        task_id, retry_count
    FROM
        (
            SELECT
                unnest($1::bigint[]) AS task_id,
                unnest($2::integer[]) AS retry_count
        ) AS subquery
), locked_qis AS (
    SELECT
        id
    FROM
        v1_queue_item
    WHERE
        (task_id, retry_count) IN (SELECT task_id, retry_count FROM input)
    ORDER BY
        id ASC
    FOR UPDATE
)
DELETE FROM
    v1_queue_item
WHERE
    id = ANY(SELECT id FROM locked_qis)
`

type DeleteTasksFromQueueParams struct {
	Taskids     []int64 `json:"taskids"`
	Retrycounts []int32 `json:"retrycounts"`
}

func (q *Queries) DeleteTasksFromQueue(ctx context.Context, db DBTX, arg DeleteTasksFromQueueParams) error {
	_, err := db.Exec(ctx, deleteTasksFromQueue, arg.Taskids, arg.Retrycounts)
	return err
}

const getDesiredLabels = `-- name: GetDesiredLabels :many
SELECT
    "key",
    "strValue",
    "intValue",
    "required",
    "weight",
    "comparator",
    "stepId"
FROM
    "StepDesiredWorkerLabel"
WHERE
    "stepId" = ANY($1::uuid[])
`

type GetDesiredLabelsRow struct {
	Key        string                `json:"key"`
	StrValue   pgtype.Text           `json:"strValue"`
	IntValue   pgtype.Int4           `json:"intValue"`
	Required   bool                  `json:"required"`
	Weight     int32                 `json:"weight"`
	Comparator WorkerLabelComparator `json:"comparator"`
	StepId     pgtype.UUID           `json:"stepId"`
}

func (q *Queries) GetDesiredLabels(ctx context.Context, db DBTX, stepids []pgtype.UUID) ([]*GetDesiredLabelsRow, error) {
	rows, err := db.Query(ctx, getDesiredLabels, stepids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetDesiredLabelsRow
	for rows.Next() {
		var i GetDesiredLabelsRow
		if err := rows.Scan(
			&i.Key,
			&i.StrValue,
			&i.IntValue,
			&i.Required,
			&i.Weight,
			&i.Comparator,
			&i.StepId,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMinUnprocessedQueueItemId = `-- name: GetMinUnprocessedQueueItemId :one
WITH priority_1 AS (
    SELECT
        id
    FROM
        v1_queue_item
    WHERE
        tenant_id = $1::uuid
        AND queue = $2::text
        AND priority = 1
    ORDER BY
        id ASC
    LIMIT 1
),
priority_2 AS (
    SELECT
        id
    FROM
        v1_queue_item
    WHERE
        tenant_id = $1::uuid
        AND queue = $2::text
        AND priority = 2
    ORDER BY
        id ASC
    LIMIT 1
),
priority_3 AS (
    SELECT
        id
    FROM
        v1_queue_item
    WHERE
        tenant_id = $1::uuid
        AND queue = $2::text
        AND priority = 3
    ORDER BY
        id ASC
    LIMIT 1
),
priority_4 AS (
    SELECT
        id
    FROM
        v1_queue_item
    WHERE
        tenant_id = $1::uuid
        AND queue = $2::text
        AND priority = 4
    ORDER BY
        id ASC
    LIMIT 1
)
SELECT
    COALESCE(MIN(id), 0)::bigint AS "minId"
FROM (
    SELECT id FROM priority_1
    UNION ALL
    SELECT id FROM priority_2
    UNION ALL
    SELECT id FROM priority_3
    UNION ALL
    SELECT id FROM priority_4
) AS combined_priorities
`

type GetMinUnprocessedQueueItemIdParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Queue    string      `json:"queue"`
}

func (q *Queries) GetMinUnprocessedQueueItemId(ctx context.Context, db DBTX, arg GetMinUnprocessedQueueItemIdParams) (int64, error) {
	row := db.QueryRow(ctx, getMinUnprocessedQueueItemId, arg.Tenantid, arg.Queue)
	var minId int64
	err := row.Scan(&minId)
	return minId, err
}

const getQueuedCounts = `-- name: GetQueuedCounts :many
SELECT
    queue,
    COUNT(*) AS count
FROM
    v1_queue_item qi
WHERE
    qi.tenant_id = $1::uuid
GROUP BY
    qi.queue
`

type GetQueuedCountsRow struct {
	Queue string `json:"queue"`
	Count int64  `json:"count"`
}

func (q *Queries) GetQueuedCounts(ctx context.Context, db DBTX, tenantid pgtype.UUID) ([]*GetQueuedCountsRow, error) {
	rows, err := db.Query(ctx, getQueuedCounts, tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetQueuedCountsRow
	for rows.Next() {
		var i GetQueuedCountsRow
		if err := rows.Scan(&i.Queue, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBufferedTaskRuntimes = `-- name: InsertBufferedTaskRuntimes :exec
WITH input AS (
    SELECT
        UNNEST($2::bigint[]) AS task_id,
        UNNEST($3::timestamptz[]) AS task_inserted_at,
        UNNEST($4::integer[]) AS task_retry_count
)
INSERT INTO v1_task_runtime (
    task_id,
    task_inserted_at,
    retry_count,
    worker_id,
    tenant_id,
    timeout_at,
    batch_key
)
SELECT
    input.task_id,
    input.task_inserted_at,
    input.task_retry_count,
    NULL,
    $1::uuid,
    CURRENT_TIMESTAMP + convert_duration_to_interval(t.step_timeout),
    t.batch_key
FROM
    input
JOIN
    v1_task t ON t.id = input.task_id AND t.inserted_at = input.task_inserted_at
ON CONFLICT (task_id, task_inserted_at, retry_count) DO UPDATE
SET
    timeout_at = EXCLUDED.timeout_at,
    batch_key = EXCLUDED.batch_key
WHERE
    v1_task_runtime.worker_id IS NULL
`

type InsertBufferedTaskRuntimesParams struct {
	Tenantid        pgtype.UUID          `json:"tenantid"`
	Taskids         []int64              `json:"taskids"`
	Taskinsertedats []pgtype.Timestamptz `json:"taskinsertedats"`
	Taskretrycounts []int32              `json:"taskretrycounts"`
}

func (q *Queries) InsertBufferedTaskRuntimes(ctx context.Context, db DBTX, arg InsertBufferedTaskRuntimesParams) error {
	_, err := db.Exec(ctx, insertBufferedTaskRuntimes,
		arg.Tenantid,
		arg.Taskids,
		arg.Taskinsertedats,
		arg.Taskretrycounts,
	)
	return err
}

const listActionsForWorkers = `-- name: ListActionsForWorkers :many
SELECT
    w."id" as "workerId",
    a."actionId"
FROM
    "Worker" w
LEFT JOIN
    "_ActionToWorker" atw ON w."id" = atw."B"
LEFT JOIN
    "Action" a ON atw."A" = a."id"
WHERE
    w."tenantId" = $1::uuid
    AND w."id" = ANY($2::uuid[])
    AND w."dispatcherId" IS NOT NULL
    AND w."lastHeartbeatAt" > NOW() - INTERVAL '5 seconds'
    AND w."isActive" = true
    AND w."isPaused" = false
`

type ListActionsForWorkersParams struct {
	Tenantid  pgtype.UUID   `json:"tenantid"`
	Workerids []pgtype.UUID `json:"workerids"`
}

type ListActionsForWorkersRow struct {
	WorkerId pgtype.UUID `json:"workerId"`
	ActionId pgtype.Text `json:"actionId"`
}

func (q *Queries) ListActionsForWorkers(ctx context.Context, db DBTX, arg ListActionsForWorkersParams) ([]*ListActionsForWorkersRow, error) {
	rows, err := db.Query(ctx, listActionsForWorkers, arg.Tenantid, arg.Workerids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListActionsForWorkersRow
	for rows.Next() {
		var i ListActionsForWorkersRow
		if err := rows.Scan(&i.WorkerId, &i.ActionId); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAvailableSlotsForWorkers = `-- name: ListAvailableSlotsForWorkers :many
WITH worker_max_runs AS (
    SELECT
        "id",
        "maxRuns"
    FROM
        "Worker"
    WHERE
        "tenantId" = $1::uuid
        AND "id" = ANY($2::uuid[])
), worker_filled_slots AS (
    SELECT
        worker_id,
        (
            COALESCE(SUM(CASE WHEN batch_id IS NULL THEN 1 ELSE 0 END), 0)::integer
            + COUNT(DISTINCT batch_id)::integer
        ) AS "filledSlots"
    FROM
        v1_task_runtime
    WHERE
        tenant_id = $1::uuid
        AND worker_id = ANY($2::uuid[])
    GROUP BY
        worker_id
)
SELECT
    wmr."id",
    wmr."maxRuns" - COALESCE(wfs."filledSlots", 0) AS "availableSlots"
FROM
    worker_max_runs wmr
LEFT JOIN
    worker_filled_slots wfs ON wmr."id" = wfs.worker_id
`

type ListAvailableSlotsForWorkersParams struct {
	Tenantid  pgtype.UUID   `json:"tenantid"`
	Workerids []pgtype.UUID `json:"workerids"`
}

type ListAvailableSlotsForWorkersRow struct {
	ID             pgtype.UUID `json:"id"`
	AvailableSlots int32       `json:"availableSlots"`
}

// subtract the filled slots from the max runs to get the available slots
func (q *Queries) ListAvailableSlotsForWorkers(ctx context.Context, db DBTX, arg ListAvailableSlotsForWorkersParams) ([]*ListAvailableSlotsForWorkersRow, error) {
	rows, err := db.Query(ctx, listAvailableSlotsForWorkers, arg.Tenantid, arg.Workerids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListAvailableSlotsForWorkersRow
	for rows.Next() {
		var i ListAvailableSlotsForWorkersRow
		if err := rows.Scan(&i.ID, &i.AvailableSlots); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBatchedQueueItemsForBatch = `-- name: ListBatchedQueueItemsForBatch :many
SELECT
    id,
    tenant_id,
    queue,
    task_id,
    task_inserted_at,
    external_id,
    action_id,
    step_id,
    workflow_id,
    workflow_run_id,
    schedule_timeout_at,
    step_timeout,
    priority,
    sticky,
    desired_worker_id,
    retry_count,
    batch_key,
    inserted_at
FROM
    v1_batched_queue_item
WHERE
    tenant_id = $1::uuid
    AND step_id = $2::uuid
    AND batch_key = $3::text
    AND (
        $4::bigint IS NULL
        OR id > $4::bigint
    )
ORDER BY
    priority DESC,
    id ASC
LIMIT
    COALESCE($5::integer, 1000)
`

type ListBatchedQueueItemsForBatchParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Stepid   pgtype.UUID `json:"stepid"`
	Batchkey string      `json:"batchkey"`
	AfterId  pgtype.Int8 `json:"afterId"`
	Limit    pgtype.Int4 `json:"limit"`
}

func (q *Queries) ListBatchedQueueItemsForBatch(ctx context.Context, db DBTX, arg ListBatchedQueueItemsForBatchParams) ([]*V1BatchedQueueItem, error) {
	rows, err := db.Query(ctx, listBatchedQueueItemsForBatch,
		arg.Tenantid,
		arg.Stepid,
		arg.Batchkey,
		arg.AfterId,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V1BatchedQueueItem
	for rows.Next() {
		var i V1BatchedQueueItem
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Queue,
			&i.TaskID,
			&i.TaskInsertedAt,
			&i.ExternalID,
			&i.ActionID,
			&i.StepID,
			&i.WorkflowID,
			&i.WorkflowRunID,
			&i.ScheduleTimeoutAt,
			&i.StepTimeout,
			&i.Priority,
			&i.Sticky,
			&i.DesiredWorkerID,
			&i.RetryCount,
			&i.BatchKey,
			&i.InsertedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBatchedQueueItemsToTimeout = `-- name: ListBatchedQueueItemsToTimeout :many
SELECT
    bqi.id,
    bqi.tenant_id,
    bqi.queue,
    bqi.task_id,
    bqi.task_inserted_at,
    bqi.external_id,
    bqi.action_id,
    bqi.step_id,
    bqi.workflow_id,
    bqi.workflow_run_id,
    bqi.schedule_timeout_at,
    bqi.step_timeout,
    bqi.priority,
    bqi.sticky,
    bqi.desired_worker_id,
    bqi.retry_count,
    bqi.batch_key
FROM
    v1_batched_queue_item bqi
LEFT JOIN
    v1_task_runtime tr ON (
        tr.task_id = bqi.task_id
        AND tr.task_inserted_at = bqi.task_inserted_at
        AND tr.retry_count = bqi.retry_count
    )
WHERE
    bqi.tenant_id = $1::uuid
    AND bqi.schedule_timeout_at <= NOW()
    AND tr.task_id IS NULL  -- Only timeout tasks that are NOT already running
ORDER BY
    bqi.id ASC
LIMIT
    COALESCE($2::integer, 1000)
`

type ListBatchedQueueItemsToTimeoutParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Limit    pgtype.Int4 `json:"limit"`
}

type ListBatchedQueueItemsToTimeoutRow struct {
	ID                int64              `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	Queue             string             `json:"queue"`
	TaskID            int64              `json:"task_id"`
	TaskInsertedAt    pgtype.Timestamptz `json:"task_inserted_at"`
	ExternalID        pgtype.UUID        `json:"external_id"`
	ActionID          string             `json:"action_id"`
	StepID            pgtype.UUID        `json:"step_id"`
	WorkflowID        pgtype.UUID        `json:"workflow_id"`
	WorkflowRunID     pgtype.UUID        `json:"workflow_run_id"`
	ScheduleTimeoutAt pgtype.Timestamp   `json:"schedule_timeout_at"`
	StepTimeout       pgtype.Text        `json:"step_timeout"`
	Priority          int32              `json:"priority"`
	Sticky            V1StickyStrategy   `json:"sticky"`
	DesiredWorkerID   pgtype.UUID        `json:"desired_worker_id"`
	RetryCount        int32              `json:"retry_count"`
	BatchKey          string             `json:"batch_key"`
}

func (q *Queries) ListBatchedQueueItemsToTimeout(ctx context.Context, db DBTX, arg ListBatchedQueueItemsToTimeoutParams) ([]*ListBatchedQueueItemsToTimeoutRow, error) {
	rows, err := db.Query(ctx, listBatchedQueueItemsToTimeout, arg.Tenantid, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListBatchedQueueItemsToTimeoutRow
	for rows.Next() {
		var i ListBatchedQueueItemsToTimeoutRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Queue,
			&i.TaskID,
			&i.TaskInsertedAt,
			&i.ExternalID,
			&i.ActionID,
			&i.StepID,
			&i.WorkflowID,
			&i.WorkflowRunID,
			&i.ScheduleTimeoutAt,
			&i.StepTimeout,
			&i.Priority,
			&i.Sticky,
			&i.DesiredWorkerID,
			&i.RetryCount,
			&i.BatchKey,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDistinctBatchResources = `-- name: ListDistinctBatchResources :many
SELECT
    b.step_id,
    b.batch_key,
    MIN(b.inserted_at)::timestamptz AS oldest_item_at,
    COUNT(*) AS pending_count,
    COALESCE(MAX(s."batch_max_size"), -1)::integer AS batch_max_size,
    COALESCE(MAX(s."batch_max_interval"), -1)::integer AS batch_max_interval,
    COALESCE(MAX(s."batch_group_max_runs"), -1)::integer AS batch_group_max_runs
FROM
    v1_batched_queue_item b
JOIN
    "Step" s ON s."id" = b.step_id
WHERE
    b.tenant_id = $1::uuid
GROUP BY
    b.step_id,
    b.batch_key
ORDER BY
    oldest_item_at ASC
`

type ListDistinctBatchResourcesRow struct {
	StepID            pgtype.UUID        `json:"step_id"`
	BatchKey          string             `json:"batch_key"`
	OldestItemAt      pgtype.Timestamptz `json:"oldest_item_at"`
	PendingCount      int64              `json:"pending_count"`
	BatchMaxSize      int32              `json:"batch_max_size"`
	BatchMaxInterval  int32              `json:"batch_max_interval"`
	BatchGroupMaxRuns int32              `json:"batch_group_max_runs"`
}

func (q *Queries) ListDistinctBatchResources(ctx context.Context, db DBTX, tenantid pgtype.UUID) ([]*ListDistinctBatchResourcesRow, error) {
	rows, err := db.Query(ctx, listDistinctBatchResources, tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListDistinctBatchResourcesRow
	for rows.Next() {
		var i ListDistinctBatchResourcesRow
		if err := rows.Scan(
			&i.StepID,
			&i.BatchKey,
			&i.OldestItemAt,
			&i.PendingCount,
			&i.BatchMaxSize,
			&i.BatchMaxInterval,
			&i.BatchGroupMaxRuns,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExistingBatchedQueueItemIds = `-- name: ListExistingBatchedQueueItemIds :many
SELECT
    id
FROM
    v1_batched_queue_item
WHERE
    tenant_id = $1::uuid
    AND id = ANY($2::bigint[])
`

type ListExistingBatchedQueueItemIdsParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Ids      []int64     `json:"ids"`
}

func (q *Queries) ListExistingBatchedQueueItemIds(ctx context.Context, db DBTX, arg ListExistingBatchedQueueItemIdsParams) ([]int64, error) {
	rows, err := db.Query(ctx, listExistingBatchedQueueItemIds, arg.Tenantid, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQueueItemsForQueue = `-- name: ListQueueItemsForQueue :many
SELECT
    id, tenant_id, queue, task_id, task_inserted_at, external_id, action_id, step_id, workflow_id, workflow_run_id, schedule_timeout_at, step_timeout, priority, sticky, desired_worker_id, retry_count, batch_key
FROM
    v1_queue_item qi
WHERE
    qi.tenant_id = $1::uuid
    AND qi.queue = $2::text
    AND (
        $3::bigint IS NULL OR
        qi.id >= $3::bigint
    )
    -- Added to ensure that the index is used
    AND qi.priority >= 1 AND qi.priority <= 4
ORDER BY
    qi.priority DESC,
    qi.id ASC
LIMIT
    COALESCE($4::integer, 100)
`

type ListQueueItemsForQueueParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Queue    string      `json:"queue"`
	GtId     pgtype.Int8 `json:"gtId"`
	Limit    pgtype.Int4 `json:"limit"`
}

func (q *Queries) ListQueueItemsForQueue(ctx context.Context, db DBTX, arg ListQueueItemsForQueueParams) ([]*V1QueueItem, error) {
	rows, err := db.Query(ctx, listQueueItemsForQueue,
		arg.Tenantid,
		arg.Queue,
		arg.GtId,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V1QueueItem
	for rows.Next() {
		var i V1QueueItem
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Queue,
			&i.TaskID,
			&i.TaskInsertedAt,
			&i.ExternalID,
			&i.ActionID,
			&i.StepID,
			&i.WorkflowID,
			&i.WorkflowRunID,
			&i.ScheduleTimeoutAt,
			&i.StepTimeout,
			&i.Priority,
			&i.Sticky,
			&i.DesiredWorkerID,
			&i.RetryCount,
			&i.BatchKey,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQueues = `-- name: ListQueues :many
SELECT
    tenant_id, name, last_active
FROM
    v1_queue
WHERE
    tenant_id = $1::uuid
    AND last_active > NOW() - INTERVAL '1 day'
`

func (q *Queries) ListQueues(ctx context.Context, db DBTX, tenantid pgtype.UUID) ([]*V1Queue, error) {
	rows, err := db.Query(ctx, listQueues, tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V1Queue
	for rows.Next() {
		var i V1Queue
		if err := rows.Scan(&i.TenantID, &i.Name, &i.LastActive); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepsWithBatchConfig = `-- name: ListStepsWithBatchConfig :many
SELECT
    "id" AS step_id
FROM
    "Step"
WHERE
    "id" = ANY($1::uuid[])
    AND "batch_max_size" IS NOT NULL
    AND "batch_max_size" >= 1
`

func (q *Queries) ListStepsWithBatchConfig(ctx context.Context, db DBTX, stepids []pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := db.Query(ctx, listStepsWithBatchConfig, stepids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var step_id pgtype.UUID
		if err := rows.Scan(&step_id); err != nil {
			return nil, err
		}
		items = append(items, step_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const moveBatchedQueueItems = `-- name: MoveBatchedQueueItems :many
WITH moved_items AS (
    DELETE FROM v1_batched_queue_item
    WHERE id = ANY($1::bigint[])
    RETURNING
        tenant_id,
        queue,
        task_id,
        task_inserted_at,
        external_id,
        action_id,
        step_id,
        workflow_id,
        workflow_run_id,
        schedule_timeout_at,
        step_timeout,
        priority,
        sticky,
        desired_worker_id,
        retry_count,
        batch_key
)
INSERT INTO v1_queue_item (
    tenant_id,
    queue,
    task_id,
    task_inserted_at,
    external_id,
    action_id,
    step_id,
    workflow_id,
    workflow_run_id,
    schedule_timeout_at,
    step_timeout,
    priority,
    sticky,
    desired_worker_id,
    retry_count,
    batch_key
)
SELECT
    tenant_id,
    queue,
    task_id,
    task_inserted_at,
    external_id,
    action_id,
    step_id,
    workflow_id,
    workflow_run_id,
    schedule_timeout_at,
    step_timeout,
    priority,
    sticky,
    desired_worker_id,
    retry_count,
    batch_key
FROM moved_items
RETURNING id, tenant_id, task_id, task_inserted_at, retry_count
`

type MoveBatchedQueueItemsRow struct {
	ID             int64              `json:"id"`
	TenantID       pgtype.UUID        `json:"tenant_id"`
	TaskID         int64              `json:"task_id"`
	TaskInsertedAt pgtype.Timestamptz `json:"task_inserted_at"`
	RetryCount     int32              `json:"retry_count"`
}

func (q *Queries) MoveBatchedQueueItems(ctx context.Context, db DBTX, ids []int64) ([]*MoveBatchedQueueItemsRow, error) {
	rows, err := db.Query(ctx, moveBatchedQueueItems, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*MoveBatchedQueueItemsRow
	for rows.Next() {
		var i MoveBatchedQueueItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.TaskID,
			&i.TaskInsertedAt,
			&i.RetryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const moveQueueItemsToBatchedQueue = `-- name: MoveQueueItemsToBatchedQueue :many
WITH locked_qis AS (
    SELECT
        qi.id, qi.tenant_id, qi.queue, qi.task_id, qi.task_inserted_at, qi.external_id, qi.action_id, qi.step_id, qi.workflow_id, qi.workflow_run_id, qi.schedule_timeout_at, qi.step_timeout, qi.priority, qi.sticky, qi.desired_worker_id, qi.retry_count, qi.batch_key
    FROM
        v1_queue_item qi
    JOIN
        "Step" s ON s."id" = qi.step_id
    WHERE
        qi.id = ANY($1::bigint[])
        AND s."batch_max_size" IS NOT NULL
        AND s."batch_max_size" >= 1
    ORDER BY
        qi.id ASC
    FOR UPDATE
), inserted AS (
    INSERT INTO v1_batched_queue_item (
        tenant_id,
        queue,
        task_id,
        task_inserted_at,
        external_id,
        action_id,
        step_id,
        workflow_id,
        workflow_run_id,
        schedule_timeout_at,
        step_timeout,
        priority,
        sticky,
        desired_worker_id,
        retry_count,
        batch_key,
        inserted_at
    )
    SELECT
        tenant_id,
        queue,
        task_id,
        task_inserted_at,
        external_id,
        action_id,
        step_id,
        workflow_id,
        workflow_run_id,
        schedule_timeout_at,
        step_timeout,
        priority,
        sticky,
        desired_worker_id,
        retry_count,
        COALESCE(BTRIM(batch_key), ''),
        CURRENT_TIMESTAMP
    FROM
        locked_qis
    ON CONFLICT (task_id, task_inserted_at, retry_count) DO NOTHING
    RETURNING task_id
), deleted AS (
    DELETE FROM v1_queue_item
    WHERE id IN (SELECT id FROM locked_qis)
    RETURNING id
)
SELECT id FROM deleted
`

func (q *Queries) MoveQueueItemsToBatchedQueue(ctx context.Context, db DBTX, ids []int64) ([]int64, error) {
	rows, err := db.Query(ctx, moveQueueItemsToBatchedQueue, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const moveRateLimitedQueueItems = `-- name: MoveRateLimitedQueueItems :many
WITH input AS (
    SELECT
        UNNEST($1::bigint[]) AS id,
        UNNEST($2::timestamptz[]) AS requeue_after
), moved_items AS (
    DELETE FROM v1_queue_item
    WHERE id = ANY(SELECT id FROM input)
    RETURNING
        id,
        tenant_id,
        queue,
        task_id,
        task_inserted_at,
        external_id,
        action_id,
        step_id,
        workflow_id,
        workflow_run_id,
        schedule_timeout_at,
        step_timeout,
        priority,
        sticky,
        desired_worker_id,
        retry_count,
        batch_key
)
INSERT INTO v1_rate_limited_queue_items (
    requeue_after,
    tenant_id,
    queue,
    task_id,
    task_inserted_at,
    external_id,
    action_id,
    step_id,
    workflow_id,
    workflow_run_id,
    schedule_timeout_at,
    step_timeout,
    priority,
    sticky,
    desired_worker_id,
    retry_count,
    batch_key
)
SELECT
    i.requeue_after,
    tenant_id,
    queue,
    task_id,
    task_inserted_at,
    external_id,
    action_id,
    step_id,
    workflow_id,
    workflow_run_id,
    schedule_timeout_at,
    step_timeout,
    priority,
    sticky,
    desired_worker_id,
    retry_count,
    batch_key
FROM moved_items
JOIN input i ON moved_items.id = i.id
ON CONFLICT (task_id, task_inserted_at, retry_count) DO NOTHING
RETURNING tenant_id, task_id, task_inserted_at, retry_count
`

type MoveRateLimitedQueueItemsParams struct {
	Ids          []int64              `json:"ids"`
	Requeueafter []pgtype.Timestamptz `json:"requeueafter"`
}

type MoveRateLimitedQueueItemsRow struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	TaskID         int64              `json:"task_id"`
	TaskInsertedAt pgtype.Timestamptz `json:"task_inserted_at"`
	RetryCount     int32              `json:"retry_count"`
}

func (q *Queries) MoveRateLimitedQueueItems(ctx context.Context, db DBTX, arg MoveRateLimitedQueueItemsParams) ([]*MoveRateLimitedQueueItemsRow, error) {
	rows, err := db.Query(ctx, moveRateLimitedQueueItems, arg.Ids, arg.Requeueafter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*MoveRateLimitedQueueItemsRow
	for rows.Next() {
		var i MoveRateLimitedQueueItemsRow
		if err := rows.Scan(
			&i.TenantID,
			&i.TaskID,
			&i.TaskInsertedAt,
			&i.RetryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const requeueRateLimitedQueueItems = `-- name: RequeueRateLimitedQueueItems :many
WITH ready_items AS (
    SELECT
        tenant_id,
        queue,
        task_id,
        task_inserted_at,
        external_id,
        action_id,
        step_id,
        workflow_id,
        workflow_run_id,
        schedule_timeout_at,
        step_timeout,
        priority,
        sticky,
        desired_worker_id,
        retry_count,
        batch_key
    FROM
        v1_rate_limited_queue_items
    WHERE
        tenant_id = $1::uuid
        AND queue = $2::text
        AND requeue_after <= NOW()
    ORDER BY
        task_id, task_inserted_at, retry_count
    FOR UPDATE SKIP LOCKED -- locked are about to be deleted
), deleted_items AS (
    DELETE FROM v1_rate_limited_queue_items
    WHERE
        (task_id, task_inserted_at, retry_count) IN (SELECT task_id, task_inserted_at, retry_count FROM ready_items)
    RETURNING
        tenant_id,
        queue,
        task_id,
        task_inserted_at,
        external_id,
        action_id,
        step_id,
        workflow_id,
        workflow_run_id,
        schedule_timeout_at,
        step_timeout,
        priority,
        sticky,
        desired_worker_id,
        retry_count,
        batch_key
)
INSERT INTO v1_queue_item (
    tenant_id,
    queue,
    task_id,
    task_inserted_at,
    external_id,
    action_id,
    step_id,
    workflow_id,
    workflow_run_id,
    schedule_timeout_at,
    step_timeout,
    priority,
    sticky,
    desired_worker_id,
    retry_count,
    batch_key
)
SELECT
    tenant_id,
    queue,
    task_id,
    task_inserted_at,
    external_id,
    action_id,
    step_id,
    workflow_id,
    workflow_run_id,
    schedule_timeout_at,
    step_timeout,
    priority,
    sticky,
    desired_worker_id,
    retry_count,
    batch_key
FROM ready_items
RETURNING id, tenant_id, task_id, task_inserted_at, retry_count
`

type RequeueRateLimitedQueueItemsParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Queue    string      `json:"queue"`
}

type RequeueRateLimitedQueueItemsRow struct {
	ID             int64              `json:"id"`
	TenantID       pgtype.UUID        `json:"tenant_id"`
	TaskID         int64              `json:"task_id"`
	TaskInsertedAt pgtype.Timestamptz `json:"task_inserted_at"`
	RetryCount     int32              `json:"retry_count"`
}

func (q *Queries) RequeueRateLimitedQueueItems(ctx context.Context, db DBTX, arg RequeueRateLimitedQueueItemsParams) ([]*RequeueRateLimitedQueueItemsRow, error) {
	rows, err := db.Query(ctx, requeueRateLimitedQueueItems, arg.Tenantid, arg.Queue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RequeueRateLimitedQueueItemsRow
	for rows.Next() {
		var i RequeueRateLimitedQueueItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.TaskID,
			&i.TaskInsertedAt,
			&i.RetryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTasksToAssigned = `-- name: UpdateTasksToAssigned :many
WITH input AS (
    SELECT
        id,
        inserted_at,
        worker_id
    FROM
        (
            SELECT
                UNNEST($1::bigint[]) AS id,
                UNNEST($2::timestamptz[]) AS inserted_at,
                UNNEST($3::uuid[]) AS worker_id
        ) AS subquery
    ORDER BY id
), updated_tasks AS (
    SELECT
        t.id,
        t.inserted_at,
        t.retry_count,
        i.worker_id,
        t.tenant_id,
        t.batch_key,
        CURRENT_TIMESTAMP + convert_duration_to_interval(t.step_timeout) AS timeout_at
    FROM
        v1_task t
    JOIN
        input i ON (t.id, t.inserted_at) = (i.id, i.inserted_at)
    WHERE
        t.inserted_at >= $4::timestamptz
        AND NOT EXISTS (
            SELECT 1
            FROM v1_task_event e
            WHERE
                e.task_id = t.id
                AND e.task_inserted_at = t.inserted_at
                AND e.retry_count = t.retry_count
                AND e.event_type = 'CANCELLED'::v1_task_event_type
        )
    ORDER BY t.id
), assigned_tasks AS (
    INSERT INTO v1_task_runtime (
        task_id,
        task_inserted_at,
        retry_count,
        worker_id,
        tenant_id,
        batch_key,
        timeout_at
    )
    SELECT
        t.id,
        t.inserted_at,
        t.retry_count,
        t.worker_id,
        $5::uuid,
        t.batch_key,
        t.timeout_at
    FROM
        updated_tasks t
    ON CONFLICT (task_id, task_inserted_at, retry_count) DO UPDATE
    SET
        worker_id = EXCLUDED.worker_id,
        tenant_id = EXCLUDED.tenant_id,
        batch_key = EXCLUDED.batch_key,
        timeout_at = EXCLUDED.timeout_at
    -- only return the task ids that were successfully assigned
    RETURNING task_id, worker_id
)
SELECT
    asr.task_id,
    asr.worker_id
FROM
    assigned_tasks asr
`

type UpdateTasksToAssignedParams struct {
	Taskids           []int64              `json:"taskids"`
	Taskinsertedats   []pgtype.Timestamptz `json:"taskinsertedats"`
	Workerids         []pgtype.UUID        `json:"workerids"`
	Mintaskinsertedat pgtype.Timestamptz   `json:"mintaskinsertedat"`
	Tenantid          pgtype.UUID          `json:"tenantid"`
}

type UpdateTasksToAssignedRow struct {
	TaskID   int64       `json:"task_id"`
	WorkerID pgtype.UUID `json:"worker_id"`
}

func (q *Queries) UpdateTasksToAssigned(ctx context.Context, db DBTX, arg UpdateTasksToAssignedParams) ([]*UpdateTasksToAssignedRow, error) {
	rows, err := db.Query(ctx, updateTasksToAssigned,
		arg.Taskids,
		arg.Taskinsertedats,
		arg.Workerids,
		arg.Mintaskinsertedat,
		arg.Tenantid,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UpdateTasksToAssignedRow
	for rows.Next() {
		var i UpdateTasksToAssignedRow
		if err := rows.Scan(&i.TaskID, &i.WorkerID); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertQueues = `-- name: UpsertQueues :exec
WITH ordered_names AS (
    SELECT unnest($2::text[]) AS name
    ORDER BY name ASC
), existing_queues AS (
    SELECT tenant_id, name, last_active
    FROM v1_queue
    WHERE tenant_id = $1
      AND name = ANY($2::text[])
), locked_existing_queues AS (
    SELECT tenant_id, name, last_active
    FROM v1_queue
    WHERE
        tenant_id = $1
        AND name IN (SELECT name FROM existing_queues)
    ORDER BY name ASC
    FOR UPDATE SKIP LOCKED
), names_to_insert AS (
    SELECT on1.name
    FROM ordered_names on1
    LEFT JOIN existing_queues eq ON eq.name = on1.name
    WHERE eq.name IS NULL
), updated_queues AS (
    UPDATE v1_queue
    SET last_active = NOW()
    WHERE tenant_id = $1
      AND name IN (SELECT name FROM locked_existing_queues)
)
INSERT INTO v1_queue (tenant_id, name, last_active)
SELECT $1, name, NOW()
FROM names_to_insert
ON CONFLICT (tenant_id, name) DO NOTHING
`

type UpsertQueuesParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Names    []string    `json:"names"`
}

// Insert new queues
func (q *Queries) UpsertQueues(ctx context.Context, db DBTX, arg UpsertQueuesParams) error {
	_, err := db.Exec(ctx, upsertQueues, arg.TenantID, arg.Names)
	return err
}
