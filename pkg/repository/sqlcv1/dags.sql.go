// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: dags.sql

package sqlcv1

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type CreateDAGDataParams struct {
	DagID              int64              `json:"dag_id"`
	DagInsertedAt      pgtype.Timestamptz `json:"dag_inserted_at"`
	Input              []byte             `json:"input"`
	AdditionalMetadata []byte             `json:"additional_metadata"`
}

const createDAGs = `-- name: CreateDAGs :many
WITH input AS (
    SELECT
        tenant_id, external_id, display_name, workflow_id, workflow_version_id, parent_task_external_id
    FROM
        (
            SELECT
                unnest($1::uuid[]) AS tenant_id,
                unnest($2::uuid[]) AS external_id,
                unnest($3::text[]) AS display_name,
                unnest($4::uuid[]) AS workflow_id,
                unnest($5::uuid[]) AS workflow_version_id,
                unnest($6::uuid[]) AS parent_task_external_id
        ) AS subquery
)
INSERT INTO v1_dag (
    tenant_id,
    external_id,
    display_name,
    workflow_id,
    workflow_version_id,
    parent_task_external_id
)
SELECT
    i.tenant_id,
    i.external_id,
    i.display_name,
    i.workflow_id,
    i.workflow_version_id,
    NULLIF(i.parent_task_external_id, '00000000-0000-0000-0000-000000000000'::uuid)
FROM
    input i
RETURNING
    id, inserted_at, tenant_id, external_id, display_name, workflow_id, workflow_version_id, parent_task_external_id
`

type CreateDAGsParams struct {
	Tenantids             []uuid.UUID `json:"tenantids"`
	Externalids           []uuid.UUID `json:"externalids"`
	Displaynames          []string    `json:"displaynames"`
	Workflowids           []uuid.UUID `json:"workflowids"`
	Workflowversionids    []uuid.UUID `json:"workflowversionids"`
	Parenttaskexternalids []uuid.UUID `json:"parenttaskexternalids"`
}

func (q *Queries) CreateDAGs(ctx context.Context, db DBTX, arg CreateDAGsParams) ([]*V1Dag, error) {
	rows, err := db.Query(ctx, createDAGs,
		arg.Tenantids,
		arg.Externalids,
		arg.Displaynames,
		arg.Workflowids,
		arg.Workflowversionids,
		arg.Parenttaskexternalids,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V1Dag
	for rows.Next() {
		var i V1Dag
		if err := rows.Scan(
			&i.ID,
			&i.InsertedAt,
			&i.TenantID,
			&i.ExternalID,
			&i.DisplayName,
			&i.WorkflowID,
			&i.WorkflowVersionID,
			&i.ParentTaskExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDAGData = `-- name: GetDAGData :many
WITH input AS (
    SELECT
        dag_id, dag_inserted_at
    FROM
        (
            SELECT
                unnest($1::bigint[]) AS dag_id,
                unnest($2::timestamptz[]) AS dag_inserted_at
        ) AS subquery
)
SELECT
    v1_dag_data.dag_id, v1_dag_data.dag_inserted_at, input, additional_metadata, input.dag_id, input.dag_inserted_at
FROM
    v1_dag_data
JOIN
    input USING (dag_id, dag_inserted_at)
`

type GetDAGDataParams struct {
	Dagids         []int64              `json:"dagids"`
	Daginsertedats []pgtype.Timestamptz `json:"daginsertedats"`
}

type GetDAGDataRow struct {
	DagID              int64              `json:"dag_id"`
	DagInsertedAt      pgtype.Timestamptz `json:"dag_inserted_at"`
	Input              []byte             `json:"input"`
	AdditionalMetadata []byte             `json:"additional_metadata"`
	DagID_2            interface{}        `json:"dag_id_2"`
	DagInsertedAt_2    interface{}        `json:"dag_inserted_at_2"`
}

func (q *Queries) GetDAGData(ctx context.Context, db DBTX, arg GetDAGDataParams) ([]*GetDAGDataRow, error) {
	rows, err := db.Query(ctx, getDAGData, arg.Dagids, arg.Daginsertedats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetDAGDataRow
	for rows.Next() {
		var i GetDAGDataRow
		if err := rows.Scan(
			&i.DagID,
			&i.DagInsertedAt,
			&i.Input,
			&i.AdditionalMetadata,
			&i.DagID_2,
			&i.DagInsertedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
