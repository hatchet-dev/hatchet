// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: durable_event_log.sql

package sqlcv1

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createDurableEventLogCallback = `-- name: CreateDurableEventLogCallback :one
INSERT INTO v1_durable_event_log_callback (
    tenant_id,
    durable_task_id,
    durable_task_inserted_at,
    inserted_at,
    kind,
    node_id,
    is_satisfied,
    external_id,
    dispatcher_id
)
VALUES (
    $1::UUID,
    $2::BIGINT,
    $3::TIMESTAMPTZ,
    $4::TIMESTAMPTZ,
    $5::v1_durable_event_log_callback_kind,
    $6::BIGINT,
    $7::BOOLEAN,
    $8::UUID,
    $9::UUID
)
ON CONFLICT (durable_task_id, durable_task_inserted_at, node_id) DO NOTHING
RETURNING tenant_id, external_id, inserted_at, id, durable_task_id, durable_task_inserted_at, kind, node_id, is_satisfied, dispatcher_id
`

type CreateDurableEventLogCallbackParams struct {
	Tenantid              uuid.UUID                     `json:"tenantid"`
	Durabletaskid         int64                         `json:"durabletaskid"`
	Durabletaskinsertedat pgtype.Timestamptz            `json:"durabletaskinsertedat"`
	Insertedat            pgtype.Timestamptz            `json:"insertedat"`
	Kind                  V1DurableEventLogCallbackKind `json:"kind"`
	Nodeid                int64                         `json:"nodeid"`
	Issatisfied           bool                          `json:"issatisfied"`
	Externalid            uuid.UUID                     `json:"externalid"`
	Dispatcherid          uuid.UUID                     `json:"dispatcherid"`
}

func (q *Queries) CreateDurableEventLogCallback(ctx context.Context, db DBTX, arg CreateDurableEventLogCallbackParams) (*V1DurableEventLogCallback, error) {
	row := db.QueryRow(ctx, createDurableEventLogCallback,
		arg.Tenantid,
		arg.Durabletaskid,
		arg.Durabletaskinsertedat,
		arg.Insertedat,
		arg.Kind,
		arg.Nodeid,
		arg.Issatisfied,
		arg.Externalid,
		arg.Dispatcherid,
	)
	var i V1DurableEventLogCallback
	err := row.Scan(
		&i.TenantID,
		&i.ExternalID,
		&i.InsertedAt,
		&i.ID,
		&i.DurableTaskID,
		&i.DurableTaskInsertedAt,
		&i.Kind,
		&i.NodeID,
		&i.IsSatisfied,
		&i.DispatcherID,
	)
	return &i, err
}

const createDurableEventLogEntry = `-- name: CreateDurableEventLogEntry :one
INSERT INTO v1_durable_event_log_entry (
    tenant_id,
    external_id,
    durable_task_id,
    durable_task_inserted_at,
    inserted_at,
    kind,
    node_id,
    parent_node_id,
    branch_id,
    data_hash,
    data_hash_alg
)
VALUES (
    $1::UUID,
    $2::UUID,
    $3::BIGINT,
    $4::TIMESTAMPTZ,
    NOW(),
    $5::v1_durable_event_log_entry_kind,
    $6::BIGINT,
    $7::BIGINT,
    $8::BIGINT,
    $9::BYTEA,
    $10::TEXT
)
ON CONFLICT (durable_task_id, durable_task_inserted_at, node_id) DO NOTHING
RETURNING tenant_id, external_id, inserted_at, id, durable_task_id, durable_task_inserted_at, kind, node_id, parent_node_id, branch_id, data_hash, data_hash_alg
`

type CreateDurableEventLogEntryParams struct {
	Tenantid              uuid.UUID                  `json:"tenantid"`
	Externalid            uuid.UUID                  `json:"externalid"`
	Durabletaskid         int64                      `json:"durabletaskid"`
	Durabletaskinsertedat pgtype.Timestamptz         `json:"durabletaskinsertedat"`
	Kind                  V1DurableEventLogEntryKind `json:"kind"`
	Nodeid                int64                      `json:"nodeid"`
	ParentNodeId          pgtype.Int8                `json:"parentNodeId"`
	Branchid              int64                      `json:"branchid"`
	Datahash              []byte                     `json:"datahash"`
	Datahashalg           string                     `json:"datahashalg"`
}

func (q *Queries) CreateDurableEventLogEntry(ctx context.Context, db DBTX, arg CreateDurableEventLogEntryParams) (*V1DurableEventLogEntry, error) {
	row := db.QueryRow(ctx, createDurableEventLogEntry,
		arg.Tenantid,
		arg.Externalid,
		arg.Durabletaskid,
		arg.Durabletaskinsertedat,
		arg.Kind,
		arg.Nodeid,
		arg.ParentNodeId,
		arg.Branchid,
		arg.Datahash,
		arg.Datahashalg,
	)
	var i V1DurableEventLogEntry
	err := row.Scan(
		&i.TenantID,
		&i.ExternalID,
		&i.InsertedAt,
		&i.ID,
		&i.DurableTaskID,
		&i.DurableTaskInsertedAt,
		&i.Kind,
		&i.NodeID,
		&i.ParentNodeID,
		&i.BranchID,
		&i.DataHash,
		&i.DataHashAlg,
	)
	return &i, err
}

const createEventLogFile = `-- name: CreateEventLogFile :one
INSERT INTO v1_durable_event_log_file (
    tenant_id,
    durable_task_id,
    durable_task_inserted_at,
    latest_invocation_count,
    latest_inserted_at,
    latest_node_id,
    latest_branch_id,
    latest_branch_first_parent_node_id
) VALUES (
    $1::UUID,
    $2::BIGINT,
    $3::TIMESTAMPTZ,
    0,
    NOW(),
    1,
    1,
    0
)
ON CONFLICT (durable_task_id, durable_task_inserted_at)
DO UPDATE SET
    latest_node_id = GREATEST(v1_durable_event_log_file.latest_node_id, EXCLUDED.latest_node_id),
    latest_inserted_at = NOW(),
    latest_invocation_count = GREATEST(v1_durable_event_log_file.latest_invocation_count, EXCLUDED.latest_invocation_count)
RETURNING tenant_id, durable_task_id, durable_task_inserted_at, latest_invocation_count, latest_inserted_at, latest_node_id, latest_branch_id, latest_branch_first_parent_node_id
`

type CreateEventLogFileParams struct {
	Tenantid              uuid.UUID          `json:"tenantid"`
	Durabletaskid         int64              `json:"durabletaskid"`
	Durabletaskinsertedat pgtype.Timestamptz `json:"durabletaskinsertedat"`
}

func (q *Queries) CreateEventLogFile(ctx context.Context, db DBTX, arg CreateEventLogFileParams) (*V1DurableEventLogFile, error) {
	row := db.QueryRow(ctx, createEventLogFile, arg.Tenantid, arg.Durabletaskid, arg.Durabletaskinsertedat)
	var i V1DurableEventLogFile
	err := row.Scan(
		&i.TenantID,
		&i.DurableTaskID,
		&i.DurableTaskInsertedAt,
		&i.LatestInvocationCount,
		&i.LatestInsertedAt,
		&i.LatestNodeID,
		&i.LatestBranchID,
		&i.LatestBranchFirstParentNodeID,
	)
	return &i, err
}

const getAndLockLogFile = `-- name: GetAndLockLogFile :one
SELECT tenant_id, durable_task_id, durable_task_inserted_at, latest_invocation_count, latest_inserted_at, latest_node_id, latest_branch_id, latest_branch_first_parent_node_id
FROM v1_durable_event_log_file
WHERE durable_task_id = $1::BIGINT
    AND durable_task_inserted_at = $2::TIMESTAMPTZ
FOR UPDATE
`

type GetAndLockLogFileParams struct {
	Durabletaskid         int64              `json:"durabletaskid"`
	Durabletaskinsertedat pgtype.Timestamptz `json:"durabletaskinsertedat"`
}

func (q *Queries) GetAndLockLogFile(ctx context.Context, db DBTX, arg GetAndLockLogFileParams) (*V1DurableEventLogFile, error) {
	row := db.QueryRow(ctx, getAndLockLogFile, arg.Durabletaskid, arg.Durabletaskinsertedat)
	var i V1DurableEventLogFile
	err := row.Scan(
		&i.TenantID,
		&i.DurableTaskID,
		&i.DurableTaskInsertedAt,
		&i.LatestInvocationCount,
		&i.LatestInsertedAt,
		&i.LatestNodeID,
		&i.LatestBranchID,
		&i.LatestBranchFirstParentNodeID,
	)
	return &i, err
}

const getDurableEventLogCallback = `-- name: GetDurableEventLogCallback :one
SELECT tenant_id, external_id, inserted_at, id, durable_task_id, durable_task_inserted_at, kind, node_id, is_satisfied, dispatcher_id
FROM v1_durable_event_log_callback
WHERE durable_task_id = $1::BIGINT
  AND durable_task_inserted_at = $2::TIMESTAMPTZ
  AND node_id = $3::BIGINT
`

type GetDurableEventLogCallbackParams struct {
	Durabletaskid         int64              `json:"durabletaskid"`
	Durabletaskinsertedat pgtype.Timestamptz `json:"durabletaskinsertedat"`
	Nodeid                int64              `json:"nodeid"`
}

func (q *Queries) GetDurableEventLogCallback(ctx context.Context, db DBTX, arg GetDurableEventLogCallbackParams) (*V1DurableEventLogCallback, error) {
	row := db.QueryRow(ctx, getDurableEventLogCallback, arg.Durabletaskid, arg.Durabletaskinsertedat, arg.Nodeid)
	var i V1DurableEventLogCallback
	err := row.Scan(
		&i.TenantID,
		&i.ExternalID,
		&i.InsertedAt,
		&i.ID,
		&i.DurableTaskID,
		&i.DurableTaskInsertedAt,
		&i.Kind,
		&i.NodeID,
		&i.IsSatisfied,
		&i.DispatcherID,
	)
	return &i, err
}

const getDurableEventLogEntry = `-- name: GetDurableEventLogEntry :one
SELECT tenant_id, external_id, inserted_at, id, durable_task_id, durable_task_inserted_at, kind, node_id, parent_node_id, branch_id, data_hash, data_hash_alg
FROM v1_durable_event_log_entry
WHERE durable_task_id = $1::BIGINT
  AND durable_task_inserted_at = $2::TIMESTAMPTZ
  AND node_id = $3::BIGINT
`

type GetDurableEventLogEntryParams struct {
	Durabletaskid         int64              `json:"durabletaskid"`
	Durabletaskinsertedat pgtype.Timestamptz `json:"durabletaskinsertedat"`
	Nodeid                int64              `json:"nodeid"`
}

func (q *Queries) GetDurableEventLogEntry(ctx context.Context, db DBTX, arg GetDurableEventLogEntryParams) (*V1DurableEventLogEntry, error) {
	row := db.QueryRow(ctx, getDurableEventLogEntry, arg.Durabletaskid, arg.Durabletaskinsertedat, arg.Nodeid)
	var i V1DurableEventLogEntry
	err := row.Scan(
		&i.TenantID,
		&i.ExternalID,
		&i.InsertedAt,
		&i.ID,
		&i.DurableTaskID,
		&i.DurableTaskInsertedAt,
		&i.Kind,
		&i.NodeID,
		&i.ParentNodeID,
		&i.BranchID,
		&i.DataHash,
		&i.DataHashAlg,
	)
	return &i, err
}

const getSatisfiedCallbacks = `-- name: GetSatisfiedCallbacks :many
SELECT cb.tenant_id, cb.external_id, cb.inserted_at, cb.id, cb.durable_task_id, cb.durable_task_inserted_at, cb.kind, cb.node_id, cb.is_satisfied, cb.dispatcher_id, t.external_id AS task_external_id
FROM v1_durable_event_log_callback cb
JOIN v1_task t ON t.id = cb.durable_task_id
    AND t.inserted_at = cb.durable_task_inserted_at
    AND t.tenant_id = $1::UUID
WHERE (t.external_id, cb.node_id) IN (
    SELECT
        unnest($2::uuid[]),
        unnest($3::bigint[])
)
  AND cb.is_satisfied = TRUE
`

type GetSatisfiedCallbacksParams struct {
	Tenantid        uuid.UUID   `json:"tenantid"`
	Taskexternalids []uuid.UUID `json:"taskexternalids"`
	Nodeids         []int64     `json:"nodeids"`
}

type GetSatisfiedCallbacksRow struct {
	TenantID              uuid.UUID                         `json:"tenant_id"`
	ExternalID            uuid.UUID                         `json:"external_id"`
	InsertedAt            pgtype.Timestamptz                `json:"inserted_at"`
	ID                    int64                             `json:"id"`
	DurableTaskID         int64                             `json:"durable_task_id"`
	DurableTaskInsertedAt pgtype.Timestamptz                `json:"durable_task_inserted_at"`
	Kind                  NullV1DurableEventLogCallbackKind `json:"kind"`
	NodeID                int64                             `json:"node_id"`
	IsSatisfied           bool                              `json:"is_satisfied"`
	DispatcherID          *uuid.UUID                        `json:"dispatcher_id"`
	TaskExternalID        uuid.UUID                         `json:"task_external_id"`
}

func (q *Queries) GetSatisfiedCallbacks(ctx context.Context, db DBTX, arg GetSatisfiedCallbacksParams) ([]*GetSatisfiedCallbacksRow, error) {
	rows, err := db.Query(ctx, getSatisfiedCallbacks, arg.Tenantid, arg.Taskexternalids, arg.Nodeids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetSatisfiedCallbacksRow
	for rows.Next() {
		var i GetSatisfiedCallbacksRow
		if err := rows.Scan(
			&i.TenantID,
			&i.ExternalID,
			&i.InsertedAt,
			&i.ID,
			&i.DurableTaskID,
			&i.DurableTaskInsertedAt,
			&i.Kind,
			&i.NodeID,
			&i.IsSatisfied,
			&i.DispatcherID,
			&i.TaskExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDurableEventLogCallbackSatisfied = `-- name: UpdateDurableEventLogCallbackSatisfied :one
UPDATE v1_durable_event_log_callback
SET is_satisfied = $1::BOOLEAN
WHERE durable_task_id = $2::BIGINT
  AND durable_task_inserted_at = $3::TIMESTAMPTZ
  AND node_id = $4::BIGINT
RETURNING tenant_id, external_id, inserted_at, id, durable_task_id, durable_task_inserted_at, kind, node_id, is_satisfied, dispatcher_id
`

type UpdateDurableEventLogCallbackSatisfiedParams struct {
	Issatisfied           bool               `json:"issatisfied"`
	Durabletaskid         int64              `json:"durabletaskid"`
	Durabletaskinsertedat pgtype.Timestamptz `json:"durabletaskinsertedat"`
	Nodeid                int64              `json:"nodeid"`
}

func (q *Queries) UpdateDurableEventLogCallbackSatisfied(ctx context.Context, db DBTX, arg UpdateDurableEventLogCallbackSatisfiedParams) (*V1DurableEventLogCallback, error) {
	row := db.QueryRow(ctx, updateDurableEventLogCallbackSatisfied,
		arg.Issatisfied,
		arg.Durabletaskid,
		arg.Durabletaskinsertedat,
		arg.Nodeid,
	)
	var i V1DurableEventLogCallback
	err := row.Scan(
		&i.TenantID,
		&i.ExternalID,
		&i.InsertedAt,
		&i.ID,
		&i.DurableTaskID,
		&i.DurableTaskInsertedAt,
		&i.Kind,
		&i.NodeID,
		&i.IsSatisfied,
		&i.DispatcherID,
	)
	return &i, err
}

const updateLogFileNodeIdInvocationCount = `-- name: UpdateLogFileNodeIdInvocationCount :one
UPDATE v1_durable_event_log_file
SET
    latest_node_id = COALESCE($1::BIGINT, v1_durable_event_log_file.latest_node_id),
    latest_invocation_count = COALESCE($2::BIGINT, v1_durable_event_log_file.latest_invocation_count)
WHERE durable_task_id = $3::BIGINT
  AND durable_task_inserted_at = $4::TIMESTAMPTZ
RETURNING tenant_id, durable_task_id, durable_task_inserted_at, latest_invocation_count, latest_inserted_at, latest_node_id, latest_branch_id, latest_branch_first_parent_node_id
`

type UpdateLogFileNodeIdInvocationCountParams struct {
	Nodeid                int64              `json:"nodeid"`
	Invocationcount       int64              `json:"invocationcount"`
	Durabletaskid         int64              `json:"durabletaskid"`
	Durabletaskinsertedat pgtype.Timestamptz `json:"durabletaskinsertedat"`
}

func (q *Queries) UpdateLogFileNodeIdInvocationCount(ctx context.Context, db DBTX, arg UpdateLogFileNodeIdInvocationCountParams) (*V1DurableEventLogFile, error) {
	row := db.QueryRow(ctx, updateLogFileNodeIdInvocationCount,
		arg.Nodeid,
		arg.Invocationcount,
		arg.Durabletaskid,
		arg.Durabletaskinsertedat,
	)
	var i V1DurableEventLogFile
	err := row.Scan(
		&i.TenantID,
		&i.DurableTaskID,
		&i.DurableTaskInsertedAt,
		&i.LatestInvocationCount,
		&i.LatestInsertedAt,
		&i.LatestNodeID,
		&i.LatestBranchID,
		&i.LatestBranchFirstParentNodeID,
	)
	return &i, err
}
