// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: durable_event_log.sql

package sqlcv1

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getDurableEventLogCallback = `-- name: GetDurableEventLogCallback :one
SELECT tenant_id, external_id, inserted_at, id, durable_task_id, durable_task_inserted_at, kind, node_id, is_satisfied, dispatcher_id
FROM v1_durable_event_log_callback
WHERE durable_task_id = $1::BIGINT
  AND durable_task_inserted_at = $2::TIMESTAMPTZ
  AND node_id = $3::BIGINT
`

type GetDurableEventLogCallbackParams struct {
	Durabletaskid         int64              `json:"durabletaskid"`
	Durabletaskinsertedat pgtype.Timestamptz `json:"durabletaskinsertedat"`
	Nodeid                int64              `json:"nodeid"`
}

func (q *Queries) GetDurableEventLogCallback(ctx context.Context, db DBTX, arg GetDurableEventLogCallbackParams) (*V1DurableEventLogCallback, error) {
	row := db.QueryRow(ctx, getDurableEventLogCallback, arg.Durabletaskid, arg.Durabletaskinsertedat, arg.Nodeid)
	var i V1DurableEventLogCallback
	err := row.Scan(
		&i.TenantID,
		&i.ExternalID,
		&i.InsertedAt,
		&i.ID,
		&i.DurableTaskID,
		&i.DurableTaskInsertedAt,
		&i.Kind,
		&i.NodeID,
		&i.IsSatisfied,
		&i.DispatcherID,
	)
	return &i, err
}

const getDurableEventLogEntry = `-- name: GetDurableEventLogEntry :one
SELECT tenant_id, external_id, inserted_at, id, durable_task_id, durable_task_inserted_at, kind, node_id, parent_node_id, branch_id, data_hash, data_hash_alg
FROM v1_durable_event_log_entry
WHERE durable_task_id = $1::BIGINT
  AND durable_task_inserted_at = $2::TIMESTAMPTZ
  AND node_id = $3::BIGINT
`

type GetDurableEventLogEntryParams struct {
	Durabletaskid         int64              `json:"durabletaskid"`
	Durabletaskinsertedat pgtype.Timestamptz `json:"durabletaskinsertedat"`
	Nodeid                int64              `json:"nodeid"`
}

func (q *Queries) GetDurableEventLogEntry(ctx context.Context, db DBTX, arg GetDurableEventLogEntryParams) (*V1DurableEventLogEntry, error) {
	row := db.QueryRow(ctx, getDurableEventLogEntry, arg.Durabletaskid, arg.Durabletaskinsertedat, arg.Nodeid)
	var i V1DurableEventLogEntry
	err := row.Scan(
		&i.TenantID,
		&i.ExternalID,
		&i.InsertedAt,
		&i.ID,
		&i.DurableTaskID,
		&i.DurableTaskInsertedAt,
		&i.Kind,
		&i.NodeID,
		&i.ParentNodeID,
		&i.BranchID,
		&i.DataHash,
		&i.DataHashAlg,
	)
	return &i, err
}

const getOrCreateDurableEventLogCallback = `-- name: GetOrCreateDurableEventLogCallback :one
WITH inputs AS (
    SELECT
        $1::UUID AS tenant_id,
        $2::BIGINT AS durable_task_id,
        $3::TIMESTAMPTZ AS durable_task_inserted_at,
        $4::TIMESTAMPTZ AS inserted_at,
        $5::v1_durable_event_log_callback_kind AS kind,
        $6::BIGINT AS node_id,
        $7::BOOLEAN AS is_satisfied,
        $8::UUID AS external_id,
        $9::UUID AS dispatcher_id
), ins AS (
    INSERT INTO v1_durable_event_log_callback (
        tenant_id,
        durable_task_id,
        durable_task_inserted_at,
        inserted_at,
        kind,
        node_id,
        is_satisfied,
        external_id,
        dispatcher_id
    )
    SELECT
        i.tenant_id,
        i.durable_task_id,
        i.durable_task_inserted_at,
        i.inserted_at,
        i.kind,
        i.node_id,
        i.is_satisfied,
        i.external_id,
        i.dispatcher_id
    FROM
        inputs i
    ON CONFLICT (durable_task_id, durable_task_inserted_at, node_id) DO NOTHING
    RETURNING tenant_id, external_id, inserted_at, id, durable_task_id, durable_task_inserted_at, kind, node_id, is_satisfied, dispatcher_id
)

SELECT
    tenant_id, durable_task_id, durable_task_inserted_at, inserted_at, kind, node_id, is_satisfied, external_id, dispatcher_id,
    (SELECT COUNT(*) FROM ins) = 0 AS already_exists
FROM inputs
`

type GetOrCreateDurableEventLogCallbackParams struct {
	Tenantid              uuid.UUID                     `json:"tenantid"`
	Durabletaskid         int64                         `json:"durabletaskid"`
	Durabletaskinsertedat pgtype.Timestamptz            `json:"durabletaskinsertedat"`
	Insertedat            pgtype.Timestamptz            `json:"insertedat"`
	Kind                  V1DurableEventLogCallbackKind `json:"kind"`
	Nodeid                int64                         `json:"nodeid"`
	Issatisfied           bool                          `json:"issatisfied"`
	Externalid            uuid.UUID                     `json:"externalid"`
	Dispatcherid          uuid.UUID                     `json:"dispatcherid"`
}

type GetOrCreateDurableEventLogCallbackRow struct {
	TenantID              uuid.UUID                     `json:"tenant_id"`
	DurableTaskID         int64                         `json:"durable_task_id"`
	DurableTaskInsertedAt pgtype.Timestamptz            `json:"durable_task_inserted_at"`
	InsertedAt            pgtype.Timestamptz            `json:"inserted_at"`
	Kind                  V1DurableEventLogCallbackKind `json:"kind"`
	NodeID                int64                         `json:"node_id"`
	IsSatisfied           bool                          `json:"is_satisfied"`
	ExternalID            uuid.UUID                     `json:"external_id"`
	DispatcherID          uuid.UUID                     `json:"dispatcher_id"`
	AlreadyExists         bool                          `json:"already_exists"`
}

func (q *Queries) GetOrCreateDurableEventLogCallback(ctx context.Context, db DBTX, arg GetOrCreateDurableEventLogCallbackParams) (*GetOrCreateDurableEventLogCallbackRow, error) {
	row := db.QueryRow(ctx, getOrCreateDurableEventLogCallback,
		arg.Tenantid,
		arg.Durabletaskid,
		arg.Durabletaskinsertedat,
		arg.Insertedat,
		arg.Kind,
		arg.Nodeid,
		arg.Issatisfied,
		arg.Externalid,
		arg.Dispatcherid,
	)
	var i GetOrCreateDurableEventLogCallbackRow
	err := row.Scan(
		&i.TenantID,
		&i.DurableTaskID,
		&i.DurableTaskInsertedAt,
		&i.InsertedAt,
		&i.Kind,
		&i.NodeID,
		&i.IsSatisfied,
		&i.ExternalID,
		&i.DispatcherID,
		&i.AlreadyExists,
	)
	return &i, err
}

const getOrCreateDurableEventLogEntry = `-- name: GetOrCreateDurableEventLogEntry :one
WITH inputs AS (
    SELECT
        $1::UUID AS tenant_id,
        $2::UUID AS external_id,
        $3::BIGINT AS durable_task_id,
        $4::TIMESTAMPTZ AS durable_task_inserted_at,
        $5::TIMESTAMPTZ AS inserted_at,
        $6::v1_durable_event_log_entry_kind AS kind,
        $7::BIGINT AS node_id,
        $8::BIGINT AS parent_node_id,
        $9::BIGINT AS branch_id,
        $10::BYTEA AS data_hash,
        $11::TEXT AS data_hash_alg
), inserts AS (
    INSERT INTO v1_durable_event_log_entry (
        tenant_id,
        external_id,
        durable_task_id,
        durable_task_inserted_at,
        inserted_at,
        kind,
        node_id,
        parent_node_id,
        branch_id,
        data_hash,
        data_hash_alg
    )
    SELECT
        i.tenant_id,
        i.external_id,
        i.durable_task_id,
        i.durable_task_inserted_at,
        i.inserted_at,
        i.kind,
        i.node_id,
        i.parent_node_id,
        i.branch_id,
        i.data_hash,
        i.data_hash_alg
    FROM
        inputs i
    ON CONFLICT (durable_task_id, durable_task_inserted_at, node_id) DO NOTHING
    RETURNING tenant_id, external_id, inserted_at, id, durable_task_id, durable_task_inserted_at, kind, node_id, parent_node_id, branch_id, data_hash, data_hash_alg
), node_id_update AS (
    -- todo: this should probably be figured out at the repo level
    UPDATE v1_durable_event_log_file AS f
    SET latest_node_id = GREATEST(f.latest_node_id, i.latest_node_id)
    FROM inputs i
    WHERE
        f.durable_task_id = i.durable_task_id
        AND f.durable_task_inserted_at = i.durable_task_inserted_at
)

SELECT
    tenant_id, external_id, inserted_at, id, durable_task_id, durable_task_inserted_at, kind, node_id, parent_node_id, branch_id, data_hash, data_hash_alg,
    (SELECT COUNT(*) FROM inserts) = 0 AS already_exists
FROM inserts
`

type GetOrCreateDurableEventLogEntryParams struct {
	Tenantid              uuid.UUID                  `json:"tenantid"`
	Externalid            uuid.UUID                  `json:"externalid"`
	Durabletaskid         int64                      `json:"durabletaskid"`
	Durabletaskinsertedat pgtype.Timestamptz         `json:"durabletaskinsertedat"`
	Insertedat            pgtype.Timestamptz         `json:"insertedat"`
	Kind                  V1DurableEventLogEntryKind `json:"kind"`
	Nodeid                int64                      `json:"nodeid"`
	ParentNodeId          pgtype.Int8                `json:"parentNodeId"`
	Branchid              int64                      `json:"branchid"`
	Datahash              []byte                     `json:"datahash"`
	Datahashalg           string                     `json:"datahashalg"`
}

type GetOrCreateDurableEventLogEntryRow struct {
	TenantID              uuid.UUID                      `json:"tenant_id"`
	ExternalID            uuid.UUID                      `json:"external_id"`
	InsertedAt            pgtype.Timestamptz             `json:"inserted_at"`
	ID                    int64                          `json:"id"`
	DurableTaskID         int64                          `json:"durable_task_id"`
	DurableTaskInsertedAt pgtype.Timestamptz             `json:"durable_task_inserted_at"`
	Kind                  NullV1DurableEventLogEntryKind `json:"kind"`
	NodeID                int64                          `json:"node_id"`
	ParentNodeID          pgtype.Int8                    `json:"parent_node_id"`
	BranchID              int64                          `json:"branch_id"`
	DataHash              []byte                         `json:"data_hash"`
	DataHashAlg           pgtype.Text                    `json:"data_hash_alg"`
	AlreadyExists         bool                           `json:"already_exists"`
}

func (q *Queries) GetOrCreateDurableEventLogEntry(ctx context.Context, db DBTX, arg GetOrCreateDurableEventLogEntryParams) (*GetOrCreateDurableEventLogEntryRow, error) {
	row := db.QueryRow(ctx, getOrCreateDurableEventLogEntry,
		arg.Tenantid,
		arg.Externalid,
		arg.Durabletaskid,
		arg.Durabletaskinsertedat,
		arg.Insertedat,
		arg.Kind,
		arg.Nodeid,
		arg.ParentNodeId,
		arg.Branchid,
		arg.Datahash,
		arg.Datahashalg,
	)
	var i GetOrCreateDurableEventLogEntryRow
	err := row.Scan(
		&i.TenantID,
		&i.ExternalID,
		&i.InsertedAt,
		&i.ID,
		&i.DurableTaskID,
		&i.DurableTaskInsertedAt,
		&i.Kind,
		&i.NodeID,
		&i.ParentNodeID,
		&i.BranchID,
		&i.DataHash,
		&i.DataHashAlg,
		&i.AlreadyExists,
	)
	return &i, err
}

const getOrCreateDurableEventLogFile = `-- name: GetOrCreateDurableEventLogFile :one
WITH to_insert AS (
    SELECT
        $1::UUID AS tenant_id,
        $2::BIGINT AS durable_task_id,
        $3::TIMESTAMPTZ AS durable_task_inserted_at,
        $4::TIMESTAMPTZ AS latest_inserted_at,
        $5::BIGINT AS latest_node_id,
        $6::BIGINT AS latest_branch_id,
        $7::BIGINT AS latest_branch_first_parent_node_id
), ins AS (
    INSERT INTO v1_durable_event_log_file (
        tenant_id,
        durable_task_id,
        durable_task_inserted_at,
        latest_inserted_at,
        latest_node_id,
        latest_branch_id,
        latest_branch_first_parent_node_id
    )
    SELECT
        tenant_id,
        durable_task_id,
        durable_task_inserted_at,
        latest_inserted_at,
        latest_node_id,
        latest_branch_id,
        latest_branch_first_parent_node_id
    FROM to_insert
    ON CONFLICT (durable_task_id, durable_task_inserted_at) DO NOTHING
)

SELECT
    tenant_id, durable_task_id, durable_task_inserted_at, latest_inserted_at, latest_node_id, latest_branch_id, latest_branch_first_parent_node_id,
    (SELECT COUNT(*) FROM ins) = 0 AS already_exists
FROM to_insert
`

type GetOrCreateDurableEventLogFileParams struct {
	Tenantid                      uuid.UUID          `json:"tenantid"`
	Durabletaskid                 int64              `json:"durabletaskid"`
	Durabletaskinsertedat         pgtype.Timestamptz `json:"durabletaskinsertedat"`
	Latestinsertedat              pgtype.Timestamptz `json:"latestinsertedat"`
	Latestnodeid                  int64              `json:"latestnodeid"`
	Latestbranchid                int64              `json:"latestbranchid"`
	Latestbranchfirstparentnodeid int64              `json:"latestbranchfirstparentnodeid"`
}

type GetOrCreateDurableEventLogFileRow struct {
	TenantID                      uuid.UUID          `json:"tenant_id"`
	DurableTaskID                 int64              `json:"durable_task_id"`
	DurableTaskInsertedAt         pgtype.Timestamptz `json:"durable_task_inserted_at"`
	LatestInsertedAt              pgtype.Timestamptz `json:"latest_inserted_at"`
	LatestNodeID                  int64              `json:"latest_node_id"`
	LatestBranchID                int64              `json:"latest_branch_id"`
	LatestBranchFirstParentNodeID int64              `json:"latest_branch_first_parent_node_id"`
	AlreadyExists                 bool               `json:"already_exists"`
}

func (q *Queries) GetOrCreateDurableEventLogFile(ctx context.Context, db DBTX, arg GetOrCreateDurableEventLogFileParams) (*GetOrCreateDurableEventLogFileRow, error) {
	row := db.QueryRow(ctx, getOrCreateDurableEventLogFile,
		arg.Tenantid,
		arg.Durabletaskid,
		arg.Durabletaskinsertedat,
		arg.Latestinsertedat,
		arg.Latestnodeid,
		arg.Latestbranchid,
		arg.Latestbranchfirstparentnodeid,
	)
	var i GetOrCreateDurableEventLogFileRow
	err := row.Scan(
		&i.TenantID,
		&i.DurableTaskID,
		&i.DurableTaskInsertedAt,
		&i.LatestInsertedAt,
		&i.LatestNodeID,
		&i.LatestBranchID,
		&i.LatestBranchFirstParentNodeID,
		&i.AlreadyExists,
	)
	return &i, err
}

const listDurableEventLogCallbacks = `-- name: ListDurableEventLogCallbacks :many
SELECT tenant_id, external_id, inserted_at, id, durable_task_id, durable_task_inserted_at, kind, node_id, is_satisfied, dispatcher_id
FROM v1_durable_event_log_callback
WHERE durable_task_id = $1::BIGINT
  AND durable_task_inserted_at = $2::TIMESTAMPTZ
ORDER BY inserted_at ASC
`

type ListDurableEventLogCallbacksParams struct {
	Durabletaskid         int64              `json:"durabletaskid"`
	Durabletaskinsertedat pgtype.Timestamptz `json:"durabletaskinsertedat"`
}

func (q *Queries) ListDurableEventLogCallbacks(ctx context.Context, db DBTX, arg ListDurableEventLogCallbacksParams) ([]*V1DurableEventLogCallback, error) {
	rows, err := db.Query(ctx, listDurableEventLogCallbacks, arg.Durabletaskid, arg.Durabletaskinsertedat)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V1DurableEventLogCallback
	for rows.Next() {
		var i V1DurableEventLogCallback
		if err := rows.Scan(
			&i.TenantID,
			&i.ExternalID,
			&i.InsertedAt,
			&i.ID,
			&i.DurableTaskID,
			&i.DurableTaskInsertedAt,
			&i.Kind,
			&i.NodeID,
			&i.IsSatisfied,
			&i.DispatcherID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDurableEventLogEntries = `-- name: ListDurableEventLogEntries :many
SELECT tenant_id, external_id, inserted_at, id, durable_task_id, durable_task_inserted_at, kind, node_id, parent_node_id, branch_id, data_hash, data_hash_alg
FROM v1_durable_event_log_entry
WHERE durable_task_id = $1::BIGINT
  AND durable_task_inserted_at = $2::TIMESTAMPTZ
ORDER BY node_id ASC
`

type ListDurableEventLogEntriesParams struct {
	Durabletaskid         int64              `json:"durabletaskid"`
	Durabletaskinsertedat pgtype.Timestamptz `json:"durabletaskinsertedat"`
}

func (q *Queries) ListDurableEventLogEntries(ctx context.Context, db DBTX, arg ListDurableEventLogEntriesParams) ([]*V1DurableEventLogEntry, error) {
	rows, err := db.Query(ctx, listDurableEventLogEntries, arg.Durabletaskid, arg.Durabletaskinsertedat)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V1DurableEventLogEntry
	for rows.Next() {
		var i V1DurableEventLogEntry
		if err := rows.Scan(
			&i.TenantID,
			&i.ExternalID,
			&i.InsertedAt,
			&i.ID,
			&i.DurableTaskID,
			&i.DurableTaskInsertedAt,
			&i.Kind,
			&i.NodeID,
			&i.ParentNodeID,
			&i.BranchID,
			&i.DataHash,
			&i.DataHashAlg,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDurableEventLogCallbackSatisfied = `-- name: UpdateDurableEventLogCallbackSatisfied :one
UPDATE v1_durable_event_log_callback
SET is_satisfied = $1::BOOLEAN
WHERE durable_task_id = $2::BIGINT
  AND durable_task_inserted_at = $3::TIMESTAMPTZ
  AND node_id = $4::BIGINT
RETURNING tenant_id, external_id, inserted_at, id, durable_task_id, durable_task_inserted_at, kind, node_id, is_satisfied, dispatcher_id
`

type UpdateDurableEventLogCallbackSatisfiedParams struct {
	Issatisfied           bool               `json:"issatisfied"`
	Durabletaskid         int64              `json:"durabletaskid"`
	Durabletaskinsertedat pgtype.Timestamptz `json:"durabletaskinsertedat"`
	Nodeid                int64              `json:"nodeid"`
}

func (q *Queries) UpdateDurableEventLogCallbackSatisfied(ctx context.Context, db DBTX, arg UpdateDurableEventLogCallbackSatisfiedParams) (*V1DurableEventLogCallback, error) {
	row := db.QueryRow(ctx, updateDurableEventLogCallbackSatisfied,
		arg.Issatisfied,
		arg.Durabletaskid,
		arg.Durabletaskinsertedat,
		arg.Nodeid,
	)
	var i V1DurableEventLogCallback
	err := row.Scan(
		&i.TenantID,
		&i.ExternalID,
		&i.InsertedAt,
		&i.ID,
		&i.DurableTaskID,
		&i.DurableTaskInsertedAt,
		&i.Kind,
		&i.NodeID,
		&i.IsSatisfied,
		&i.DispatcherID,
	)
	return &i, err
}
