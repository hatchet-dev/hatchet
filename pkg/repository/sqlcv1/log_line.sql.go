// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: log_line.sql

package sqlcv1

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type InsertLogLineParams struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	TaskID         int64              `json:"task_id"`
	TaskInsertedAt pgtype.Timestamptz `json:"task_inserted_at"`
	Message        string             `json:"message"`
	Metadata       []byte             `json:"metadata"`
	RetryCount     int32              `json:"retry_count"`
	Level          V1LogLineLevel     `json:"level"`
}

const listLogLines = `-- name: ListLogLines :many
SELECT
    id, created_at, tenant_id, task_id, task_inserted_at, message, level, metadata, retry_count
FROM
    v1_log_line l
WHERE
    l.tenant_id = $1::UUID
    AND l.task_id = $2::BIGINT
    AND l.task_inserted_at = $3::TIMESTAMPTZ
    AND ($4::TEXT IS NULL OR l.message ILIKE CONCAT('%', $4::TEXT, '%'))
    AND ($5::TIMESTAMPTZ IS NULL OR l.created_at > $5::TIMESTAMPTZ)
    AND ($6::TIMESTAMPTZ IS NULL OR l.created_at < $6::TIMESTAMPTZ)
    AND ($7::v1_log_line_level[] IS NULL OR l.level = ANY($7::v1_log_line_level[]))
    AND ($8::INTEGER IS NULL OR l.retry_count = ($8::INTEGER - 1))
ORDER BY
    CASE WHEN $9::TEXT = 'DESC' THEN l.created_at END DESC,
    CASE WHEN $9::TEXT = 'ASC' THEN l.created_at END ASC
LIMIT COALESCE($11::BIGINT, 1000)
OFFSET COALESCE($10::BIGINT, 0)
`

type ListLogLinesParams struct {
	Tenantid         pgtype.UUID        `json:"tenantid"`
	Taskid           int64              `json:"taskid"`
	Taskinsertedat   pgtype.Timestamptz `json:"taskinsertedat"`
	Search           pgtype.Text        `json:"search"`
	Since            pgtype.Timestamptz `json:"since"`
	Until            pgtype.Timestamptz `json:"until"`
	Levels           []V1LogLineLevel   `json:"levels"`
	Attempt          pgtype.Int4        `json:"attempt"`
	Orderbydirection string             `json:"orderbydirection"`
	Offset           pgtype.Int8        `json:"offset"`
	Limit            pgtype.Int8        `json:"limit"`
}

func (q *Queries) ListLogLines(ctx context.Context, db DBTX, arg ListLogLinesParams) ([]*V1LogLine, error) {
	rows, err := db.Query(ctx, listLogLines,
		arg.Tenantid,
		arg.Taskid,
		arg.Taskinsertedat,
		arg.Search,
		arg.Since,
		arg.Until,
		arg.Levels,
		arg.Attempt,
		arg.Orderbydirection,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V1LogLine
	for rows.Next() {
		var i V1LogLine
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.TenantID,
			&i.TaskID,
			&i.TaskInsertedAt,
			&i.Message,
			&i.Level,
			&i.Metadata,
			&i.RetryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
