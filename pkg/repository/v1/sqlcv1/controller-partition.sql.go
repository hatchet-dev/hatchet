// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: controller-partition.sql

package sqlcv1

import (
	"context"
)

const v1ListTenantsByControllerPartitionId = `-- name: V1ListTenantsByControllerPartitionId :many
SELECT
    id, "createdAt", "updatedAt", "deletedAt", version, "uiVersion", name, slug, "analyticsOptOut", "alertMemberEmails", "controllerPartitionId", "workerPartitionId", "dataRetentionPeriod", "schedulerPartitionId", "canUpgradeV1"
FROM
    "Tenant" as tenants
WHERE
    "controllerPartitionId" = $1::text
    AND "version" = 'V1'::"TenantMajorEngineVersion"
    AND (
        $2::boolean = false
        OR (
            (
                $3::boolean = false
                OR EXISTS (
                    SELECT 1
                    FROM v1_task_runtime vtr
                    WHERE vtr.tenant_id = tenants.id
                        AND vtr.timeout_at <= NOW() + INTERVAL '5 seconds' -- NOTE: this is a 5 second buffer to "look ahead" to account for poll interval
                )
            )
            AND (
                $4::boolean = false
                OR EXISTS (
                    SELECT 1
                    FROM v1_durable_sleep vds
                    WHERE vds.tenant_id = tenants.id
                        AND vds.sleep_until <= CURRENT_TIMESTAMP + INTERVAL '5 seconds' -- NOTE: this is a 5 second buffer to "look ahead" to account for poll interval
                )
            )
            AND (
                $5::boolean = false
                OR EXISTS (
                    SELECT 1
                    FROM v1_retry_queue_item rqi
                    WHERE rqi.tenant_id = tenants.id
                        AND rqi.retry_after <= NOW() + INTERVAL '5 seconds' -- NOTE: this is a 5 second buffer to "look ahead" to account for poll interval
                    ORDER BY
                        rqi.task_id, rqi.task_inserted_at, rqi.task_retry_count
                )
            )
            AND (
                $6::boolean = false
                OR EXISTS (
                    SELECT 1
                    FROM "Worker" w
                    JOIN  v1_task_runtime runtime ON w."id" = runtime.worker_id
                    WHERE w."tenantId" = tenants.id
                        AND w."lastHeartbeatAt" < NOW() - INTERVAL '30 seconds' -- NOTE: this is 30 seconds should match the heartbeat check
                )
            )
        )
    )
`

type V1ListTenantsByControllerPartitionIdParams struct {
	ControllerPartitionId string `json:"controllerPartitionId"`
	WithFilter            bool   `json:"withFilter"`
	WithTimeoutTasks      bool   `json:"withTimeoutTasks"`
	WithExpiredSleeps     bool   `json:"withExpiredSleeps"`
	WithRetryQueueItems   bool   `json:"withRetryQueueItems"`
	WithReassignTasks     bool   `json:"withReassignTasks"`
}

func (q *Queries) V1ListTenantsByControllerPartitionId(ctx context.Context, db DBTX, arg V1ListTenantsByControllerPartitionIdParams) ([]*Tenant, error) {
	rows, err := db.Query(ctx, v1ListTenantsByControllerPartitionId,
		arg.ControllerPartitionId,
		arg.WithFilter,
		arg.WithTimeoutTasks,
		arg.WithExpiredSleeps,
		arg.WithRetryQueueItems,
		arg.WithReassignTasks,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Tenant
	for rows.Next() {
		var i Tenant
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Version,
			&i.UiVersion,
			&i.Name,
			&i.Slug,
			&i.AnalyticsOptOut,
			&i.AlertMemberEmails,
			&i.ControllerPartitionId,
			&i.WorkerPartitionId,
			&i.DataRetentionPeriod,
			&i.SchedulerPartitionId,
			&i.CanUpgradeV1,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const v1ListTenantsBySchedulerPartitionId = `-- name: V1ListTenantsBySchedulerPartitionId :many
SELECT
    id, "createdAt", "updatedAt", "deletedAt", version, "uiVersion", name, slug, "analyticsOptOut", "alertMemberEmails", "controllerPartitionId", "workerPartitionId", "dataRetentionPeriod", "schedulerPartitionId", "canUpgradeV1"
FROM
    "Tenant" as tenants
WHERE
    "schedulerPartitionId" = $1::text
    AND "version" = 'V1'::"TenantMajorEngineVersion"
    AND (
        $2::boolean = false
        OR (
            EXISTS (
                SELECT 1
                FROM v1_queue_item vqi
                WHERE vqi.tenant_id = tenants.id
            )
            AND EXISTS (
                 SELECT 1
                 FROM "Worker" w
                 WHERE w."tenantId" = tenants.id
                     AND w."lastHeartbeatAt" >= NOW() - INTERVAL '30 seconds'
             )
        )
    )
`

type V1ListTenantsBySchedulerPartitionIdParams struct {
	SchedulerPartitionId string `json:"schedulerPartitionId"`
	WithFilter           bool   `json:"withFilter"`
}

func (q *Queries) V1ListTenantsBySchedulerPartitionId(ctx context.Context, db DBTX, arg V1ListTenantsBySchedulerPartitionIdParams) ([]*Tenant, error) {
	rows, err := db.Query(ctx, v1ListTenantsBySchedulerPartitionId, arg.SchedulerPartitionId, arg.WithFilter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Tenant
	for rows.Next() {
		var i Tenant
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Version,
			&i.UiVersion,
			&i.Name,
			&i.Slug,
			&i.AnalyticsOptOut,
			&i.AlertMemberEmails,
			&i.ControllerPartitionId,
			&i.WorkerPartitionId,
			&i.DataRetentionPeriod,
			&i.SchedulerPartitionId,
			&i.CanUpgradeV1,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
