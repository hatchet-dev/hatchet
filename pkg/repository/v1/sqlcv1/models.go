// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0

package sqlcv1

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type ConcurrencyLimitStrategy string

const (
	ConcurrencyLimitStrategyCANCELINPROGRESS ConcurrencyLimitStrategy = "CANCEL_IN_PROGRESS"
	ConcurrencyLimitStrategyDROPNEWEST       ConcurrencyLimitStrategy = "DROP_NEWEST"
	ConcurrencyLimitStrategyQUEUENEWEST      ConcurrencyLimitStrategy = "QUEUE_NEWEST"
	ConcurrencyLimitStrategyGROUPROUNDROBIN  ConcurrencyLimitStrategy = "GROUP_ROUND_ROBIN"
	ConcurrencyLimitStrategyCANCELNEWEST     ConcurrencyLimitStrategy = "CANCEL_NEWEST"
)

func (e *ConcurrencyLimitStrategy) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ConcurrencyLimitStrategy(s)
	case string:
		*e = ConcurrencyLimitStrategy(s)
	default:
		return fmt.Errorf("unsupported scan type for ConcurrencyLimitStrategy: %T", src)
	}
	return nil
}

type NullConcurrencyLimitStrategy struct {
	ConcurrencyLimitStrategy ConcurrencyLimitStrategy `json:"ConcurrencyLimitStrategy"`
	Valid                    bool                     `json:"valid"` // Valid is true if ConcurrencyLimitStrategy is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullConcurrencyLimitStrategy) Scan(value interface{}) error {
	if value == nil {
		ns.ConcurrencyLimitStrategy, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ConcurrencyLimitStrategy.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullConcurrencyLimitStrategy) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ConcurrencyLimitStrategy), nil
}

type InternalQueue string

const (
	InternalQueueWORKERSEMAPHORECOUNT InternalQueue = "WORKER_SEMAPHORE_COUNT"
	InternalQueueSTEPRUNUPDATE        InternalQueue = "STEP_RUN_UPDATE"
	InternalQueueWORKFLOWRUNUPDATE    InternalQueue = "WORKFLOW_RUN_UPDATE"
	InternalQueueWORKFLOWRUNPAUSED    InternalQueue = "WORKFLOW_RUN_PAUSED"
	InternalQueueSTEPRUNUPDATEV2      InternalQueue = "STEP_RUN_UPDATE_V2"
)

func (e *InternalQueue) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InternalQueue(s)
	case string:
		*e = InternalQueue(s)
	default:
		return fmt.Errorf("unsupported scan type for InternalQueue: %T", src)
	}
	return nil
}

type NullInternalQueue struct {
	InternalQueue InternalQueue `json:"InternalQueue"`
	Valid         bool          `json:"valid"` // Valid is true if InternalQueue is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInternalQueue) Scan(value interface{}) error {
	if value == nil {
		ns.InternalQueue, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InternalQueue.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInternalQueue) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InternalQueue), nil
}

type InviteLinkStatus string

const (
	InviteLinkStatusPENDING  InviteLinkStatus = "PENDING"
	InviteLinkStatusACCEPTED InviteLinkStatus = "ACCEPTED"
	InviteLinkStatusREJECTED InviteLinkStatus = "REJECTED"
)

func (e *InviteLinkStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InviteLinkStatus(s)
	case string:
		*e = InviteLinkStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for InviteLinkStatus: %T", src)
	}
	return nil
}

type NullInviteLinkStatus struct {
	InviteLinkStatus InviteLinkStatus `json:"InviteLinkStatus"`
	Valid            bool             `json:"valid"` // Valid is true if InviteLinkStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInviteLinkStatus) Scan(value interface{}) error {
	if value == nil {
		ns.InviteLinkStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InviteLinkStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInviteLinkStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InviteLinkStatus), nil
}

type JobKind string

const (
	JobKindDEFAULT   JobKind = "DEFAULT"
	JobKindONFAILURE JobKind = "ON_FAILURE"
)

func (e *JobKind) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = JobKind(s)
	case string:
		*e = JobKind(s)
	default:
		return fmt.Errorf("unsupported scan type for JobKind: %T", src)
	}
	return nil
}

type NullJobKind struct {
	JobKind JobKind `json:"JobKind"`
	Valid   bool    `json:"valid"` // Valid is true if JobKind is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullJobKind) Scan(value interface{}) error {
	if value == nil {
		ns.JobKind, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.JobKind.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullJobKind) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.JobKind), nil
}

type JobRunStatus string

const (
	JobRunStatusPENDING   JobRunStatus = "PENDING"
	JobRunStatusRUNNING   JobRunStatus = "RUNNING"
	JobRunStatusSUCCEEDED JobRunStatus = "SUCCEEDED"
	JobRunStatusFAILED    JobRunStatus = "FAILED"
	JobRunStatusCANCELLED JobRunStatus = "CANCELLED"
	JobRunStatusBACKOFF   JobRunStatus = "BACKOFF"
)

func (e *JobRunStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = JobRunStatus(s)
	case string:
		*e = JobRunStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for JobRunStatus: %T", src)
	}
	return nil
}

type NullJobRunStatus struct {
	JobRunStatus JobRunStatus `json:"JobRunStatus"`
	Valid        bool         `json:"valid"` // Valid is true if JobRunStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullJobRunStatus) Scan(value interface{}) error {
	if value == nil {
		ns.JobRunStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.JobRunStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullJobRunStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.JobRunStatus), nil
}

type LeaseKind string

const (
	LeaseKindWORKER              LeaseKind = "WORKER"
	LeaseKindQUEUE               LeaseKind = "QUEUE"
	LeaseKindCONCURRENCYSTRATEGY LeaseKind = "CONCURRENCY_STRATEGY"
)

func (e *LeaseKind) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LeaseKind(s)
	case string:
		*e = LeaseKind(s)
	default:
		return fmt.Errorf("unsupported scan type for LeaseKind: %T", src)
	}
	return nil
}

type NullLeaseKind struct {
	LeaseKind LeaseKind `json:"LeaseKind"`
	Valid     bool      `json:"valid"` // Valid is true if LeaseKind is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLeaseKind) Scan(value interface{}) error {
	if value == nil {
		ns.LeaseKind, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LeaseKind.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLeaseKind) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LeaseKind), nil
}

type LimitResource string

const (
	LimitResourceWORKFLOWRUN LimitResource = "WORKFLOW_RUN"
	LimitResourceEVENT       LimitResource = "EVENT"
	LimitResourceWORKER      LimitResource = "WORKER"
	LimitResourceCRON        LimitResource = "CRON"
	LimitResourceSCHEDULE    LimitResource = "SCHEDULE"
)

func (e *LimitResource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LimitResource(s)
	case string:
		*e = LimitResource(s)
	default:
		return fmt.Errorf("unsupported scan type for LimitResource: %T", src)
	}
	return nil
}

type NullLimitResource struct {
	LimitResource LimitResource `json:"LimitResource"`
	Valid         bool          `json:"valid"` // Valid is true if LimitResource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLimitResource) Scan(value interface{}) error {
	if value == nil {
		ns.LimitResource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LimitResource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLimitResource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LimitResource), nil
}

type LogLineLevel string

const (
	LogLineLevelDEBUG LogLineLevel = "DEBUG"
	LogLineLevelINFO  LogLineLevel = "INFO"
	LogLineLevelWARN  LogLineLevel = "WARN"
	LogLineLevelERROR LogLineLevel = "ERROR"
)

func (e *LogLineLevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LogLineLevel(s)
	case string:
		*e = LogLineLevel(s)
	default:
		return fmt.Errorf("unsupported scan type for LogLineLevel: %T", src)
	}
	return nil
}

type NullLogLineLevel struct {
	LogLineLevel LogLineLevel `json:"LogLineLevel"`
	Valid        bool         `json:"valid"` // Valid is true if LogLineLevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLogLineLevel) Scan(value interface{}) error {
	if value == nil {
		ns.LogLineLevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LogLineLevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLogLineLevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LogLineLevel), nil
}

type MessageQueueItemStatus string

const (
	MessageQueueItemStatusPENDING  MessageQueueItemStatus = "PENDING"
	MessageQueueItemStatusASSIGNED MessageQueueItemStatus = "ASSIGNED"
)

func (e *MessageQueueItemStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MessageQueueItemStatus(s)
	case string:
		*e = MessageQueueItemStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for MessageQueueItemStatus: %T", src)
	}
	return nil
}

type NullMessageQueueItemStatus struct {
	MessageQueueItemStatus MessageQueueItemStatus `json:"MessageQueueItemStatus"`
	Valid                  bool                   `json:"valid"` // Valid is true if MessageQueueItemStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMessageQueueItemStatus) Scan(value interface{}) error {
	if value == nil {
		ns.MessageQueueItemStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MessageQueueItemStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMessageQueueItemStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MessageQueueItemStatus), nil
}

type StepExpressionKind string

const (
	StepExpressionKindDYNAMICRATELIMITKEY    StepExpressionKind = "DYNAMIC_RATE_LIMIT_KEY"
	StepExpressionKindDYNAMICRATELIMITVALUE  StepExpressionKind = "DYNAMIC_RATE_LIMIT_VALUE"
	StepExpressionKindDYNAMICRATELIMITUNITS  StepExpressionKind = "DYNAMIC_RATE_LIMIT_UNITS"
	StepExpressionKindDYNAMICRATELIMITWINDOW StepExpressionKind = "DYNAMIC_RATE_LIMIT_WINDOW"
)

func (e *StepExpressionKind) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StepExpressionKind(s)
	case string:
		*e = StepExpressionKind(s)
	default:
		return fmt.Errorf("unsupported scan type for StepExpressionKind: %T", src)
	}
	return nil
}

type NullStepExpressionKind struct {
	StepExpressionKind StepExpressionKind `json:"StepExpressionKind"`
	Valid              bool               `json:"valid"` // Valid is true if StepExpressionKind is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStepExpressionKind) Scan(value interface{}) error {
	if value == nil {
		ns.StepExpressionKind, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StepExpressionKind.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStepExpressionKind) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StepExpressionKind), nil
}

type StepRateLimitKind string

const (
	StepRateLimitKindSTATIC  StepRateLimitKind = "STATIC"
	StepRateLimitKindDYNAMIC StepRateLimitKind = "DYNAMIC"
)

func (e *StepRateLimitKind) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StepRateLimitKind(s)
	case string:
		*e = StepRateLimitKind(s)
	default:
		return fmt.Errorf("unsupported scan type for StepRateLimitKind: %T", src)
	}
	return nil
}

type NullStepRateLimitKind struct {
	StepRateLimitKind StepRateLimitKind `json:"StepRateLimitKind"`
	Valid             bool              `json:"valid"` // Valid is true if StepRateLimitKind is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStepRateLimitKind) Scan(value interface{}) error {
	if value == nil {
		ns.StepRateLimitKind, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StepRateLimitKind.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStepRateLimitKind) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StepRateLimitKind), nil
}

type StepRunEventReason string

const (
	StepRunEventReasonREQUEUEDNOWORKER             StepRunEventReason = "REQUEUED_NO_WORKER"
	StepRunEventReasonREQUEUEDRATELIMIT            StepRunEventReason = "REQUEUED_RATE_LIMIT"
	StepRunEventReasonSCHEDULINGTIMEDOUT           StepRunEventReason = "SCHEDULING_TIMED_OUT"
	StepRunEventReasonASSIGNED                     StepRunEventReason = "ASSIGNED"
	StepRunEventReasonSTARTED                      StepRunEventReason = "STARTED"
	StepRunEventReasonFINISHED                     StepRunEventReason = "FINISHED"
	StepRunEventReasonFAILED                       StepRunEventReason = "FAILED"
	StepRunEventReasonRETRYING                     StepRunEventReason = "RETRYING"
	StepRunEventReasonCANCELLED                    StepRunEventReason = "CANCELLED"
	StepRunEventReasonTIMEDOUT                     StepRunEventReason = "TIMED_OUT"
	StepRunEventReasonREASSIGNED                   StepRunEventReason = "REASSIGNED"
	StepRunEventReasonSLOTRELEASED                 StepRunEventReason = "SLOT_RELEASED"
	StepRunEventReasonTIMEOUTREFRESHED             StepRunEventReason = "TIMEOUT_REFRESHED"
	StepRunEventReasonRETRIEDBYUSER                StepRunEventReason = "RETRIED_BY_USER"
	StepRunEventReasonSENTTOWORKER                 StepRunEventReason = "SENT_TO_WORKER"
	StepRunEventReasonWORKFLOWRUNGROUPKEYSUCCEEDED StepRunEventReason = "WORKFLOW_RUN_GROUP_KEY_SUCCEEDED"
	StepRunEventReasonWORKFLOWRUNGROUPKEYFAILED    StepRunEventReason = "WORKFLOW_RUN_GROUP_KEY_FAILED"
	StepRunEventReasonRATELIMITERROR               StepRunEventReason = "RATE_LIMIT_ERROR"
	StepRunEventReasonACKNOWLEDGED                 StepRunEventReason = "ACKNOWLEDGED"
)

func (e *StepRunEventReason) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StepRunEventReason(s)
	case string:
		*e = StepRunEventReason(s)
	default:
		return fmt.Errorf("unsupported scan type for StepRunEventReason: %T", src)
	}
	return nil
}

type NullStepRunEventReason struct {
	StepRunEventReason StepRunEventReason `json:"StepRunEventReason"`
	Valid              bool               `json:"valid"` // Valid is true if StepRunEventReason is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStepRunEventReason) Scan(value interface{}) error {
	if value == nil {
		ns.StepRunEventReason, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StepRunEventReason.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStepRunEventReason) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StepRunEventReason), nil
}

type StepRunEventSeverity string

const (
	StepRunEventSeverityINFO     StepRunEventSeverity = "INFO"
	StepRunEventSeverityWARNING  StepRunEventSeverity = "WARNING"
	StepRunEventSeverityCRITICAL StepRunEventSeverity = "CRITICAL"
)

func (e *StepRunEventSeverity) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StepRunEventSeverity(s)
	case string:
		*e = StepRunEventSeverity(s)
	default:
		return fmt.Errorf("unsupported scan type for StepRunEventSeverity: %T", src)
	}
	return nil
}

type NullStepRunEventSeverity struct {
	StepRunEventSeverity StepRunEventSeverity `json:"StepRunEventSeverity"`
	Valid                bool                 `json:"valid"` // Valid is true if StepRunEventSeverity is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStepRunEventSeverity) Scan(value interface{}) error {
	if value == nil {
		ns.StepRunEventSeverity, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StepRunEventSeverity.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStepRunEventSeverity) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StepRunEventSeverity), nil
}

type StepRunStatus string

const (
	StepRunStatusPENDING           StepRunStatus = "PENDING"
	StepRunStatusPENDINGASSIGNMENT StepRunStatus = "PENDING_ASSIGNMENT"
	StepRunStatusASSIGNED          StepRunStatus = "ASSIGNED"
	StepRunStatusRUNNING           StepRunStatus = "RUNNING"
	StepRunStatusSUCCEEDED         StepRunStatus = "SUCCEEDED"
	StepRunStatusFAILED            StepRunStatus = "FAILED"
	StepRunStatusCANCELLED         StepRunStatus = "CANCELLED"
	StepRunStatusCANCELLING        StepRunStatus = "CANCELLING"
	StepRunStatusBACKOFF           StepRunStatus = "BACKOFF"
)

func (e *StepRunStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StepRunStatus(s)
	case string:
		*e = StepRunStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for StepRunStatus: %T", src)
	}
	return nil
}

type NullStepRunStatus struct {
	StepRunStatus StepRunStatus `json:"StepRunStatus"`
	Valid         bool          `json:"valid"` // Valid is true if StepRunStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStepRunStatus) Scan(value interface{}) error {
	if value == nil {
		ns.StepRunStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StepRunStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStepRunStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StepRunStatus), nil
}

type StickyStrategy string

const (
	StickyStrategySOFT StickyStrategy = "SOFT"
	StickyStrategyHARD StickyStrategy = "HARD"
)

func (e *StickyStrategy) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StickyStrategy(s)
	case string:
		*e = StickyStrategy(s)
	default:
		return fmt.Errorf("unsupported scan type for StickyStrategy: %T", src)
	}
	return nil
}

type NullStickyStrategy struct {
	StickyStrategy StickyStrategy `json:"StickyStrategy"`
	Valid          bool           `json:"valid"` // Valid is true if StickyStrategy is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStickyStrategy) Scan(value interface{}) error {
	if value == nil {
		ns.StickyStrategy, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StickyStrategy.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStickyStrategy) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StickyStrategy), nil
}

type TenantMajorEngineVersion string

const (
	TenantMajorEngineVersionV0 TenantMajorEngineVersion = "V0"
	TenantMajorEngineVersionV1 TenantMajorEngineVersion = "V1"
)

func (e *TenantMajorEngineVersion) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TenantMajorEngineVersion(s)
	case string:
		*e = TenantMajorEngineVersion(s)
	default:
		return fmt.Errorf("unsupported scan type for TenantMajorEngineVersion: %T", src)
	}
	return nil
}

type NullTenantMajorEngineVersion struct {
	TenantMajorEngineVersion TenantMajorEngineVersion `json:"TenantMajorEngineVersion"`
	Valid                    bool                     `json:"valid"` // Valid is true if TenantMajorEngineVersion is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTenantMajorEngineVersion) Scan(value interface{}) error {
	if value == nil {
		ns.TenantMajorEngineVersion, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TenantMajorEngineVersion.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTenantMajorEngineVersion) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TenantMajorEngineVersion), nil
}

type TenantMemberRole string

const (
	TenantMemberRoleOWNER  TenantMemberRole = "OWNER"
	TenantMemberRoleADMIN  TenantMemberRole = "ADMIN"
	TenantMemberRoleMEMBER TenantMemberRole = "MEMBER"
)

func (e *TenantMemberRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TenantMemberRole(s)
	case string:
		*e = TenantMemberRole(s)
	default:
		return fmt.Errorf("unsupported scan type for TenantMemberRole: %T", src)
	}
	return nil
}

type NullTenantMemberRole struct {
	TenantMemberRole TenantMemberRole `json:"TenantMemberRole"`
	Valid            bool             `json:"valid"` // Valid is true if TenantMemberRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTenantMemberRole) Scan(value interface{}) error {
	if value == nil {
		ns.TenantMemberRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TenantMemberRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTenantMemberRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TenantMemberRole), nil
}

type TenantResourceLimitAlertType string

const (
	TenantResourceLimitAlertTypeAlarm     TenantResourceLimitAlertType = "Alarm"
	TenantResourceLimitAlertTypeExhausted TenantResourceLimitAlertType = "Exhausted"
)

func (e *TenantResourceLimitAlertType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TenantResourceLimitAlertType(s)
	case string:
		*e = TenantResourceLimitAlertType(s)
	default:
		return fmt.Errorf("unsupported scan type for TenantResourceLimitAlertType: %T", src)
	}
	return nil
}

type NullTenantResourceLimitAlertType struct {
	TenantResourceLimitAlertType TenantResourceLimitAlertType `json:"TenantResourceLimitAlertType"`
	Valid                        bool                         `json:"valid"` // Valid is true if TenantResourceLimitAlertType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTenantResourceLimitAlertType) Scan(value interface{}) error {
	if value == nil {
		ns.TenantResourceLimitAlertType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TenantResourceLimitAlertType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTenantResourceLimitAlertType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TenantResourceLimitAlertType), nil
}

type V1ConcurrencyStrategy string

const (
	V1ConcurrencyStrategyNONE             V1ConcurrencyStrategy = "NONE"
	V1ConcurrencyStrategyGROUPROUNDROBIN  V1ConcurrencyStrategy = "GROUP_ROUND_ROBIN"
	V1ConcurrencyStrategyCANCELINPROGRESS V1ConcurrencyStrategy = "CANCEL_IN_PROGRESS"
	V1ConcurrencyStrategyCANCELNEWEST     V1ConcurrencyStrategy = "CANCEL_NEWEST"
)

func (e *V1ConcurrencyStrategy) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V1ConcurrencyStrategy(s)
	case string:
		*e = V1ConcurrencyStrategy(s)
	default:
		return fmt.Errorf("unsupported scan type for V1ConcurrencyStrategy: %T", src)
	}
	return nil
}

type NullV1ConcurrencyStrategy struct {
	V1ConcurrencyStrategy V1ConcurrencyStrategy `json:"v1_concurrency_strategy"`
	Valid                 bool                  `json:"valid"` // Valid is true if V1ConcurrencyStrategy is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV1ConcurrencyStrategy) Scan(value interface{}) error {
	if value == nil {
		ns.V1ConcurrencyStrategy, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V1ConcurrencyStrategy.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV1ConcurrencyStrategy) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V1ConcurrencyStrategy), nil
}

type V1EventType string

const (
	V1EventTypeUSER     V1EventType = "USER"
	V1EventTypeINTERNAL V1EventType = "INTERNAL"
)

func (e *V1EventType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V1EventType(s)
	case string:
		*e = V1EventType(s)
	default:
		return fmt.Errorf("unsupported scan type for V1EventType: %T", src)
	}
	return nil
}

type NullV1EventType struct {
	V1EventType V1EventType `json:"v1_event_type"`
	Valid       bool        `json:"valid"` // Valid is true if V1EventType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV1EventType) Scan(value interface{}) error {
	if value == nil {
		ns.V1EventType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V1EventType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV1EventType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V1EventType), nil
}

type V1EventTypeOlap string

const (
	V1EventTypeOlapRETRYING           V1EventTypeOlap = "RETRYING"
	V1EventTypeOlapREASSIGNED         V1EventTypeOlap = "REASSIGNED"
	V1EventTypeOlapRETRIEDBYUSER      V1EventTypeOlap = "RETRIED_BY_USER"
	V1EventTypeOlapCREATED            V1EventTypeOlap = "CREATED"
	V1EventTypeOlapQUEUED             V1EventTypeOlap = "QUEUED"
	V1EventTypeOlapREQUEUEDNOWORKER   V1EventTypeOlap = "REQUEUED_NO_WORKER"
	V1EventTypeOlapREQUEUEDRATELIMIT  V1EventTypeOlap = "REQUEUED_RATE_LIMIT"
	V1EventTypeOlapASSIGNED           V1EventTypeOlap = "ASSIGNED"
	V1EventTypeOlapACKNOWLEDGED       V1EventTypeOlap = "ACKNOWLEDGED"
	V1EventTypeOlapSENTTOWORKER       V1EventTypeOlap = "SENT_TO_WORKER"
	V1EventTypeOlapSLOTRELEASED       V1EventTypeOlap = "SLOT_RELEASED"
	V1EventTypeOlapSTARTED            V1EventTypeOlap = "STARTED"
	V1EventTypeOlapTIMEOUTREFRESHED   V1EventTypeOlap = "TIMEOUT_REFRESHED"
	V1EventTypeOlapSCHEDULINGTIMEDOUT V1EventTypeOlap = "SCHEDULING_TIMED_OUT"
	V1EventTypeOlapFINISHED           V1EventTypeOlap = "FINISHED"
	V1EventTypeOlapFAILED             V1EventTypeOlap = "FAILED"
	V1EventTypeOlapCANCELLED          V1EventTypeOlap = "CANCELLED"
	V1EventTypeOlapTIMEDOUT           V1EventTypeOlap = "TIMED_OUT"
	V1EventTypeOlapRATELIMITERROR     V1EventTypeOlap = "RATE_LIMIT_ERROR"
	V1EventTypeOlapSKIPPED            V1EventTypeOlap = "SKIPPED"
)

func (e *V1EventTypeOlap) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V1EventTypeOlap(s)
	case string:
		*e = V1EventTypeOlap(s)
	default:
		return fmt.Errorf("unsupported scan type for V1EventTypeOlap: %T", src)
	}
	return nil
}

type NullV1EventTypeOlap struct {
	V1EventTypeOlap V1EventTypeOlap `json:"v1_event_type_olap"`
	Valid           bool            `json:"valid"` // Valid is true if V1EventTypeOlap is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV1EventTypeOlap) Scan(value interface{}) error {
	if value == nil {
		ns.V1EventTypeOlap, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V1EventTypeOlap.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV1EventTypeOlap) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V1EventTypeOlap), nil
}

type V1LogLineLevel string

const (
	V1LogLineLevelDEBUG V1LogLineLevel = "DEBUG"
	V1LogLineLevelINFO  V1LogLineLevel = "INFO"
	V1LogLineLevelWARN  V1LogLineLevel = "WARN"
	V1LogLineLevelERROR V1LogLineLevel = "ERROR"
)

func (e *V1LogLineLevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V1LogLineLevel(s)
	case string:
		*e = V1LogLineLevel(s)
	default:
		return fmt.Errorf("unsupported scan type for V1LogLineLevel: %T", src)
	}
	return nil
}

type NullV1LogLineLevel struct {
	V1LogLineLevel V1LogLineLevel `json:"v1_log_line_level"`
	Valid          bool           `json:"valid"` // Valid is true if V1LogLineLevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV1LogLineLevel) Scan(value interface{}) error {
	if value == nil {
		ns.V1LogLineLevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V1LogLineLevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV1LogLineLevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V1LogLineLevel), nil
}

type V1MatchConditionAction string

const (
	V1MatchConditionActionCREATE      V1MatchConditionAction = "CREATE"
	V1MatchConditionActionQUEUE       V1MatchConditionAction = "QUEUE"
	V1MatchConditionActionCANCEL      V1MatchConditionAction = "CANCEL"
	V1MatchConditionActionSKIP        V1MatchConditionAction = "SKIP"
	V1MatchConditionActionCREATEMATCH V1MatchConditionAction = "CREATE_MATCH"
)

func (e *V1MatchConditionAction) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V1MatchConditionAction(s)
	case string:
		*e = V1MatchConditionAction(s)
	default:
		return fmt.Errorf("unsupported scan type for V1MatchConditionAction: %T", src)
	}
	return nil
}

type NullV1MatchConditionAction struct {
	V1MatchConditionAction V1MatchConditionAction `json:"v1_match_condition_action"`
	Valid                  bool                   `json:"valid"` // Valid is true if V1MatchConditionAction is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV1MatchConditionAction) Scan(value interface{}) error {
	if value == nil {
		ns.V1MatchConditionAction, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V1MatchConditionAction.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV1MatchConditionAction) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V1MatchConditionAction), nil
}

type V1MatchKind string

const (
	V1MatchKindTRIGGER V1MatchKind = "TRIGGER"
	V1MatchKindSIGNAL  V1MatchKind = "SIGNAL"
)

func (e *V1MatchKind) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V1MatchKind(s)
	case string:
		*e = V1MatchKind(s)
	default:
		return fmt.Errorf("unsupported scan type for V1MatchKind: %T", src)
	}
	return nil
}

type NullV1MatchKind struct {
	V1MatchKind V1MatchKind `json:"v1_match_kind"`
	Valid       bool        `json:"valid"` // Valid is true if V1MatchKind is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV1MatchKind) Scan(value interface{}) error {
	if value == nil {
		ns.V1MatchKind, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V1MatchKind.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV1MatchKind) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V1MatchKind), nil
}

type V1ReadableStatusOlap string

const (
	V1ReadableStatusOlapQUEUED    V1ReadableStatusOlap = "QUEUED"
	V1ReadableStatusOlapRUNNING   V1ReadableStatusOlap = "RUNNING"
	V1ReadableStatusOlapCANCELLED V1ReadableStatusOlap = "CANCELLED"
	V1ReadableStatusOlapFAILED    V1ReadableStatusOlap = "FAILED"
	V1ReadableStatusOlapCOMPLETED V1ReadableStatusOlap = "COMPLETED"
)

func (e *V1ReadableStatusOlap) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V1ReadableStatusOlap(s)
	case string:
		*e = V1ReadableStatusOlap(s)
	default:
		return fmt.Errorf("unsupported scan type for V1ReadableStatusOlap: %T", src)
	}
	return nil
}

type NullV1ReadableStatusOlap struct {
	V1ReadableStatusOlap V1ReadableStatusOlap `json:"v1_readable_status_olap"`
	Valid                bool                 `json:"valid"` // Valid is true if V1ReadableStatusOlap is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV1ReadableStatusOlap) Scan(value interface{}) error {
	if value == nil {
		ns.V1ReadableStatusOlap, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V1ReadableStatusOlap.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV1ReadableStatusOlap) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V1ReadableStatusOlap), nil
}

type V1RunKind string

const (
	V1RunKindTASK V1RunKind = "TASK"
	V1RunKindDAG  V1RunKind = "DAG"
)

func (e *V1RunKind) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V1RunKind(s)
	case string:
		*e = V1RunKind(s)
	default:
		return fmt.Errorf("unsupported scan type for V1RunKind: %T", src)
	}
	return nil
}

type NullV1RunKind struct {
	V1RunKind V1RunKind `json:"v1_run_kind"`
	Valid     bool      `json:"valid"` // Valid is true if V1RunKind is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV1RunKind) Scan(value interface{}) error {
	if value == nil {
		ns.V1RunKind, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V1RunKind.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV1RunKind) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V1RunKind), nil
}

type V1StatusKind string

const (
	V1StatusKindTASK V1StatusKind = "TASK"
	V1StatusKindDAG  V1StatusKind = "DAG"
)

func (e *V1StatusKind) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V1StatusKind(s)
	case string:
		*e = V1StatusKind(s)
	default:
		return fmt.Errorf("unsupported scan type for V1StatusKind: %T", src)
	}
	return nil
}

type NullV1StatusKind struct {
	V1StatusKind V1StatusKind `json:"v1_status_kind"`
	Valid        bool         `json:"valid"` // Valid is true if V1StatusKind is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV1StatusKind) Scan(value interface{}) error {
	if value == nil {
		ns.V1StatusKind, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V1StatusKind.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV1StatusKind) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V1StatusKind), nil
}

type V1StepMatchConditionKind string

const (
	V1StepMatchConditionKindPARENTOVERRIDE V1StepMatchConditionKind = "PARENT_OVERRIDE"
	V1StepMatchConditionKindUSEREVENT      V1StepMatchConditionKind = "USER_EVENT"
	V1StepMatchConditionKindSLEEP          V1StepMatchConditionKind = "SLEEP"
)

func (e *V1StepMatchConditionKind) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V1StepMatchConditionKind(s)
	case string:
		*e = V1StepMatchConditionKind(s)
	default:
		return fmt.Errorf("unsupported scan type for V1StepMatchConditionKind: %T", src)
	}
	return nil
}

type NullV1StepMatchConditionKind struct {
	V1StepMatchConditionKind V1StepMatchConditionKind `json:"v1_step_match_condition_kind"`
	Valid                    bool                     `json:"valid"` // Valid is true if V1StepMatchConditionKind is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV1StepMatchConditionKind) Scan(value interface{}) error {
	if value == nil {
		ns.V1StepMatchConditionKind, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V1StepMatchConditionKind.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV1StepMatchConditionKind) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V1StepMatchConditionKind), nil
}

type V1StickyStrategy string

const (
	V1StickyStrategyNONE V1StickyStrategy = "NONE"
	V1StickyStrategySOFT V1StickyStrategy = "SOFT"
	V1StickyStrategyHARD V1StickyStrategy = "HARD"
)

func (e *V1StickyStrategy) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V1StickyStrategy(s)
	case string:
		*e = V1StickyStrategy(s)
	default:
		return fmt.Errorf("unsupported scan type for V1StickyStrategy: %T", src)
	}
	return nil
}

type NullV1StickyStrategy struct {
	V1StickyStrategy V1StickyStrategy `json:"v1_sticky_strategy"`
	Valid            bool             `json:"valid"` // Valid is true if V1StickyStrategy is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV1StickyStrategy) Scan(value interface{}) error {
	if value == nil {
		ns.V1StickyStrategy, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V1StickyStrategy.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV1StickyStrategy) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V1StickyStrategy), nil
}

type V1StickyStrategyOlap string

const (
	V1StickyStrategyOlapNONE V1StickyStrategyOlap = "NONE"
	V1StickyStrategyOlapSOFT V1StickyStrategyOlap = "SOFT"
	V1StickyStrategyOlapHARD V1StickyStrategyOlap = "HARD"
)

func (e *V1StickyStrategyOlap) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V1StickyStrategyOlap(s)
	case string:
		*e = V1StickyStrategyOlap(s)
	default:
		return fmt.Errorf("unsupported scan type for V1StickyStrategyOlap: %T", src)
	}
	return nil
}

type NullV1StickyStrategyOlap struct {
	V1StickyStrategyOlap V1StickyStrategyOlap `json:"v1_sticky_strategy_olap"`
	Valid                bool                 `json:"valid"` // Valid is true if V1StickyStrategyOlap is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV1StickyStrategyOlap) Scan(value interface{}) error {
	if value == nil {
		ns.V1StickyStrategyOlap, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V1StickyStrategyOlap.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV1StickyStrategyOlap) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V1StickyStrategyOlap), nil
}

type V1TaskEventType string

const (
	V1TaskEventTypeCOMPLETED       V1TaskEventType = "COMPLETED"
	V1TaskEventTypeFAILED          V1TaskEventType = "FAILED"
	V1TaskEventTypeCANCELLED       V1TaskEventType = "CANCELLED"
	V1TaskEventTypeSIGNALCREATED   V1TaskEventType = "SIGNAL_CREATED"
	V1TaskEventTypeSIGNALCOMPLETED V1TaskEventType = "SIGNAL_COMPLETED"
)

func (e *V1TaskEventType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V1TaskEventType(s)
	case string:
		*e = V1TaskEventType(s)
	default:
		return fmt.Errorf("unsupported scan type for V1TaskEventType: %T", src)
	}
	return nil
}

type NullV1TaskEventType struct {
	V1TaskEventType V1TaskEventType `json:"v1_task_event_type"`
	Valid           bool            `json:"valid"` // Valid is true if V1TaskEventType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV1TaskEventType) Scan(value interface{}) error {
	if value == nil {
		ns.V1TaskEventType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V1TaskEventType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV1TaskEventType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V1TaskEventType), nil
}

type V1TaskInitialState string

const (
	V1TaskInitialStateQUEUED    V1TaskInitialState = "QUEUED"
	V1TaskInitialStateCANCELLED V1TaskInitialState = "CANCELLED"
	V1TaskInitialStateSKIPPED   V1TaskInitialState = "SKIPPED"
	V1TaskInitialStateFAILED    V1TaskInitialState = "FAILED"
)

func (e *V1TaskInitialState) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = V1TaskInitialState(s)
	case string:
		*e = V1TaskInitialState(s)
	default:
		return fmt.Errorf("unsupported scan type for V1TaskInitialState: %T", src)
	}
	return nil
}

type NullV1TaskInitialState struct {
	V1TaskInitialState V1TaskInitialState `json:"v1_task_initial_state"`
	Valid              bool               `json:"valid"` // Valid is true if V1TaskInitialState is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullV1TaskInitialState) Scan(value interface{}) error {
	if value == nil {
		ns.V1TaskInitialState, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.V1TaskInitialState.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullV1TaskInitialState) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.V1TaskInitialState), nil
}

type VcsProvider string

const (
	VcsProviderGITHUB VcsProvider = "GITHUB"
)

func (e *VcsProvider) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = VcsProvider(s)
	case string:
		*e = VcsProvider(s)
	default:
		return fmt.Errorf("unsupported scan type for VcsProvider: %T", src)
	}
	return nil
}

type NullVcsProvider struct {
	VcsProvider VcsProvider `json:"VcsProvider"`
	Valid       bool        `json:"valid"` // Valid is true if VcsProvider is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullVcsProvider) Scan(value interface{}) error {
	if value == nil {
		ns.VcsProvider, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.VcsProvider.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullVcsProvider) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.VcsProvider), nil
}

type WebhookWorkerRequestMethod string

const (
	WebhookWorkerRequestMethodGET  WebhookWorkerRequestMethod = "GET"
	WebhookWorkerRequestMethodPOST WebhookWorkerRequestMethod = "POST"
	WebhookWorkerRequestMethodPUT  WebhookWorkerRequestMethod = "PUT"
)

func (e *WebhookWorkerRequestMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WebhookWorkerRequestMethod(s)
	case string:
		*e = WebhookWorkerRequestMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for WebhookWorkerRequestMethod: %T", src)
	}
	return nil
}

type NullWebhookWorkerRequestMethod struct {
	WebhookWorkerRequestMethod WebhookWorkerRequestMethod `json:"WebhookWorkerRequestMethod"`
	Valid                      bool                       `json:"valid"` // Valid is true if WebhookWorkerRequestMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWebhookWorkerRequestMethod) Scan(value interface{}) error {
	if value == nil {
		ns.WebhookWorkerRequestMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WebhookWorkerRequestMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWebhookWorkerRequestMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WebhookWorkerRequestMethod), nil
}

type WorkerLabelComparator string

const (
	WorkerLabelComparatorEQUAL              WorkerLabelComparator = "EQUAL"
	WorkerLabelComparatorNOTEQUAL           WorkerLabelComparator = "NOT_EQUAL"
	WorkerLabelComparatorGREATERTHAN        WorkerLabelComparator = "GREATER_THAN"
	WorkerLabelComparatorGREATERTHANOREQUAL WorkerLabelComparator = "GREATER_THAN_OR_EQUAL"
	WorkerLabelComparatorLESSTHAN           WorkerLabelComparator = "LESS_THAN"
	WorkerLabelComparatorLESSTHANOREQUAL    WorkerLabelComparator = "LESS_THAN_OR_EQUAL"
)

func (e *WorkerLabelComparator) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkerLabelComparator(s)
	case string:
		*e = WorkerLabelComparator(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkerLabelComparator: %T", src)
	}
	return nil
}

type NullWorkerLabelComparator struct {
	WorkerLabelComparator WorkerLabelComparator `json:"WorkerLabelComparator"`
	Valid                 bool                  `json:"valid"` // Valid is true if WorkerLabelComparator is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkerLabelComparator) Scan(value interface{}) error {
	if value == nil {
		ns.WorkerLabelComparator, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkerLabelComparator.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkerLabelComparator) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkerLabelComparator), nil
}

type WorkerSDKS string

const (
	WorkerSDKSUNKNOWN    WorkerSDKS = "UNKNOWN"
	WorkerSDKSGO         WorkerSDKS = "GO"
	WorkerSDKSPYTHON     WorkerSDKS = "PYTHON"
	WorkerSDKSTYPESCRIPT WorkerSDKS = "TYPESCRIPT"
)

func (e *WorkerSDKS) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkerSDKS(s)
	case string:
		*e = WorkerSDKS(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkerSDKS: %T", src)
	}
	return nil
}

type NullWorkerSDKS struct {
	WorkerSDKS WorkerSDKS `json:"WorkerSDKS"`
	Valid      bool       `json:"valid"` // Valid is true if WorkerSDKS is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkerSDKS) Scan(value interface{}) error {
	if value == nil {
		ns.WorkerSDKS, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkerSDKS.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkerSDKS) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkerSDKS), nil
}

type WorkerType string

const (
	WorkerTypeWEBHOOK    WorkerType = "WEBHOOK"
	WorkerTypeMANAGED    WorkerType = "MANAGED"
	WorkerTypeSELFHOSTED WorkerType = "SELFHOSTED"
)

func (e *WorkerType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkerType(s)
	case string:
		*e = WorkerType(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkerType: %T", src)
	}
	return nil
}

type NullWorkerType struct {
	WorkerType WorkerType `json:"WorkerType"`
	Valid      bool       `json:"valid"` // Valid is true if WorkerType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkerType) Scan(value interface{}) error {
	if value == nil {
		ns.WorkerType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkerType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkerType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkerType), nil
}

type WorkflowKind string

const (
	WorkflowKindFUNCTION WorkflowKind = "FUNCTION"
	WorkflowKindDURABLE  WorkflowKind = "DURABLE"
	WorkflowKindDAG      WorkflowKind = "DAG"
)

func (e *WorkflowKind) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkflowKind(s)
	case string:
		*e = WorkflowKind(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkflowKind: %T", src)
	}
	return nil
}

type NullWorkflowKind struct {
	WorkflowKind WorkflowKind `json:"WorkflowKind"`
	Valid        bool         `json:"valid"` // Valid is true if WorkflowKind is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkflowKind) Scan(value interface{}) error {
	if value == nil {
		ns.WorkflowKind, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkflowKind.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkflowKind) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkflowKind), nil
}

type WorkflowRunStatus string

const (
	WorkflowRunStatusPENDING    WorkflowRunStatus = "PENDING"
	WorkflowRunStatusRUNNING    WorkflowRunStatus = "RUNNING"
	WorkflowRunStatusSUCCEEDED  WorkflowRunStatus = "SUCCEEDED"
	WorkflowRunStatusFAILED     WorkflowRunStatus = "FAILED"
	WorkflowRunStatusQUEUED     WorkflowRunStatus = "QUEUED"
	WorkflowRunStatusCANCELLING WorkflowRunStatus = "CANCELLING"
	WorkflowRunStatusCANCELLED  WorkflowRunStatus = "CANCELLED"
	WorkflowRunStatusBACKOFF    WorkflowRunStatus = "BACKOFF"
)

func (e *WorkflowRunStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkflowRunStatus(s)
	case string:
		*e = WorkflowRunStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkflowRunStatus: %T", src)
	}
	return nil
}

type NullWorkflowRunStatus struct {
	WorkflowRunStatus WorkflowRunStatus `json:"WorkflowRunStatus"`
	Valid             bool              `json:"valid"` // Valid is true if WorkflowRunStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkflowRunStatus) Scan(value interface{}) error {
	if value == nil {
		ns.WorkflowRunStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkflowRunStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkflowRunStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkflowRunStatus), nil
}

type WorkflowTriggerCronRefMethods string

const (
	WorkflowTriggerCronRefMethodsDEFAULT WorkflowTriggerCronRefMethods = "DEFAULT"
	WorkflowTriggerCronRefMethodsAPI     WorkflowTriggerCronRefMethods = "API"
)

func (e *WorkflowTriggerCronRefMethods) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkflowTriggerCronRefMethods(s)
	case string:
		*e = WorkflowTriggerCronRefMethods(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkflowTriggerCronRefMethods: %T", src)
	}
	return nil
}

type NullWorkflowTriggerCronRefMethods struct {
	WorkflowTriggerCronRefMethods WorkflowTriggerCronRefMethods `json:"WorkflowTriggerCronRefMethods"`
	Valid                         bool                          `json:"valid"` // Valid is true if WorkflowTriggerCronRefMethods is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkflowTriggerCronRefMethods) Scan(value interface{}) error {
	if value == nil {
		ns.WorkflowTriggerCronRefMethods, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkflowTriggerCronRefMethods.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkflowTriggerCronRefMethods) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkflowTriggerCronRefMethods), nil
}

type WorkflowTriggerScheduledRefMethods string

const (
	WorkflowTriggerScheduledRefMethodsDEFAULT WorkflowTriggerScheduledRefMethods = "DEFAULT"
	WorkflowTriggerScheduledRefMethodsAPI     WorkflowTriggerScheduledRefMethods = "API"
)

func (e *WorkflowTriggerScheduledRefMethods) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkflowTriggerScheduledRefMethods(s)
	case string:
		*e = WorkflowTriggerScheduledRefMethods(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkflowTriggerScheduledRefMethods: %T", src)
	}
	return nil
}

type NullWorkflowTriggerScheduledRefMethods struct {
	WorkflowTriggerScheduledRefMethods WorkflowTriggerScheduledRefMethods `json:"WorkflowTriggerScheduledRefMethods"`
	Valid                              bool                               `json:"valid"` // Valid is true if WorkflowTriggerScheduledRefMethods is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkflowTriggerScheduledRefMethods) Scan(value interface{}) error {
	if value == nil {
		ns.WorkflowTriggerScheduledRefMethods, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkflowTriggerScheduledRefMethods.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkflowTriggerScheduledRefMethods) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkflowTriggerScheduledRefMethods), nil
}

type APIToken struct {
	ID          pgtype.UUID      `json:"id"`
	CreatedAt   pgtype.Timestamp `json:"createdAt"`
	UpdatedAt   pgtype.Timestamp `json:"updatedAt"`
	ExpiresAt   pgtype.Timestamp `json:"expiresAt"`
	Revoked     bool             `json:"revoked"`
	Name        pgtype.Text      `json:"name"`
	TenantId    pgtype.UUID      `json:"tenantId"`
	NextAlertAt pgtype.Timestamp `json:"nextAlertAt"`
	Internal    bool             `json:"internal"`
}

type Action struct {
	Description pgtype.Text `json:"description"`
	TenantId    pgtype.UUID `json:"tenantId"`
	ActionId    string      `json:"actionId"`
	ID          pgtype.UUID `json:"id"`
}

type ActionToWorker struct {
	B pgtype.UUID `json:"B"`
	A pgtype.UUID `json:"A"`
}

type ControllerPartition struct {
	ID            string           `json:"id"`
	CreatedAt     pgtype.Timestamp `json:"createdAt"`
	UpdatedAt     pgtype.Timestamp `json:"updatedAt"`
	LastHeartbeat pgtype.Timestamp `json:"lastHeartbeat"`
	Name          pgtype.Text      `json:"name"`
}

type Dispatcher struct {
	ID              pgtype.UUID      `json:"id"`
	CreatedAt       pgtype.Timestamp `json:"createdAt"`
	UpdatedAt       pgtype.Timestamp `json:"updatedAt"`
	DeletedAt       pgtype.Timestamp `json:"deletedAt"`
	LastHeartbeatAt pgtype.Timestamp `json:"lastHeartbeatAt"`
	IsActive        bool             `json:"isActive"`
}

type Event struct {
	ID                 pgtype.UUID      `json:"id"`
	CreatedAt          pgtype.Timestamp `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	DeletedAt          pgtype.Timestamp `json:"deletedAt"`
	Key                string           `json:"key"`
	TenantId           pgtype.UUID      `json:"tenantId"`
	ReplayedFromId     pgtype.UUID      `json:"replayedFromId"`
	Data               []byte           `json:"data"`
	AdditionalMetadata []byte           `json:"additionalMetadata"`
	InsertOrder        pgtype.Int4      `json:"insertOrder"`
}

type EventKey struct {
	Key      string      `json:"key"`
	TenantId pgtype.UUID `json:"tenantId"`
	ID       int64       `json:"id"`
}

type GetGroupKeyRun struct {
	ID                pgtype.UUID      `json:"id"`
	CreatedAt         pgtype.Timestamp `json:"createdAt"`
	UpdatedAt         pgtype.Timestamp `json:"updatedAt"`
	DeletedAt         pgtype.Timestamp `json:"deletedAt"`
	TenantId          pgtype.UUID      `json:"tenantId"`
	WorkerId          pgtype.UUID      `json:"workerId"`
	TickerId          pgtype.UUID      `json:"tickerId"`
	Status            StepRunStatus    `json:"status"`
	Input             []byte           `json:"input"`
	Output            pgtype.Text      `json:"output"`
	RequeueAfter      pgtype.Timestamp `json:"requeueAfter"`
	Error             pgtype.Text      `json:"error"`
	StartedAt         pgtype.Timestamp `json:"startedAt"`
	FinishedAt        pgtype.Timestamp `json:"finishedAt"`
	TimeoutAt         pgtype.Timestamp `json:"timeoutAt"`
	CancelledAt       pgtype.Timestamp `json:"cancelledAt"`
	CancelledReason   pgtype.Text      `json:"cancelledReason"`
	CancelledError    pgtype.Text      `json:"cancelledError"`
	WorkflowRunId     pgtype.UUID      `json:"workflowRunId"`
	ScheduleTimeoutAt pgtype.Timestamp `json:"scheduleTimeoutAt"`
}

type InternalQueueItem struct {
	ID        int64         `json:"id"`
	Queue     InternalQueue `json:"queue"`
	IsQueued  bool          `json:"isQueued"`
	Data      []byte        `json:"data"`
	TenantId  pgtype.UUID   `json:"tenantId"`
	Priority  int32         `json:"priority"`
	UniqueKey pgtype.Text   `json:"uniqueKey"`
}

type Job struct {
	ID                pgtype.UUID      `json:"id"`
	CreatedAt         pgtype.Timestamp `json:"createdAt"`
	UpdatedAt         pgtype.Timestamp `json:"updatedAt"`
	DeletedAt         pgtype.Timestamp `json:"deletedAt"`
	TenantId          pgtype.UUID      `json:"tenantId"`
	WorkflowVersionId pgtype.UUID      `json:"workflowVersionId"`
	Name              string           `json:"name"`
	Description       pgtype.Text      `json:"description"`
	Timeout           pgtype.Text      `json:"timeout"`
	Kind              JobKind          `json:"kind"`
}

type JobRun struct {
	ID              pgtype.UUID      `json:"id"`
	CreatedAt       pgtype.Timestamp `json:"createdAt"`
	UpdatedAt       pgtype.Timestamp `json:"updatedAt"`
	DeletedAt       pgtype.Timestamp `json:"deletedAt"`
	TenantId        pgtype.UUID      `json:"tenantId"`
	JobId           pgtype.UUID      `json:"jobId"`
	TickerId        pgtype.UUID      `json:"tickerId"`
	Status          JobRunStatus     `json:"status"`
	Result          []byte           `json:"result"`
	StartedAt       pgtype.Timestamp `json:"startedAt"`
	FinishedAt      pgtype.Timestamp `json:"finishedAt"`
	TimeoutAt       pgtype.Timestamp `json:"timeoutAt"`
	CancelledAt     pgtype.Timestamp `json:"cancelledAt"`
	CancelledReason pgtype.Text      `json:"cancelledReason"`
	CancelledError  pgtype.Text      `json:"cancelledError"`
	WorkflowRunId   pgtype.UUID      `json:"workflowRunId"`
}

type JobRunLookupData struct {
	ID        pgtype.UUID      `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	DeletedAt pgtype.Timestamp `json:"deletedAt"`
	JobRunId  pgtype.UUID      `json:"jobRunId"`
	TenantId  pgtype.UUID      `json:"tenantId"`
	Data      []byte           `json:"data"`
}

type Lease struct {
	ID         int64            `json:"id"`
	ExpiresAt  pgtype.Timestamp `json:"expiresAt"`
	TenantId   pgtype.UUID      `json:"tenantId"`
	ResourceId string           `json:"resourceId"`
	Kind       LeaseKind        `json:"kind"`
}

type LogLine struct {
	ID        int64            `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	TenantId  pgtype.UUID      `json:"tenantId"`
	StepRunId pgtype.UUID      `json:"stepRunId"`
	Message   string           `json:"message"`
	Level     LogLineLevel     `json:"level"`
	Metadata  []byte           `json:"metadata"`
}

type MessageQueue struct {
	Name                string           `json:"name"`
	LastActive          pgtype.Timestamp `json:"lastActive"`
	Durable             bool             `json:"durable"`
	AutoDeleted         bool             `json:"autoDeleted"`
	Exclusive           bool             `json:"exclusive"`
	ExclusiveConsumerId pgtype.UUID      `json:"exclusiveConsumerId"`
}

type MessageQueueItem struct {
	ID        int64                  `json:"id"`
	Payload   []byte                 `json:"payload"`
	ReadAfter pgtype.Timestamp       `json:"readAfter"`
	ExpiresAt pgtype.Timestamp       `json:"expiresAt"`
	QueueId   pgtype.Text            `json:"queueId"`
	Status    MessageQueueItemStatus `json:"status"`
}

type Queue struct {
	ID         int64            `json:"id"`
	TenantId   pgtype.UUID      `json:"tenantId"`
	Name       string           `json:"name"`
	LastActive pgtype.Timestamp `json:"lastActive"`
}

type QueueItem struct {
	ID                int64              `json:"id"`
	StepRunId         pgtype.UUID        `json:"stepRunId"`
	StepId            pgtype.UUID        `json:"stepId"`
	ActionId          pgtype.Text        `json:"actionId"`
	ScheduleTimeoutAt pgtype.Timestamp   `json:"scheduleTimeoutAt"`
	StepTimeout       pgtype.Text        `json:"stepTimeout"`
	Priority          int32              `json:"priority"`
	IsQueued          bool               `json:"isQueued"`
	TenantId          pgtype.UUID        `json:"tenantId"`
	Queue             string             `json:"queue"`
	Sticky            NullStickyStrategy `json:"sticky"`
	DesiredWorkerId   pgtype.UUID        `json:"desiredWorkerId"`
}

type RateLimit struct {
	TenantId   pgtype.UUID      `json:"tenantId"`
	Key        string           `json:"key"`
	LimitValue int32            `json:"limitValue"`
	Value      int32            `json:"value"`
	Window     string           `json:"window"`
	LastRefill pgtype.Timestamp `json:"lastRefill"`
}

type RetryQueueItem struct {
	ID         int64            `json:"id"`
	RetryAfter pgtype.Timestamp `json:"retryAfter"`
	StepRunId  pgtype.UUID      `json:"stepRunId"`
	TenantId   pgtype.UUID      `json:"tenantId"`
	IsQueued   bool             `json:"isQueued"`
}

type SNSIntegration struct {
	ID        pgtype.UUID      `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	TenantId  pgtype.UUID      `json:"tenantId"`
	TopicArn  string           `json:"topicArn"`
}

type SchedulerPartition struct {
	ID            string           `json:"id"`
	CreatedAt     pgtype.Timestamp `json:"createdAt"`
	UpdatedAt     pgtype.Timestamp `json:"updatedAt"`
	LastHeartbeat pgtype.Timestamp `json:"lastHeartbeat"`
	Name          pgtype.Text      `json:"name"`
}

type SecurityCheckIdent struct {
	ID pgtype.UUID `json:"id"`
}

type SemaphoreQueueItem struct {
	StepRunId pgtype.UUID `json:"stepRunId"`
	WorkerId  pgtype.UUID `json:"workerId"`
	TenantId  pgtype.UUID `json:"tenantId"`
}

type Service struct {
	ID          pgtype.UUID      `json:"id"`
	CreatedAt   pgtype.Timestamp `json:"createdAt"`
	UpdatedAt   pgtype.Timestamp `json:"updatedAt"`
	DeletedAt   pgtype.Timestamp `json:"deletedAt"`
	Name        string           `json:"name"`
	Description pgtype.Text      `json:"description"`
	TenantId    pgtype.UUID      `json:"tenantId"`
}

type ServiceToWorker struct {
	A pgtype.UUID `json:"A"`
	B pgtype.UUID `json:"B"`
}

type SlackAppWebhook struct {
	ID          pgtype.UUID      `json:"id"`
	CreatedAt   pgtype.Timestamp `json:"createdAt"`
	UpdatedAt   pgtype.Timestamp `json:"updatedAt"`
	DeletedAt   pgtype.Timestamp `json:"deletedAt"`
	TenantId    pgtype.UUID      `json:"tenantId"`
	TeamId      string           `json:"teamId"`
	TeamName    string           `json:"teamName"`
	ChannelId   string           `json:"channelId"`
	ChannelName string           `json:"channelName"`
	WebhookURL  []byte           `json:"webhookURL"`
}

type Step struct {
	ID                 pgtype.UUID      `json:"id"`
	CreatedAt          pgtype.Timestamp `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	DeletedAt          pgtype.Timestamp `json:"deletedAt"`
	ReadableId         pgtype.Text      `json:"readableId"`
	TenantId           pgtype.UUID      `json:"tenantId"`
	JobId              pgtype.UUID      `json:"jobId"`
	ActionId           string           `json:"actionId"`
	Timeout            pgtype.Text      `json:"timeout"`
	CustomUserData     []byte           `json:"customUserData"`
	Retries            int32            `json:"retries"`
	RetryBackoffFactor pgtype.Float8    `json:"retryBackoffFactor"`
	RetryMaxBackoff    pgtype.Int4      `json:"retryMaxBackoff"`
	ScheduleTimeout    string           `json:"scheduleTimeout"`
}

type StepDesiredWorkerLabel struct {
	ID         int64                 `json:"id"`
	CreatedAt  pgtype.Timestamp      `json:"createdAt"`
	UpdatedAt  pgtype.Timestamp      `json:"updatedAt"`
	StepId     pgtype.UUID           `json:"stepId"`
	Key        string                `json:"key"`
	StrValue   pgtype.Text           `json:"strValue"`
	IntValue   pgtype.Int4           `json:"intValue"`
	Required   bool                  `json:"required"`
	Comparator WorkerLabelComparator `json:"comparator"`
	Weight     int32                 `json:"weight"`
}

type StepExpression struct {
	Key        string             `json:"key"`
	StepId     pgtype.UUID        `json:"stepId"`
	Expression string             `json:"expression"`
	Kind       StepExpressionKind `json:"kind"`
}

type StepOrder struct {
	A pgtype.UUID `json:"A"`
	B pgtype.UUID `json:"B"`
}

type StepRateLimit struct {
	Units        int32             `json:"units"`
	StepId       pgtype.UUID       `json:"stepId"`
	RateLimitKey string            `json:"rateLimitKey"`
	TenantId     pgtype.UUID       `json:"tenantId"`
	Kind         StepRateLimitKind `json:"kind"`
}

type StepRun struct {
	ID                 pgtype.UUID      `json:"id"`
	CreatedAt          pgtype.Timestamp `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	DeletedAt          pgtype.Timestamp `json:"deletedAt"`
	TenantId           pgtype.UUID      `json:"tenantId"`
	JobRunId           pgtype.UUID      `json:"jobRunId"`
	StepId             pgtype.UUID      `json:"stepId"`
	Order              int64            `json:"order"`
	WorkerId           pgtype.UUID      `json:"workerId"`
	TickerId           pgtype.UUID      `json:"tickerId"`
	Status             StepRunStatus    `json:"status"`
	Input              []byte           `json:"input"`
	Output             []byte           `json:"output"`
	RequeueAfter       pgtype.Timestamp `json:"requeueAfter"`
	ScheduleTimeoutAt  pgtype.Timestamp `json:"scheduleTimeoutAt"`
	Error              pgtype.Text      `json:"error"`
	StartedAt          pgtype.Timestamp `json:"startedAt"`
	FinishedAt         pgtype.Timestamp `json:"finishedAt"`
	TimeoutAt          pgtype.Timestamp `json:"timeoutAt"`
	CancelledAt        pgtype.Timestamp `json:"cancelledAt"`
	CancelledReason    pgtype.Text      `json:"cancelledReason"`
	CancelledError     pgtype.Text      `json:"cancelledError"`
	InputSchema        []byte           `json:"inputSchema"`
	CallerFiles        []byte           `json:"callerFiles"`
	GitRepoBranch      pgtype.Text      `json:"gitRepoBranch"`
	RetryCount         int32            `json:"retryCount"`
	SemaphoreReleased  bool             `json:"semaphoreReleased"`
	Queue              string           `json:"queue"`
	Priority           pgtype.Int4      `json:"priority"`
	InternalRetryCount int32            `json:"internalRetryCount"`
}

type StepRunEvent struct {
	ID            int64                `json:"id"`
	TimeFirstSeen pgtype.Timestamp     `json:"timeFirstSeen"`
	TimeLastSeen  pgtype.Timestamp     `json:"timeLastSeen"`
	StepRunId     pgtype.UUID          `json:"stepRunId"`
	Reason        StepRunEventReason   `json:"reason"`
	Severity      StepRunEventSeverity `json:"severity"`
	Message       string               `json:"message"`
	Count         int32                `json:"count"`
	Data          []byte               `json:"data"`
	WorkflowRunId pgtype.UUID          `json:"workflowRunId"`
}

type StepRunExpressionEval struct {
	Key       string             `json:"key"`
	StepRunId pgtype.UUID        `json:"stepRunId"`
	ValueStr  pgtype.Text        `json:"valueStr"`
	ValueInt  pgtype.Int4        `json:"valueInt"`
	Kind      StepExpressionKind `json:"kind"`
}

type StepRunOrder struct {
	A pgtype.UUID `json:"A"`
	B pgtype.UUID `json:"B"`
}

type StepRunResultArchive struct {
	ID              pgtype.UUID      `json:"id"`
	CreatedAt       pgtype.Timestamp `json:"createdAt"`
	UpdatedAt       pgtype.Timestamp `json:"updatedAt"`
	DeletedAt       pgtype.Timestamp `json:"deletedAt"`
	StepRunId       pgtype.UUID      `json:"stepRunId"`
	Order           int64            `json:"order"`
	Input           []byte           `json:"input"`
	Output          []byte           `json:"output"`
	Error           pgtype.Text      `json:"error"`
	StartedAt       pgtype.Timestamp `json:"startedAt"`
	FinishedAt      pgtype.Timestamp `json:"finishedAt"`
	TimeoutAt       pgtype.Timestamp `json:"timeoutAt"`
	CancelledAt     pgtype.Timestamp `json:"cancelledAt"`
	CancelledReason pgtype.Text      `json:"cancelledReason"`
	CancelledError  pgtype.Text      `json:"cancelledError"`
	RetryCount      int32            `json:"retryCount"`
}

type StreamEvent struct {
	ID        int64            `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	TenantId  pgtype.UUID      `json:"tenantId"`
	StepRunId pgtype.UUID      `json:"stepRunId"`
	Message   []byte           `json:"message"`
	Metadata  []byte           `json:"metadata"`
}

type Tenant struct {
	ID                    pgtype.UUID              `json:"id"`
	CreatedAt             pgtype.Timestamp         `json:"createdAt"`
	UpdatedAt             pgtype.Timestamp         `json:"updatedAt"`
	DeletedAt             pgtype.Timestamp         `json:"deletedAt"`
	Version               TenantMajorEngineVersion `json:"version"`
	Name                  string                   `json:"name"`
	Slug                  string                   `json:"slug"`
	AnalyticsOptOut       bool                     `json:"analyticsOptOut"`
	AlertMemberEmails     bool                     `json:"alertMemberEmails"`
	ControllerPartitionId pgtype.Text              `json:"controllerPartitionId"`
	WorkerPartitionId     pgtype.Text              `json:"workerPartitionId"`
	DataRetentionPeriod   string                   `json:"dataRetentionPeriod"`
	SchedulerPartitionId  pgtype.Text              `json:"schedulerPartitionId"`
	CanUpgradeV1          bool                     `json:"canUpgradeV1"`
}

type TenantAlertEmailGroup struct {
	ID        pgtype.UUID      `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	DeletedAt pgtype.Timestamp `json:"deletedAt"`
	TenantId  pgtype.UUID      `json:"tenantId"`
	Emails    string           `json:"emails"`
}

type TenantAlertingSettings struct {
	ID                              pgtype.UUID      `json:"id"`
	CreatedAt                       pgtype.Timestamp `json:"createdAt"`
	UpdatedAt                       pgtype.Timestamp `json:"updatedAt"`
	DeletedAt                       pgtype.Timestamp `json:"deletedAt"`
	TenantId                        pgtype.UUID      `json:"tenantId"`
	MaxFrequency                    string           `json:"maxFrequency"`
	LastAlertedAt                   pgtype.Timestamp `json:"lastAlertedAt"`
	TickerId                        pgtype.UUID      `json:"tickerId"`
	EnableExpiringTokenAlerts       bool             `json:"enableExpiringTokenAlerts"`
	EnableWorkflowRunFailureAlerts  bool             `json:"enableWorkflowRunFailureAlerts"`
	EnableTenantResourceLimitAlerts bool             `json:"enableTenantResourceLimitAlerts"`
}

type TenantInviteLink struct {
	ID           pgtype.UUID      `json:"id"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	UpdatedAt    pgtype.Timestamp `json:"updatedAt"`
	TenantId     pgtype.UUID      `json:"tenantId"`
	InviterEmail string           `json:"inviterEmail"`
	InviteeEmail string           `json:"inviteeEmail"`
	Expires      pgtype.Timestamp `json:"expires"`
	Status       InviteLinkStatus `json:"status"`
	Role         TenantMemberRole `json:"role"`
}

type TenantMember struct {
	ID        pgtype.UUID      `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	TenantId  pgtype.UUID      `json:"tenantId"`
	UserId    pgtype.UUID      `json:"userId"`
	Role      TenantMemberRole `json:"role"`
}

type TenantResourceLimit struct {
	ID               pgtype.UUID      `json:"id"`
	CreatedAt        pgtype.Timestamp `json:"createdAt"`
	UpdatedAt        pgtype.Timestamp `json:"updatedAt"`
	Resource         LimitResource    `json:"resource"`
	TenantId         pgtype.UUID      `json:"tenantId"`
	LimitValue       int32            `json:"limitValue"`
	AlarmValue       pgtype.Int4      `json:"alarmValue"`
	Value            int32            `json:"value"`
	Window           pgtype.Text      `json:"window"`
	LastRefill       pgtype.Timestamp `json:"lastRefill"`
	CustomValueMeter bool             `json:"customValueMeter"`
}

type TenantResourceLimitAlert struct {
	ID              pgtype.UUID                  `json:"id"`
	CreatedAt       pgtype.Timestamp             `json:"createdAt"`
	UpdatedAt       pgtype.Timestamp             `json:"updatedAt"`
	ResourceLimitId pgtype.UUID                  `json:"resourceLimitId"`
	TenantId        pgtype.UUID                  `json:"tenantId"`
	Resource        LimitResource                `json:"resource"`
	AlertType       TenantResourceLimitAlertType `json:"alertType"`
	Value           int32                        `json:"value"`
	Limit           int32                        `json:"limit"`
}

type TenantVcsProvider struct {
	ID          pgtype.UUID      `json:"id"`
	CreatedAt   pgtype.Timestamp `json:"createdAt"`
	UpdatedAt   pgtype.Timestamp `json:"updatedAt"`
	DeletedAt   pgtype.Timestamp `json:"deletedAt"`
	TenantId    pgtype.UUID      `json:"tenantId"`
	VcsProvider VcsProvider      `json:"vcsProvider"`
	Config      []byte           `json:"config"`
}

type TenantWorkerPartition struct {
	ID            string           `json:"id"`
	CreatedAt     pgtype.Timestamp `json:"createdAt"`
	UpdatedAt     pgtype.Timestamp `json:"updatedAt"`
	LastHeartbeat pgtype.Timestamp `json:"lastHeartbeat"`
	Name          pgtype.Text      `json:"name"`
}

type Ticker struct {
	ID              pgtype.UUID      `json:"id"`
	CreatedAt       pgtype.Timestamp `json:"createdAt"`
	UpdatedAt       pgtype.Timestamp `json:"updatedAt"`
	LastHeartbeatAt pgtype.Timestamp `json:"lastHeartbeatAt"`
	IsActive        bool             `json:"isActive"`
}

type TimeoutQueueItem struct {
	ID         int64            `json:"id"`
	StepRunId  pgtype.UUID      `json:"stepRunId"`
	RetryCount int32            `json:"retryCount"`
	TimeoutAt  pgtype.Timestamp `json:"timeoutAt"`
	TenantId   pgtype.UUID      `json:"tenantId"`
	IsQueued   bool             `json:"isQueued"`
}

type TmpWorkflowConcurrencySlot struct {
	SortID                    int64       `json:"sort_id"`
	TenantID                  pgtype.UUID `json:"tenant_id"`
	WorkflowID                pgtype.UUID `json:"workflow_id"`
	WorkflowVersionID         pgtype.UUID `json:"workflow_version_id"`
	WorkflowRunID             pgtype.UUID `json:"workflow_run_id"`
	StrategyID                int64       `json:"strategy_id"`
	CompletedChildStrategyIds []int64     `json:"completed_child_strategy_ids"`
	ChildStrategyIds          []int64     `json:"child_strategy_ids"`
	Priority                  int32       `json:"priority"`
	Key                       string      `json:"key"`
	IsFilled                  bool        `json:"is_filled"`
}

type User struct {
	ID            pgtype.UUID      `json:"id"`
	CreatedAt     pgtype.Timestamp `json:"createdAt"`
	UpdatedAt     pgtype.Timestamp `json:"updatedAt"`
	DeletedAt     pgtype.Timestamp `json:"deletedAt"`
	Email         string           `json:"email"`
	EmailVerified bool             `json:"emailVerified"`
	Name          pgtype.Text      `json:"name"`
}

type UserOAuth struct {
	ID             pgtype.UUID      `json:"id"`
	CreatedAt      pgtype.Timestamp `json:"createdAt"`
	UpdatedAt      pgtype.Timestamp `json:"updatedAt"`
	UserId         pgtype.UUID      `json:"userId"`
	Provider       string           `json:"provider"`
	ProviderUserId string           `json:"providerUserId"`
	ExpiresAt      pgtype.Timestamp `json:"expiresAt"`
	AccessToken    []byte           `json:"accessToken"`
	RefreshToken   []byte           `json:"refreshToken"`
}

type UserPassword struct {
	Hash   string      `json:"hash"`
	UserId pgtype.UUID `json:"userId"`
}

type UserSession struct {
	ID        pgtype.UUID      `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	UserId    pgtype.UUID      `json:"userId"`
	Data      []byte           `json:"data"`
	ExpiresAt pgtype.Timestamp `json:"expiresAt"`
}

type V1ConcurrencySlot struct {
	SortID                pgtype.Int8        `json:"sort_id"`
	TaskID                int64              `json:"task_id"`
	TaskInsertedAt        pgtype.Timestamptz `json:"task_inserted_at"`
	TaskRetryCount        int32              `json:"task_retry_count"`
	ExternalID            pgtype.UUID        `json:"external_id"`
	TenantID              pgtype.UUID        `json:"tenant_id"`
	WorkflowID            pgtype.UUID        `json:"workflow_id"`
	WorkflowVersionID     pgtype.UUID        `json:"workflow_version_id"`
	WorkflowRunID         pgtype.UUID        `json:"workflow_run_id"`
	StrategyID            int64              `json:"strategy_id"`
	ParentStrategyID      pgtype.Int8        `json:"parent_strategy_id"`
	Priority              int32              `json:"priority"`
	Key                   string             `json:"key"`
	IsFilled              bool               `json:"is_filled"`
	NextParentStrategyIds []int64            `json:"next_parent_strategy_ids"`
	NextStrategyIds       []int64            `json:"next_strategy_ids"`
	NextKeys              []string           `json:"next_keys"`
	QueueToNotify         string             `json:"queue_to_notify"`
	ScheduleTimeoutAt     pgtype.Timestamp   `json:"schedule_timeout_at"`
}

type V1Dag struct {
	ID                   int64              `json:"id"`
	InsertedAt           pgtype.Timestamptz `json:"inserted_at"`
	TenantID             pgtype.UUID        `json:"tenant_id"`
	ExternalID           pgtype.UUID        `json:"external_id"`
	DisplayName          string             `json:"display_name"`
	WorkflowID           pgtype.UUID        `json:"workflow_id"`
	WorkflowVersionID    pgtype.UUID        `json:"workflow_version_id"`
	ParentTaskExternalID pgtype.UUID        `json:"parent_task_external_id"`
}

type V1DagData struct {
	DagID              int64              `json:"dag_id"`
	DagInsertedAt      pgtype.Timestamptz `json:"dag_inserted_at"`
	Input              []byte             `json:"input"`
	AdditionalMetadata []byte             `json:"additional_metadata"`
}

type V1DagToTask struct {
	DagID          int64              `json:"dag_id"`
	DagInsertedAt  pgtype.Timestamptz `json:"dag_inserted_at"`
	TaskID         int64              `json:"task_id"`
	TaskInsertedAt pgtype.Timestamptz `json:"task_inserted_at"`
}

type V1DagToTaskOlap struct {
	DagID          int64              `json:"dag_id"`
	DagInsertedAt  pgtype.Timestamptz `json:"dag_inserted_at"`
	TaskID         int64              `json:"task_id"`
	TaskInsertedAt pgtype.Timestamptz `json:"task_inserted_at"`
}

type V1DagsOlap struct {
	ID                   int64                `json:"id"`
	InsertedAt           pgtype.Timestamptz   `json:"inserted_at"`
	TenantID             pgtype.UUID          `json:"tenant_id"`
	ExternalID           pgtype.UUID          `json:"external_id"`
	DisplayName          string               `json:"display_name"`
	WorkflowID           pgtype.UUID          `json:"workflow_id"`
	WorkflowVersionID    pgtype.UUID          `json:"workflow_version_id"`
	ReadableStatus       V1ReadableStatusOlap `json:"readable_status"`
	Input                []byte               `json:"input"`
	AdditionalMetadata   []byte               `json:"additional_metadata"`
	ParentTaskExternalID pgtype.UUID          `json:"parent_task_external_id"`
}

type V1DurableSleep struct {
	ID         int64              `json:"id"`
	TenantID   pgtype.UUID        `json:"tenant_id"`
	SleepUntil pgtype.Timestamptz `json:"sleep_until"`
}

type V1LogLine struct {
	ID             int64              `json:"id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	TenantID       pgtype.UUID        `json:"tenant_id"`
	TaskID         int64              `json:"task_id"`
	TaskInsertedAt pgtype.Timestamptz `json:"task_inserted_at"`
	Message        string             `json:"message"`
	Level          V1LogLineLevel     `json:"level"`
	Metadata       []byte             `json:"metadata"`
}

type V1LookupTable struct {
	TenantID   pgtype.UUID        `json:"tenant_id"`
	ExternalID pgtype.UUID        `json:"external_id"`
	TaskID     pgtype.Int8        `json:"task_id"`
	DagID      pgtype.Int8        `json:"dag_id"`
	InsertedAt pgtype.Timestamptz `json:"inserted_at"`
}

type V1LookupTableOlap struct {
	TenantID   pgtype.UUID        `json:"tenant_id"`
	ExternalID pgtype.UUID        `json:"external_id"`
	TaskID     pgtype.Int8        `json:"task_id"`
	DagID      pgtype.Int8        `json:"dag_id"`
	InsertedAt pgtype.Timestamptz `json:"inserted_at"`
}

type V1Match struct {
	ID                            int64              `json:"id"`
	TenantID                      pgtype.UUID        `json:"tenant_id"`
	Kind                          V1MatchKind        `json:"kind"`
	IsSatisfied                   bool               `json:"is_satisfied"`
	ExistingData                  []byte             `json:"existing_data"`
	SignalTaskID                  pgtype.Int8        `json:"signal_task_id"`
	SignalTaskInsertedAt          pgtype.Timestamptz `json:"signal_task_inserted_at"`
	SignalExternalID              pgtype.UUID        `json:"signal_external_id"`
	SignalKey                     pgtype.Text        `json:"signal_key"`
	TriggerDagID                  pgtype.Int8        `json:"trigger_dag_id"`
	TriggerDagInsertedAt          pgtype.Timestamptz `json:"trigger_dag_inserted_at"`
	TriggerStepID                 pgtype.UUID        `json:"trigger_step_id"`
	TriggerStepIndex              pgtype.Int8        `json:"trigger_step_index"`
	TriggerExternalID             pgtype.UUID        `json:"trigger_external_id"`
	TriggerWorkflowRunID          pgtype.UUID        `json:"trigger_workflow_run_id"`
	TriggerParentTaskExternalID   pgtype.UUID        `json:"trigger_parent_task_external_id"`
	TriggerParentTaskID           pgtype.Int8        `json:"trigger_parent_task_id"`
	TriggerParentTaskInsertedAt   pgtype.Timestamptz `json:"trigger_parent_task_inserted_at"`
	TriggerChildIndex             pgtype.Int8        `json:"trigger_child_index"`
	TriggerChildKey               pgtype.Text        `json:"trigger_child_key"`
	TriggerExistingTaskID         pgtype.Int8        `json:"trigger_existing_task_id"`
	TriggerExistingTaskInsertedAt pgtype.Timestamptz `json:"trigger_existing_task_inserted_at"`
}

type V1MatchCondition struct {
	V1MatchID         int64                  `json:"v1_match_id"`
	ID                int64                  `json:"id"`
	TenantID          pgtype.UUID            `json:"tenant_id"`
	RegisteredAt      pgtype.Timestamptz     `json:"registered_at"`
	EventType         V1EventType            `json:"event_type"`
	EventKey          string                 `json:"event_key"`
	EventResourceHint pgtype.Text            `json:"event_resource_hint"`
	ReadableDataKey   string                 `json:"readable_data_key"`
	IsSatisfied       bool                   `json:"is_satisfied"`
	Action            V1MatchConditionAction `json:"action"`
	OrGroupID         pgtype.UUID            `json:"or_group_id"`
	Expression        pgtype.Text            `json:"expression"`
	Data              []byte                 `json:"data"`
}

type V1Queue struct {
	TenantID   pgtype.UUID      `json:"tenant_id"`
	Name       string           `json:"name"`
	LastActive pgtype.Timestamp `json:"last_active"`
}

type V1QueueItem struct {
	ID                int64              `json:"id"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	Queue             string             `json:"queue"`
	TaskID            int64              `json:"task_id"`
	TaskInsertedAt    pgtype.Timestamptz `json:"task_inserted_at"`
	ExternalID        pgtype.UUID        `json:"external_id"`
	ActionID          string             `json:"action_id"`
	StepID            pgtype.UUID        `json:"step_id"`
	WorkflowID        pgtype.UUID        `json:"workflow_id"`
	WorkflowRunID     pgtype.UUID        `json:"workflow_run_id"`
	ScheduleTimeoutAt pgtype.Timestamp   `json:"schedule_timeout_at"`
	StepTimeout       pgtype.Text        `json:"step_timeout"`
	Priority          int32              `json:"priority"`
	Sticky            V1StickyStrategy   `json:"sticky"`
	DesiredWorkerID   pgtype.UUID        `json:"desired_worker_id"`
	RetryCount        int32              `json:"retry_count"`
}

type V1RetryQueueItem struct {
	TaskID         int64              `json:"task_id"`
	TaskInsertedAt pgtype.Timestamptz `json:"task_inserted_at"`
	TaskRetryCount int32              `json:"task_retry_count"`
	RetryAfter     pgtype.Timestamptz `json:"retry_after"`
	TenantID       pgtype.UUID        `json:"tenant_id"`
}

type V1RunsOlap struct {
	TenantID             pgtype.UUID          `json:"tenant_id"`
	ID                   int64                `json:"id"`
	InsertedAt           pgtype.Timestamptz   `json:"inserted_at"`
	ExternalID           pgtype.UUID          `json:"external_id"`
	ReadableStatus       V1ReadableStatusOlap `json:"readable_status"`
	Kind                 V1RunKind            `json:"kind"`
	WorkflowID           pgtype.UUID          `json:"workflow_id"`
	WorkflowVersionID    pgtype.UUID          `json:"workflow_version_id"`
	AdditionalMetadata   []byte               `json:"additional_metadata"`
	ParentTaskExternalID pgtype.UUID          `json:"parent_task_external_id"`
}

type V1StatusesOlap struct {
	ExternalID     pgtype.UUID          `json:"external_id"`
	InsertedAt     pgtype.Timestamptz   `json:"inserted_at"`
	TenantID       pgtype.UUID          `json:"tenant_id"`
	WorkflowID     pgtype.UUID          `json:"workflow_id"`
	Kind           V1RunKind            `json:"kind"`
	ReadableStatus V1ReadableStatusOlap `json:"readable_status"`
}

type V1StepConcurrency struct {
	ID                int64                 `json:"id"`
	ParentStrategyID  pgtype.Int8           `json:"parent_strategy_id"`
	WorkflowID        pgtype.UUID           `json:"workflow_id"`
	WorkflowVersionID pgtype.UUID           `json:"workflow_version_id"`
	StepID            pgtype.UUID           `json:"step_id"`
	IsActive          bool                  `json:"is_active"`
	Strategy          V1ConcurrencyStrategy `json:"strategy"`
	Expression        string                `json:"expression"`
	TenantID          pgtype.UUID           `json:"tenant_id"`
	MaxConcurrency    int32                 `json:"max_concurrency"`
}

type V1StepMatchCondition struct {
	ID               int64                    `json:"id"`
	TenantID         pgtype.UUID              `json:"tenant_id"`
	StepID           pgtype.UUID              `json:"step_id"`
	ReadableDataKey  string                   `json:"readable_data_key"`
	Action           V1MatchConditionAction   `json:"action"`
	OrGroupID        pgtype.UUID              `json:"or_group_id"`
	Expression       pgtype.Text              `json:"expression"`
	Kind             V1StepMatchConditionKind `json:"kind"`
	SleepDuration    pgtype.Text              `json:"sleep_duration"`
	EventKey         pgtype.Text              `json:"event_key"`
	ParentReadableID pgtype.Text              `json:"parent_readable_id"`
}

type V1Task struct {
	ID                           int64              `json:"id"`
	InsertedAt                   pgtype.Timestamptz `json:"inserted_at"`
	TenantID                     pgtype.UUID        `json:"tenant_id"`
	Queue                        string             `json:"queue"`
	ActionID                     string             `json:"action_id"`
	StepID                       pgtype.UUID        `json:"step_id"`
	StepReadableID               string             `json:"step_readable_id"`
	WorkflowID                   pgtype.UUID        `json:"workflow_id"`
	WorkflowVersionID            pgtype.UUID        `json:"workflow_version_id"`
	WorkflowRunID                pgtype.UUID        `json:"workflow_run_id"`
	ScheduleTimeout              string             `json:"schedule_timeout"`
	StepTimeout                  pgtype.Text        `json:"step_timeout"`
	Priority                     pgtype.Int4        `json:"priority"`
	Sticky                       V1StickyStrategy   `json:"sticky"`
	DesiredWorkerID              pgtype.UUID        `json:"desired_worker_id"`
	ExternalID                   pgtype.UUID        `json:"external_id"`
	DisplayName                  string             `json:"display_name"`
	Input                        []byte             `json:"input"`
	RetryCount                   int32              `json:"retry_count"`
	InternalRetryCount           int32              `json:"internal_retry_count"`
	AppRetryCount                int32              `json:"app_retry_count"`
	StepIndex                    int64              `json:"step_index"`
	AdditionalMetadata           []byte             `json:"additional_metadata"`
	DagID                        pgtype.Int8        `json:"dag_id"`
	DagInsertedAt                pgtype.Timestamptz `json:"dag_inserted_at"`
	ParentTaskExternalID         pgtype.UUID        `json:"parent_task_external_id"`
	ParentTaskID                 pgtype.Int8        `json:"parent_task_id"`
	ParentTaskInsertedAt         pgtype.Timestamptz `json:"parent_task_inserted_at"`
	ChildIndex                   pgtype.Int8        `json:"child_index"`
	ChildKey                     pgtype.Text        `json:"child_key"`
	InitialState                 V1TaskInitialState `json:"initial_state"`
	InitialStateReason           pgtype.Text        `json:"initial_state_reason"`
	ConcurrencyParentStrategyIds []pgtype.Int8      `json:"concurrency_parent_strategy_ids"`
	ConcurrencyStrategyIds       []int64            `json:"concurrency_strategy_ids"`
	ConcurrencyKeys              []string           `json:"concurrency_keys"`
	RetryBackoffFactor           pgtype.Float8      `json:"retry_backoff_factor"`
	RetryMaxBackoff              pgtype.Int4        `json:"retry_max_backoff"`
}

type V1TaskEvent struct {
	ID             int64              `json:"id"`
	TenantID       pgtype.UUID        `json:"tenant_id"`
	TaskID         int64              `json:"task_id"`
	TaskInsertedAt pgtype.Timestamptz `json:"task_inserted_at"`
	RetryCount     int32              `json:"retry_count"`
	EventType      V1TaskEventType    `json:"event_type"`
	EventKey       pgtype.Text        `json:"event_key"`
	CreatedAt      pgtype.Timestamp   `json:"created_at"`
	Data           []byte             `json:"data"`
}

type V1TaskEventsOlap struct {
	TenantID               pgtype.UUID          `json:"tenant_id"`
	ID                     int64                `json:"id"`
	InsertedAt             pgtype.Timestamptz   `json:"inserted_at"`
	TaskID                 int64                `json:"task_id"`
	TaskInsertedAt         pgtype.Timestamptz   `json:"task_inserted_at"`
	EventType              V1EventTypeOlap      `json:"event_type"`
	WorkflowID             pgtype.UUID          `json:"workflow_id"`
	EventTimestamp         pgtype.Timestamptz   `json:"event_timestamp"`
	ReadableStatus         V1ReadableStatusOlap `json:"readable_status"`
	RetryCount             int32                `json:"retry_count"`
	ErrorMessage           pgtype.Text          `json:"error_message"`
	Output                 []byte               `json:"output"`
	WorkerID               pgtype.UUID          `json:"worker_id"`
	AdditionalEventData    pgtype.Text          `json:"additional__event_data"`
	AdditionalEventMessage pgtype.Text          `json:"additional__event_message"`
}

type V1TaskEventsOlapTmp struct {
	TenantID       pgtype.UUID          `json:"tenant_id"`
	RequeueAfter   pgtype.Timestamptz   `json:"requeue_after"`
	RequeueRetries int32                `json:"requeue_retries"`
	ID             int64                `json:"id"`
	TaskID         int64                `json:"task_id"`
	TaskInsertedAt pgtype.Timestamptz   `json:"task_inserted_at"`
	EventType      V1EventTypeOlap      `json:"event_type"`
	ReadableStatus V1ReadableStatusOlap `json:"readable_status"`
	RetryCount     int32                `json:"retry_count"`
	WorkerID       pgtype.UUID          `json:"worker_id"`
}

type V1TaskExpressionEval struct {
	Key            string             `json:"key"`
	TaskID         int64              `json:"task_id"`
	TaskInsertedAt pgtype.Timestamptz `json:"task_inserted_at"`
	ValueStr       pgtype.Text        `json:"value_str"`
	ValueInt       pgtype.Int4        `json:"value_int"`
	Kind           StepExpressionKind `json:"kind"`
}

type V1TaskRuntime struct {
	TaskID         int64              `json:"task_id"`
	TaskInsertedAt pgtype.Timestamptz `json:"task_inserted_at"`
	RetryCount     int32              `json:"retry_count"`
	WorkerID       pgtype.UUID        `json:"worker_id"`
	TenantID       pgtype.UUID        `json:"tenant_id"`
	TimeoutAt      pgtype.Timestamp   `json:"timeout_at"`
}

type V1TaskStatusUpdatesTmp struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	RequeueAfter   pgtype.Timestamptz `json:"requeue_after"`
	RequeueRetries int32              `json:"requeue_retries"`
	ID             int64              `json:"id"`
	DagID          int64              `json:"dag_id"`
	DagInsertedAt  pgtype.Timestamptz `json:"dag_inserted_at"`
}

type V1TasksOlap struct {
	TenantID             pgtype.UUID          `json:"tenant_id"`
	ID                   int64                `json:"id"`
	InsertedAt           pgtype.Timestamptz   `json:"inserted_at"`
	ExternalID           pgtype.UUID          `json:"external_id"`
	Queue                string               `json:"queue"`
	ActionID             string               `json:"action_id"`
	StepID               pgtype.UUID          `json:"step_id"`
	WorkflowID           pgtype.UUID          `json:"workflow_id"`
	WorkflowVersionID    pgtype.UUID          `json:"workflow_version_id"`
	WorkflowRunID        pgtype.UUID          `json:"workflow_run_id"`
	ScheduleTimeout      string               `json:"schedule_timeout"`
	StepTimeout          pgtype.Text          `json:"step_timeout"`
	Priority             pgtype.Int4          `json:"priority"`
	Sticky               V1StickyStrategyOlap `json:"sticky"`
	DesiredWorkerID      pgtype.UUID          `json:"desired_worker_id"`
	DisplayName          string               `json:"display_name"`
	Input                []byte               `json:"input"`
	AdditionalMetadata   []byte               `json:"additional_metadata"`
	ReadableStatus       V1ReadableStatusOlap `json:"readable_status"`
	LatestRetryCount     int32                `json:"latest_retry_count"`
	LatestWorkerID       pgtype.UUID          `json:"latest_worker_id"`
	DagID                pgtype.Int8          `json:"dag_id"`
	DagInsertedAt        pgtype.Timestamptz   `json:"dag_inserted_at"`
	ParentTaskExternalID pgtype.UUID          `json:"parent_task_external_id"`
}

type V1WorkflowConcurrency struct {
	ID                int64                 `json:"id"`
	WorkflowID        pgtype.UUID           `json:"workflow_id"`
	WorkflowVersionID pgtype.UUID           `json:"workflow_version_id"`
	IsActive          bool                  `json:"is_active"`
	Strategy          V1ConcurrencyStrategy `json:"strategy"`
	ChildStrategyIds  []int64               `json:"child_strategy_ids"`
	Expression        string                `json:"expression"`
	TenantID          pgtype.UUID           `json:"tenant_id"`
	MaxConcurrency    int32                 `json:"max_concurrency"`
}

type V1WorkflowConcurrencySlot struct {
	SortID                    int64       `json:"sort_id"`
	TenantID                  pgtype.UUID `json:"tenant_id"`
	WorkflowID                pgtype.UUID `json:"workflow_id"`
	WorkflowVersionID         pgtype.UUID `json:"workflow_version_id"`
	WorkflowRunID             pgtype.UUID `json:"workflow_run_id"`
	StrategyID                int64       `json:"strategy_id"`
	CompletedChildStrategyIds []int64     `json:"completed_child_strategy_ids"`
	ChildStrategyIds          []int64     `json:"child_strategy_ids"`
	Priority                  int32       `json:"priority"`
	Key                       string      `json:"key"`
	IsFilled                  bool        `json:"is_filled"`
}

type WebhookWorker struct {
	ID         pgtype.UUID      `json:"id"`
	CreatedAt  pgtype.Timestamp `json:"createdAt"`
	UpdatedAt  pgtype.Timestamp `json:"updatedAt"`
	Name       string           `json:"name"`
	Secret     string           `json:"secret"`
	Url        string           `json:"url"`
	TokenValue pgtype.Text      `json:"tokenValue"`
	Deleted    bool             `json:"deleted"`
	TokenId    pgtype.UUID      `json:"tokenId"`
	TenantId   pgtype.UUID      `json:"tenantId"`
}

type WebhookWorkerRequest struct {
	ID              pgtype.UUID                `json:"id"`
	CreatedAt       pgtype.Timestamp           `json:"createdAt"`
	WebhookWorkerId pgtype.UUID                `json:"webhookWorkerId"`
	Method          WebhookWorkerRequestMethod `json:"method"`
	StatusCode      int32                      `json:"statusCode"`
}

type WebhookWorkerWorkflow struct {
	ID              pgtype.UUID `json:"id"`
	WebhookWorkerId pgtype.UUID `json:"webhookWorkerId"`
	WorkflowId      pgtype.UUID `json:"workflowId"`
}

type Worker struct {
	ID                      pgtype.UUID      `json:"id"`
	CreatedAt               pgtype.Timestamp `json:"createdAt"`
	UpdatedAt               pgtype.Timestamp `json:"updatedAt"`
	DeletedAt               pgtype.Timestamp `json:"deletedAt"`
	TenantId                pgtype.UUID      `json:"tenantId"`
	LastHeartbeatAt         pgtype.Timestamp `json:"lastHeartbeatAt"`
	Name                    string           `json:"name"`
	DispatcherId            pgtype.UUID      `json:"dispatcherId"`
	MaxRuns                 int32            `json:"maxRuns"`
	IsActive                bool             `json:"isActive"`
	LastListenerEstablished pgtype.Timestamp `json:"lastListenerEstablished"`
	IsPaused                bool             `json:"isPaused"`
	Type                    WorkerType       `json:"type"`
	WebhookId               pgtype.UUID      `json:"webhookId"`
	Language                NullWorkerSDKS   `json:"language"`
	LanguageVersion         pgtype.Text      `json:"languageVersion"`
	Os                      pgtype.Text      `json:"os"`
	RuntimeExtra            pgtype.Text      `json:"runtimeExtra"`
	SdkVersion              pgtype.Text      `json:"sdkVersion"`
}

type WorkerAssignEvent struct {
	ID               int64       `json:"id"`
	WorkerId         pgtype.UUID `json:"workerId"`
	AssignedStepRuns []byte      `json:"assignedStepRuns"`
}

type WorkerLabel struct {
	ID        int64            `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	WorkerId  pgtype.UUID      `json:"workerId"`
	Key       string           `json:"key"`
	StrValue  pgtype.Text      `json:"strValue"`
	IntValue  pgtype.Int4      `json:"intValue"`
}

type Workflow struct {
	ID          pgtype.UUID      `json:"id"`
	CreatedAt   pgtype.Timestamp `json:"createdAt"`
	UpdatedAt   pgtype.Timestamp `json:"updatedAt"`
	DeletedAt   pgtype.Timestamp `json:"deletedAt"`
	TenantId    pgtype.UUID      `json:"tenantId"`
	Name        string           `json:"name"`
	Description pgtype.Text      `json:"description"`
	IsPaused    pgtype.Bool      `json:"isPaused"`
}

type WorkflowConcurrency struct {
	ID                         pgtype.UUID              `json:"id"`
	CreatedAt                  pgtype.Timestamp         `json:"createdAt"`
	UpdatedAt                  pgtype.Timestamp         `json:"updatedAt"`
	WorkflowVersionId          pgtype.UUID              `json:"workflowVersionId"`
	GetConcurrencyGroupId      pgtype.UUID              `json:"getConcurrencyGroupId"`
	MaxRuns                    int32                    `json:"maxRuns"`
	LimitStrategy              ConcurrencyLimitStrategy `json:"limitStrategy"`
	ConcurrencyGroupExpression pgtype.Text              `json:"concurrencyGroupExpression"`
}

type WorkflowRun struct {
	CreatedAt          pgtype.Timestamp  `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp  `json:"updatedAt"`
	DeletedAt          pgtype.Timestamp  `json:"deletedAt"`
	TenantId           pgtype.UUID       `json:"tenantId"`
	WorkflowVersionId  pgtype.UUID       `json:"workflowVersionId"`
	Status             WorkflowRunStatus `json:"status"`
	Error              pgtype.Text       `json:"error"`
	StartedAt          pgtype.Timestamp  `json:"startedAt"`
	FinishedAt         pgtype.Timestamp  `json:"finishedAt"`
	ConcurrencyGroupId pgtype.Text       `json:"concurrencyGroupId"`
	DisplayName        pgtype.Text       `json:"displayName"`
	ID                 pgtype.UUID       `json:"id"`
	ChildIndex         pgtype.Int4       `json:"childIndex"`
	ChildKey           pgtype.Text       `json:"childKey"`
	ParentId           pgtype.UUID       `json:"parentId"`
	ParentStepRunId    pgtype.UUID       `json:"parentStepRunId"`
	AdditionalMetadata []byte            `json:"additionalMetadata"`
	Duration           pgtype.Int8       `json:"duration"`
	Priority           pgtype.Int4       `json:"priority"`
	InsertOrder        pgtype.Int4       `json:"insertOrder"`
}

type WorkflowRunDedupe struct {
	ID            int64            `json:"id"`
	CreatedAt     pgtype.Timestamp `json:"createdAt"`
	UpdatedAt     pgtype.Timestamp `json:"updatedAt"`
	TenantId      pgtype.UUID      `json:"tenantId"`
	WorkflowId    pgtype.UUID      `json:"workflowId"`
	WorkflowRunId pgtype.UUID      `json:"workflowRunId"`
	Value         string           `json:"value"`
}

type WorkflowRunStickyState struct {
	ID              int64            `json:"id"`
	CreatedAt       pgtype.Timestamp `json:"createdAt"`
	UpdatedAt       pgtype.Timestamp `json:"updatedAt"`
	TenantId        pgtype.UUID      `json:"tenantId"`
	WorkflowRunId   pgtype.UUID      `json:"workflowRunId"`
	DesiredWorkerId pgtype.UUID      `json:"desiredWorkerId"`
	Strategy        StickyStrategy   `json:"strategy"`
}

type WorkflowRunTriggeredBy struct {
	ID           pgtype.UUID      `json:"id"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	UpdatedAt    pgtype.Timestamp `json:"updatedAt"`
	DeletedAt    pgtype.Timestamp `json:"deletedAt"`
	TenantId     pgtype.UUID      `json:"tenantId"`
	EventId      pgtype.UUID      `json:"eventId"`
	CronParentId pgtype.UUID      `json:"cronParentId"`
	CronSchedule pgtype.Text      `json:"cronSchedule"`
	ScheduledId  pgtype.UUID      `json:"scheduledId"`
	Input        []byte           `json:"input"`
	ParentId     pgtype.UUID      `json:"parentId"`
	CronName     pgtype.Text      `json:"cronName"`
}

type WorkflowTag struct {
	ID        pgtype.UUID      `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	TenantId  pgtype.UUID      `json:"tenantId"`
	Name      string           `json:"name"`
	Color     string           `json:"color"`
}

type WorkflowToWorkflowTag struct {
	A pgtype.UUID `json:"A"`
	B pgtype.UUID `json:"B"`
}

type WorkflowTriggerCronRef struct {
	ParentId           pgtype.UUID                   `json:"parentId"`
	Cron               string                        `json:"cron"`
	TickerId           pgtype.UUID                   `json:"tickerId"`
	Input              []byte                        `json:"input"`
	Enabled            bool                          `json:"enabled"`
	AdditionalMetadata []byte                        `json:"additionalMetadata"`
	CreatedAt          pgtype.Timestamp              `json:"createdAt"`
	DeletedAt          pgtype.Timestamp              `json:"deletedAt"`
	UpdatedAt          pgtype.Timestamp              `json:"updatedAt"`
	Name               pgtype.Text                   `json:"name"`
	ID                 pgtype.UUID                   `json:"id"`
	Method             WorkflowTriggerCronRefMethods `json:"method"`
}

type WorkflowTriggerEventRef struct {
	ParentId pgtype.UUID `json:"parentId"`
	EventKey string      `json:"eventKey"`
}

type WorkflowTriggerScheduledRef struct {
	ID                  pgtype.UUID                        `json:"id"`
	ParentId            pgtype.UUID                        `json:"parentId"`
	TriggerAt           pgtype.Timestamp                   `json:"triggerAt"`
	TickerId            pgtype.UUID                        `json:"tickerId"`
	Input               []byte                             `json:"input"`
	ChildIndex          pgtype.Int4                        `json:"childIndex"`
	ChildKey            pgtype.Text                        `json:"childKey"`
	ParentStepRunId     pgtype.UUID                        `json:"parentStepRunId"`
	ParentWorkflowRunId pgtype.UUID                        `json:"parentWorkflowRunId"`
	AdditionalMetadata  []byte                             `json:"additionalMetadata"`
	CreatedAt           pgtype.Timestamp                   `json:"createdAt"`
	DeletedAt           pgtype.Timestamp                   `json:"deletedAt"`
	UpdatedAt           pgtype.Timestamp                   `json:"updatedAt"`
	Method              WorkflowTriggerScheduledRefMethods `json:"method"`
}

type WorkflowTriggers struct {
	ID                pgtype.UUID      `json:"id"`
	CreatedAt         pgtype.Timestamp `json:"createdAt"`
	UpdatedAt         pgtype.Timestamp `json:"updatedAt"`
	DeletedAt         pgtype.Timestamp `json:"deletedAt"`
	WorkflowVersionId pgtype.UUID      `json:"workflowVersionId"`
	TenantId          pgtype.UUID      `json:"tenantId"`
}

type WorkflowVersion struct {
	ID              pgtype.UUID        `json:"id"`
	CreatedAt       pgtype.Timestamp   `json:"createdAt"`
	UpdatedAt       pgtype.Timestamp   `json:"updatedAt"`
	DeletedAt       pgtype.Timestamp   `json:"deletedAt"`
	Version         pgtype.Text        `json:"version"`
	Order           int64              `json:"order"`
	WorkflowId      pgtype.UUID        `json:"workflowId"`
	Checksum        string             `json:"checksum"`
	ScheduleTimeout string             `json:"scheduleTimeout"`
	OnFailureJobId  pgtype.UUID        `json:"onFailureJobId"`
	Sticky          NullStickyStrategy `json:"sticky"`
	Kind            WorkflowKind       `json:"kind"`
	DefaultPriority pgtype.Int4        `json:"defaultPriority"`
}
