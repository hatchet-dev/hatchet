// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: workers.sql

package sqlcv1

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getWorkerById = `-- name: GetWorkerById :one
SELECT
    w.id, w."createdAt", w."updatedAt", w."deletedAt", w."tenantId", w."lastHeartbeatAt", w.name, w."dispatcherId", w."maxRuns", w."isActive", w."lastListenerEstablished", w."isPaused", w.type, w."webhookId", w.language, w."languageVersion", w.os, w."runtimeExtra", w."sdkVersion",
    ww."url" AS "webhookUrl",
    w."maxRuns" - (
        SELECT COUNT(*)
        FROM v1_task_runtime runtime
        WHERE
            runtime.tenant_id = w."tenantId" AND
            runtime.worker_id = w."id"
    ) AS "remainingSlots"
FROM
    "Worker" w
LEFT JOIN
    "WebhookWorker" ww ON w."webhookId" = ww."id"
WHERE
    w."id" = $1::uuid
`

type GetWorkerByIdRow struct {
	Worker         Worker      `json:"worker"`
	WebhookUrl     pgtype.Text `json:"webhookUrl"`
	RemainingSlots int32       `json:"remainingSlots"`
}

func (q *Queries) GetWorkerById(ctx context.Context, db DBTX, id pgtype.UUID) (*GetWorkerByIdRow, error) {
	row := db.QueryRow(ctx, getWorkerById, id)
	var i GetWorkerByIdRow
	err := row.Scan(
		&i.Worker.ID,
		&i.Worker.CreatedAt,
		&i.Worker.UpdatedAt,
		&i.Worker.DeletedAt,
		&i.Worker.TenantId,
		&i.Worker.LastHeartbeatAt,
		&i.Worker.Name,
		&i.Worker.DispatcherId,
		&i.Worker.MaxRuns,
		&i.Worker.IsActive,
		&i.Worker.LastListenerEstablished,
		&i.Worker.IsPaused,
		&i.Worker.Type,
		&i.Worker.WebhookId,
		&i.Worker.Language,
		&i.Worker.LanguageVersion,
		&i.Worker.Os,
		&i.Worker.RuntimeExtra,
		&i.Worker.SdkVersion,
		&i.WebhookUrl,
		&i.RemainingSlots,
	)
	return &i, err
}

const listManyWorkerLabels = `-- name: ListManyWorkerLabels :many
SELECT
    "id",
    "key",
    "intValue",
    "strValue",
    "createdAt",
    "updatedAt",
    "workerId"
FROM "WorkerLabel" wl
WHERE wl."workerId" = ANY($1::uuid[])
`

type ListManyWorkerLabelsRow struct {
	ID        int64            `json:"id"`
	Key       string           `json:"key"`
	IntValue  pgtype.Int4      `json:"intValue"`
	StrValue  pgtype.Text      `json:"strValue"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	WorkerId  pgtype.UUID      `json:"workerId"`
}

func (q *Queries) ListManyWorkerLabels(ctx context.Context, db DBTX, workerids []pgtype.UUID) ([]*ListManyWorkerLabelsRow, error) {
	rows, err := db.Query(ctx, listManyWorkerLabels, workerids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListManyWorkerLabelsRow
	for rows.Next() {
		var i ListManyWorkerLabelsRow
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.IntValue,
			&i.StrValue,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WorkerId,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSemaphoreSlotsWithStateForWorker = `-- name: ListSemaphoreSlotsWithStateForWorker :many
SELECT
    task_id, task_inserted_at, runtime.retry_count, worker_id, runtime.tenant_id, timeout_at, id, inserted_at, v1_task.tenant_id, queue, action_id, step_id, step_readable_id, workflow_id, workflow_version_id, workflow_run_id, schedule_timeout, step_timeout, priority, sticky, desired_worker_id, external_id, display_name, input, v1_task.retry_count, internal_retry_count, app_retry_count, step_index, additional_metadata, dag_id, dag_inserted_at, parent_task_external_id, parent_task_id, parent_task_inserted_at, child_index, child_key, initial_state, initial_state_reason, concurrency_parent_strategy_ids, concurrency_strategy_ids, concurrency_keys, retry_backoff_factor, retry_max_backoff
FROM
    v1_task_runtime runtime
JOIN
    v1_task ON runtime.task_id = v1_task.id AND runtime.task_inserted_at = v1_task.inserted_at
WHERE
    runtime.tenant_id = $1::uuid
    AND runtime.worker_id = $2::uuid
LIMIT
    COALESCE($3::int, 100)
`

type ListSemaphoreSlotsWithStateForWorkerParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Workerid pgtype.UUID `json:"workerid"`
	Limit    pgtype.Int4 `json:"limit"`
}

type ListSemaphoreSlotsWithStateForWorkerRow struct {
	TaskID                       int64              `json:"task_id"`
	TaskInsertedAt               pgtype.Timestamptz `json:"task_inserted_at"`
	RetryCount                   int32              `json:"retry_count"`
	WorkerID                     pgtype.UUID        `json:"worker_id"`
	TenantID                     pgtype.UUID        `json:"tenant_id"`
	TimeoutAt                    pgtype.Timestamp   `json:"timeout_at"`
	ID                           int64              `json:"id"`
	InsertedAt                   pgtype.Timestamptz `json:"inserted_at"`
	TenantID_2                   pgtype.UUID        `json:"tenant_id_2"`
	Queue                        string             `json:"queue"`
	ActionID                     string             `json:"action_id"`
	StepID                       pgtype.UUID        `json:"step_id"`
	StepReadableID               string             `json:"step_readable_id"`
	WorkflowID                   pgtype.UUID        `json:"workflow_id"`
	WorkflowVersionID            pgtype.UUID        `json:"workflow_version_id"`
	WorkflowRunID                pgtype.UUID        `json:"workflow_run_id"`
	ScheduleTimeout              string             `json:"schedule_timeout"`
	StepTimeout                  pgtype.Text        `json:"step_timeout"`
	Priority                     pgtype.Int4        `json:"priority"`
	Sticky                       V1StickyStrategy   `json:"sticky"`
	DesiredWorkerID              pgtype.UUID        `json:"desired_worker_id"`
	ExternalID                   pgtype.UUID        `json:"external_id"`
	DisplayName                  string             `json:"display_name"`
	Input                        []byte             `json:"input"`
	RetryCount_2                 int32              `json:"retry_count_2"`
	InternalRetryCount           int32              `json:"internal_retry_count"`
	AppRetryCount                int32              `json:"app_retry_count"`
	StepIndex                    int64              `json:"step_index"`
	AdditionalMetadata           []byte             `json:"additional_metadata"`
	DagID                        pgtype.Int8        `json:"dag_id"`
	DagInsertedAt                pgtype.Timestamptz `json:"dag_inserted_at"`
	ParentTaskExternalID         pgtype.UUID        `json:"parent_task_external_id"`
	ParentTaskID                 pgtype.Int8        `json:"parent_task_id"`
	ParentTaskInsertedAt         pgtype.Timestamptz `json:"parent_task_inserted_at"`
	ChildIndex                   pgtype.Int8        `json:"child_index"`
	ChildKey                     pgtype.Text        `json:"child_key"`
	InitialState                 V1TaskInitialState `json:"initial_state"`
	InitialStateReason           pgtype.Text        `json:"initial_state_reason"`
	ConcurrencyParentStrategyIds []pgtype.Int8      `json:"concurrency_parent_strategy_ids"`
	ConcurrencyStrategyIds       []int64            `json:"concurrency_strategy_ids"`
	ConcurrencyKeys              []string           `json:"concurrency_keys"`
	RetryBackoffFactor           pgtype.Float8      `json:"retry_backoff_factor"`
	RetryMaxBackoff              pgtype.Int4        `json:"retry_max_backoff"`
}

func (q *Queries) ListSemaphoreSlotsWithStateForWorker(ctx context.Context, db DBTX, arg ListSemaphoreSlotsWithStateForWorkerParams) ([]*ListSemaphoreSlotsWithStateForWorkerRow, error) {
	rows, err := db.Query(ctx, listSemaphoreSlotsWithStateForWorker, arg.Tenantid, arg.Workerid, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListSemaphoreSlotsWithStateForWorkerRow
	for rows.Next() {
		var i ListSemaphoreSlotsWithStateForWorkerRow
		if err := rows.Scan(
			&i.TaskID,
			&i.TaskInsertedAt,
			&i.RetryCount,
			&i.WorkerID,
			&i.TenantID,
			&i.TimeoutAt,
			&i.ID,
			&i.InsertedAt,
			&i.TenantID_2,
			&i.Queue,
			&i.ActionID,
			&i.StepID,
			&i.StepReadableID,
			&i.WorkflowID,
			&i.WorkflowVersionID,
			&i.WorkflowRunID,
			&i.ScheduleTimeout,
			&i.StepTimeout,
			&i.Priority,
			&i.Sticky,
			&i.DesiredWorkerID,
			&i.ExternalID,
			&i.DisplayName,
			&i.Input,
			&i.RetryCount_2,
			&i.InternalRetryCount,
			&i.AppRetryCount,
			&i.StepIndex,
			&i.AdditionalMetadata,
			&i.DagID,
			&i.DagInsertedAt,
			&i.ParentTaskExternalID,
			&i.ParentTaskID,
			&i.ParentTaskInsertedAt,
			&i.ChildIndex,
			&i.ChildKey,
			&i.InitialState,
			&i.InitialStateReason,
			&i.ConcurrencyParentStrategyIds,
			&i.ConcurrencyStrategyIds,
			&i.ConcurrencyKeys,
			&i.RetryBackoffFactor,
			&i.RetryMaxBackoff,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkersWithSlotCount = `-- name: ListWorkersWithSlotCount :many
SELECT
    workers.id, workers."createdAt", workers."updatedAt", workers."deletedAt", workers."tenantId", workers."lastHeartbeatAt", workers.name, workers."dispatcherId", workers."maxRuns", workers."isActive", workers."lastListenerEstablished", workers."isPaused", workers.type, workers."webhookId", workers.language, workers."languageVersion", workers.os, workers."runtimeExtra", workers."sdkVersion",
    ww."url" AS "webhookUrl",
    ww."id" AS "webhookId",
    workers."maxRuns" - (
        SELECT COUNT(*)
        FROM v1_task_runtime runtime
        WHERE
            runtime.tenant_id = workers."tenantId" AND
            runtime.worker_id = workers."id"
    ) AS "remainingSlots"
FROM
    "Worker" workers
LEFT JOIN
    "WebhookWorker" ww ON workers."webhookId" = ww."id"
WHERE
    workers."tenantId" = $1
    AND (
        $2::text IS NULL OR
        workers."id" IN (
            SELECT "_ActionToWorker"."B"
            FROM "_ActionToWorker"
            INNER JOIN "Action" ON "Action"."id" = "_ActionToWorker"."A"
            WHERE "Action"."tenantId" = $1 AND "Action"."actionId" = $2::text
        )
    )
    AND (
        $3::timestamp IS NULL OR
        workers."lastHeartbeatAt" > $3::timestamp
    )
    AND (
        $4::boolean IS NULL OR
        workers."maxRuns" IS NULL OR
        ($4::boolean AND workers."maxRuns" > (
            SELECT COUNT(*)
            FROM "StepRun" srs
            WHERE srs."workerId" = workers."id" AND srs."status" = 'RUNNING'
        ))
    )
GROUP BY
    workers."id", ww."url", ww."id"
`

type ListWorkersWithSlotCountParams struct {
	Tenantid           pgtype.UUID      `json:"tenantid"`
	ActionId           pgtype.Text      `json:"actionId"`
	LastHeartbeatAfter pgtype.Timestamp `json:"lastHeartbeatAfter"`
	Assignable         pgtype.Bool      `json:"assignable"`
}

type ListWorkersWithSlotCountRow struct {
	Worker         Worker      `json:"worker"`
	WebhookUrl     pgtype.Text `json:"webhookUrl"`
	WebhookId      pgtype.UUID `json:"webhookId"`
	RemainingSlots int32       `json:"remainingSlots"`
}

func (q *Queries) ListWorkersWithSlotCount(ctx context.Context, db DBTX, arg ListWorkersWithSlotCountParams) ([]*ListWorkersWithSlotCountRow, error) {
	rows, err := db.Query(ctx, listWorkersWithSlotCount,
		arg.Tenantid,
		arg.ActionId,
		arg.LastHeartbeatAfter,
		arg.Assignable,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListWorkersWithSlotCountRow
	for rows.Next() {
		var i ListWorkersWithSlotCountRow
		if err := rows.Scan(
			&i.Worker.ID,
			&i.Worker.CreatedAt,
			&i.Worker.UpdatedAt,
			&i.Worker.DeletedAt,
			&i.Worker.TenantId,
			&i.Worker.LastHeartbeatAt,
			&i.Worker.Name,
			&i.Worker.DispatcherId,
			&i.Worker.MaxRuns,
			&i.Worker.IsActive,
			&i.Worker.LastListenerEstablished,
			&i.Worker.IsPaused,
			&i.Worker.Type,
			&i.Worker.WebhookId,
			&i.Worker.Language,
			&i.Worker.LanguageVersion,
			&i.Worker.Os,
			&i.Worker.RuntimeExtra,
			&i.Worker.SdkVersion,
			&i.WebhookUrl,
			&i.WebhookId,
			&i.RemainingSlots,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
