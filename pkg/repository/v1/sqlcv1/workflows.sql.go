// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: workflows.sql

package sqlcv1

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listStepExpressions = `-- name: ListStepExpressions :many
SELECT
    key, "stepId", expression, kind
FROM
    "StepExpression"
WHERE
    "stepId" = ANY($1::uuid[])
`

func (q *Queries) ListStepExpressions(ctx context.Context, db DBTX, stepids []pgtype.UUID) ([]*StepExpression, error) {
	rows, err := db.Query(ctx, listStepExpressions, stepids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*StepExpression
	for rows.Next() {
		var i StepExpression
		if err := rows.Scan(
			&i.Key,
			&i.StepId,
			&i.Expression,
			&i.Kind,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepsByIds = `-- name: ListStepsByIds :many
SELECT
    s.id, s."createdAt", s."updatedAt", s."deletedAt", s."readableId", s."tenantId", s."jobId", s."actionId", s.timeout, s."customUserData", s.retries, s."retryBackoffFactor", s."retryMaxBackoff", s."scheduleTimeout",
    wv."id" as "workflowVersionId",
    w."name" as "workflowName",
    w."id" as "workflowId",
    COUNT(sc.id) as "concurrencyCount"
FROM
    "Step" s
JOIN
    "Job" j ON j."id" = s."jobId"
JOIN
    "WorkflowVersion" wv ON wv."id" = j."workflowVersionId"
JOIN
    "Workflow" w ON w."id" = wv."workflowId"
LEFT JOIN
    v1_step_concurrency sc ON sc.workflow_id = w."id" AND sc.step_id = s."id"
WHERE
    s."id" = ANY($1::uuid[])
    AND w."tenantId" = $2::uuid
    AND w."deletedAt" IS NULL
    AND wv."deletedAt" IS NULL
GROUP BY
    s."id", wv."id", w."name", w."id"
`

type ListStepsByIdsParams struct {
	Ids      []pgtype.UUID `json:"ids"`
	Tenantid pgtype.UUID   `json:"tenantid"`
}

type ListStepsByIdsRow struct {
	ID                 pgtype.UUID      `json:"id"`
	CreatedAt          pgtype.Timestamp `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	DeletedAt          pgtype.Timestamp `json:"deletedAt"`
	ReadableId         pgtype.Text      `json:"readableId"`
	TenantId           pgtype.UUID      `json:"tenantId"`
	JobId              pgtype.UUID      `json:"jobId"`
	ActionId           string           `json:"actionId"`
	Timeout            pgtype.Text      `json:"timeout"`
	CustomUserData     []byte           `json:"customUserData"`
	Retries            int32            `json:"retries"`
	RetryBackoffFactor pgtype.Float8    `json:"retryBackoffFactor"`
	RetryMaxBackoff    pgtype.Int4      `json:"retryMaxBackoff"`
	ScheduleTimeout    string           `json:"scheduleTimeout"`
	WorkflowVersionId  pgtype.UUID      `json:"workflowVersionId"`
	WorkflowName       string           `json:"workflowName"`
	WorkflowId         pgtype.UUID      `json:"workflowId"`
	ConcurrencyCount   int64            `json:"concurrencyCount"`
}

func (q *Queries) ListStepsByIds(ctx context.Context, db DBTX, arg ListStepsByIdsParams) ([]*ListStepsByIdsRow, error) {
	rows, err := db.Query(ctx, listStepsByIds, arg.Ids, arg.Tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListStepsByIdsRow
	for rows.Next() {
		var i ListStepsByIdsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ReadableId,
			&i.TenantId,
			&i.JobId,
			&i.ActionId,
			&i.Timeout,
			&i.CustomUserData,
			&i.Retries,
			&i.RetryBackoffFactor,
			&i.RetryMaxBackoff,
			&i.ScheduleTimeout,
			&i.WorkflowVersionId,
			&i.WorkflowName,
			&i.WorkflowId,
			&i.ConcurrencyCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStepsByWorkflowVersionIds = `-- name: ListStepsByWorkflowVersionIds :many
WITH steps AS (
    SELECT
        s.id, s."createdAt", s."updatedAt", s."deletedAt", s."readableId", s."tenantId", s."jobId", s."actionId", s.timeout, s."customUserData", s.retries, s."retryBackoffFactor", s."retryMaxBackoff", s."scheduleTimeout",
        wv."id" as "workflowVersionId",
        w."name" as "workflowName",
        w."id" as "workflowId",
        j."kind" as "jobKind"
    FROM
        "WorkflowVersion" as wv
    JOIN
        "Workflow" as w ON w."id" = wv."workflowId"
    JOIN
        "Job" j ON j."workflowVersionId" = wv."id"
    JOIN
        "Step" s ON s."jobId" = j."id"
    WHERE
        wv."id" = ANY($1::uuid[])
        AND w."tenantId" = $2::uuid
        AND w."deletedAt" IS NULL
        AND wv."deletedAt" IS NULL
), step_orders AS (
    SELECT
        so."B" as "stepId",
        array_agg(so."A")::uuid[] as "parents"
    FROM
        steps
    JOIN
        "_StepOrder" so ON so."B" = steps."id"
    GROUP BY
        so."B"
)
SELECT
    s.id, s."createdAt", s."updatedAt", s."deletedAt", s."readableId", s."tenantId", s."jobId", s."actionId", s.timeout, s."customUserData", s.retries, s."retryBackoffFactor", s."retryMaxBackoff", s."scheduleTimeout", s."workflowVersionId", s."workflowName", s."workflowId", s."jobKind",
    COALESCE(so."parents", '{}'::uuid[]) as "parents"
FROM
    steps s
LEFT JOIN
    step_orders so ON so."stepId" = s."id"
`

type ListStepsByWorkflowVersionIdsParams struct {
	Ids      []pgtype.UUID `json:"ids"`
	Tenantid pgtype.UUID   `json:"tenantid"`
}

type ListStepsByWorkflowVersionIdsRow struct {
	ID                 pgtype.UUID      `json:"id"`
	CreatedAt          pgtype.Timestamp `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	DeletedAt          pgtype.Timestamp `json:"deletedAt"`
	ReadableId         pgtype.Text      `json:"readableId"`
	TenantId           pgtype.UUID      `json:"tenantId"`
	JobId              pgtype.UUID      `json:"jobId"`
	ActionId           string           `json:"actionId"`
	Timeout            pgtype.Text      `json:"timeout"`
	CustomUserData     []byte           `json:"customUserData"`
	Retries            int32            `json:"retries"`
	RetryBackoffFactor pgtype.Float8    `json:"retryBackoffFactor"`
	RetryMaxBackoff    pgtype.Int4      `json:"retryMaxBackoff"`
	ScheduleTimeout    string           `json:"scheduleTimeout"`
	WorkflowVersionId  pgtype.UUID      `json:"workflowVersionId"`
	WorkflowName       string           `json:"workflowName"`
	WorkflowId         pgtype.UUID      `json:"workflowId"`
	JobKind            JobKind          `json:"jobKind"`
	Parents            []pgtype.UUID    `json:"parents"`
}

func (q *Queries) ListStepsByWorkflowVersionIds(ctx context.Context, db DBTX, arg ListStepsByWorkflowVersionIdsParams) ([]*ListStepsByWorkflowVersionIdsRow, error) {
	rows, err := db.Query(ctx, listStepsByWorkflowVersionIds, arg.Ids, arg.Tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListStepsByWorkflowVersionIdsRow
	for rows.Next() {
		var i ListStepsByWorkflowVersionIdsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ReadableId,
			&i.TenantId,
			&i.JobId,
			&i.ActionId,
			&i.Timeout,
			&i.CustomUserData,
			&i.Retries,
			&i.RetryBackoffFactor,
			&i.RetryMaxBackoff,
			&i.ScheduleTimeout,
			&i.WorkflowVersionId,
			&i.WorkflowName,
			&i.WorkflowId,
			&i.JobKind,
			&i.Parents,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
