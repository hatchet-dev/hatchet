// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: tasks.sql

package sqlcv1

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createConcurrencyPartition = `-- name: CreateConcurrencyPartition :exec
SELECT create_v1_range_partition(
    'v1_concurrency_slot',
    $1::date
)
`

func (q *Queries) CreateConcurrencyPartition(ctx context.Context, db DBTX, date pgtype.Date) error {
	_, err := db.Exec(ctx, createConcurrencyPartition, date)
	return err
}

const createTaskPartition = `-- name: CreateTaskPartition :exec
SELECT create_v1_range_partition(
    'v1_task',
    $1::date
)
`

func (q *Queries) CreateTaskPartition(ctx context.Context, db DBTX, date pgtype.Date) error {
	_, err := db.Exec(ctx, createTaskPartition, date)
	return err
}

const failTaskAppFailure = `-- name: FailTaskAppFailure :many
WITH locked_tasks AS (
    SELECT
        id,
        step_id
    FROM
        v1_task
    WHERE
        id = ANY($1::bigint[])
        AND tenant_id = $2::uuid
    -- order by the task id to get a stable lock order
    ORDER BY
        id
    FOR UPDATE
), tasks_to_steps AS (
    SELECT
        t.id,
        t.step_id,
        s."retries"
    FROM
        locked_tasks t
    JOIN
        "Step" s ON s."id" = t.step_id
)
UPDATE
    v1_task
SET
    retry_count = retry_count + 1,
    app_retry_count = app_retry_count + 1
FROM
    tasks_to_steps
WHERE
    v1_task.id = tasks_to_steps.id
    AND tasks_to_steps."retries" > v1_task.app_retry_count
RETURNING
    v1_task.id,
    v1_task.retry_count
`

type FailTaskAppFailureParams struct {
	Taskids  []int64     `json:"taskids"`
	Tenantid pgtype.UUID `json:"tenantid"`
}

type FailTaskAppFailureRow struct {
	ID         int64 `json:"id"`
	RetryCount int32 `json:"retry_count"`
}

// Fails a task due to an application-level error
func (q *Queries) FailTaskAppFailure(ctx context.Context, db DBTX, arg FailTaskAppFailureParams) ([]*FailTaskAppFailureRow, error) {
	rows, err := db.Query(ctx, failTaskAppFailure, arg.Taskids, arg.Tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FailTaskAppFailureRow
	for rows.Next() {
		var i FailTaskAppFailureRow
		if err := rows.Scan(&i.ID, &i.RetryCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const failTaskInternalFailure = `-- name: FailTaskInternalFailure :many
WITH locked_tasks AS (
    SELECT
        id
    FROM
        v1_task
    WHERE
        id = ANY($2::bigint[])
        AND tenant_id = $3::uuid
    -- order by the task id to get a stable lock order
    ORDER BY
        id
    FOR UPDATE
)
UPDATE
    v1_task
SET
    retry_count = retry_count + 1,
    internal_retry_count = internal_retry_count + 1
FROM
    locked_tasks
WHERE
    v1_task.id = locked_tasks.id
    AND $1::int > v1_task.internal_retry_count
RETURNING
    v1_task.id,
    v1_task.retry_count
`

type FailTaskInternalFailureParams struct {
	Maxinternalretries int32       `json:"maxinternalretries"`
	Taskids            []int64     `json:"taskids"`
	Tenantid           pgtype.UUID `json:"tenantid"`
}

type FailTaskInternalFailureRow struct {
	ID         int64 `json:"id"`
	RetryCount int32 `json:"retry_count"`
}

// Fails a task due to an application-level error
func (q *Queries) FailTaskInternalFailure(ctx context.Context, db DBTX, arg FailTaskInternalFailureParams) ([]*FailTaskInternalFailureRow, error) {
	rows, err := db.Query(ctx, failTaskInternalFailure, arg.Maxinternalretries, arg.Taskids, arg.Tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FailTaskInternalFailureRow
	for rows.Next() {
		var i FailTaskInternalFailureRow
		if err := rows.Scan(&i.ID, &i.RetryCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConcurrencyPartitionsBeforeDate = `-- name: ListConcurrencyPartitionsBeforeDate :many
SELECT
    p::text AS partition_name
FROM
    get_v1_partitions_before_date(
        'v1_concurrency_slot',
        $1::date
    ) AS p
`

func (q *Queries) ListConcurrencyPartitionsBeforeDate(ctx context.Context, db DBTX, date pgtype.Date) ([]string, error) {
	rows, err := db.Query(ctx, listConcurrencyPartitionsBeforeDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var partition_name string
		if err := rows.Scan(&partition_name); err != nil {
			return nil, err
		}
		items = append(items, partition_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMatchingSignalEvents = `-- name: ListMatchingSignalEvents :many
WITH input AS (
    SELECT
        task_id, signal_key
    FROM
        (
            SELECT
                unnest($3::bigint[]) AS task_id,
                unnest($4::text[]) AS signal_key
        ) AS subquery
)
SELECT
    e.id, e.tenant_id, e.task_id, e.retry_count, e.event_type, e.event_key, e.created_at, e.data
FROM
    v1_task_event e
JOIN
    input i ON i.task_id = e.task_id AND i.signal_key = e.event_key
WHERE
    e.tenant_id = $1::uuid
    AND e.event_type = $2::v1_task_event_type
`

type ListMatchingSignalEventsParams struct {
	Tenantid   pgtype.UUID     `json:"tenantid"`
	Eventtype  V1TaskEventType `json:"eventtype"`
	Taskids    []int64         `json:"taskids"`
	Signalkeys []string        `json:"signalkeys"`
}

func (q *Queries) ListMatchingSignalEvents(ctx context.Context, db DBTX, arg ListMatchingSignalEventsParams) ([]*V1TaskEvent, error) {
	rows, err := db.Query(ctx, listMatchingSignalEvents,
		arg.Tenantid,
		arg.Eventtype,
		arg.Taskids,
		arg.Signalkeys,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V1TaskEvent
	for rows.Next() {
		var i V1TaskEvent
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.TaskID,
			&i.RetryCount,
			&i.EventType,
			&i.EventKey,
			&i.CreatedAt,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTaskMetas = `-- name: ListTaskMetas :many
SELECT
    id,
    inserted_at,
    external_id,
    retry_count,
    workflow_id
FROM
    v1_task
WHERE
    tenant_id = $1
    AND id = ANY($2::bigint[])
`

type ListTaskMetasParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Ids      []int64     `json:"ids"`
}

type ListTaskMetasRow struct {
	ID         int64              `json:"id"`
	InsertedAt pgtype.Timestamptz `json:"inserted_at"`
	ExternalID pgtype.UUID        `json:"external_id"`
	RetryCount int32              `json:"retry_count"`
	WorkflowID pgtype.UUID        `json:"workflow_id"`
}

func (q *Queries) ListTaskMetas(ctx context.Context, db DBTX, arg ListTaskMetasParams) ([]*ListTaskMetasRow, error) {
	rows, err := db.Query(ctx, listTaskMetas, arg.TenantID, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListTaskMetasRow
	for rows.Next() {
		var i ListTaskMetasRow
		if err := rows.Scan(
			&i.ID,
			&i.InsertedAt,
			&i.ExternalID,
			&i.RetryCount,
			&i.WorkflowID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTaskPartitionsBeforeDate = `-- name: ListTaskPartitionsBeforeDate :many
SELECT
    p::text AS partition_name
FROM
    get_v1_partitions_before_date(
        'v1_task',
        $1::date
    ) AS p
`

func (q *Queries) ListTaskPartitionsBeforeDate(ctx context.Context, db DBTX, date pgtype.Date) ([]string, error) {
	rows, err := db.Query(ctx, listTaskPartitionsBeforeDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var partition_name string
		if err := rows.Scan(&partition_name); err != nil {
			return nil, err
		}
		items = append(items, partition_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT
    id, inserted_at, tenant_id, queue, action_id, step_id, step_readable_id, workflow_id, schedule_timeout, step_timeout, priority, sticky, desired_worker_id, external_id, display_name, input, retry_count, internal_retry_count, app_retry_count, additional_metadata, dag_id, dag_inserted_at, parent_external_id, child_index, child_key, initial_state, initial_state_reason, concurrency_strategy_ids, concurrency_keys, retry_backoff_factor, retry_max_backoff
FROM
    v1_task
WHERE
    tenant_id = $1
    AND id = ANY($2::bigint[])
`

type ListTasksParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Ids      []int64     `json:"ids"`
}

func (q *Queries) ListTasks(ctx context.Context, db DBTX, arg ListTasksParams) ([]*V1Task, error) {
	rows, err := db.Query(ctx, listTasks, arg.TenantID, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V1Task
	for rows.Next() {
		var i V1Task
		if err := rows.Scan(
			&i.ID,
			&i.InsertedAt,
			&i.TenantID,
			&i.Queue,
			&i.ActionID,
			&i.StepID,
			&i.StepReadableID,
			&i.WorkflowID,
			&i.ScheduleTimeout,
			&i.StepTimeout,
			&i.Priority,
			&i.Sticky,
			&i.DesiredWorkerID,
			&i.ExternalID,
			&i.DisplayName,
			&i.Input,
			&i.RetryCount,
			&i.InternalRetryCount,
			&i.AppRetryCount,
			&i.AdditionalMetadata,
			&i.DagID,
			&i.DagInsertedAt,
			&i.ParentExternalID,
			&i.ChildIndex,
			&i.ChildKey,
			&i.InitialState,
			&i.InitialStateReason,
			&i.ConcurrencyStrategyIds,
			&i.ConcurrencyKeys,
			&i.RetryBackoffFactor,
			&i.RetryMaxBackoff,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const processTaskReassignments = `-- name: ProcessTaskReassignments :many
WITH tasks_on_inactive_workers AS (
    SELECT
        runtime.task_id,
        runtime.retry_count,
        runtime.worker_id
    FROM
        "Worker" w
    JOIN
        v1_task_runtime runtime ON w."id" = runtime.worker_id
    WHERE
        w."tenantId" = $1::uuid
        AND w."lastHeartbeatAt" < NOW() - INTERVAL '30 seconds'
    LIMIT
        COALESCE($2::integer, 1000)
), locked_runtimes AS (
    SELECT
        v1_task_runtime.task_id,
        v1_task_runtime.retry_count,
        tasks_on_inactive_workers.worker_id
    FROM
        v1_task_runtime
    JOIN
        tasks_on_inactive_workers ON tasks_on_inactive_workers.task_id = v1_task_runtime.task_id AND tasks_on_inactive_workers.retry_count = v1_task_runtime.retry_count
    ORDER BY
        task_id
    -- We do a SKIP LOCKED because a lock on v1_task_runtime means its being deleted
    FOR UPDATE SKIP LOCKED
), locked_tasks AS (
    SELECT
        v1_task.id,
        v1_task.retry_count,
        locked_runtimes.worker_id
    FROM
        v1_task
    JOIN
        -- NOTE: we only join when retry count matches
        locked_runtimes ON locked_runtimes.task_id = v1_task.id AND locked_runtimes.retry_count = v1_task.retry_count
    -- order by the task id to get a stable lock order
    ORDER BY
        id
    FOR UPDATE
), deleted_runtimes AS (
    DELETE FROM
        v1_task_runtime
    WHERE
        (task_id, retry_count) IN (SELECT task_id, retry_count FROM locked_runtimes)
), update_tasks AS (
    UPDATE
        v1_task
    SET
        retry_count = v1_task.retry_count + 1,
        internal_retry_count = v1_task.internal_retry_count + 1
    FROM
        locked_tasks
    WHERE
        v1_task.id = locked_tasks.id
        AND $3::int > v1_task.internal_retry_count
    RETURNING
        v1_task.id,
        v1_task.retry_count
), updated_tasks AS (
    SELECT
        id, retry_count, worker_id
    FROM
        locked_tasks
    WHERE
        id IN (SELECT id FROM update_tasks)
), failed_tasks AS (
    SELECT
        id, retry_count, worker_id
    FROM
        locked_tasks
    WHERE
        id NOT IN (SELECT id FROM update_tasks)
)
SELECT
    t1.id,
    t1.retry_count,
    t1.worker_id,
    'REASSIGNED' AS "operation"
FROM
    updated_tasks t1
UNION ALL
SELECT
    t2.id,
    t2.retry_count,
    t2.worker_id,
    'FAILED' AS "operation"
FROM
    failed_tasks t2
`

type ProcessTaskReassignmentsParams struct {
	Tenantid           pgtype.UUID `json:"tenantid"`
	Limit              pgtype.Int4 `json:"limit"`
	Maxinternalretries int32       `json:"maxinternalretries"`
}

type ProcessTaskReassignmentsRow struct {
	ID         int64       `json:"id"`
	RetryCount int32       `json:"retry_count"`
	WorkerID   pgtype.UUID `json:"worker_id"`
	Operation  string      `json:"operation"`
}

func (q *Queries) ProcessTaskReassignments(ctx context.Context, db DBTX, arg ProcessTaskReassignmentsParams) ([]*ProcessTaskReassignmentsRow, error) {
	rows, err := db.Query(ctx, processTaskReassignments, arg.Tenantid, arg.Limit, arg.Maxinternalretries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ProcessTaskReassignmentsRow
	for rows.Next() {
		var i ProcessTaskReassignmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.RetryCount,
			&i.WorkerID,
			&i.Operation,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const processTaskTimeouts = `-- name: ProcessTaskTimeouts :many
WITH expired_runtimes AS (
    SELECT
        task_id,
        retry_count,
        worker_id
    FROM
        v1_task_runtime
    WHERE
        tenant_id = $1::uuid
        AND timeout_at <= NOW()
    ORDER BY
        task_id
    LIMIT
        COALESCE($2::integer, 1000)
    FOR UPDATE SKIP LOCKED
), locked_tasks AS (
    SELECT
        v1_task.id,
        v1_task.retry_count,
        v1_task.step_id,
        expired_runtimes.worker_id
    FROM
        v1_task
    JOIN
        -- NOTE: we only join when retry count matches
        expired_runtimes ON expired_runtimes.task_id = v1_task.id AND expired_runtimes.retry_count = v1_task.retry_count
    -- order by the task id to get a stable lock order
    ORDER BY
        id
    FOR UPDATE
), deleted_tqis AS (
    DELETE FROM
        v1_task_runtime
    WHERE
        (task_id, retry_count) IN (SELECT task_id, retry_count FROM expired_runtimes)
), tasks_to_steps AS (
    SELECT
        t.id,
        t.step_id,
        s."retries"
    FROM
        locked_tasks t
    JOIN
        "Step" s ON s."id" = t.step_id
), updated_tasks AS (
    UPDATE
        v1_task
    SET
        retry_count = retry_count + 1,
        app_retry_count = app_retry_count + 1
    FROM
        tasks_to_steps
    WHERE
        v1_task.id = tasks_to_steps.id
        AND tasks_to_steps."retries" > v1_task.app_retry_count
)
SELECT
    id, retry_count, step_id, worker_id
FROM
    locked_tasks
`

type ProcessTaskTimeoutsParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	Limit    pgtype.Int4 `json:"limit"`
}

type ProcessTaskTimeoutsRow struct {
	ID         int64       `json:"id"`
	RetryCount int32       `json:"retry_count"`
	StepID     pgtype.UUID `json:"step_id"`
	WorkerID   pgtype.UUID `json:"worker_id"`
}

func (q *Queries) ProcessTaskTimeouts(ctx context.Context, db DBTX, arg ProcessTaskTimeoutsParams) ([]*ProcessTaskTimeoutsRow, error) {
	rows, err := db.Query(ctx, processTaskTimeouts, arg.Tenantid, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ProcessTaskTimeoutsRow
	for rows.Next() {
		var i ProcessTaskTimeoutsRow
		if err := rows.Scan(
			&i.ID,
			&i.RetryCount,
			&i.StepID,
			&i.WorkerID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const releaseTasks = `-- name: ReleaseTasks :many
WITH input AS (
    SELECT
        task_id, retry_count
    FROM
        (
            SELECT
                unnest($1::bigint[]) AS task_id,
                unnest($2::integer[]) AS retry_count
        ) AS subquery
), runtimes_to_delete AS (
    SELECT
        task_id,
        retry_count,
        worker_id
    FROM
        v1_task_runtime
    WHERE
        (task_id, retry_count) IN (SELECT task_id, retry_count FROM input)
    ORDER BY
        task_id
    FOR UPDATE
), deleted_runtimes AS (
    DELETE FROM
        v1_task_runtime
    WHERE
        (task_id, retry_count) IN (SELECT task_id, retry_count FROM runtimes_to_delete)
)
SELECT
    t.queue,
    t.id,
    t.inserted_at,
    t.external_id,
    t.step_readable_id,
    r.worker_id,
    t.retry_count,
    t.concurrency_strategy_ids
FROM
    v1_task t
JOIN
    runtimes_to_delete r ON r.task_id = t.id AND r.retry_count = t.retry_count
`

type ReleaseTasksParams struct {
	Taskids     []int64 `json:"taskids"`
	Retrycounts []int32 `json:"retrycounts"`
}

type ReleaseTasksRow struct {
	Queue                  string             `json:"queue"`
	ID                     int64              `json:"id"`
	InsertedAt             pgtype.Timestamptz `json:"inserted_at"`
	ExternalID             pgtype.UUID        `json:"external_id"`
	StepReadableID         string             `json:"step_readable_id"`
	WorkerID               pgtype.UUID        `json:"worker_id"`
	RetryCount             int32              `json:"retry_count"`
	ConcurrencyStrategyIds []int64            `json:"concurrency_strategy_ids"`
}

func (q *Queries) ReleaseTasks(ctx context.Context, db DBTX, arg ReleaseTasksParams) ([]*ReleaseTasksRow, error) {
	rows, err := db.Query(ctx, releaseTasks, arg.Taskids, arg.Retrycounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ReleaseTasksRow
	for rows.Next() {
		var i ReleaseTasksRow
		if err := rows.Scan(
			&i.Queue,
			&i.ID,
			&i.InsertedAt,
			&i.ExternalID,
			&i.StepReadableID,
			&i.WorkerID,
			&i.RetryCount,
			&i.ConcurrencyStrategyIds,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
