// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: filters.sql

package sqlcv1

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkUpsertDeclarativeFilters = `-- name: BulkUpsertDeclarativeFilters :many
WITH inputs AS (
    SELECT
        UNNEST($3::TEXT[]) AS scope,
        UNNEST($4::TEXT[]) AS expression,
        UNNEST($5::JSONB[]) AS payload
), deletions AS (
    DELETE FROM v1_filter
    WHERE
        tenant_id = $1::UUID
        AND workflow_id = $2::UUID
        AND is_declarative
)

INSERT INTO v1_filter (
    tenant_id,
    workflow_id,
    scope,
    expression,
    payload,
    is_declarative
)
SELECT
    $1::UUID,
    $2::UUID,
    scope,
    expression,
    payload,
    true
FROM inputs
RETURNING id, tenant_id, workflow_id, scope, expression, payload, payload_hash, is_declarative, inserted_at, updated_at
`

type BulkUpsertDeclarativeFiltersParams struct {
	Tenantid    pgtype.UUID `json:"tenantid"`
	Workflowid  pgtype.UUID `json:"workflowid"`
	Scopes      []string    `json:"scopes"`
	Expressions []string    `json:"expressions"`
	Payloads    [][]byte    `json:"payloads"`
}

// IMPORTANT: This query overwrites all existing declarative filters for a workflow.
// it's intended to be used when the workflow version is created.
func (q *Queries) BulkUpsertDeclarativeFilters(ctx context.Context, db DBTX, arg BulkUpsertDeclarativeFiltersParams) ([]*V1Filter, error) {
	rows, err := db.Query(ctx, bulkUpsertDeclarativeFilters,
		arg.Tenantid,
		arg.Workflowid,
		arg.Scopes,
		arg.Expressions,
		arg.Payloads,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V1Filter
	for rows.Next() {
		var i V1Filter
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.WorkflowID,
			&i.Scope,
			&i.Expression,
			&i.Payload,
			&i.PayloadHash,
			&i.IsDeclarative,
			&i.InsertedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createFilter = `-- name: CreateFilter :one
INSERT INTO v1_filter (
    tenant_id,
    workflow_id,
    scope,
    expression,
    payload,
    is_declarative
) VALUES (
    $1::UUID,
    $2::UUID,
    $3::TEXT,
    $4::TEXT,
    $5::JSONB,
    false
)
RETURNING id, tenant_id, workflow_id, scope, expression, payload, payload_hash, is_declarative, inserted_at, updated_at
`

type CreateFilterParams struct {
	Tenantid   pgtype.UUID `json:"tenantid"`
	Workflowid pgtype.UUID `json:"workflowid"`
	Scope      string      `json:"scope"`
	Expression string      `json:"expression"`
	Payload    []byte      `json:"payload"`
}

func (q *Queries) CreateFilter(ctx context.Context, db DBTX, arg CreateFilterParams) (*V1Filter, error) {
	row := db.QueryRow(ctx, createFilter,
		arg.Tenantid,
		arg.Workflowid,
		arg.Scope,
		arg.Expression,
		arg.Payload,
	)
	var i V1Filter
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.Scope,
		&i.Expression,
		&i.Payload,
		&i.PayloadHash,
		&i.IsDeclarative,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteFilter = `-- name: DeleteFilter :one
DELETE FROM v1_filter
WHERE
    tenant_id = $1::UUID
    AND id = $2::UUID
RETURNING id, tenant_id, workflow_id, scope, expression, payload, payload_hash, is_declarative, inserted_at, updated_at
`

type DeleteFilterParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) DeleteFilter(ctx context.Context, db DBTX, arg DeleteFilterParams) (*V1Filter, error) {
	row := db.QueryRow(ctx, deleteFilter, arg.Tenantid, arg.ID)
	var i V1Filter
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.Scope,
		&i.Expression,
		&i.Payload,
		&i.PayloadHash,
		&i.IsDeclarative,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getFilter = `-- name: GetFilter :one
SELECT id, tenant_id, workflow_id, scope, expression, payload, payload_hash, is_declarative, inserted_at, updated_at
FROM v1_filter
WHERE
    tenant_id = $1::UUID
    AND id = $2::UUID
`

type GetFilterParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) GetFilter(ctx context.Context, db DBTX, arg GetFilterParams) (*V1Filter, error) {
	row := db.QueryRow(ctx, getFilter, arg.Tenantid, arg.ID)
	var i V1Filter
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.Scope,
		&i.Expression,
		&i.Payload,
		&i.PayloadHash,
		&i.IsDeclarative,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listFilterCountsForWorkflows = `-- name: ListFilterCountsForWorkflows :many
WITH inputs AS (
    SELECT UNNEST($2::UUID[]) AS workflow_id
)

SELECT workflow_id, COUNT(*)
FROM v1_filter
WHERE
    tenant_id = $1::UUID
    AND workflow_id = ANY($2::UUID[])
GROUP BY workflow_id
`

type ListFilterCountsForWorkflowsParams struct {
	Tenantid    pgtype.UUID   `json:"tenantid"`
	Workflowids []pgtype.UUID `json:"workflowids"`
}

type ListFilterCountsForWorkflowsRow struct {
	WorkflowID pgtype.UUID `json:"workflow_id"`
	Count      int64       `json:"count"`
}

func (q *Queries) ListFilterCountsForWorkflows(ctx context.Context, db DBTX, arg ListFilterCountsForWorkflowsParams) ([]*ListFilterCountsForWorkflowsRow, error) {
	rows, err := db.Query(ctx, listFilterCountsForWorkflows, arg.Tenantid, arg.Workflowids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListFilterCountsForWorkflowsRow
	for rows.Next() {
		var i ListFilterCountsForWorkflowsRow
		if err := rows.Scan(&i.WorkflowID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilters = `-- name: ListFilters :many
WITH inputs AS (
    SELECT
        UNNEST(COALESCE($4::UUID[], '{}')) AS workflow_id,
        UNNEST(COALESCE($5::TEXT[], '{}')) AS scope
), num_filter_inputs AS (
    SELECT COUNT(*) AS ct
    FROM inputs
    WHERE workflow_id IS NOT NULL AND scope IS NOT NULL
)

SELECT f.id, f.tenant_id, f.workflow_id, f.scope, f.expression, f.payload, f.payload_hash, f.is_declarative, f.inserted_at, f.updated_at
FROM v1_filter f
CROSS JOIN num_filter_inputs n
JOIN inputs i ON (n.ct = 0) OR (f.workflow_id, f.scope) = (i.workflow_id, i.scope)
WHERE f.tenant_id = $1::UUID
ORDER BY f.tenant_id, f.id DESC
LIMIT COALESCE($3::BIGINT, 20000)
OFFSET COALESCE($2::BIGINT, 0)
`

type ListFiltersParams struct {
	Tenantid     pgtype.UUID   `json:"tenantid"`
	FilterOffset pgtype.Int8   `json:"filterOffset"`
	FilterLimit  pgtype.Int8   `json:"filterLimit"`
	Workflowids  []pgtype.UUID `json:"workflowids"`
	Scopes       []string      `json:"scopes"`
}

func (q *Queries) ListFilters(ctx context.Context, db DBTX, arg ListFiltersParams) ([]*V1Filter, error) {
	rows, err := db.Query(ctx, listFilters,
		arg.Tenantid,
		arg.FilterOffset,
		arg.FilterLimit,
		arg.Workflowids,
		arg.Scopes,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V1Filter
	for rows.Next() {
		var i V1Filter
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.WorkflowID,
			&i.Scope,
			&i.Expression,
			&i.Payload,
			&i.PayloadHash,
			&i.IsDeclarative,
			&i.InsertedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFilter = `-- name: UpdateFilter :one
UPDATE v1_filter
SET
    scope = COALESCE($1::TEXT, scope),
    expression = COALESCE($2::TEXT, expression),
    payload = COALESCE($3::JSONB, payload),
    updated_at = NOW()
WHERE
    tenant_id = $4::UUID
    AND id = $5::UUID
RETURNING id, tenant_id, workflow_id, scope, expression, payload, payload_hash, is_declarative, inserted_at, updated_at
`

type UpdateFilterParams struct {
	Scope      pgtype.Text `json:"scope"`
	Expression pgtype.Text `json:"expression"`
	Payload    []byte      `json:"payload"`
	Tenantid   pgtype.UUID `json:"tenantid"`
	ID         pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateFilter(ctx context.Context, db DBTX, arg UpdateFilterParams) (*V1Filter, error) {
	row := db.QueryRow(ctx, updateFilter,
		arg.Scope,
		arg.Expression,
		arg.Payload,
		arg.Tenantid,
		arg.ID,
	)
	var i V1Filter
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.Scope,
		&i.Expression,
		&i.Payload,
		&i.PayloadHash,
		&i.IsDeclarative,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
