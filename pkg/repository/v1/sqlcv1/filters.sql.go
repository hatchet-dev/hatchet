// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: filters.sql

package sqlcv1

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFilter = `-- name: CreateFilter :one
INSERT INTO v1_filter (
    tenant_id,
    workflow_id,
    scope,
    expression,
    payload
) VALUES (
    $1::UUID,
    $2::UUID,
    $3::TEXT,
    $4::TEXT,
    $5::JSONB
)
ON CONFLICT (tenant_id, workflow_id, scope, expression) DO UPDATE
SET
    payload = EXCLUDED.payload,
    updated_at = NOW()
WHERE v1_filter.tenant_id = $1::UUID
  AND v1_filter.workflow_id = $2::UUID
  AND v1_filter.scope = $3::TEXT
  AND v1_filter.expression = $4::TEXT
RETURNING id, tenant_id, workflow_id, scope, expression, payload, inserted_at, updated_at
`

type CreateFilterParams struct {
	Tenantid   pgtype.UUID `json:"tenantid"`
	Workflowid pgtype.UUID `json:"workflowid"`
	Scope      string      `json:"scope"`
	Expression string      `json:"expression"`
	Payload    []byte      `json:"payload"`
}

func (q *Queries) CreateFilter(ctx context.Context, db DBTX, arg CreateFilterParams) (*V1Filter, error) {
	row := db.QueryRow(ctx, createFilter,
		arg.Tenantid,
		arg.Workflowid,
		arg.Scope,
		arg.Expression,
		arg.Payload,
	)
	var i V1Filter
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.Scope,
		&i.Expression,
		&i.Payload,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteFilter = `-- name: DeleteFilter :one
DELETE FROM v1_filter
WHERE
    tenant_id = $1::UUID
    AND id = $2::UUID
RETURNING id, tenant_id, workflow_id, scope, expression, payload, inserted_at, updated_at
`

type DeleteFilterParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) DeleteFilter(ctx context.Context, db DBTX, arg DeleteFilterParams) (*V1Filter, error) {
	row := db.QueryRow(ctx, deleteFilter, arg.Tenantid, arg.ID)
	var i V1Filter
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.Scope,
		&i.Expression,
		&i.Payload,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getFilter = `-- name: GetFilter :one
SELECT id, tenant_id, workflow_id, scope, expression, payload, inserted_at, updated_at
FROM v1_filter
WHERE
    tenant_id = $1::UUID
    AND id = $2::UUID
`

type GetFilterParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) GetFilter(ctx context.Context, db DBTX, arg GetFilterParams) (*V1Filter, error) {
	row := db.QueryRow(ctx, getFilter, arg.Tenantid, arg.ID)
	var i V1Filter
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.Scope,
		&i.Expression,
		&i.Payload,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateFilter = `-- name: UpdateFilter :one
UPDATE v1_filter
SET
    scope = COALESCE($1::TEXT, scope),
    expression = COALESCE($2::TEXT, expression),
    payload = COALESCE($3::JSONB, payload),
    updated_at = NOW()
WHERE
    tenant_id = $4::UUID
    AND id = $5::UUID
RETURNING id, tenant_id, workflow_id, scope, expression, payload, inserted_at, updated_at
`

type UpdateFilterParams struct {
	Scope      pgtype.Text `json:"scope"`
	Expression pgtype.Text `json:"expression"`
	Payload    []byte      `json:"payload"`
	Tenantid   pgtype.UUID `json:"tenantid"`
	ID         pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateFilter(ctx context.Context, db DBTX, arg UpdateFilterParams) (*V1Filter, error) {
	row := db.QueryRow(ctx, updateFilter,
		arg.Scope,
		arg.Expression,
		arg.Payload,
		arg.Tenantid,
		arg.ID,
	)
	var i V1Filter
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.Scope,
		&i.Expression,
		&i.Payload,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
