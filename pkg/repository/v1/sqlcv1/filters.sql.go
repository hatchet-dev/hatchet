// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: filters.sql

package sqlcv1

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFilter = `-- name: CreateFilter :one
WITH latest_version AS (
    SELECT DISTINCT ON (workflowVersions."workflowId")
        workflowVersions."id" AS workflowVersionId,
        workflowVersions."workflowId",
        workflowVersions."order"
    FROM
        "WorkflowVersion" as workflowVersions
    WHERE
        workflowVersions."workflowId" = $2::UUID AND
        workflowVersions."deletedAt" IS NULL
    ORDER BY
        workflowVersions."workflowId", workflowVersions."order" DESC
)

INSERT INTO v1_filter (
    tenant_id,
    workflow_id,
    workflow_version_id,
    resource_hint,
    expression,
    payload
)

SELECT
    $1::UUID AS tenant_id,
    $2::UUID AS workflow_id,
    v.workflowVersionId AS workflow_version_id,
    $3::TEXT AS resource_hint,
    $4::TEXT AS expression,
    COALESCE($5::JSONB, '{}'::JSONB) AS payload
FROM latest_version v
RETURNING id, tenant_id, workflow_id, workflow_version_id, resource_hint, expression, payload
`

type CreateFilterParams struct {
	Tenantid     pgtype.UUID `json:"tenantid"`
	Workflowid   pgtype.UUID `json:"workflowid"`
	Resourcehint string      `json:"resourcehint"`
	Expression   string      `json:"expression"`
	Payload      []byte      `json:"payload"`
}

func (q *Queries) CreateFilter(ctx context.Context, db DBTX, arg CreateFilterParams) (*V1Filter, error) {
	row := db.QueryRow(ctx, createFilter,
		arg.Tenantid,
		arg.Workflowid,
		arg.Resourcehint,
		arg.Expression,
		arg.Payload,
	)
	var i V1Filter
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.WorkflowVersionID,
		&i.ResourceHint,
		&i.Expression,
		&i.Payload,
	)
	return &i, err
}

const listFilters = `-- name: ListFilters :many
WITH inputs AS (
    SELECT
        UNNEST($1::UUID[]) AS tenant_id,
        UNNEST($2::UUID[]) AS workflow_id,
        UNNEST($3::UUID[]) AS workflow_version_id,
        UNNEST($4::TEXT[]) AS resource_hint
)

SELECT id, f.tenant_id, f.workflow_id, f.workflow_version_id, f.resource_hint, expression, payload, i.tenant_id, i.workflow_id, i.workflow_version_id, i.resource_hint
FROM v1_filter f
JOIN inputs i ON (f.tenant_id, f.workflow_id, f.workflow_version_id, f.resource_hint) = (i.tenant_id, i.workflow_id, i.workflow_version_id, i.resource_hint)
`

type ListFiltersParams struct {
	Tenantids          []pgtype.UUID `json:"tenantids"`
	Workflowids        []pgtype.UUID `json:"workflowids"`
	Workflowversionids []pgtype.UUID `json:"workflowversionids"`
	Resourcehints      []string      `json:"resourcehints"`
}

type ListFiltersRow struct {
	ID                  int64       `json:"id"`
	TenantID            pgtype.UUID `json:"tenant_id"`
	WorkflowID          pgtype.UUID `json:"workflow_id"`
	WorkflowVersionID   pgtype.UUID `json:"workflow_version_id"`
	ResourceHint        string      `json:"resource_hint"`
	Expression          string      `json:"expression"`
	Payload             []byte      `json:"payload"`
	TenantID_2          interface{} `json:"tenant_id_2"`
	WorkflowID_2        interface{} `json:"workflow_id_2"`
	WorkflowVersionID_2 interface{} `json:"workflow_version_id_2"`
	ResourceHint_2      interface{} `json:"resource_hint_2"`
}

func (q *Queries) ListFilters(ctx context.Context, db DBTX, arg ListFiltersParams) ([]*ListFiltersRow, error) {
	rows, err := db.Query(ctx, listFilters,
		arg.Tenantids,
		arg.Workflowids,
		arg.Workflowversionids,
		arg.Resourcehints,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListFiltersRow
	for rows.Next() {
		var i ListFiltersRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.WorkflowID,
			&i.WorkflowVersionID,
			&i.ResourceHint,
			&i.Expression,
			&i.Payload,
			&i.TenantID_2,
			&i.WorkflowID_2,
			&i.WorkflowVersionID_2,
			&i.ResourceHint_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
