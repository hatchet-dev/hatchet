// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: payload-store.sql

package sqlcv1

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const finalizePayloadOffloads = `-- name: FinalizePayloadOffloads :exec
WITH inputs AS (
    SELECT
        UNNEST($1::BIGINT[]) AS id,
        UNNEST($2::TIMESTAMPTZ[]) AS inserted_at,
        UNNEST(CAST($3::TEXT[] AS v1_payload_type[])) AS type,
        UNNEST($4::TIMESTAMPTZ[]) AS offload_at,
        UNNEST($5::JSONB[]) AS value,
        UNNEST($6::UUID[]) AS tenant_id
), payload_updates AS (
    UPDATE v1_payload
    SET
        value = i.value,
        updated_at = NOW()
    FROM inputs i
    WHERE
        v1_payload.id = i.id
        AND v1_payload.inserted_at = i.inserted_at
        AND v1_payload.tenant_id = i.tenant_id
)

DELETE FROM v1_payload_wal
WHERE
    (offload_at, payload_id, payload_inserted_at, payload_type, tenant_id) IN (
        SELECT offload_at, id, inserted_at, type, tenant_id
        FROM inputs
    )
`

type FinalizePayloadOffloadsParams struct {
	Ids          []int64              `json:"ids"`
	Insertedats  []pgtype.Timestamptz `json:"insertedats"`
	Payloadtypes []string             `json:"payloadtypes"`
	Offloadats   []pgtype.Timestamptz `json:"offloadats"`
	Values       [][]byte             `json:"values"`
	Tenantids    []pgtype.UUID        `json:"tenantids"`
}

func (q *Queries) FinalizePayloadOffloads(ctx context.Context, db DBTX, arg FinalizePayloadOffloadsParams) error {
	_, err := db.Exec(ctx, finalizePayloadOffloads,
		arg.Ids,
		arg.Insertedats,
		arg.Payloadtypes,
		arg.Offloadats,
		arg.Values,
		arg.Tenantids,
	)
	return err
}

const pollPayloadWALForRecordsToOffload = `-- name: PollPayloadWALForRecordsToOffload :many
WITH to_update AS (
    SELECT tenant_id, offload_at, payload_id, payload_inserted_at, payload_type, operation, offload_process_lease_id, offload_process_lease_expires_at
    FROM v1_payload_wal
    WHERE
        offload_at < NOW()
        AND offload_process_lease_id IS NULL OR offload_process_lease_expires_at < NOW()
    ORDER BY offload_at, payload_id, payload_inserted_at, payload_type, tenant_id
    FOR UPDATE
    LIMIT $2::INT
)

UPDATE v1_payload_wal
SET
    offload_process_lease_id = $1::UUID,
    offload_process_lease_expires_at = NOW() + INTERVAL '5 minutes'
FROM to_update
WHERE
    v1_payload_wal.tenant_id = to_update.tenant_id
    AND v1_payload_wal.offload_at = to_update.offload_at
    AND v1_payload_wal.payload_id = to_update.payload_id
    AND v1_payload_wal.payload_inserted_at = to_update.payload_inserted_at
    AND v1_payload_wal.payload_type = to_update.payload_type
RETURNING to_update.tenant_id, to_update.offload_at, to_update.payload_id, to_update.payload_inserted_at, to_update.payload_type, to_update.operation, to_update.offload_process_lease_id, to_update.offload_process_lease_expires_at
`

type PollPayloadWALForRecordsToOffloadParams struct {
	Leaseid   pgtype.UUID `json:"leaseid"`
	Polllimit int32       `json:"polllimit"`
}

type PollPayloadWALForRecordsToOffloadRow struct {
	TenantID                     pgtype.UUID           `json:"tenant_id"`
	OffloadAt                    pgtype.Timestamptz    `json:"offload_at"`
	PayloadID                    int64                 `json:"payload_id"`
	PayloadInsertedAt            pgtype.Timestamptz    `json:"payload_inserted_at"`
	PayloadType                  V1PayloadType         `json:"payload_type"`
	Operation                    V1PayloadWalOperation `json:"operation"`
	OffloadProcessLeaseID        pgtype.UUID           `json:"offload_process_lease_id"`
	OffloadProcessLeaseExpiresAt pgtype.Timestamptz    `json:"offload_process_lease_expires_at"`
}

func (q *Queries) PollPayloadWALForRecordsToOffload(ctx context.Context, db DBTX, arg PollPayloadWALForRecordsToOffloadParams) ([]*PollPayloadWALForRecordsToOffloadRow, error) {
	rows, err := db.Query(ctx, pollPayloadWALForRecordsToOffload, arg.Leaseid, arg.Polllimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*PollPayloadWALForRecordsToOffloadRow
	for rows.Next() {
		var i PollPayloadWALForRecordsToOffloadRow
		if err := rows.Scan(
			&i.TenantID,
			&i.OffloadAt,
			&i.PayloadID,
			&i.PayloadInsertedAt,
			&i.PayloadType,
			&i.Operation,
			&i.OffloadProcessLeaseID,
			&i.OffloadProcessLeaseExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readPayload = `-- name: ReadPayload :one
SELECT tenant_id, id, inserted_at, type, value, updated_at
FROM v1_payload
WHERE
    tenant_id = $1::UUID
    AND type = $2::v1_payload_type
    AND id = $3::BIGINT
    AND inserted_at = $4::TIMESTAMPTZ
`

type ReadPayloadParams struct {
	Tenantid   pgtype.UUID        `json:"tenantid"`
	Type       V1PayloadType      `json:"type"`
	ID         int64              `json:"id"`
	Insertedat pgtype.Timestamptz `json:"insertedat"`
}

func (q *Queries) ReadPayload(ctx context.Context, db DBTX, arg ReadPayloadParams) (*V1Payload, error) {
	row := db.QueryRow(ctx, readPayload,
		arg.Tenantid,
		arg.Type,
		arg.ID,
		arg.Insertedat,
	)
	var i V1Payload
	err := row.Scan(
		&i.TenantID,
		&i.ID,
		&i.InsertedAt,
		&i.Type,
		&i.Value,
		&i.UpdatedAt,
	)
	return &i, err
}

const readPayloads = `-- name: ReadPayloads :many
WITH inputs AS (
    SELECT
        UNNEST($2::BIGINT[]) AS id,
        UNNEST($3::TIMESTAMPTZ[]) AS inserted_at,
        UNNEST(CAST($4::TEXT[] AS v1_payload_type[])) AS type
)

SELECT tenant_id, id, inserted_at, type, value, updated_at
FROM v1_payload
WHERE
    tenant_id = $1::UUID
    AND (id, inserted_at, type) IN (
        SELECT id, inserted_at, type
        FROM inputs
    )
`

type ReadPayloadsParams struct {
	Tenantid    pgtype.UUID          `json:"tenantid"`
	Ids         []int64              `json:"ids"`
	Insertedats []pgtype.Timestamptz `json:"insertedats"`
	Types       []string             `json:"types"`
}

func (q *Queries) ReadPayloads(ctx context.Context, db DBTX, arg ReadPayloadsParams) ([]*V1Payload, error) {
	rows, err := db.Query(ctx, readPayloads,
		arg.Tenantid,
		arg.Ids,
		arg.Insertedats,
		arg.Types,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V1Payload
	for rows.Next() {
		var i V1Payload
		if err := rows.Scan(
			&i.TenantID,
			&i.ID,
			&i.InsertedAt,
			&i.Type,
			&i.Value,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const writePayloadWAL = `-- name: WritePayloadWAL :exec
WITH inputs AS (
    SELECT
        UNNEST($2::BIGINT[]) AS payload_id,
        UNNEST($3::TIMESTAMPTZ[]) AS payload_inserted_at,
        UNNEST(CAST($4::TEXT[] AS v1_payload_type[])) AS payload_type,
        UNNEST($5::TIMESTAMPTZ[]) AS offload_at,
        UNNEST(CAST($6::TEXT[] AS v1_payload_wal_operation[])) AS operation
)

INSERT INTO v1_payload_wal (
    tenant_id,
    offload_at,
    payload_id,
    payload_inserted_at,
    payload_type,
    operation
)
SELECT
    $1::UUID,
    i.offload_at,
    i.payload_id,
    i.payload_inserted_at,
    i.payload_type,
    i.operation
FROM
    inputs i
`

type WritePayloadWALParams struct {
	Tenantid           pgtype.UUID          `json:"tenantid"`
	Payloadids         []int64              `json:"payloadids"`
	Payloadinsertedats []pgtype.Timestamptz `json:"payloadinsertedats"`
	Payloadtypes       []string             `json:"payloadtypes"`
	Offloadats         []pgtype.Timestamptz `json:"offloadats"`
	Operations         []string             `json:"operations"`
}

func (q *Queries) WritePayloadWAL(ctx context.Context, db DBTX, arg WritePayloadWALParams) error {
	_, err := db.Exec(ctx, writePayloadWAL,
		arg.Tenantid,
		arg.Payloadids,
		arg.Payloadinsertedats,
		arg.Payloadtypes,
		arg.Offloadats,
		arg.Operations,
	)
	return err
}

const writePayloads = `-- name: WritePayloads :exec
WITH inputs AS (
    SELECT
        UNNEST($2::BIGINT[]) AS id,
        UNNEST($3::TIMESTAMPTZ[]) AS inserted_at,
        UNNEST(CAST($4::TEXT[] AS v1_payload_type[])) AS type,
        UNNEST($5::JSONB[]) AS payload
)
INSERT INTO v1_payload (
    tenant_id,
    id,
    inserted_at,
    type,
    value
)
SELECT
    $1::UUID,
    i.id,
    i.inserted_at,
    i.type,
    i.payload
FROM
    inputs i
`

type WritePayloadsParams struct {
	Tenantid    pgtype.UUID          `json:"tenantid"`
	Ids         []int64              `json:"ids"`
	Insertedats []pgtype.Timestamptz `json:"insertedats"`
	Types       []string             `json:"types"`
	Payloads    [][]byte             `json:"payloads"`
}

func (q *Queries) WritePayloads(ctx context.Context, db DBTX, arg WritePayloadsParams) error {
	_, err := db.Exec(ctx, writePayloads,
		arg.Tenantid,
		arg.Ids,
		arg.Insertedats,
		arg.Types,
		arg.Payloads,
	)
	return err
}
