// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: payload-store.sql

package sqlcv1

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const analyzeV1Payload = `-- name: AnalyzeV1Payload :exec
ANALYZE v1_payload
`

func (q *Queries) AnalyzeV1Payload(ctx context.Context, db DBTX) error {
	_, err := db.Exec(ctx, analyzeV1Payload)
	return err
}

const computeWALMetrics = `-- name: ComputeWALMetrics :one
SELECT
    MIN(offload_at) AS min_offload_at,
    MIN(offload_at) - NOW() AS longest_offload_lag,
    COUNT(*) AS total_wal_records
FROM
    v1_payload_wal
`

type ComputeWALMetricsRow struct {
	MinOffloadAt      interface{} `json:"min_offload_at"`
	LongestOffloadLag int32       `json:"longest_offload_lag"`
	TotalWalRecords   int64       `json:"total_wal_records"`
}

func (q *Queries) ComputeWALMetrics(ctx context.Context, db DBTX) (*ComputeWALMetricsRow, error) {
	row := db.QueryRow(ctx, computeWALMetrics)
	var i ComputeWALMetricsRow
	err := row.Scan(&i.MinOffloadAt, &i.LongestOffloadLag, &i.TotalWalRecords)
	return &i, err
}

const cutOverPayloadsToExternal = `-- name: CutOverPayloadsToExternal :one
WITH tenants AS (
    SELECT UNNEST(
        find_matching_tenants_in_payload_cutover_queue_item_partition(
            $1::INT
        )
    ) AS tenant_id
), queue_items AS (
    SELECT tenant_id, cut_over_at, payload_id, payload_inserted_at, payload_type
    FROM v1_payload_cutover_queue_item
    WHERE
        tenant_id = ANY(SELECT tenant_id FROM tenants)
        AND cut_over_at <= NOW()
    ORDER BY cut_over_at
    LIMIT $2::INT
    FOR UPDATE SKIP LOCKED
), payload_updates AS (
    UPDATE v1_payload
    SET
        location = 'EXTERNAL',
        inline_content = NULL,
        updated_at = NOW()
    FROM queue_items qi
    WHERE
        v1_payload.id = qi.payload_id
        AND v1_payload.inserted_at = qi.payload_inserted_at
        AND v1_payload.tenant_id = qi.tenant_id
        AND v1_payload.type = qi.payload_type
        AND v1_payload.external_location_key IS NOT NULL
), deletions AS (
    DELETE FROM v1_payload_cutover_queue_item
    WHERE
        (cut_over_at, payload_id, payload_inserted_at, payload_type, tenant_id) IN (
            SELECT cut_over_at, payload_id, payload_inserted_at, payload_type, tenant_id
            FROM queue_items
        )
)

SELECT COUNT(*)
FROM queue_items
`

type CutOverPayloadsToExternalParams struct {
	Partitionnumber int32 `json:"partitionnumber"`
	Polllimit       int32 `json:"polllimit"`
}

func (q *Queries) CutOverPayloadsToExternal(ctx context.Context, db DBTX, arg CutOverPayloadsToExternalParams) (int64, error) {
	row := db.QueryRow(ctx, cutOverPayloadsToExternal, arg.Partitionnumber, arg.Polllimit)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const pollPayloadWALForRecordsToReplicate = `-- name: PollPayloadWALForRecordsToReplicate :many
WITH tenants AS (
    SELECT UNNEST(
        find_matching_tenants_in_payload_wal_partition(
            $1::INT
        )
    ) AS tenant_id
), wal_records AS (
    SELECT tenant_id, offload_at, payload_id, payload_inserted_at, payload_type, operation
    FROM v1_payload_wal
    WHERE tenant_id = ANY(SELECT tenant_id FROM tenants)
    ORDER BY offload_at
    LIMIT $2::INT
    FOR UPDATE SKIP LOCKED
), wal_records_without_payload AS (
    SELECT tenant_id, offload_at, payload_id, payload_inserted_at, payload_type, operation
    FROM wal_records wr
    WHERE NOT EXISTS (
        SELECT 1
        FROM v1_payload p
        WHERE (p.tenant_id, p.inserted_at, p.id, p.type) = (wr.tenant_id, wr.payload_inserted_at, wr.payload_id, wr.payload_type)
    )
), deleted_wal_records AS (
    DELETE FROM v1_payload_wal
    WHERE (offload_at, payload_id, payload_inserted_at, payload_type, tenant_id) IN (
        SELECT offload_at, payload_id, payload_inserted_at, payload_type, tenant_id
        FROM wal_records_without_payload
    )
)
SELECT wr.tenant_id, wr.offload_at, wr.payload_id, wr.payload_inserted_at, wr.payload_type, wr.operation, p.location, p.inline_content
FROM wal_records wr
JOIN v1_payload p ON (p.tenant_id, p.inserted_at, p.id, p.type) = (wr.tenant_id, wr.payload_inserted_at, wr.payload_id, wr.payload_type)
`

type PollPayloadWALForRecordsToReplicateParams struct {
	Partitionnumber int32 `json:"partitionnumber"`
	Polllimit       int32 `json:"polllimit"`
}

type PollPayloadWALForRecordsToReplicateRow struct {
	TenantID          pgtype.UUID           `json:"tenant_id"`
	OffloadAt         pgtype.Timestamptz    `json:"offload_at"`
	PayloadID         int64                 `json:"payload_id"`
	PayloadInsertedAt pgtype.Timestamptz    `json:"payload_inserted_at"`
	PayloadType       V1PayloadType         `json:"payload_type"`
	Operation         V1PayloadWalOperation `json:"operation"`
	Location          V1PayloadLocation     `json:"location"`
	InlineContent     []byte                `json:"inline_content"`
}

func (q *Queries) PollPayloadWALForRecordsToReplicate(ctx context.Context, db DBTX, arg PollPayloadWALForRecordsToReplicateParams) ([]*PollPayloadWALForRecordsToReplicateRow, error) {
	rows, err := db.Query(ctx, pollPayloadWALForRecordsToReplicate, arg.Partitionnumber, arg.Polllimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*PollPayloadWALForRecordsToReplicateRow
	for rows.Next() {
		var i PollPayloadWALForRecordsToReplicateRow
		if err := rows.Scan(
			&i.TenantID,
			&i.OffloadAt,
			&i.PayloadID,
			&i.PayloadInsertedAt,
			&i.PayloadType,
			&i.Operation,
			&i.Location,
			&i.InlineContent,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readPayloads = `-- name: ReadPayloads :many
WITH inputs AS (
    SELECT
        UNNEST($1::BIGINT[]) AS id,
        UNNEST($2::TIMESTAMPTZ[]) AS inserted_at,
        UNNEST($3::UUID[]) AS tenant_id,
        UNNEST(CAST($4::TEXT[] AS v1_payload_type[])) AS type
)

SELECT tenant_id, id, inserted_at, external_id, type, location, external_location_key, inline_content, updated_at
FROM v1_payload
WHERE (tenant_id, id, inserted_at, type) IN (
        SELECT tenant_id, id, inserted_at, type
        FROM inputs
    )
`

type ReadPayloadsParams struct {
	Ids         []int64              `json:"ids"`
	Insertedats []pgtype.Timestamptz `json:"insertedats"`
	Tenantids   []pgtype.UUID        `json:"tenantids"`
	Types       []string             `json:"types"`
}

func (q *Queries) ReadPayloads(ctx context.Context, db DBTX, arg ReadPayloadsParams) ([]*V1Payload, error) {
	rows, err := db.Query(ctx, readPayloads,
		arg.Ids,
		arg.Insertedats,
		arg.Tenantids,
		arg.Types,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V1Payload
	for rows.Next() {
		var i V1Payload
		if err := rows.Scan(
			&i.TenantID,
			&i.ID,
			&i.InsertedAt,
			&i.ExternalID,
			&i.Type,
			&i.Location,
			&i.ExternalLocationKey,
			&i.InlineContent,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setPayloadExternalKeys = `-- name: SetPayloadExternalKeys :many
WITH inputs AS (
    SELECT
        UNNEST($1::BIGINT[]) AS id,
        UNNEST($2::TIMESTAMPTZ[]) AS inserted_at,
        UNNEST(CAST($3::TEXT[] AS v1_payload_type[])) AS type,
        UNNEST($4::TIMESTAMPTZ[]) AS offload_at,
        UNNEST($5::TEXT[]) AS external_location_key,
        UNNEST($6::UUID[]) AS tenant_id
), payload_updates AS (
    UPDATE v1_payload
    SET
        external_location_key = i.external_location_key,
        updated_at = NOW()
    FROM inputs i
    WHERE
        v1_payload.id = i.id
        AND v1_payload.inserted_at = i.inserted_at
        AND v1_payload.tenant_id = i.tenant_id
    RETURNING v1_payload.tenant_id, v1_payload.id, v1_payload.inserted_at, v1_payload.external_id, v1_payload.type, v1_payload.location, v1_payload.external_location_key, v1_payload.inline_content, v1_payload.updated_at
), cutover_queue_items AS (
    INSERT INTO v1_payload_cutover_queue_item (
        tenant_id,
        cut_over_at,
        payload_id,
        payload_inserted_at,
        payload_type
    )
    SELECT
        i.tenant_id,
        i.offload_at,
        i.id,
        i.inserted_at,
        i.type
    FROM
        inputs i
    ON CONFLICT DO NOTHING
), deletions AS (
    DELETE FROM v1_payload_wal
    WHERE
        (offload_at, payload_id, payload_inserted_at, payload_type, tenant_id) IN (
            SELECT offload_at, id, inserted_at, type, tenant_id
            FROM inputs
        )
)

SELECT tenant_id, id, inserted_at, external_id, type, location, external_location_key, inline_content, updated_at
FROM payload_updates
`

type SetPayloadExternalKeysParams struct {
	Ids                  []int64              `json:"ids"`
	Insertedats          []pgtype.Timestamptz `json:"insertedats"`
	Payloadtypes         []string             `json:"payloadtypes"`
	Offloadats           []pgtype.Timestamptz `json:"offloadats"`
	Externallocationkeys []string             `json:"externallocationkeys"`
	Tenantids            []pgtype.UUID        `json:"tenantids"`
}

type SetPayloadExternalKeysRow struct {
	TenantID            pgtype.UUID        `json:"tenant_id"`
	ID                  int64              `json:"id"`
	InsertedAt          pgtype.Timestamptz `json:"inserted_at"`
	ExternalID          pgtype.UUID        `json:"external_id"`
	Type                V1PayloadType      `json:"type"`
	Location            V1PayloadLocation  `json:"location"`
	ExternalLocationKey pgtype.Text        `json:"external_location_key"`
	InlineContent       []byte             `json:"inline_content"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) SetPayloadExternalKeys(ctx context.Context, db DBTX, arg SetPayloadExternalKeysParams) ([]*SetPayloadExternalKeysRow, error) {
	rows, err := db.Query(ctx, setPayloadExternalKeys,
		arg.Ids,
		arg.Insertedats,
		arg.Payloadtypes,
		arg.Offloadats,
		arg.Externallocationkeys,
		arg.Tenantids,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SetPayloadExternalKeysRow
	for rows.Next() {
		var i SetPayloadExternalKeysRow
		if err := rows.Scan(
			&i.TenantID,
			&i.ID,
			&i.InsertedAt,
			&i.ExternalID,
			&i.Type,
			&i.Location,
			&i.ExternalLocationKey,
			&i.InlineContent,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const writePayloadWAL = `-- name: WritePayloadWAL :exec
WITH inputs AS (
    SELECT
        UNNEST($1::BIGINT[]) AS payload_id,
        UNNEST($2::TIMESTAMPTZ[]) AS payload_inserted_at,
        UNNEST(CAST($3::TEXT[] AS v1_payload_type[])) AS payload_type,
        UNNEST($4::TIMESTAMPTZ[]) AS offload_at,
        UNNEST($5::UUID[]) AS tenant_id
)

INSERT INTO v1_payload_wal (
    tenant_id,
    offload_at,
    payload_id,
    payload_inserted_at,
    payload_type
)
SELECT
    i.tenant_id,
    i.offload_at,
    i.payload_id,
    i.payload_inserted_at,
    i.payload_type
FROM
    inputs i
ON CONFLICT DO NOTHING
`

type WritePayloadWALParams struct {
	Payloadids         []int64              `json:"payloadids"`
	Payloadinsertedats []pgtype.Timestamptz `json:"payloadinsertedats"`
	Payloadtypes       []string             `json:"payloadtypes"`
	Offloadats         []pgtype.Timestamptz `json:"offloadats"`
	Tenantids          []pgtype.UUID        `json:"tenantids"`
}

func (q *Queries) WritePayloadWAL(ctx context.Context, db DBTX, arg WritePayloadWALParams) error {
	_, err := db.Exec(ctx, writePayloadWAL,
		arg.Payloadids,
		arg.Payloadinsertedats,
		arg.Payloadtypes,
		arg.Offloadats,
		arg.Tenantids,
	)
	return err
}

const writePayloads = `-- name: WritePayloads :exec
WITH inputs AS (
    SELECT DISTINCT
        UNNEST($1::BIGINT[]) AS id,
        UNNEST($2::TIMESTAMPTZ[]) AS inserted_at,
        UNNEST($3::UUID[]) AS external_id,
        UNNEST(CAST($4::TEXT[] AS v1_payload_type[])) AS type,
        UNNEST(CAST($5::TEXT[] AS v1_payload_location[])) AS location,
        UNNEST($6::TEXT[]) AS external_location_key,
        UNNEST($7::JSONB[]) AS inline_content,
        UNNEST($8::UUID[]) AS tenant_id
)

INSERT INTO v1_payload (
    tenant_id,
    id,
    inserted_at,
    external_id,
    type,
    location,
    external_location_key,
    inline_content
)
SELECT
    i.tenant_id,
    i.id,
    i.inserted_at,
    i.external_id,
    i.type,
    i.location,
    CASE WHEN i.external_location_key = '' OR i.location != 'EXTERNAL' THEN NULL ELSE i.external_location_key END,
    i.inline_content
FROM
    inputs i
ON CONFLICT (tenant_id, id, inserted_at, type)
DO UPDATE SET
    location = EXCLUDED.location,
    external_location_key = CASE WHEN EXCLUDED.external_location_key = '' OR EXCLUDED.location != 'EXTERNAL' THEN NULL ELSE EXCLUDED.external_location_key END,
    inline_content = EXCLUDED.inline_content,
    updated_at = NOW()
`

type WritePayloadsParams struct {
	Ids                  []int64              `json:"ids"`
	Insertedats          []pgtype.Timestamptz `json:"insertedats"`
	Externalids          []pgtype.UUID        `json:"externalids"`
	Types                []string             `json:"types"`
	Locations            []string             `json:"locations"`
	Externallocationkeys []string             `json:"externallocationkeys"`
	Inlinecontents       [][]byte             `json:"inlinecontents"`
	Tenantids            []pgtype.UUID        `json:"tenantids"`
}

func (q *Queries) WritePayloads(ctx context.Context, db DBTX, arg WritePayloadsParams) error {
	_, err := db.Exec(ctx, writePayloads,
		arg.Ids,
		arg.Insertedats,
		arg.Externalids,
		arg.Types,
		arg.Locations,
		arg.Externallocationkeys,
		arg.Inlinecontents,
		arg.Tenantids,
	)
	return err
}
