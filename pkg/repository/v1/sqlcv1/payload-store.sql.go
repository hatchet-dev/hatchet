// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: payload-store.sql

package sqlcv1

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const readPayload = `-- name: ReadPayload :one
SELECT tenant_id, id, inserted_at, type, value, updated_at
FROM v1_payload
WHERE
    tenant_id = $1::UUID
    AND type = $2::v1_payload_type
    AND task_id = $3::BIGINT
    AND task_inserted_at = $4::TIMESTAMPTZ
`

type ReadPayloadParams struct {
	Tenantid       pgtype.UUID        `json:"tenantid"`
	Type           V1PayloadType      `json:"type"`
	Taskid         int64              `json:"taskid"`
	Taskinsertedat pgtype.Timestamptz `json:"taskinsertedat"`
}

func (q *Queries) ReadPayload(ctx context.Context, db DBTX, arg ReadPayloadParams) (*V1Payload, error) {
	row := db.QueryRow(ctx, readPayload,
		arg.Tenantid,
		arg.Type,
		arg.Taskid,
		arg.Taskinsertedat,
	)
	var i V1Payload
	err := row.Scan(
		&i.TenantID,
		&i.ID,
		&i.InsertedAt,
		&i.Type,
		&i.Value,
		&i.UpdatedAt,
	)
	return &i, err
}

const readPayloads = `-- name: ReadPayloads :many
WITH inputs AS (
    SELECT
        UNNEST($2::BIGINT[]) AS task_id,
        UNNEST($3::TIMESTAMPTZ[]) AS task_inserted_at,
        UNNEST(CAST($4::TEXT[] AS v1_payload_type[])) AS type
)

SELECT tenant_id, id, inserted_at, type, value, updated_at
FROM v1_payload
WHERE
    tenant_id = $1::UUID
    AND (task_id, task_inserted_at, type) IN (
        SELECT task_id, task_inserted_at, type
        FROM inputs
    )
`

type ReadPayloadsParams struct {
	Tenantid        pgtype.UUID          `json:"tenantid"`
	Taskids         []int64              `json:"taskids"`
	Taskinsertedats []pgtype.Timestamptz `json:"taskinsertedats"`
	Types           []string             `json:"types"`
}

func (q *Queries) ReadPayloads(ctx context.Context, db DBTX, arg ReadPayloadsParams) ([]*V1Payload, error) {
	rows, err := db.Query(ctx, readPayloads,
		arg.Tenantid,
		arg.Taskids,
		arg.Taskinsertedats,
		arg.Types,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V1Payload
	for rows.Next() {
		var i V1Payload
		if err := rows.Scan(
			&i.TenantID,
			&i.ID,
			&i.InsertedAt,
			&i.Type,
			&i.Value,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const writePayloads = `-- name: WritePayloads :exec
WITH inputs AS (
    SELECT
        UNNEST($2::BIGINT[]) AS task_id,
        UNNEST($3::TIMESTAMPTZ[]) AS task_inserted_at,
        UNNEST(CAST($4::TEXT[] AS v1_payload_type[])) AS type,
        UNNEST($5::JSONB[]) AS payload
)
INSERT INTO v1_payload (
    tenant_id,
    task_id,
    task_inserted_at,
    type,
    value
)
SELECT
    $1::UUID,
    i.task_id,
    i.task_inserted_at,
    i.type,
    i.payload
FROM
    inputs i
`

type WritePayloadsParams struct {
	Tenantid        pgtype.UUID          `json:"tenantid"`
	Taskids         []int64              `json:"taskids"`
	Taskinsertedats []pgtype.Timestamptz `json:"taskinsertedats"`
	Types           []string             `json:"types"`
	Payloads        [][]byte             `json:"payloads"`
}

func (q *Queries) WritePayloads(ctx context.Context, db DBTX, arg WritePayloadsParams) error {
	_, err := db.Exec(ctx, writePayloads,
		arg.Tenantid,
		arg.Taskids,
		arg.Taskinsertedats,
		arg.Types,
		arg.Payloads,
	)
	return err
}
