// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: webhooks.sql

package sqlcv1

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const canCreateWebhook = `-- name: CanCreateWebhook :one
SELECT COUNT(*) < $1::INT AS can_create_webhook
FROM v1_incoming_webhook
WHERE
    tenant_id = $2::UUID
`

type CanCreateWebhookParams struct {
	Webhooklimit int32     `json:"webhooklimit"`
	Tenantid     uuid.UUID `json:"tenantid"`
}

func (q *Queries) CanCreateWebhook(ctx context.Context, db DBTX, arg CanCreateWebhookParams) (bool, error) {
	row := db.QueryRow(ctx, canCreateWebhook, arg.Webhooklimit, arg.Tenantid)
	var can_create_webhook bool
	err := row.Scan(&can_create_webhook)
	return can_create_webhook, err
}

const createWebhook = `-- name: CreateWebhook :one
INSERT INTO v1_incoming_webhook (
    tenant_id,
    name,
    source_name,
    event_key_expression,
    auth_method,
    auth__basic__username,
    auth__basic__password,
    auth__api_key__header_name,
    auth__api_key__key,
    auth__hmac__algorithm,
    auth__hmac__encoding,
    auth__hmac__signature_header_name,
    auth__hmac__webhook_signing_secret

) VALUES (
    $1::UUID,
    $2::TEXT,
    $3::v1_incoming_webhook_source_name,
    $4::TEXT,
    $5::v1_incoming_webhook_auth_type,
    $6::TEXT,
    $7::BYTEA,
    $8::TEXT,
    $9::BYTEA,
    $10::v1_incoming_webhook_hmac_algorithm,
    $11::v1_incoming_webhook_hmac_encoding,
    $12::TEXT,
    $13::BYTEA
)
RETURNING tenant_id, name, source_name, event_key_expression, auth_method, auth__basic__username, auth__basic__password, auth__api_key__header_name, auth__api_key__key, auth__hmac__algorithm, auth__hmac__encoding, auth__hmac__signature_header_name, auth__hmac__webhook_signing_secret, inserted_at, updated_at
`

type CreateWebhookParams struct {
	Tenantid                     uuid.UUID                          `json:"tenantid"`
	Name                         string                             `json:"name"`
	Sourcename                   V1IncomingWebhookSourceName        `json:"sourcename"`
	Eventkeyexpression           string                             `json:"eventkeyexpression"`
	Authmethod                   V1IncomingWebhookAuthType          `json:"authmethod"`
	AuthBasicUsername            pgtype.Text                        `json:"authBasicUsername"`
	Authbasicpassword            []byte                             `json:"authbasicpassword"`
	AuthApiKeyHeaderName         pgtype.Text                        `json:"authApiKeyHeaderName"`
	Authapikeykey                []byte                             `json:"authapikeykey"`
	AuthHmacAlgorithm            NullV1IncomingWebhookHmacAlgorithm `json:"authHmacAlgorithm"`
	AuthHmacEncoding             NullV1IncomingWebhookHmacEncoding  `json:"authHmacEncoding"`
	AuthHmacSignatureHeaderName  pgtype.Text                        `json:"authHmacSignatureHeaderName"`
	Authhmacwebhooksigningsecret []byte                             `json:"authhmacwebhooksigningsecret"`
}

func (q *Queries) CreateWebhook(ctx context.Context, db DBTX, arg CreateWebhookParams) (*V1IncomingWebhook, error) {
	row := db.QueryRow(ctx, createWebhook,
		arg.Tenantid,
		arg.Name,
		arg.Sourcename,
		arg.Eventkeyexpression,
		arg.Authmethod,
		arg.AuthBasicUsername,
		arg.Authbasicpassword,
		arg.AuthApiKeyHeaderName,
		arg.Authapikeykey,
		arg.AuthHmacAlgorithm,
		arg.AuthHmacEncoding,
		arg.AuthHmacSignatureHeaderName,
		arg.Authhmacwebhooksigningsecret,
	)
	var i V1IncomingWebhook
	err := row.Scan(
		&i.TenantID,
		&i.Name,
		&i.SourceName,
		&i.EventKeyExpression,
		&i.AuthMethod,
		&i.AuthBasicUsername,
		&i.AuthBasicPassword,
		&i.AuthApiKeyHeaderName,
		&i.AuthApiKeyKey,
		&i.AuthHmacAlgorithm,
		&i.AuthHmacEncoding,
		&i.AuthHmacSignatureHeaderName,
		&i.AuthHmacWebhookSigningSecret,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteWebhook = `-- name: DeleteWebhook :one
DELETE FROM v1_incoming_webhook
WHERE
    tenant_id = $1::UUID
    AND name = $2::TEXT
RETURNING tenant_id, name, source_name, event_key_expression, auth_method, auth__basic__username, auth__basic__password, auth__api_key__header_name, auth__api_key__key, auth__hmac__algorithm, auth__hmac__encoding, auth__hmac__signature_header_name, auth__hmac__webhook_signing_secret, inserted_at, updated_at
`

type DeleteWebhookParams struct {
	Tenantid uuid.UUID `json:"tenantid"`
	Name     string    `json:"name"`
}

func (q *Queries) DeleteWebhook(ctx context.Context, db DBTX, arg DeleteWebhookParams) (*V1IncomingWebhook, error) {
	row := db.QueryRow(ctx, deleteWebhook, arg.Tenantid, arg.Name)
	var i V1IncomingWebhook
	err := row.Scan(
		&i.TenantID,
		&i.Name,
		&i.SourceName,
		&i.EventKeyExpression,
		&i.AuthMethod,
		&i.AuthBasicUsername,
		&i.AuthBasicPassword,
		&i.AuthApiKeyHeaderName,
		&i.AuthApiKeyKey,
		&i.AuthHmacAlgorithm,
		&i.AuthHmacEncoding,
		&i.AuthHmacSignatureHeaderName,
		&i.AuthHmacWebhookSigningSecret,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getWebhook = `-- name: GetWebhook :one
SELECT tenant_id, name, source_name, event_key_expression, auth_method, auth__basic__username, auth__basic__password, auth__api_key__header_name, auth__api_key__key, auth__hmac__algorithm, auth__hmac__encoding, auth__hmac__signature_header_name, auth__hmac__webhook_signing_secret, inserted_at, updated_at
FROM v1_incoming_webhook
WHERE
    name = $1::TEXT
    AND tenant_id = $2::UUID
`

type GetWebhookParams struct {
	Name     string    `json:"name"`
	Tenantid uuid.UUID `json:"tenantid"`
}

func (q *Queries) GetWebhook(ctx context.Context, db DBTX, arg GetWebhookParams) (*V1IncomingWebhook, error) {
	row := db.QueryRow(ctx, getWebhook, arg.Name, arg.Tenantid)
	var i V1IncomingWebhook
	err := row.Scan(
		&i.TenantID,
		&i.Name,
		&i.SourceName,
		&i.EventKeyExpression,
		&i.AuthMethod,
		&i.AuthBasicUsername,
		&i.AuthBasicPassword,
		&i.AuthApiKeyHeaderName,
		&i.AuthApiKeyKey,
		&i.AuthHmacAlgorithm,
		&i.AuthHmacEncoding,
		&i.AuthHmacSignatureHeaderName,
		&i.AuthHmacWebhookSigningSecret,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listWebhooks = `-- name: ListWebhooks :many
SELECT tenant_id, name, source_name, event_key_expression, auth_method, auth__basic__username, auth__basic__password, auth__api_key__header_name, auth__api_key__key, auth__hmac__algorithm, auth__hmac__encoding, auth__hmac__signature_header_name, auth__hmac__webhook_signing_secret, inserted_at, updated_at
FROM v1_incoming_webhook
WHERE
    tenant_id = $1::UUID
    AND (
        $2::v1_incoming_webhook_source_name[] IS NULL
        OR source_name = ANY($2::v1_incoming_webhook_source_name[])
    )
    AND (
        $3::TEXT[] IS NULL
        OR name = ANY($3::TEXT[])
    )
ORDER BY tenant_id, inserted_at DESC
LIMIT COALESCE($5::BIGINT, 20000)
OFFSET COALESCE($4::BIGINT, 0)
`

type ListWebhooksParams struct {
	Tenantid      uuid.UUID                     `json:"tenantid"`
	Sourcenames   []V1IncomingWebhookSourceName `json:"sourcenames"`
	Webhooknames  []string                      `json:"webhooknames"`
	WebhookOffset pgtype.Int8                   `json:"webhookOffset"`
	WebhookLimit  pgtype.Int8                   `json:"webhookLimit"`
}

func (q *Queries) ListWebhooks(ctx context.Context, db DBTX, arg ListWebhooksParams) ([]*V1IncomingWebhook, error) {
	rows, err := db.Query(ctx, listWebhooks,
		arg.Tenantid,
		arg.Sourcenames,
		arg.Webhooknames,
		arg.WebhookOffset,
		arg.WebhookLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V1IncomingWebhook
	for rows.Next() {
		var i V1IncomingWebhook
		if err := rows.Scan(
			&i.TenantID,
			&i.Name,
			&i.SourceName,
			&i.EventKeyExpression,
			&i.AuthMethod,
			&i.AuthBasicUsername,
			&i.AuthBasicPassword,
			&i.AuthApiKeyHeaderName,
			&i.AuthApiKeyKey,
			&i.AuthHmacAlgorithm,
			&i.AuthHmacEncoding,
			&i.AuthHmacSignatureHeaderName,
			&i.AuthHmacWebhookSigningSecret,
			&i.InsertedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWebhookExpression = `-- name: UpdateWebhookExpression :one
UPDATE v1_incoming_webhook
SET
    event_key_expression = $1::TEXT
WHERE
    tenant_id = $2::UUID
    AND name = $3::TEXT
RETURNING tenant_id, name, source_name, event_key_expression, auth_method, auth__basic__username, auth__basic__password, auth__api_key__header_name, auth__api_key__key, auth__hmac__algorithm, auth__hmac__encoding, auth__hmac__signature_header_name, auth__hmac__webhook_signing_secret, inserted_at, updated_at
`

type UpdateWebhookExpressionParams struct {
	Eventkeyexpression string    `json:"eventkeyexpression"`
	Tenantid           uuid.UUID `json:"tenantid"`
	Webhookname        string    `json:"webhookname"`
}

func (q *Queries) UpdateWebhookExpression(ctx context.Context, db DBTX, arg UpdateWebhookExpressionParams) (*V1IncomingWebhook, error) {
	row := db.QueryRow(ctx, updateWebhookExpression, arg.Eventkeyexpression, arg.Tenantid, arg.Webhookname)
	var i V1IncomingWebhook
	err := row.Scan(
		&i.TenantID,
		&i.Name,
		&i.SourceName,
		&i.EventKeyExpression,
		&i.AuthMethod,
		&i.AuthBasicUsername,
		&i.AuthBasicPassword,
		&i.AuthApiKeyHeaderName,
		&i.AuthApiKeyKey,
		&i.AuthHmacAlgorithm,
		&i.AuthHmacEncoding,
		&i.AuthHmacSignatureHeaderName,
		&i.AuthHmacWebhookSigningSecret,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
