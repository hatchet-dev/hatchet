// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: webhooks.sql

package sqlcv1

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createWebhook = `-- name: CreateWebhook :one
INSERT INTO v1_incoming_webhook (
    id,
    tenant_id,
    source_name,
    name,
    event_key_expression,
    auth_method,
    auth__basic__username,
    auth__basic__password,
    auth__api_key__header_name,
    auth__api_key__key,
    auth__hmac__algorithm,
    auth__hmac__encoding,
    auth__hmac__signature_header_name,
    auth__hmac__webhook_signing_secret

) VALUES (
    $1::UUID,
    $2::UUID,
    $3::TEXT,
    $4::TEXT,
    $5::TEXT,
    $6::v1_incoming_webhook_auth_type,
    $7::TEXT,
    $8::BYTEA,
    $9::TEXT,
    $10::BYTEA,
    $11::v1_incoming_webhook_hmac_algorithm,
    $12::v1_incoming_webhook_hmac_encoding,
    $13::TEXT,
    $14::BYTEA
)
RETURNING id, tenant_id, source_name, name, event_key_expression, auth_method, auth__basic__username, auth__basic__password, auth__api_key__header_name, auth__api_key__key, auth__hmac__algorithm, auth__hmac__encoding, auth__hmac__signature_header_name, auth__hmac__webhook_signing_secret, inserted_at, updated_at
`

type CreateWebhookParams struct {
	ID                           pgtype.UUID                        `json:"id"`
	Tenantid                     pgtype.UUID                        `json:"tenantid"`
	Sourcename                   string                             `json:"sourcename"`
	Name                         string                             `json:"name"`
	Eventkeyexpression           string                             `json:"eventkeyexpression"`
	Authmethod                   V1IncomingWebhookAuthType          `json:"authmethod"`
	Authbasicusername            string                             `json:"authbasicusername"`
	Authbasicpassword            []byte                             `json:"authbasicpassword"`
	Authapikeyheadername         string                             `json:"authapikeyheadername"`
	Authapikeykey                []byte                             `json:"authapikeykey"`
	AuthHmacAlgorithm            NullV1IncomingWebhookHmacAlgorithm `json:"authHmacAlgorithm"`
	AuthHmacEncoding             NullV1IncomingWebhookHmacEncoding  `json:"authHmacEncoding"`
	Authhmacsignatureheadername  string                             `json:"authhmacsignatureheadername"`
	Authhmacwebhooksigningsecret []byte                             `json:"authhmacwebhooksigningsecret"`
}

func (q *Queries) CreateWebhook(ctx context.Context, db DBTX, arg CreateWebhookParams) (*V1IncomingWebhook, error) {
	row := db.QueryRow(ctx, createWebhook,
		arg.ID,
		arg.Tenantid,
		arg.Sourcename,
		arg.Name,
		arg.Eventkeyexpression,
		arg.Authmethod,
		arg.Authbasicusername,
		arg.Authbasicpassword,
		arg.Authapikeyheadername,
		arg.Authapikeykey,
		arg.AuthHmacAlgorithm,
		arg.AuthHmacEncoding,
		arg.Authhmacsignatureheadername,
		arg.Authhmacwebhooksigningsecret,
	)
	var i V1IncomingWebhook
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SourceName,
		&i.Name,
		&i.EventKeyExpression,
		&i.AuthMethod,
		&i.AuthBasicUsername,
		&i.AuthBasicPassword,
		&i.AuthApiKeyHeaderName,
		&i.AuthApiKeyKey,
		&i.AuthHmacAlgorithm,
		&i.AuthHmacEncoding,
		&i.AuthHmacSignatureHeaderName,
		&i.AuthHmacWebhookSigningSecret,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteWebhook = `-- name: DeleteWebhook :one
DELETE FROM v1_incoming_webhook
WHERE
    tenant_id = $1::UUID
    AND id = $2::UUID
RETURNING id, tenant_id, source_name, name, event_key_expression, auth_method, auth__basic__username, auth__basic__password, auth__api_key__header_name, auth__api_key__key, auth__hmac__algorithm, auth__hmac__encoding, auth__hmac__signature_header_name, auth__hmac__webhook_signing_secret, inserted_at, updated_at
`

type DeleteWebhookParams struct {
	Tenantid pgtype.UUID `json:"tenantid"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) DeleteWebhook(ctx context.Context, db DBTX, arg DeleteWebhookParams) (*V1IncomingWebhook, error) {
	row := db.QueryRow(ctx, deleteWebhook, arg.Tenantid, arg.ID)
	var i V1IncomingWebhook
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SourceName,
		&i.Name,
		&i.EventKeyExpression,
		&i.AuthMethod,
		&i.AuthBasicUsername,
		&i.AuthBasicPassword,
		&i.AuthApiKeyHeaderName,
		&i.AuthApiKeyKey,
		&i.AuthHmacAlgorithm,
		&i.AuthHmacEncoding,
		&i.AuthHmacSignatureHeaderName,
		&i.AuthHmacWebhookSigningSecret,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getWebhook = `-- name: GetWebhook :one
SELECT id, tenant_id, source_name, name, event_key_expression, auth_method, auth__basic__username, auth__basic__password, auth__api_key__header_name, auth__api_key__key, auth__hmac__algorithm, auth__hmac__encoding, auth__hmac__signature_header_name, auth__hmac__webhook_signing_secret, inserted_at, updated_at
FROM v1_incoming_webhook
WHERE
    id = $1::UUID
    AND tenant_id = $2::UUID
`

type GetWebhookParams struct {
	ID       pgtype.UUID `json:"id"`
	Tenantid pgtype.UUID `json:"tenantid"`
}

func (q *Queries) GetWebhook(ctx context.Context, db DBTX, arg GetWebhookParams) (*V1IncomingWebhook, error) {
	row := db.QueryRow(ctx, getWebhook, arg.ID, arg.Tenantid)
	var i V1IncomingWebhook
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SourceName,
		&i.Name,
		&i.EventKeyExpression,
		&i.AuthMethod,
		&i.AuthBasicUsername,
		&i.AuthBasicPassword,
		&i.AuthApiKeyHeaderName,
		&i.AuthApiKeyKey,
		&i.AuthHmacAlgorithm,
		&i.AuthHmacEncoding,
		&i.AuthHmacSignatureHeaderName,
		&i.AuthHmacWebhookSigningSecret,
		&i.InsertedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listWebhooks = `-- name: ListWebhooks :many
SELECT id, tenant_id, source_name, name, event_key_expression, auth_method, auth__basic__username, auth__basic__password, auth__api_key__header_name, auth__api_key__key, auth__hmac__algorithm, auth__hmac__encoding, auth__hmac__signature_header_name, auth__hmac__webhook_signing_secret, inserted_at, updated_at
FROM v1_incoming_webhook
WHERE
    tenant_id = $1::UUID
    AND (
        $2::TEXT[] IS NULL
        OR source_name = ANY($2::TEXT[])
    )
    AND (
        $3::TEXT[] IS NULL
        OR name = ANY($3::TEXT[])
    )
ORDER BY inserted_at DESC
LIMIT COALESCE($5::BIGINT, 20000)
OFFSET COALESCE($4::BIGINT, 0)
`

type ListWebhooksParams struct {
	Tenantid      pgtype.UUID `json:"tenantid"`
	Sourcenames   []string    `json:"sourcenames"`
	Webhooknames  []string    `json:"webhooknames"`
	WebhookOffset pgtype.Int8 `json:"webhookOffset"`
	WebhookLimit  pgtype.Int8 `json:"webhookLimit"`
}

func (q *Queries) ListWebhooks(ctx context.Context, db DBTX, arg ListWebhooksParams) ([]*V1IncomingWebhook, error) {
	rows, err := db.Query(ctx, listWebhooks,
		arg.Tenantid,
		arg.Sourcenames,
		arg.Webhooknames,
		arg.WebhookOffset,
		arg.WebhookLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V1IncomingWebhook
	for rows.Next() {
		var i V1IncomingWebhook
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SourceName,
			&i.Name,
			&i.EventKeyExpression,
			&i.AuthMethod,
			&i.AuthBasicUsername,
			&i.AuthBasicPassword,
			&i.AuthApiKeyHeaderName,
			&i.AuthApiKeyKey,
			&i.AuthHmacAlgorithm,
			&i.AuthHmacEncoding,
			&i.AuthHmacSignatureHeaderName,
			&i.AuthHmacWebhookSigningSecret,
			&i.InsertedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
