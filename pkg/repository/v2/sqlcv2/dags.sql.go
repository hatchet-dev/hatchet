// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: dags.sql

package sqlcv2

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type CreateDAGDataParams struct {
	DagID              int64              `json:"dag_id"`
	DagInsertedAt      pgtype.Timestamptz `json:"dag_inserted_at"`
	Input              []byte             `json:"input"`
	AdditionalMetadata []byte             `json:"additional_metadata"`
}

const createDAGPartition = `-- name: CreateDAGPartition :exec
SELECT create_v2_dag_partition(
    $1::date
)
`

func (q *Queries) CreateDAGPartition(ctx context.Context, db DBTX, date pgtype.Date) error {
	_, err := db.Exec(ctx, createDAGPartition, date)
	return err
}

const createDAGs = `-- name: CreateDAGs :many
WITH input AS (
    SELECT
        tenant_id, external_id, display_name, workflow_id, workflow_version_id
    FROM
        (
            SELECT
                unnest($1::uuid[]) AS tenant_id,
                unnest($2::uuid[]) AS external_id,
                unnest($3::text[]) AS display_name,
                unnest($4::uuid[]) AS workflow_id,
                unnest($5::uuid[]) AS workflow_version_id
        ) AS subquery
)
INSERT INTO v2_dag (
    tenant_id,
    external_id,
    display_name,
    workflow_id,
    workflow_version_id
)
SELECT
    i.tenant_id,
    i.external_id,
    i.display_name,
    i.workflow_id,
    i.workflow_version_id
FROM
    input i
RETURNING
    id, inserted_at, tenant_id, external_id, display_name, workflow_id, workflow_version_id
`

type CreateDAGsParams struct {
	Tenantids          []pgtype.UUID `json:"tenantids"`
	Externalids        []pgtype.UUID `json:"externalids"`
	Displaynames       []string      `json:"displaynames"`
	Workflowids        []pgtype.UUID `json:"workflowids"`
	Workflowversionids []pgtype.UUID `json:"workflowversionids"`
}

func (q *Queries) CreateDAGs(ctx context.Context, db DBTX, arg CreateDAGsParams) ([]*V2Dag, error) {
	rows, err := db.Query(ctx, createDAGs,
		arg.Tenantids,
		arg.Externalids,
		arg.Displaynames,
		arg.Workflowids,
		arg.Workflowversionids,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V2Dag
	for rows.Next() {
		var i V2Dag
		if err := rows.Scan(
			&i.ID,
			&i.InsertedAt,
			&i.TenantID,
			&i.ExternalID,
			&i.DisplayName,
			&i.WorkflowID,
			&i.WorkflowVersionID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDAGData = `-- name: GetDAGData :many
WITH input AS (
    SELECT
        dag_id, dag_inserted_at
    FROM
        (
            SELECT
                unnest($1::bigint[]) AS dag_id,
                unnest($2::timestamptz[]) AS dag_inserted_at
        ) AS subquery
)
SELECT
    v2_dag_data.dag_id, v2_dag_data.dag_inserted_at, input, additional_metadata, input.dag_id, input.dag_inserted_at
FROM
    v2_dag_data
JOIN
    input USING (dag_id, dag_inserted_at)
`

type GetDAGDataParams struct {
	Dagids         []int64              `json:"dagids"`
	Daginsertedats []pgtype.Timestamptz `json:"daginsertedats"`
}

type GetDAGDataRow struct {
	DagID              int64              `json:"dag_id"`
	DagInsertedAt      pgtype.Timestamptz `json:"dag_inserted_at"`
	Input              []byte             `json:"input"`
	AdditionalMetadata []byte             `json:"additional_metadata"`
	DagID_2            interface{}        `json:"dag_id_2"`
	DagInsertedAt_2    interface{}        `json:"dag_inserted_at_2"`
}

func (q *Queries) GetDAGData(ctx context.Context, db DBTX, arg GetDAGDataParams) ([]*GetDAGDataRow, error) {
	rows, err := db.Query(ctx, getDAGData, arg.Dagids, arg.Daginsertedats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetDAGDataRow
	for rows.Next() {
		var i GetDAGDataRow
		if err := rows.Scan(
			&i.DagID,
			&i.DagInsertedAt,
			&i.Input,
			&i.AdditionalMetadata,
			&i.DagID_2,
			&i.DagInsertedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDAGPartitionsBeforeDate = `-- name: ListDAGPartitionsBeforeDate :many
SELECT
    p::text AS partition_name
FROM
    get_v2_dag_partitions_before(
        $1::date
    ) AS p
`

func (q *Queries) ListDAGPartitionsBeforeDate(ctx context.Context, db DBTX, date pgtype.Date) ([]string, error) {
	rows, err := db.Query(ctx, listDAGPartitionsBeforeDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var partition_name string
		if err := rows.Scan(&partition_name); err != nil {
			return nil, err
		}
		items = append(items, partition_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
