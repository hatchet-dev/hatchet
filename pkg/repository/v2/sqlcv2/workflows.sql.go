// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: workflows.sql

package sqlcv2

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getWorkflowStartData = `-- name: GetWorkflowStartData :many
WITH workflow_versions_with_steps AS (
    SELECT
        s.id, s."createdAt", s."updatedAt", s."deletedAt", s."readableId", s."tenantId", s."jobId", s."actionId", s.timeout, s."customUserData", s.retries, s."retryBackoffFactor", s."retryMaxBackoff", s."scheduleTimeout",
        wv."id" as "workflowVersionId",
        w."name" as "workflowName",
        w."id" as "workflowId"
    FROM
        "WorkflowVersion" as wv
    JOIN
        "Workflow" as w ON w."id" = wv."workflowId"
    JOIN
        "Job" j ON j."workflowVersionId" = wv."id"
    JOIN
        "Step" s ON s."jobId" = j."id"
    WHERE
        wv."id" = ANY($1::uuid[])
        AND w."tenantId" = $2::uuid
        AND w."deletedAt" IS NULL 
        AND wv."deletedAt" IS NULL
), step_counts AS (
    SELECT
        DISTINCT ON (wv."workflowVersionId") wv."workflowVersionId" as "workflowVersionId",
        COUNT(wv."id") as "numSteps"
    FROM
        workflow_versions_with_steps as wv
    GROUP BY
        wv."workflowVersionId"
)
SELECT
    wv.id, wv."createdAt", wv."updatedAt", wv."deletedAt", wv."readableId", wv."tenantId", wv."jobId", wv."actionId", wv.timeout, wv."customUserData", wv.retries, wv."retryBackoffFactor", wv."retryMaxBackoff", wv."scheduleTimeout", wv."workflowVersionId", wv."workflowName", wv."workflowId"
FROM
    workflow_versions_with_steps as wv
JOIN
    step_counts sc ON sc."workflowVersionId" = wv."workflowVersionId"
WHERE
    sc."numSteps" = 1
`

type GetWorkflowStartDataParams struct {
	Ids      []pgtype.UUID `json:"ids"`
	Tenantid pgtype.UUID   `json:"tenantid"`
}

type GetWorkflowStartDataRow struct {
	ID                 pgtype.UUID      `json:"id"`
	CreatedAt          pgtype.Timestamp `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	DeletedAt          pgtype.Timestamp `json:"deletedAt"`
	ReadableId         pgtype.Text      `json:"readableId"`
	TenantId           pgtype.UUID      `json:"tenantId"`
	JobId              pgtype.UUID      `json:"jobId"`
	ActionId           string           `json:"actionId"`
	Timeout            pgtype.Text      `json:"timeout"`
	CustomUserData     []byte           `json:"customUserData"`
	Retries            int32            `json:"retries"`
	RetryBackoffFactor pgtype.Float8    `json:"retryBackoffFactor"`
	RetryMaxBackoff    pgtype.Int4      `json:"retryMaxBackoff"`
	ScheduleTimeout    string           `json:"scheduleTimeout"`
	WorkflowVersionId  pgtype.UUID      `json:"workflowVersionId"`
	WorkflowName       string           `json:"workflowName"`
	WorkflowId         pgtype.UUID      `json:"workflowId"`
}

// If the workflow has multiple steps, this does not return any data
// If the workflow has a single step, this returns step data along with workflowVersionId and workflowName
func (q *Queries) GetWorkflowStartData(ctx context.Context, db DBTX, arg GetWorkflowStartDataParams) ([]*GetWorkflowStartDataRow, error) {
	rows, err := db.Query(ctx, getWorkflowStartData, arg.Ids, arg.Tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetWorkflowStartDataRow
	for rows.Next() {
		var i GetWorkflowStartDataRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ReadableId,
			&i.TenantId,
			&i.JobId,
			&i.ActionId,
			&i.Timeout,
			&i.CustomUserData,
			&i.Retries,
			&i.RetryBackoffFactor,
			&i.RetryMaxBackoff,
			&i.ScheduleTimeout,
			&i.WorkflowVersionId,
			&i.WorkflowName,
			&i.WorkflowId,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
