// Package rest provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package rest

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	CookieAuthScopes = "cookieAuth.Scopes"
)

// Defines values for EventOrderByDirection.
const (
	EventOrderByDirectionAsc  EventOrderByDirection = "asc"
	EventOrderByDirectionDesc EventOrderByDirection = "desc"
)

// Defines values for EventOrderByField.
const (
	EventOrderByFieldCreatedAt EventOrderByField = "createdAt"
)

// Defines values for JobRunStatus.
const (
	JobRunStatusCANCELLED JobRunStatus = "CANCELLED"
	JobRunStatusFAILED    JobRunStatus = "FAILED"
	JobRunStatusPENDING   JobRunStatus = "PENDING"
	JobRunStatusRUNNING   JobRunStatus = "RUNNING"
	JobRunStatusSUCCEEDED JobRunStatus = "SUCCEEDED"
)

// Defines values for LogLineLevel.
const (
	DEBUG LogLineLevel = "DEBUG"
	ERROR LogLineLevel = "ERROR"
	INFO  LogLineLevel = "INFO"
	WARN  LogLineLevel = "WARN"
)

// Defines values for LogLineOrderByDirection.
const (
	LogLineOrderByDirectionAsc  LogLineOrderByDirection = "asc"
	LogLineOrderByDirectionDesc LogLineOrderByDirection = "desc"
)

// Defines values for LogLineOrderByField.
const (
	LogLineOrderByFieldCreatedAt LogLineOrderByField = "createdAt"
)

// Defines values for PullRequestState.
const (
	Closed PullRequestState = "closed"
	Open   PullRequestState = "open"
)

// Defines values for StepRunStatus.
const (
	StepRunStatusASSIGNED          StepRunStatus = "ASSIGNED"
	StepRunStatusCANCELLED         StepRunStatus = "CANCELLED"
	StepRunStatusFAILED            StepRunStatus = "FAILED"
	StepRunStatusPENDING           StepRunStatus = "PENDING"
	StepRunStatusPENDINGASSIGNMENT StepRunStatus = "PENDING_ASSIGNMENT"
	StepRunStatusRUNNING           StepRunStatus = "RUNNING"
	StepRunStatusSUCCEEDED         StepRunStatus = "SUCCEEDED"
)

// Defines values for TenantMemberRole.
const (
	ADMIN  TenantMemberRole = "ADMIN"
	MEMBER TenantMemberRole = "MEMBER"
	OWNER  TenantMemberRole = "OWNER"
)

// Defines values for WorkflowConcurrencyLimitStrategy.
const (
	CANCELINPROGRESS WorkflowConcurrencyLimitStrategy = "CANCEL_IN_PROGRESS"
	DROPNEWEST       WorkflowConcurrencyLimitStrategy = "DROP_NEWEST"
	GROUPROUNDROBIN  WorkflowConcurrencyLimitStrategy = "GROUP_ROUND_ROBIN"
	QUEUENEWEST      WorkflowConcurrencyLimitStrategy = "QUEUE_NEWEST"
)

// Defines values for WorkflowRunStatus.
const (
	CANCELLED WorkflowRunStatus = "CANCELLED"
	FAILED    WorkflowRunStatus = "FAILED"
	PENDING   WorkflowRunStatus = "PENDING"
	RUNNING   WorkflowRunStatus = "RUNNING"
	SUCCEEDED WorkflowRunStatus = "SUCCEEDED"
)

// APIError defines model for APIError.
type APIError struct {
	// Code a custom Hatchet error code
	Code *uint64 `json:"code,omitempty"`

	// Description a description for this error
	Description string `json:"description"`

	// DocsLink a link to the documentation for this error, if it exists
	DocsLink *string `json:"docs_link,omitempty"`

	// Field the field that this error is associated with, if applicable
	Field *string `json:"field,omitempty"`
}

// APIErrors defines model for APIErrors.
type APIErrors struct {
	Errors []APIError `json:"errors"`
}

// APIMeta defines model for APIMeta.
type APIMeta struct {
	Auth *APIMetaAuth `json:"auth,omitempty"`
}

// APIMetaAuth defines model for APIMetaAuth.
type APIMetaAuth struct {
	// Schemes the supported types of authentication
	Schemes *[]string `json:"schemes,omitempty"`
}

// APIMetaIntegration defines model for APIMetaIntegration.
type APIMetaIntegration struct {
	// Enabled whether this integration is enabled on the instance
	Enabled bool `json:"enabled"`

	// Name the name of the integration
	Name string `json:"name"`
}

// APIResourceMeta defines model for APIResourceMeta.
type APIResourceMeta struct {
	// CreatedAt the time that this resource was created
	CreatedAt time.Time `json:"createdAt"`

	// Id the id of this resource, in UUID format
	Id openapi_types.UUID `json:"id"`

	// UpdatedAt the time that this resource was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// APIToken defines model for APIToken.
type APIToken struct {
	// ExpiresAt When the API token expires.
	ExpiresAt time.Time       `json:"expiresAt"`
	Metadata  APIResourceMeta `json:"metadata"`

	// Name The name of the API token.
	Name string `json:"name"`
}

// AcceptInviteRequest defines model for AcceptInviteRequest.
type AcceptInviteRequest struct {
	Invite string `json:"invite" validate:"required,uuid"`
}

// CreateAPITokenRequest defines model for CreateAPITokenRequest.
type CreateAPITokenRequest struct {
	// Name A name for the API token.
	Name string `json:"name"`
}

// CreateAPITokenResponse defines model for CreateAPITokenResponse.
type CreateAPITokenResponse struct {
	// Token The API token.
	Token string `json:"token"`
}

// CreatePullRequestFromStepRun defines model for CreatePullRequestFromStepRun.
type CreatePullRequestFromStepRun struct {
	BranchName string `json:"branchName"`
}

// CreateSNSIntegrationRequest defines model for CreateSNSIntegrationRequest.
type CreateSNSIntegrationRequest struct {
	// TopicArn The Amazon Resource Name (ARN) of the SNS topic.
	TopicArn string `json:"topicArn" validate:"required,min=1,max=256"`
}

// CreateTenantInviteRequest defines model for CreateTenantInviteRequest.
type CreateTenantInviteRequest struct {
	// Email The email of the user to invite.
	Email string           `json:"email" validate:"required,email"`
	Role  TenantMemberRole `json:"role"`
}

// CreateTenantRequest defines model for CreateTenantRequest.
type CreateTenantRequest struct {
	// Name The name of the tenant.
	Name string `json:"name" validate:"required"`

	// Slug The slug of the tenant.
	Slug string `json:"slug" validate:"required,hatchetName"`
}

// Event defines model for Event.
type Event struct {
	// Key The key for the event.
	Key      string          `json:"key"`
	Metadata APIResourceMeta `json:"metadata"`
	Tenant   *Tenant         `json:"tenant,omitempty"`

	// TenantId The ID of the tenant associated with this event.
	TenantId           string                   `json:"tenantId"`
	WorkflowRunSummary *EventWorkflowRunSummary `json:"workflowRunSummary,omitempty"`
}

// EventData defines model for EventData.
type EventData struct {
	// Data The data for the event (JSON bytes).
	Data string `json:"data"`
}

// EventKey The key for the event.
type EventKey = string

// EventKeyList defines model for EventKeyList.
type EventKeyList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]EventKey         `json:"rows,omitempty"`
}

// EventList defines model for EventList.
type EventList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]Event            `json:"rows,omitempty"`
}

// EventOrderByDirection defines model for EventOrderByDirection.
type EventOrderByDirection string

// EventOrderByField defines model for EventOrderByField.
type EventOrderByField string

// EventSearch defines model for EventSearch.
type EventSearch = string

// EventWorkflowRunSummary defines model for EventWorkflowRunSummary.
type EventWorkflowRunSummary struct {
	// Failed The number of failed runs.
	Failed *int64 `json:"failed,omitempty"`

	// Pending The number of pending runs.
	Pending *int64 `json:"pending,omitempty"`

	// Running The number of running runs.
	Running *int64 `json:"running,omitempty"`

	// Succeeded The number of succeeded runs.
	Succeeded *int64 `json:"succeeded,omitempty"`
}

// GetStepRunDiffResponse defines model for GetStepRunDiffResponse.
type GetStepRunDiffResponse struct {
	Diffs []StepRunDiff `json:"diffs"`
}

// GithubAppInstallation defines model for GithubAppInstallation.
type GithubAppInstallation struct {
	AccountAvatarUrl        string          `json:"account_avatar_url"`
	AccountName             string          `json:"account_name"`
	InstallationSettingsUrl string          `json:"installation_settings_url"`
	Metadata                APIResourceMeta `json:"metadata"`
}

// GithubBranch defines model for GithubBranch.
type GithubBranch struct {
	BranchName string `json:"branch_name"`
	IsDefault  bool   `json:"is_default"`
}

// GithubRepo defines model for GithubRepo.
type GithubRepo struct {
	RepoName  string `json:"repo_name"`
	RepoOwner string `json:"repo_owner"`
}

// Job defines model for Job.
type Job struct {
	// Description The description of the job.
	Description *string         `json:"description,omitempty"`
	Metadata    APIResourceMeta `json:"metadata"`
	Name        string          `json:"name"`
	Steps       []Step          `json:"steps"`
	TenantId    string          `json:"tenantId"`

	// Timeout The timeout of the job.
	Timeout   *string `json:"timeout,omitempty"`
	VersionId string  `json:"versionId"`
}

// JobRun defines model for JobRun.
type JobRun struct {
	CancelledAt     *time.Time              `json:"cancelledAt,omitempty"`
	CancelledError  *string                 `json:"cancelledError,omitempty"`
	CancelledReason *string                 `json:"cancelledReason,omitempty"`
	FinishedAt      *time.Time              `json:"finishedAt,omitempty"`
	Job             *Job                    `json:"job,omitempty"`
	JobId           string                  `json:"jobId"`
	Metadata        APIResourceMeta         `json:"metadata"`
	Result          *map[string]interface{} `json:"result,omitempty"`
	StartedAt       *time.Time              `json:"startedAt,omitempty"`
	Status          JobRunStatus            `json:"status"`
	StepRuns        *[]StepRun              `json:"stepRuns,omitempty"`
	TenantId        string                  `json:"tenantId"`
	TickerId        *string                 `json:"tickerId,omitempty"`
	TimeoutAt       *time.Time              `json:"timeoutAt,omitempty"`
	WorkflowRun     *WorkflowRun            `json:"workflowRun,omitempty"`
	WorkflowRunId   string                  `json:"workflowRunId"`
}

// JobRunStatus defines model for JobRunStatus.
type JobRunStatus string

// LinkGithubRepositoryRequest defines model for LinkGithubRepositoryRequest.
type LinkGithubRepositoryRequest struct {
	// GitRepoBranch The repository branch.
	GitRepoBranch string `json:"gitRepoBranch"`

	// GitRepoName The repository name.
	GitRepoName string `json:"gitRepoName"`

	// GitRepoOwner The repository owner.
	GitRepoOwner string `json:"gitRepoOwner"`

	// InstallationId The repository name.
	InstallationId string `json:"installationId"`
}

// ListAPIMetaIntegration defines model for ListAPIMetaIntegration.
type ListAPIMetaIntegration = []APIMetaIntegration

// ListAPITokensResponse defines model for ListAPITokensResponse.
type ListAPITokensResponse struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]APIToken         `json:"rows,omitempty"`
}

// ListGithubAppInstallationsResponse defines model for ListGithubAppInstallationsResponse.
type ListGithubAppInstallationsResponse struct {
	Pagination PaginationResponse      `json:"pagination"`
	Rows       []GithubAppInstallation `json:"rows"`
}

// ListGithubBranchesResponse defines model for ListGithubBranchesResponse.
type ListGithubBranchesResponse = []GithubBranch

// ListGithubReposResponse defines model for ListGithubReposResponse.
type ListGithubReposResponse = []GithubRepo

// ListPullRequestsResponse defines model for ListPullRequestsResponse.
type ListPullRequestsResponse struct {
	PullRequests []PullRequest `json:"pullRequests"`
}

// ListSNSIntegrations defines model for ListSNSIntegrations.
type ListSNSIntegrations struct {
	Pagination PaginationResponse `json:"pagination"`
	Rows       []SNSIntegration   `json:"rows"`
}

// LogLine defines model for LogLine.
type LogLine struct {
	// CreatedAt The creation date of the log line.
	CreatedAt time.Time `json:"createdAt"`

	// Message The log message.
	Message string `json:"message"`

	// Metadata The log metadata.
	Metadata map[string]interface{} `json:"metadata"`
}

// LogLineLevel defines model for LogLineLevel.
type LogLineLevel string

// LogLineLevelField defines model for LogLineLevelField.
type LogLineLevelField = []LogLineLevel

// LogLineList defines model for LogLineList.
type LogLineList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]LogLine          `json:"rows,omitempty"`
}

// LogLineOrderByDirection defines model for LogLineOrderByDirection.
type LogLineOrderByDirection string

// LogLineOrderByField defines model for LogLineOrderByField.
type LogLineOrderByField string

// LogLineSearch defines model for LogLineSearch.
type LogLineSearch = string

// PaginationResponse defines model for PaginationResponse.
type PaginationResponse struct {
	// CurrentPage the current page
	CurrentPage *int64 `json:"current_page,omitempty"`

	// NextPage the next page
	NextPage *int64 `json:"next_page,omitempty"`

	// NumPages the total number of pages for listing
	NumPages *int64 `json:"num_pages,omitempty"`
}

// PullRequest defines model for PullRequest.
type PullRequest struct {
	PullRequestBaseBranch string           `json:"pullRequestBaseBranch"`
	PullRequestHeadBranch string           `json:"pullRequestHeadBranch"`
	PullRequestID         int              `json:"pullRequestID"`
	PullRequestNumber     int              `json:"pullRequestNumber"`
	PullRequestState      PullRequestState `json:"pullRequestState"`
	PullRequestTitle      string           `json:"pullRequestTitle"`
	RepositoryName        string           `json:"repositoryName"`
	RepositoryOwner       string           `json:"repositoryOwner"`
}

// PullRequestState defines model for PullRequestState.
type PullRequestState string

// RejectInviteRequest defines model for RejectInviteRequest.
type RejectInviteRequest struct {
	Invite string `json:"invite" validate:"required,uuid"`
}

// ReplayEventRequest defines model for ReplayEventRequest.
type ReplayEventRequest struct {
	EventIds []openapi_types.UUID `json:"eventIds"`
}

// RerunStepRunRequest defines model for RerunStepRunRequest.
type RerunStepRunRequest struct {
	Input map[string]interface{} `json:"input"`
}

// SNSIntegration defines model for SNSIntegration.
type SNSIntegration struct {
	// IngestUrl The URL to send SNS messages to.
	IngestUrl *string         `json:"ingestUrl,omitempty"`
	Metadata  APIResourceMeta `json:"metadata"`

	// TenantId The unique identifier for the tenant that the SNS integration belongs to.
	TenantId openapi_types.UUID `json:"tenantId"`

	// TopicArn The Amazon Resource Name (ARN) of the SNS topic.
	TopicArn string `json:"topicArn"`
}

// Step defines model for Step.
type Step struct {
	Action   string          `json:"action"`
	Children *[]string       `json:"children,omitempty"`
	JobId    string          `json:"jobId"`
	Metadata APIResourceMeta `json:"metadata"`
	Parents  *[]string       `json:"parents,omitempty"`

	// ReadableId The readable id of the step.
	ReadableId string `json:"readableId"`
	TenantId   string `json:"tenantId"`

	// Timeout The timeout of the step.
	Timeout *string `json:"timeout,omitempty"`
}

// StepRun defines model for StepRun.
type StepRun struct {
	CancelledAt       *time.Time              `json:"cancelledAt,omitempty"`
	CancelledAtEpoch  *int                    `json:"cancelledAtEpoch,omitempty"`
	CancelledError    *string                 `json:"cancelledError,omitempty"`
	CancelledReason   *string                 `json:"cancelledReason,omitempty"`
	ChildWorkflowRuns *[]string               `json:"childWorkflowRuns,omitempty"`
	Children          *[]string               `json:"children,omitempty"`
	Error             *string                 `json:"error,omitempty"`
	FinishedAt        *time.Time              `json:"finishedAt,omitempty"`
	FinishedAtEpoch   *int                    `json:"finishedAtEpoch,omitempty"`
	Input             *string                 `json:"input,omitempty"`
	JobRun            *JobRun                 `json:"jobRun,omitempty"`
	JobRunId          string                  `json:"jobRunId"`
	Metadata          APIResourceMeta         `json:"metadata"`
	Output            *string                 `json:"output,omitempty"`
	Parents           *[]string               `json:"parents,omitempty"`
	RequeueAfter      *time.Time              `json:"requeueAfter,omitempty"`
	Result            *map[string]interface{} `json:"result,omitempty"`
	StartedAt         *time.Time              `json:"startedAt,omitempty"`
	StartedAtEpoch    *int                    `json:"startedAtEpoch,omitempty"`
	Status            StepRunStatus           `json:"status"`
	Step              *Step                   `json:"step,omitempty"`
	StepId            string                  `json:"stepId"`
	TenantId          string                  `json:"tenantId"`
	TimeoutAt         *time.Time              `json:"timeoutAt,omitempty"`
	TimeoutAtEpoch    *int                    `json:"timeoutAtEpoch,omitempty"`
	WorkerId          *string                 `json:"workerId,omitempty"`
}

// StepRunDiff defines model for StepRunDiff.
type StepRunDiff struct {
	Key      string `json:"key"`
	Modified string `json:"modified"`
	Original string `json:"original"`
}

// StepRunStatus defines model for StepRunStatus.
type StepRunStatus string

// Tenant defines model for Tenant.
type Tenant struct {
	Metadata APIResourceMeta `json:"metadata"`

	// Name The name of the tenant.
	Name string `json:"name"`

	// Slug The slug of the tenant.
	Slug string `json:"slug"`
}

// TenantInvite defines model for TenantInvite.
type TenantInvite struct {
	// Email The email of the user to invite.
	Email string `json:"email"`

	// Expires The time that this invite expires.
	Expires  time.Time        `json:"expires"`
	Metadata APIResourceMeta  `json:"metadata"`
	Role     TenantMemberRole `json:"role"`

	// TenantId The tenant id associated with this tenant invite.
	TenantId string `json:"tenantId"`

	// TenantName The tenant name for the tenant.
	TenantName *string `json:"tenantName,omitempty"`
}

// TenantInviteList defines model for TenantInviteList.
type TenantInviteList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]TenantInvite     `json:"rows,omitempty"`
}

// TenantMember defines model for TenantMember.
type TenantMember struct {
	Metadata APIResourceMeta  `json:"metadata"`
	Role     TenantMemberRole `json:"role"`
	Tenant   *Tenant          `json:"tenant,omitempty"`
	User     UserTenantPublic `json:"user"`
}

// TenantMemberList defines model for TenantMemberList.
type TenantMemberList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]TenantMember     `json:"rows,omitempty"`
}

// TenantMemberRole defines model for TenantMemberRole.
type TenantMemberRole string

// TriggerWorkflowRunRequest defines model for TriggerWorkflowRunRequest.
type TriggerWorkflowRunRequest struct {
	Input map[string]interface{} `json:"input"`
}

// UpdateTenantInviteRequest defines model for UpdateTenantInviteRequest.
type UpdateTenantInviteRequest struct {
	Role TenantMemberRole `json:"role"`
}

// User defines model for User.
type User struct {
	// Email The email address of the user.
	Email openapi_types.Email `json:"email"`

	// EmailVerified Whether the user has verified their email address.
	EmailVerified bool `json:"emailVerified"`

	// HasPassword Whether the user has a password set.
	HasPassword *bool           `json:"hasPassword,omitempty"`
	Metadata    APIResourceMeta `json:"metadata"`

	// Name The display name of the user.
	Name *string `json:"name,omitempty"`
}

// UserChangePasswordRequest defines model for UserChangePasswordRequest.
type UserChangePasswordRequest struct {
	// NewPassword The new password for the user.
	NewPassword string `json:"newPassword" validate:"required,password"`

	// Password The password of the user.
	Password string `json:"password" validate:"required,password"`
}

// UserLoginRequest defines model for UserLoginRequest.
type UserLoginRequest struct {
	// Email The email address of the user.
	Email openapi_types.Email `json:"email" validate:"required,email"`

	// Password The password of the user.
	Password string `json:"password" validate:"required,password"`
}

// UserRegisterRequest defines model for UserRegisterRequest.
type UserRegisterRequest struct {
	// Email The email address of the user.
	Email openapi_types.Email `json:"email" validate:"required,email"`

	// Name The name of the user.
	Name string `json:"name"`

	// Password The password of the user.
	Password string `json:"password" validate:"required,password"`
}

// UserTenantMembershipsList defines model for UserTenantMembershipsList.
type UserTenantMembershipsList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]TenantMember     `json:"rows,omitempty"`
}

// UserTenantPublic defines model for UserTenantPublic.
type UserTenantPublic struct {
	// Email The email address of the user.
	Email openapi_types.Email `json:"email"`

	// Name The display name of the user.
	Name *string `json:"name,omitempty"`
}

// Worker defines model for Worker.
type Worker struct {
	// Actions The actions this worker can perform.
	Actions *[]string `json:"actions,omitempty"`

	// LastHeartbeatAt The time this worker last sent a heartbeat.
	LastHeartbeatAt *time.Time      `json:"lastHeartbeatAt,omitempty"`
	Metadata        APIResourceMeta `json:"metadata"`

	// Name The name of the worker.
	Name string `json:"name"`

	// RecentStepRuns The recent step runs for this worker.
	RecentStepRuns *[]StepRun `json:"recentStepRuns,omitempty"`
}

// WorkerList defines model for WorkerList.
type WorkerList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]Worker           `json:"rows,omitempty"`
}

// Workflow defines model for Workflow.
type Workflow struct {
	Deployment *WorkflowDeploymentConfig `json:"deployment,omitempty"`

	// Description The description of the workflow.
	Description *string `json:"description,omitempty"`

	// Jobs The jobs of the workflow.
	Jobs     *[]Job          `json:"jobs,omitempty"`
	LastRun  *WorkflowRun    `json:"lastRun,omitempty"`
	Metadata APIResourceMeta `json:"metadata"`

	// Name The name of the workflow.
	Name string `json:"name"`

	// Tags The tags of the workflow.
	Tags     *[]WorkflowTag         `json:"tags,omitempty"`
	Versions *[]WorkflowVersionMeta `json:"versions,omitempty"`
}

// WorkflowConcurrency defines model for WorkflowConcurrency.
type WorkflowConcurrency struct {
	// GetConcurrencyGroup An action which gets the concurrency group for the WorkflowRun.
	GetConcurrencyGroup string `json:"getConcurrencyGroup"`

	// LimitStrategy The strategy to use when the concurrency limit is reached.
	LimitStrategy WorkflowConcurrencyLimitStrategy `json:"limitStrategy"`

	// MaxRuns The maximum number of concurrent workflow runs.
	MaxRuns int32 `json:"maxRuns"`
}

// WorkflowConcurrencyLimitStrategy The strategy to use when the concurrency limit is reached.
type WorkflowConcurrencyLimitStrategy string

// WorkflowDeploymentConfig defines model for WorkflowDeploymentConfig.
type WorkflowDeploymentConfig struct {
	// GitRepoBranch The repository branch.
	GitRepoBranch string `json:"gitRepoBranch"`

	// GitRepoName The repository name.
	GitRepoName string `json:"gitRepoName"`

	// GitRepoOwner The repository owner.
	GitRepoOwner          string                 `json:"gitRepoOwner"`
	GithubAppInstallation *GithubAppInstallation `json:"githubAppInstallation,omitempty"`

	// GithubAppInstallationId The id of the Github App installation.
	GithubAppInstallationId openapi_types.UUID `json:"githubAppInstallationId"`
	Metadata                APIResourceMeta    `json:"metadata"`
}

// WorkflowID A workflow ID.
type WorkflowID = string

// WorkflowList defines model for WorkflowList.
type WorkflowList struct {
	Metadata   *APIResourceMeta    `json:"metadata,omitempty"`
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]Workflow         `json:"rows,omitempty"`
}

// WorkflowRun defines model for WorkflowRun.
type WorkflowRun struct {
	DisplayName       *string                 `json:"displayName,omitempty"`
	Error             *string                 `json:"error,omitempty"`
	FinishedAt        *time.Time              `json:"finishedAt,omitempty"`
	Input             *map[string]interface{} `json:"input,omitempty"`
	JobRuns           *[]JobRun               `json:"jobRuns,omitempty"`
	Metadata          APIResourceMeta         `json:"metadata"`
	ParentId          *openapi_types.UUID     `json:"parentId,omitempty"`
	ParentStepRunId   *openapi_types.UUID     `json:"parentStepRunId,omitempty"`
	StartedAt         *time.Time              `json:"startedAt,omitempty"`
	Status            WorkflowRunStatus       `json:"status"`
	TenantId          string                  `json:"tenantId"`
	TriggeredBy       WorkflowRunTriggeredBy  `json:"triggeredBy"`
	WorkflowVersion   *WorkflowVersion        `json:"workflowVersion,omitempty"`
	WorkflowVersionId string                  `json:"workflowVersionId"`
}

// WorkflowRunList defines model for WorkflowRunList.
type WorkflowRunList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]WorkflowRun      `json:"rows,omitempty"`
}

// WorkflowRunStatus defines model for WorkflowRunStatus.
type WorkflowRunStatus string

// WorkflowRunStatusList defines model for WorkflowRunStatusList.
type WorkflowRunStatusList = []WorkflowRunStatus

// WorkflowRunTriggeredBy defines model for WorkflowRunTriggeredBy.
type WorkflowRunTriggeredBy struct {
	CronParentId *string         `json:"cronParentId,omitempty"`
	CronSchedule *string         `json:"cronSchedule,omitempty"`
	Event        *Event          `json:"event,omitempty"`
	EventId      *string         `json:"eventId,omitempty"`
	Metadata     APIResourceMeta `json:"metadata"`
	ParentId     string          `json:"parentId"`
}

// WorkflowTag defines model for WorkflowTag.
type WorkflowTag struct {
	// Color The description of the workflow.
	Color string `json:"color"`

	// Name The name of the workflow.
	Name string `json:"name"`
}

// WorkflowTriggerCronRef defines model for WorkflowTriggerCronRef.
type WorkflowTriggerCronRef struct {
	Cron     *string `json:"cron,omitempty"`
	ParentId *string `json:"parent_id,omitempty"`
}

// WorkflowTriggerEventRef defines model for WorkflowTriggerEventRef.
type WorkflowTriggerEventRef struct {
	EventKey *string `json:"event_key,omitempty"`
	ParentId *string `json:"parent_id,omitempty"`
}

// WorkflowTriggers defines model for WorkflowTriggers.
type WorkflowTriggers struct {
	Crons             *[]WorkflowTriggerCronRef  `json:"crons,omitempty"`
	Events            *[]WorkflowTriggerEventRef `json:"events,omitempty"`
	Metadata          *APIResourceMeta           `json:"metadata,omitempty"`
	TenantId          *string                    `json:"tenant_id,omitempty"`
	WorkflowVersionId *string                    `json:"workflow_version_id,omitempty"`
}

// WorkflowVersion defines model for WorkflowVersion.
type WorkflowVersion struct {
	Concurrency *WorkflowConcurrency `json:"concurrency,omitempty"`
	Jobs        *[]Job               `json:"jobs,omitempty"`
	Metadata    APIResourceMeta      `json:"metadata"`
	Order       int32                `json:"order"`
	Triggers    *WorkflowTriggers    `json:"triggers,omitempty"`

	// Version The version of the workflow.
	Version    string    `json:"version"`
	Workflow   *Workflow `json:"workflow,omitempty"`
	WorkflowId string    `json:"workflowId"`
}

// WorkflowVersionDefinition defines model for WorkflowVersionDefinition.
type WorkflowVersionDefinition struct {
	// RawDefinition The raw YAML definition of the workflow.
	RawDefinition string `json:"rawDefinition"`
}

// WorkflowVersionMeta defines model for WorkflowVersionMeta.
type WorkflowVersionMeta struct {
	Metadata APIResourceMeta `json:"metadata"`
	Order    int32           `json:"order"`

	// Version The version of the workflow.
	Version    string    `json:"version"`
	Workflow   *Workflow `json:"workflow,omitempty"`
	WorkflowId string    `json:"workflowId"`
}

// LogLineListParams defines parameters for LogLineList.
type LogLineListParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Levels A list of levels to filter by
	Levels *LogLineLevelField `form:"levels,omitempty" json:"levels,omitempty"`

	// Search The search query to filter for
	Search *LogLineSearch `form:"search,omitempty" json:"search,omitempty"`

	// OrderByField What to order by
	OrderByField *LogLineOrderByField `form:"orderByField,omitempty" json:"orderByField,omitempty"`

	// OrderByDirection The order direction
	OrderByDirection *LogLineOrderByDirection `form:"orderByDirection,omitempty" json:"orderByDirection,omitempty"`
}

// EventListParams defines parameters for EventList.
type EventListParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Keys A list of keys to filter by
	Keys *[]EventKey `form:"keys,omitempty" json:"keys,omitempty"`

	// Workflows A list of workflow IDs to filter by
	Workflows *[]WorkflowID `form:"workflows,omitempty" json:"workflows,omitempty"`

	// Statuses A list of workflow run statuses to filter by
	Statuses *WorkflowRunStatusList `form:"statuses,omitempty" json:"statuses,omitempty"`

	// Search The search query to filter for
	Search *EventSearch `form:"search,omitempty" json:"search,omitempty"`

	// OrderByField What to order by
	OrderByField *EventOrderByField `form:"orderByField,omitempty" json:"orderByField,omitempty"`

	// OrderByDirection The order direction
	OrderByDirection *EventOrderByDirection `form:"orderByDirection,omitempty" json:"orderByDirection,omitempty"`
}

// WorkflowRunListPullRequestsParams defines parameters for WorkflowRunListPullRequests.
type WorkflowRunListPullRequestsParams struct {
	// State The pull request state
	State *PullRequestState `form:"state,omitempty" json:"state,omitempty"`
}

// WorkflowRunListParams defines parameters for WorkflowRunList.
type WorkflowRunListParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// EventId The event id to get runs for.
	EventId *openapi_types.UUID `form:"eventId,omitempty" json:"eventId,omitempty"`

	// WorkflowId The workflow id to get runs for.
	WorkflowId *openapi_types.UUID `form:"workflowId,omitempty" json:"workflowId,omitempty"`

	// ParentWorkflowRunId The parent workflow run id
	ParentWorkflowRunId *openapi_types.UUID `form:"parentWorkflowRunId,omitempty" json:"parentWorkflowRunId,omitempty"`

	// ParentStepRunId The parent step run id
	ParentStepRunId *openapi_types.UUID `form:"parentStepRunId,omitempty" json:"parentStepRunId,omitempty"`
}

// WorkflowRunCreateParams defines parameters for WorkflowRunCreate.
type WorkflowRunCreateParams struct {
	// Version The workflow version. If not supplied, the latest version is fetched.
	Version *openapi_types.UUID `form:"version,omitempty" json:"version,omitempty"`
}

// WorkflowVersionGetParams defines parameters for WorkflowVersionGet.
type WorkflowVersionGetParams struct {
	// Version The workflow version. If not supplied, the latest version is fetched.
	Version *openapi_types.UUID `form:"version,omitempty" json:"version,omitempty"`
}

// WorkflowVersionGetDefinitionParams defines parameters for WorkflowVersionGetDefinition.
type WorkflowVersionGetDefinitionParams struct {
	// Version The workflow version. If not supplied, the latest version is fetched.
	Version *openapi_types.UUID `form:"version,omitempty" json:"version,omitempty"`
}

// StepRunUpdateCreatePrJSONRequestBody defines body for StepRunUpdateCreatePr for application/json ContentType.
type StepRunUpdateCreatePrJSONRequestBody = CreatePullRequestFromStepRun

// TenantCreateJSONRequestBody defines body for TenantCreate for application/json ContentType.
type TenantCreateJSONRequestBody = CreateTenantRequest

// ApiTokenCreateJSONRequestBody defines body for ApiTokenCreate for application/json ContentType.
type ApiTokenCreateJSONRequestBody = CreateAPITokenRequest

// EventUpdateReplayJSONRequestBody defines body for EventUpdateReplay for application/json ContentType.
type EventUpdateReplayJSONRequestBody = ReplayEventRequest

// TenantInviteCreateJSONRequestBody defines body for TenantInviteCreate for application/json ContentType.
type TenantInviteCreateJSONRequestBody = CreateTenantInviteRequest

// TenantInviteUpdateJSONRequestBody defines body for TenantInviteUpdate for application/json ContentType.
type TenantInviteUpdateJSONRequestBody = UpdateTenantInviteRequest

// SnsCreateJSONRequestBody defines body for SnsCreate for application/json ContentType.
type SnsCreateJSONRequestBody = CreateSNSIntegrationRequest

// StepRunUpdateRerunJSONRequestBody defines body for StepRunUpdateRerun for application/json ContentType.
type StepRunUpdateRerunJSONRequestBody = RerunStepRunRequest

// TenantInviteAcceptJSONRequestBody defines body for TenantInviteAccept for application/json ContentType.
type TenantInviteAcceptJSONRequestBody = AcceptInviteRequest

// TenantInviteRejectJSONRequestBody defines body for TenantInviteReject for application/json ContentType.
type TenantInviteRejectJSONRequestBody = RejectInviteRequest

// UserUpdateLoginJSONRequestBody defines body for UserUpdateLogin for application/json ContentType.
type UserUpdateLoginJSONRequestBody = UserLoginRequest

// UserUpdatePasswordJSONRequestBody defines body for UserUpdatePassword for application/json ContentType.
type UserUpdatePasswordJSONRequestBody = UserChangePasswordRequest

// UserCreateJSONRequestBody defines body for UserCreate for application/json ContentType.
type UserCreateJSONRequestBody = UserRegisterRequest

// WorkflowUpdateLinkGithubJSONRequestBody defines body for WorkflowUpdateLinkGithub for application/json ContentType.
type WorkflowUpdateLinkGithubJSONRequestBody = LinkGithubRepositoryRequest

// WorkflowRunCreateJSONRequestBody defines body for WorkflowRunCreate for application/json ContentType.
type WorkflowRunCreateJSONRequestBody = TriggerWorkflowRunRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// LivenessGet request
	LivenessGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadinessGet request
	ReadinessGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiTokenUpdateRevoke request
	ApiTokenUpdateRevoke(ctx context.Context, apiToken openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventDataGet request
	EventDataGet(ctx context.Context, event openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GithubAppListInstallations request
	GithubAppListInstallations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GithubAppListRepos request
	GithubAppListRepos(ctx context.Context, ghInstallation openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GithubAppListBranches request
	GithubAppListBranches(ctx context.Context, ghInstallation openapi_types.UUID, ghRepoOwner string, ghRepoName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GithubUpdateGlobalWebhook request
	GithubUpdateGlobalWebhook(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GithubUpdateTenantWebhook request
	GithubUpdateTenantWebhook(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetadataGet request
	MetadataGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetadataListIntegrations request
	MetadataListIntegrations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnsDelete request
	SnsDelete(ctx context.Context, sns openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnsUpdate request
	SnsUpdate(ctx context.Context, tenant openapi_types.UUID, event string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunUpdateCreatePrWithBody request with any body
	StepRunUpdateCreatePrWithBody(ctx context.Context, stepRun openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StepRunUpdateCreatePr(ctx context.Context, stepRun openapi_types.UUID, body StepRunUpdateCreatePrJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunGetDiff request
	StepRunGetDiff(ctx context.Context, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogLineList request
	LogLineList(ctx context.Context, stepRun openapi_types.UUID, params *LogLineListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantCreateWithBody request with any body
	TenantCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantCreate(ctx context.Context, body TenantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiTokenList request
	ApiTokenList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiTokenCreateWithBody request with any body
	ApiTokenCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApiTokenCreate(ctx context.Context, tenant openapi_types.UUID, body ApiTokenCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventList request
	EventList(ctx context.Context, tenant openapi_types.UUID, params *EventListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventKeyList request
	EventKeyList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventUpdateReplayWithBody request with any body
	EventUpdateReplayWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EventUpdateReplay(ctx context.Context, tenant openapi_types.UUID, body EventUpdateReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteList request
	TenantInviteList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteCreateWithBody request with any body
	TenantInviteCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantInviteCreate(ctx context.Context, tenant openapi_types.UUID, body TenantInviteCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteDelete request
	TenantInviteDelete(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteUpdateWithBody request with any body
	TenantInviteUpdateWithBody(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantInviteUpdate(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, body TenantInviteUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantMemberList request
	TenantMemberList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnsList request
	SnsList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnsCreateWithBody request with any body
	SnsCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SnsCreate(ctx context.Context, tenant openapi_types.UUID, body SnsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunGet request
	StepRunGet(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunUpdateCancel request
	StepRunUpdateCancel(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunUpdateRerunWithBody request with any body
	StepRunUpdateRerunWithBody(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StepRunUpdateRerun(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, body StepRunUpdateRerunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunGetSchema request
	StepRunGetSchema(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerList request
	WorkerList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunGet request
	WorkflowRunGet(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunListPullRequests request
	WorkflowRunListPullRequests(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, params *WorkflowRunListPullRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowList request
	WorkflowList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunList request
	WorkflowRunList(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserGetCurrent request
	UserGetCurrent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateGithubOauthCallback request
	UserUpdateGithubOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateGithubOauthStart request
	UserUpdateGithubOauthStart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateGoogleOauthCallback request
	UserUpdateGoogleOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateGoogleOauthStart request
	UserUpdateGoogleOauthStart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserListTenantInvites request
	UserListTenantInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteAcceptWithBody request with any body
	TenantInviteAcceptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantInviteAccept(ctx context.Context, body TenantInviteAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteRejectWithBody request with any body
	TenantInviteRejectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantInviteReject(ctx context.Context, body TenantInviteRejectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateLoginWithBody request with any body
	UserUpdateLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserUpdateLogin(ctx context.Context, body UserUpdateLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateLogout request
	UserUpdateLogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantMembershipsList request
	TenantMembershipsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdatePasswordWithBody request with any body
	UserUpdatePasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserUpdatePassword(ctx context.Context, body UserUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserCreateWithBody request with any body
	UserCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserCreate(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerGet request
	WorkerGet(ctx context.Context, worker openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowDelete request
	WorkflowDelete(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowGet request
	WorkflowGet(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowUpdateLinkGithubWithBody request with any body
	WorkflowUpdateLinkGithubWithBody(ctx context.Context, workflow openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorkflowUpdateLinkGithub(ctx context.Context, workflow openapi_types.UUID, body WorkflowUpdateLinkGithubJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunCreateWithBody request with any body
	WorkflowRunCreateWithBody(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorkflowRunCreate(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, body WorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowVersionGet request
	WorkflowVersionGet(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowVersionGetDefinition request
	WorkflowVersionGetDefinition(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetDefinitionParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) LivenessGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLivenessGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadinessGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadinessGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiTokenUpdateRevoke(ctx context.Context, apiToken openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiTokenUpdateRevokeRequest(c.Server, apiToken)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventDataGet(ctx context.Context, event openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventDataGetRequest(c.Server, event)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GithubAppListInstallations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGithubAppListInstallationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GithubAppListRepos(ctx context.Context, ghInstallation openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGithubAppListReposRequest(c.Server, ghInstallation)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GithubAppListBranches(ctx context.Context, ghInstallation openapi_types.UUID, ghRepoOwner string, ghRepoName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGithubAppListBranchesRequest(c.Server, ghInstallation, ghRepoOwner, ghRepoName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GithubUpdateGlobalWebhook(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGithubUpdateGlobalWebhookRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GithubUpdateTenantWebhook(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGithubUpdateTenantWebhookRequest(c.Server, webhook)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataListIntegrations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataListIntegrationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnsDelete(ctx context.Context, sns openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnsDeleteRequest(c.Server, sns)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnsUpdate(ctx context.Context, tenant openapi_types.UUID, event string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnsUpdateRequest(c.Server, tenant, event)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunUpdateCreatePrWithBody(ctx context.Context, stepRun openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunUpdateCreatePrRequestWithBody(c.Server, stepRun, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunUpdateCreatePr(ctx context.Context, stepRun openapi_types.UUID, body StepRunUpdateCreatePrJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunUpdateCreatePrRequest(c.Server, stepRun, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunGetDiff(ctx context.Context, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunGetDiffRequest(c.Server, stepRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogLineList(ctx context.Context, stepRun openapi_types.UUID, params *LogLineListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogLineListRequest(c.Server, stepRun, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantCreate(ctx context.Context, body TenantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiTokenList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiTokenListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiTokenCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiTokenCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiTokenCreate(ctx context.Context, tenant openapi_types.UUID, body ApiTokenCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiTokenCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventList(ctx context.Context, tenant openapi_types.UUID, params *EventListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventListRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventKeyList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventKeyListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventUpdateReplayWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventUpdateReplayRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventUpdateReplay(ctx context.Context, tenant openapi_types.UUID, body EventUpdateReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventUpdateReplayRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteCreate(ctx context.Context, tenant openapi_types.UUID, body TenantInviteCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteDelete(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteDeleteRequest(c.Server, tenant, tenantInvite)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteUpdateWithBody(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteUpdateRequestWithBody(c.Server, tenant, tenantInvite, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteUpdate(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, body TenantInviteUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteUpdateRequest(c.Server, tenant, tenantInvite, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantMemberList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantMemberListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnsList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnsListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnsCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnsCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnsCreate(ctx context.Context, tenant openapi_types.UUID, body SnsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnsCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunGet(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunGetRequest(c.Server, tenant, stepRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunUpdateCancel(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunUpdateCancelRequest(c.Server, tenant, stepRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunUpdateRerunWithBody(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunUpdateRerunRequestWithBody(c.Server, tenant, stepRun, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunUpdateRerun(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, body StepRunUpdateRerunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunUpdateRerunRequest(c.Server, tenant, stepRun, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunGetSchema(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunGetSchemaRequest(c.Server, tenant, stepRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunGet(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunGetRequest(c.Server, tenant, workflowRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunListPullRequests(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, params *WorkflowRunListPullRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunListPullRequestsRequest(c.Server, tenant, workflowRun, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunList(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunListRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserGetCurrent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserGetCurrentRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateGithubOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateGithubOauthCallbackRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateGithubOauthStart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateGithubOauthStartRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateGoogleOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateGoogleOauthCallbackRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateGoogleOauthStart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateGoogleOauthStartRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserListTenantInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserListTenantInvitesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteAcceptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteAcceptRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteAccept(ctx context.Context, body TenantInviteAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteAcceptRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteRejectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteRejectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteReject(ctx context.Context, body TenantInviteRejectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteRejectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateLogin(ctx context.Context, body UserUpdateLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateLogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantMembershipsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantMembershipsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdatePasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdatePasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdatePassword(ctx context.Context, body UserUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdatePasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserCreate(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerGet(ctx context.Context, worker openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerGetRequest(c.Server, worker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowDelete(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowDeleteRequest(c.Server, workflow)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowGet(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowGetRequest(c.Server, workflow)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowUpdateLinkGithubWithBody(ctx context.Context, workflow openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowUpdateLinkGithubRequestWithBody(c.Server, workflow, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowUpdateLinkGithub(ctx context.Context, workflow openapi_types.UUID, body WorkflowUpdateLinkGithubJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowUpdateLinkGithubRequest(c.Server, workflow, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunCreateWithBody(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunCreateRequestWithBody(c.Server, workflow, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunCreate(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, body WorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunCreateRequest(c.Server, workflow, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowVersionGet(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowVersionGetRequest(c.Server, workflow, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowVersionGetDefinition(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetDefinitionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowVersionGetDefinitionRequest(c.Server, workflow, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewLivenessGetRequest generates requests for LivenessGet
func NewLivenessGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/live")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadinessGetRequest generates requests for ReadinessGet
func NewReadinessGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApiTokenUpdateRevokeRequest generates requests for ApiTokenUpdateRevoke
func NewApiTokenUpdateRevokeRequest(server string, apiToken openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "api-token", runtime.ParamLocationPath, apiToken)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/api-tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEventDataGetRequest generates requests for EventDataGet
func NewEventDataGetRequest(server string, event openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event", runtime.ParamLocationPath, event)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/events/%s/data", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGithubAppListInstallationsRequest generates requests for GithubAppListInstallations
func NewGithubAppListInstallationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/github-app/installations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGithubAppListReposRequest generates requests for GithubAppListRepos
func NewGithubAppListReposRequest(server string, ghInstallation openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gh-installation", runtime.ParamLocationPath, ghInstallation)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/github-app/installations/%s/repos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGithubAppListBranchesRequest generates requests for GithubAppListBranches
func NewGithubAppListBranchesRequest(server string, ghInstallation openapi_types.UUID, ghRepoOwner string, ghRepoName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gh-installation", runtime.ParamLocationPath, ghInstallation)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "gh-repo-owner", runtime.ParamLocationPath, ghRepoOwner)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "gh-repo-name", runtime.ParamLocationPath, ghRepoName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/github-app/installations/%s/repos/%s/%s/branches", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGithubUpdateGlobalWebhookRequest generates requests for GithubUpdateGlobalWebhook
func NewGithubUpdateGlobalWebhookRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/github/webhook")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGithubUpdateTenantWebhookRequest generates requests for GithubUpdateTenantWebhook
func NewGithubUpdateTenantWebhookRequest(server string, webhook openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhook", runtime.ParamLocationPath, webhook)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/github/webhook/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetadataGetRequest generates requests for MetadataGet
func NewMetadataGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meta")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetadataListIntegrationsRequest generates requests for MetadataListIntegrations
func NewMetadataListIntegrationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meta/integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnsDeleteRequest generates requests for SnsDelete
func NewSnsDeleteRequest(server string, sns openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sns", runtime.ParamLocationPath, sns)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnsUpdateRequest generates requests for SnsUpdate
func NewSnsUpdateRequest(server string, tenant openapi_types.UUID, event string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "event", runtime.ParamLocationPath, event)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sns/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStepRunUpdateCreatePrRequest calls the generic StepRunUpdateCreatePr builder with application/json body
func NewStepRunUpdateCreatePrRequest(server string, stepRun openapi_types.UUID, body StepRunUpdateCreatePrJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStepRunUpdateCreatePrRequestWithBody(server, stepRun, "application/json", bodyReader)
}

// NewStepRunUpdateCreatePrRequestWithBody generates requests for StepRunUpdateCreatePr with any type of body
func NewStepRunUpdateCreatePrRequestWithBody(server string, stepRun openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/step-runs/%s/create-pr", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStepRunGetDiffRequest generates requests for StepRunGetDiff
func NewStepRunGetDiffRequest(server string, stepRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/step-runs/%s/diff", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogLineListRequest generates requests for LogLineList
func NewLogLineListRequest(server string, stepRun openapi_types.UUID, params *LogLineListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/step-runs/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Levels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "levels", runtime.ParamLocationQuery, *params.Levels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByField", runtime.ParamLocationQuery, *params.OrderByField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByDirection", runtime.ParamLocationQuery, *params.OrderByDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantCreateRequest calls the generic TenantCreate builder with application/json body
func NewTenantCreateRequest(server string, body TenantCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewTenantCreateRequestWithBody generates requests for TenantCreate with any type of body
func NewTenantCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewApiTokenListRequest generates requests for ApiTokenList
func NewApiTokenListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/api-tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApiTokenCreateRequest calls the generic ApiTokenCreate builder with application/json body
func NewApiTokenCreateRequest(server string, tenant openapi_types.UUID, body ApiTokenCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApiTokenCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewApiTokenCreateRequestWithBody generates requests for ApiTokenCreate with any type of body
func NewApiTokenCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/api-tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEventListRequest generates requests for EventList
func NewEventListRequest(server string, tenant openapi_types.UUID, params *EventListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keys", runtime.ParamLocationQuery, *params.Keys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Workflows != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflows", runtime.ParamLocationQuery, *params.Workflows); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Statuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statuses", runtime.ParamLocationQuery, *params.Statuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByField", runtime.ParamLocationQuery, *params.OrderByField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByDirection", runtime.ParamLocationQuery, *params.OrderByDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEventKeyListRequest generates requests for EventKeyList
func NewEventKeyListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/events/keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEventUpdateReplayRequest calls the generic EventUpdateReplay builder with application/json body
func NewEventUpdateReplayRequest(server string, tenant openapi_types.UUID, body EventUpdateReplayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEventUpdateReplayRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewEventUpdateReplayRequestWithBody generates requests for EventUpdateReplay with any type of body
func NewEventUpdateReplayRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/events/replay", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantInviteListRequest generates requests for TenantInviteList
func NewTenantInviteListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/invites", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantInviteCreateRequest calls the generic TenantInviteCreate builder with application/json body
func NewTenantInviteCreateRequest(server string, tenant openapi_types.UUID, body TenantInviteCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantInviteCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewTenantInviteCreateRequestWithBody generates requests for TenantInviteCreate with any type of body
func NewTenantInviteCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/invites", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantInviteDeleteRequest generates requests for TenantInviteDelete
func NewTenantInviteDeleteRequest(server string, tenant openapi_types.UUID, tenantInvite openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-invite", runtime.ParamLocationPath, tenantInvite)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/invites/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantInviteUpdateRequest calls the generic TenantInviteUpdate builder with application/json body
func NewTenantInviteUpdateRequest(server string, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, body TenantInviteUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantInviteUpdateRequestWithBody(server, tenant, tenantInvite, "application/json", bodyReader)
}

// NewTenantInviteUpdateRequestWithBody generates requests for TenantInviteUpdate with any type of body
func NewTenantInviteUpdateRequestWithBody(server string, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-invite", runtime.ParamLocationPath, tenantInvite)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/invites/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantMemberListRequest generates requests for TenantMemberList
func NewTenantMemberListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnsListRequest generates requests for SnsList
func NewSnsListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/sns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnsCreateRequest calls the generic SnsCreate builder with application/json body
func NewSnsCreateRequest(server string, tenant openapi_types.UUID, body SnsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSnsCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewSnsCreateRequestWithBody generates requests for SnsCreate with any type of body
func NewSnsCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/sns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStepRunGetRequest generates requests for StepRunGet
func NewStepRunGetRequest(server string, tenant openapi_types.UUID, stepRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/step-runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStepRunUpdateCancelRequest generates requests for StepRunUpdateCancel
func NewStepRunUpdateCancelRequest(server string, tenant openapi_types.UUID, stepRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/step-runs/%s/cancel", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStepRunUpdateRerunRequest calls the generic StepRunUpdateRerun builder with application/json body
func NewStepRunUpdateRerunRequest(server string, tenant openapi_types.UUID, stepRun openapi_types.UUID, body StepRunUpdateRerunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStepRunUpdateRerunRequestWithBody(server, tenant, stepRun, "application/json", bodyReader)
}

// NewStepRunUpdateRerunRequestWithBody generates requests for StepRunUpdateRerun with any type of body
func NewStepRunUpdateRerunRequestWithBody(server string, tenant openapi_types.UUID, stepRun openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/step-runs/%s/rerun", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStepRunGetSchemaRequest generates requests for StepRunGetSchema
func NewStepRunGetSchemaRequest(server string, tenant openapi_types.UUID, stepRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/step-runs/%s/schema", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerListRequest generates requests for WorkerList
func NewWorkerListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/worker", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowRunGetRequest generates requests for WorkflowRunGet
func NewWorkflowRunGetRequest(server string, tenant openapi_types.UUID, workflowRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workflow-run", runtime.ParamLocationPath, workflowRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflow-runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowRunListPullRequestsRequest generates requests for WorkflowRunListPullRequests
func NewWorkflowRunListPullRequestsRequest(server string, tenant openapi_types.UUID, workflowRun openapi_types.UUID, params *WorkflowRunListPullRequestsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workflow-run", runtime.ParamLocationPath, workflowRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflow-runs/%s/prs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowListRequest generates requests for WorkflowList
func NewWorkflowListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowRunListRequest generates requests for WorkflowRunList
func NewWorkflowRunListRequest(server string, tenant openapi_types.UUID, params *WorkflowRunListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventId", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkflowId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflowId", runtime.ParamLocationQuery, *params.WorkflowId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentWorkflowRunId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentWorkflowRunId", runtime.ParamLocationQuery, *params.ParentWorkflowRunId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentStepRunId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentStepRunId", runtime.ParamLocationQuery, *params.ParentStepRunId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserGetCurrentRequest generates requests for UserGetCurrent
func NewUserGetCurrentRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/current")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateGithubOauthCallbackRequest generates requests for UserUpdateGithubOauthCallback
func NewUserUpdateGithubOauthCallbackRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/github/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateGithubOauthStartRequest generates requests for UserUpdateGithubOauthStart
func NewUserUpdateGithubOauthStartRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/github/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateGoogleOauthCallbackRequest generates requests for UserUpdateGoogleOauthCallback
func NewUserUpdateGoogleOauthCallbackRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/google/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateGoogleOauthStartRequest generates requests for UserUpdateGoogleOauthStart
func NewUserUpdateGoogleOauthStartRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/google/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserListTenantInvitesRequest generates requests for UserListTenantInvites
func NewUserListTenantInvitesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantInviteAcceptRequest calls the generic TenantInviteAccept builder with application/json body
func NewTenantInviteAcceptRequest(server string, body TenantInviteAcceptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantInviteAcceptRequestWithBody(server, "application/json", bodyReader)
}

// NewTenantInviteAcceptRequestWithBody generates requests for TenantInviteAccept with any type of body
func NewTenantInviteAcceptRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/invites/accept")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantInviteRejectRequest calls the generic TenantInviteReject builder with application/json body
func NewTenantInviteRejectRequest(server string, body TenantInviteRejectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantInviteRejectRequestWithBody(server, "application/json", bodyReader)
}

// NewTenantInviteRejectRequestWithBody generates requests for TenantInviteReject with any type of body
func NewTenantInviteRejectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/invites/reject")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserUpdateLoginRequest calls the generic UserUpdateLogin builder with application/json body
func NewUserUpdateLoginRequest(server string, body UserUpdateLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserUpdateLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewUserUpdateLoginRequestWithBody generates requests for UserUpdateLogin with any type of body
func NewUserUpdateLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserUpdateLogoutRequest generates requests for UserUpdateLogout
func NewUserUpdateLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantMembershipsListRequest generates requests for TenantMembershipsList
func NewTenantMembershipsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/memberships")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdatePasswordRequest calls the generic UserUpdatePassword builder with application/json body
func NewUserUpdatePasswordRequest(server string, body UserUpdatePasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserUpdatePasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewUserUpdatePasswordRequestWithBody generates requests for UserUpdatePassword with any type of body
func NewUserUpdatePasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserCreateRequest calls the generic UserCreate builder with application/json body
func NewUserCreateRequest(server string, body UserCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewUserCreateRequestWithBody generates requests for UserCreate with any type of body
func NewUserCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorkerGetRequest generates requests for WorkerGet
func NewWorkerGetRequest(server string, worker openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "worker", runtime.ParamLocationPath, worker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowDeleteRequest generates requests for WorkflowDelete
func NewWorkflowDeleteRequest(server string, workflow openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowGetRequest generates requests for WorkflowGet
func NewWorkflowGetRequest(server string, workflow openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowUpdateLinkGithubRequest calls the generic WorkflowUpdateLinkGithub builder with application/json body
func NewWorkflowUpdateLinkGithubRequest(server string, workflow openapi_types.UUID, body WorkflowUpdateLinkGithubJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorkflowUpdateLinkGithubRequestWithBody(server, workflow, "application/json", bodyReader)
}

// NewWorkflowUpdateLinkGithubRequestWithBody generates requests for WorkflowUpdateLinkGithub with any type of body
func NewWorkflowUpdateLinkGithubRequestWithBody(server string, workflow openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s/link-github", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorkflowRunCreateRequest calls the generic WorkflowRunCreate builder with application/json body
func NewWorkflowRunCreateRequest(server string, workflow openapi_types.UUID, params *WorkflowRunCreateParams, body WorkflowRunCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorkflowRunCreateRequestWithBody(server, workflow, params, "application/json", bodyReader)
}

// NewWorkflowRunCreateRequestWithBody generates requests for WorkflowRunCreate with any type of body
func NewWorkflowRunCreateRequestWithBody(server string, workflow openapi_types.UUID, params *WorkflowRunCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s/trigger", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorkflowVersionGetRequest generates requests for WorkflowVersionGet
func NewWorkflowVersionGetRequest(server string, workflow openapi_types.UUID, params *WorkflowVersionGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowVersionGetDefinitionRequest generates requests for WorkflowVersionGetDefinition
func NewWorkflowVersionGetDefinitionRequest(server string, workflow openapi_types.UUID, params *WorkflowVersionGetDefinitionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s/versions/definition", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// LivenessGetWithResponse request
	LivenessGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LivenessGetResponse, error)

	// ReadinessGetWithResponse request
	ReadinessGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReadinessGetResponse, error)

	// ApiTokenUpdateRevokeWithResponse request
	ApiTokenUpdateRevokeWithResponse(ctx context.Context, apiToken openapi_types.UUID, reqEditors ...RequestEditorFn) (*ApiTokenUpdateRevokeResponse, error)

	// EventDataGetWithResponse request
	EventDataGetWithResponse(ctx context.Context, event openapi_types.UUID, reqEditors ...RequestEditorFn) (*EventDataGetResponse, error)

	// GithubAppListInstallationsWithResponse request
	GithubAppListInstallationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GithubAppListInstallationsResponse, error)

	// GithubAppListReposWithResponse request
	GithubAppListReposWithResponse(ctx context.Context, ghInstallation openapi_types.UUID, reqEditors ...RequestEditorFn) (*GithubAppListReposResponse, error)

	// GithubAppListBranchesWithResponse request
	GithubAppListBranchesWithResponse(ctx context.Context, ghInstallation openapi_types.UUID, ghRepoOwner string, ghRepoName string, reqEditors ...RequestEditorFn) (*GithubAppListBranchesResponse, error)

	// GithubUpdateGlobalWebhookWithResponse request
	GithubUpdateGlobalWebhookWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GithubUpdateGlobalWebhookResponse, error)

	// GithubUpdateTenantWebhookWithResponse request
	GithubUpdateTenantWebhookWithResponse(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*GithubUpdateTenantWebhookResponse, error)

	// MetadataGetWithResponse request
	MetadataGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetadataGetResponse, error)

	// MetadataListIntegrationsWithResponse request
	MetadataListIntegrationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetadataListIntegrationsResponse, error)

	// SnsDeleteWithResponse request
	SnsDeleteWithResponse(ctx context.Context, sns openapi_types.UUID, reqEditors ...RequestEditorFn) (*SnsDeleteResponse, error)

	// SnsUpdateWithResponse request
	SnsUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, event string, reqEditors ...RequestEditorFn) (*SnsUpdateResponse, error)

	// StepRunUpdateCreatePrWithBodyWithResponse request with any body
	StepRunUpdateCreatePrWithBodyWithResponse(ctx context.Context, stepRun openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StepRunUpdateCreatePrResponse, error)

	StepRunUpdateCreatePrWithResponse(ctx context.Context, stepRun openapi_types.UUID, body StepRunUpdateCreatePrJSONRequestBody, reqEditors ...RequestEditorFn) (*StepRunUpdateCreatePrResponse, error)

	// StepRunGetDiffWithResponse request
	StepRunGetDiffWithResponse(ctx context.Context, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunGetDiffResponse, error)

	// LogLineListWithResponse request
	LogLineListWithResponse(ctx context.Context, stepRun openapi_types.UUID, params *LogLineListParams, reqEditors ...RequestEditorFn) (*LogLineListResponse, error)

	// TenantCreateWithBodyWithResponse request with any body
	TenantCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantCreateResponse, error)

	TenantCreateWithResponse(ctx context.Context, body TenantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantCreateResponse, error)

	// ApiTokenListWithResponse request
	ApiTokenListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*ApiTokenListResponse, error)

	// ApiTokenCreateWithBodyWithResponse request with any body
	ApiTokenCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApiTokenCreateResponse, error)

	ApiTokenCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body ApiTokenCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ApiTokenCreateResponse, error)

	// EventListWithResponse request
	EventListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *EventListParams, reqEditors ...RequestEditorFn) (*EventListResponse, error)

	// EventKeyListWithResponse request
	EventKeyListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*EventKeyListResponse, error)

	// EventUpdateReplayWithBodyWithResponse request with any body
	EventUpdateReplayWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventUpdateReplayResponse, error)

	EventUpdateReplayWithResponse(ctx context.Context, tenant openapi_types.UUID, body EventUpdateReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*EventUpdateReplayResponse, error)

	// TenantInviteListWithResponse request
	TenantInviteListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantInviteListResponse, error)

	// TenantInviteCreateWithBodyWithResponse request with any body
	TenantInviteCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteCreateResponse, error)

	TenantInviteCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body TenantInviteCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteCreateResponse, error)

	// TenantInviteDeleteWithResponse request
	TenantInviteDeleteWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantInviteDeleteResponse, error)

	// TenantInviteUpdateWithBodyWithResponse request with any body
	TenantInviteUpdateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteUpdateResponse, error)

	TenantInviteUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, body TenantInviteUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteUpdateResponse, error)

	// TenantMemberListWithResponse request
	TenantMemberListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantMemberListResponse, error)

	// SnsListWithResponse request
	SnsListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*SnsListResponse, error)

	// SnsCreateWithBodyWithResponse request with any body
	SnsCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnsCreateResponse, error)

	SnsCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body SnsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SnsCreateResponse, error)

	// StepRunGetWithResponse request
	StepRunGetWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunGetResponse, error)

	// StepRunUpdateCancelWithResponse request
	StepRunUpdateCancelWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunUpdateCancelResponse, error)

	// StepRunUpdateRerunWithBodyWithResponse request with any body
	StepRunUpdateRerunWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StepRunUpdateRerunResponse, error)

	StepRunUpdateRerunWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, body StepRunUpdateRerunJSONRequestBody, reqEditors ...RequestEditorFn) (*StepRunUpdateRerunResponse, error)

	// StepRunGetSchemaWithResponse request
	StepRunGetSchemaWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunGetSchemaResponse, error)

	// WorkerListWithResponse request
	WorkerListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkerListResponse, error)

	// WorkflowRunGetWithResponse request
	WorkflowRunGetWithResponse(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowRunGetResponse, error)

	// WorkflowRunListPullRequestsWithResponse request
	WorkflowRunListPullRequestsWithResponse(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, params *WorkflowRunListPullRequestsParams, reqEditors ...RequestEditorFn) (*WorkflowRunListPullRequestsResponse, error)

	// WorkflowListWithResponse request
	WorkflowListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowListResponse, error)

	// WorkflowRunListWithResponse request
	WorkflowRunListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunListParams, reqEditors ...RequestEditorFn) (*WorkflowRunListResponse, error)

	// UserGetCurrentWithResponse request
	UserGetCurrentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserGetCurrentResponse, error)

	// UserUpdateGithubOauthCallbackWithResponse request
	UserUpdateGithubOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGithubOauthCallbackResponse, error)

	// UserUpdateGithubOauthStartWithResponse request
	UserUpdateGithubOauthStartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGithubOauthStartResponse, error)

	// UserUpdateGoogleOauthCallbackWithResponse request
	UserUpdateGoogleOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGoogleOauthCallbackResponse, error)

	// UserUpdateGoogleOauthStartWithResponse request
	UserUpdateGoogleOauthStartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGoogleOauthStartResponse, error)

	// UserListTenantInvitesWithResponse request
	UserListTenantInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserListTenantInvitesResponse, error)

	// TenantInviteAcceptWithBodyWithResponse request with any body
	TenantInviteAcceptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteAcceptResponse, error)

	TenantInviteAcceptWithResponse(ctx context.Context, body TenantInviteAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteAcceptResponse, error)

	// TenantInviteRejectWithBodyWithResponse request with any body
	TenantInviteRejectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteRejectResponse, error)

	TenantInviteRejectWithResponse(ctx context.Context, body TenantInviteRejectJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteRejectResponse, error)

	// UserUpdateLoginWithBodyWithResponse request with any body
	UserUpdateLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdateLoginResponse, error)

	UserUpdateLoginWithResponse(ctx context.Context, body UserUpdateLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdateLoginResponse, error)

	// UserUpdateLogoutWithResponse request
	UserUpdateLogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateLogoutResponse, error)

	// TenantMembershipsListWithResponse request
	TenantMembershipsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TenantMembershipsListResponse, error)

	// UserUpdatePasswordWithBodyWithResponse request with any body
	UserUpdatePasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdatePasswordResponse, error)

	UserUpdatePasswordWithResponse(ctx context.Context, body UserUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdatePasswordResponse, error)

	// UserCreateWithBodyWithResponse request with any body
	UserCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserCreateResponse, error)

	UserCreateWithResponse(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserCreateResponse, error)

	// WorkerGetWithResponse request
	WorkerGetWithResponse(ctx context.Context, worker openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkerGetResponse, error)

	// WorkflowDeleteWithResponse request
	WorkflowDeleteWithResponse(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowDeleteResponse, error)

	// WorkflowGetWithResponse request
	WorkflowGetWithResponse(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowGetResponse, error)

	// WorkflowUpdateLinkGithubWithBodyWithResponse request with any body
	WorkflowUpdateLinkGithubWithBodyWithResponse(ctx context.Context, workflow openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkflowUpdateLinkGithubResponse, error)

	WorkflowUpdateLinkGithubWithResponse(ctx context.Context, workflow openapi_types.UUID, body WorkflowUpdateLinkGithubJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkflowUpdateLinkGithubResponse, error)

	// WorkflowRunCreateWithBodyWithResponse request with any body
	WorkflowRunCreateWithBodyWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkflowRunCreateResponse, error)

	WorkflowRunCreateWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, body WorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkflowRunCreateResponse, error)

	// WorkflowVersionGetWithResponse request
	WorkflowVersionGetWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetParams, reqEditors ...RequestEditorFn) (*WorkflowVersionGetResponse, error)

	// WorkflowVersionGetDefinitionWithResponse request
	WorkflowVersionGetDefinitionWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetDefinitionParams, reqEditors ...RequestEditorFn) (*WorkflowVersionGetDefinitionResponse, error)
}

type LivenessGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LivenessGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LivenessGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadinessGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReadinessGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadinessGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiTokenUpdateRevokeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r ApiTokenUpdateRevokeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiTokenUpdateRevokeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventDataGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventData
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r EventDataGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventDataGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GithubAppListInstallationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListGithubAppInstallationsResponse
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r GithubAppListInstallationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GithubAppListInstallationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GithubAppListReposResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListGithubReposResponse
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r GithubAppListReposResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GithubAppListReposResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GithubAppListBranchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListGithubBranchesResponse
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r GithubAppListBranchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GithubAppListBranchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GithubUpdateGlobalWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r GithubUpdateGlobalWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GithubUpdateGlobalWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GithubUpdateTenantWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r GithubUpdateTenantWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GithubUpdateTenantWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetadataGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *APIMeta
	JSON400      *APIErrors
}

// Status returns HTTPResponse.Status
func (r MetadataGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetadataGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetadataListIntegrationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAPIMetaIntegration
	JSON400      *APIErrors
}

// Status returns HTTPResponse.Status
func (r MetadataListIntegrationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetadataListIntegrationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r SnsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r SnsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunUpdateCreatePrResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePullRequestFromStepRun
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunUpdateCreatePrResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunUpdateCreatePrResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunGetDiffResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetStepRunDiffResponse
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunGetDiffResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunGetDiffResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogLineListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogLineList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r LogLineListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogLineListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tenant
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiTokenListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAPITokensResponse
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r ApiTokenListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiTokenListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiTokenCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateAPITokenResponse
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r ApiTokenCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiTokenCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r EventListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventKeyListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventKeyList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r EventKeyListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventKeyListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventUpdateReplayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r EventUpdateReplayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventUpdateReplayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantInviteList
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantInviteListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TenantInvite
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantInviteCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantInvite
	JSON400      *APIErrors
}

// Status returns HTTPResponse.Status
func (r TenantInviteDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantInvite
	JSON400      *APIErrors
}

// Status returns HTTPResponse.Status
func (r TenantInviteUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantMemberListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantMemberList
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantMemberListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantMemberListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSNSIntegrations
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r SnsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SNSIntegration
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r SnsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StepRun
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunUpdateCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StepRun
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunUpdateCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunUpdateCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunUpdateRerunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StepRun
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunUpdateRerunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunUpdateRerunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunGetSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunGetSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunGetSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkerList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkerListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowRun
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunListPullRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPullRequestsResponse
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunListPullRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunListPullRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowRunList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserGetCurrentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserGetCurrentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserGetCurrentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateGithubOauthCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateGithubOauthCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateGithubOauthCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateGithubOauthStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateGithubOauthStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateGithubOauthStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateGoogleOauthCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateGoogleOauthCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateGoogleOauthCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateGoogleOauthStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateGoogleOauthStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateGoogleOauthStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserListTenantInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantInviteList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserListTenantInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserListTenantInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteAcceptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantInviteAcceptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteAcceptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteRejectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantInviteRejectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteRejectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserUpdateLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateLogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserUpdateLogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateLogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantMembershipsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserTenantMembershipsList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r TenantMembershipsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantMembershipsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdatePasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserUpdatePasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdatePasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Worker
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkerGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workflow
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowUpdateLinkGithubResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workflow
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowUpdateLinkGithubResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowUpdateLinkGithubResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowRun
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowVersionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowVersion
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowVersionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowVersionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowVersionGetDefinitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowVersionDefinition
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowVersionGetDefinitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowVersionGetDefinitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// LivenessGetWithResponse request returning *LivenessGetResponse
func (c *ClientWithResponses) LivenessGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LivenessGetResponse, error) {
	rsp, err := c.LivenessGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLivenessGetResponse(rsp)
}

// ReadinessGetWithResponse request returning *ReadinessGetResponse
func (c *ClientWithResponses) ReadinessGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReadinessGetResponse, error) {
	rsp, err := c.ReadinessGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadinessGetResponse(rsp)
}

// ApiTokenUpdateRevokeWithResponse request returning *ApiTokenUpdateRevokeResponse
func (c *ClientWithResponses) ApiTokenUpdateRevokeWithResponse(ctx context.Context, apiToken openapi_types.UUID, reqEditors ...RequestEditorFn) (*ApiTokenUpdateRevokeResponse, error) {
	rsp, err := c.ApiTokenUpdateRevoke(ctx, apiToken, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiTokenUpdateRevokeResponse(rsp)
}

// EventDataGetWithResponse request returning *EventDataGetResponse
func (c *ClientWithResponses) EventDataGetWithResponse(ctx context.Context, event openapi_types.UUID, reqEditors ...RequestEditorFn) (*EventDataGetResponse, error) {
	rsp, err := c.EventDataGet(ctx, event, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventDataGetResponse(rsp)
}

// GithubAppListInstallationsWithResponse request returning *GithubAppListInstallationsResponse
func (c *ClientWithResponses) GithubAppListInstallationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GithubAppListInstallationsResponse, error) {
	rsp, err := c.GithubAppListInstallations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGithubAppListInstallationsResponse(rsp)
}

// GithubAppListReposWithResponse request returning *GithubAppListReposResponse
func (c *ClientWithResponses) GithubAppListReposWithResponse(ctx context.Context, ghInstallation openapi_types.UUID, reqEditors ...RequestEditorFn) (*GithubAppListReposResponse, error) {
	rsp, err := c.GithubAppListRepos(ctx, ghInstallation, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGithubAppListReposResponse(rsp)
}

// GithubAppListBranchesWithResponse request returning *GithubAppListBranchesResponse
func (c *ClientWithResponses) GithubAppListBranchesWithResponse(ctx context.Context, ghInstallation openapi_types.UUID, ghRepoOwner string, ghRepoName string, reqEditors ...RequestEditorFn) (*GithubAppListBranchesResponse, error) {
	rsp, err := c.GithubAppListBranches(ctx, ghInstallation, ghRepoOwner, ghRepoName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGithubAppListBranchesResponse(rsp)
}

// GithubUpdateGlobalWebhookWithResponse request returning *GithubUpdateGlobalWebhookResponse
func (c *ClientWithResponses) GithubUpdateGlobalWebhookWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GithubUpdateGlobalWebhookResponse, error) {
	rsp, err := c.GithubUpdateGlobalWebhook(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGithubUpdateGlobalWebhookResponse(rsp)
}

// GithubUpdateTenantWebhookWithResponse request returning *GithubUpdateTenantWebhookResponse
func (c *ClientWithResponses) GithubUpdateTenantWebhookWithResponse(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*GithubUpdateTenantWebhookResponse, error) {
	rsp, err := c.GithubUpdateTenantWebhook(ctx, webhook, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGithubUpdateTenantWebhookResponse(rsp)
}

// MetadataGetWithResponse request returning *MetadataGetResponse
func (c *ClientWithResponses) MetadataGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetadataGetResponse, error) {
	rsp, err := c.MetadataGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataGetResponse(rsp)
}

// MetadataListIntegrationsWithResponse request returning *MetadataListIntegrationsResponse
func (c *ClientWithResponses) MetadataListIntegrationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetadataListIntegrationsResponse, error) {
	rsp, err := c.MetadataListIntegrations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataListIntegrationsResponse(rsp)
}

// SnsDeleteWithResponse request returning *SnsDeleteResponse
func (c *ClientWithResponses) SnsDeleteWithResponse(ctx context.Context, sns openapi_types.UUID, reqEditors ...RequestEditorFn) (*SnsDeleteResponse, error) {
	rsp, err := c.SnsDelete(ctx, sns, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnsDeleteResponse(rsp)
}

// SnsUpdateWithResponse request returning *SnsUpdateResponse
func (c *ClientWithResponses) SnsUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, event string, reqEditors ...RequestEditorFn) (*SnsUpdateResponse, error) {
	rsp, err := c.SnsUpdate(ctx, tenant, event, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnsUpdateResponse(rsp)
}

// StepRunUpdateCreatePrWithBodyWithResponse request with arbitrary body returning *StepRunUpdateCreatePrResponse
func (c *ClientWithResponses) StepRunUpdateCreatePrWithBodyWithResponse(ctx context.Context, stepRun openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StepRunUpdateCreatePrResponse, error) {
	rsp, err := c.StepRunUpdateCreatePrWithBody(ctx, stepRun, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunUpdateCreatePrResponse(rsp)
}

func (c *ClientWithResponses) StepRunUpdateCreatePrWithResponse(ctx context.Context, stepRun openapi_types.UUID, body StepRunUpdateCreatePrJSONRequestBody, reqEditors ...RequestEditorFn) (*StepRunUpdateCreatePrResponse, error) {
	rsp, err := c.StepRunUpdateCreatePr(ctx, stepRun, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunUpdateCreatePrResponse(rsp)
}

// StepRunGetDiffWithResponse request returning *StepRunGetDiffResponse
func (c *ClientWithResponses) StepRunGetDiffWithResponse(ctx context.Context, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunGetDiffResponse, error) {
	rsp, err := c.StepRunGetDiff(ctx, stepRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunGetDiffResponse(rsp)
}

// LogLineListWithResponse request returning *LogLineListResponse
func (c *ClientWithResponses) LogLineListWithResponse(ctx context.Context, stepRun openapi_types.UUID, params *LogLineListParams, reqEditors ...RequestEditorFn) (*LogLineListResponse, error) {
	rsp, err := c.LogLineList(ctx, stepRun, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogLineListResponse(rsp)
}

// TenantCreateWithBodyWithResponse request with arbitrary body returning *TenantCreateResponse
func (c *ClientWithResponses) TenantCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantCreateResponse, error) {
	rsp, err := c.TenantCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantCreateResponse(rsp)
}

func (c *ClientWithResponses) TenantCreateWithResponse(ctx context.Context, body TenantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantCreateResponse, error) {
	rsp, err := c.TenantCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantCreateResponse(rsp)
}

// ApiTokenListWithResponse request returning *ApiTokenListResponse
func (c *ClientWithResponses) ApiTokenListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*ApiTokenListResponse, error) {
	rsp, err := c.ApiTokenList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiTokenListResponse(rsp)
}

// ApiTokenCreateWithBodyWithResponse request with arbitrary body returning *ApiTokenCreateResponse
func (c *ClientWithResponses) ApiTokenCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApiTokenCreateResponse, error) {
	rsp, err := c.ApiTokenCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiTokenCreateResponse(rsp)
}

func (c *ClientWithResponses) ApiTokenCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body ApiTokenCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ApiTokenCreateResponse, error) {
	rsp, err := c.ApiTokenCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiTokenCreateResponse(rsp)
}

// EventListWithResponse request returning *EventListResponse
func (c *ClientWithResponses) EventListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *EventListParams, reqEditors ...RequestEditorFn) (*EventListResponse, error) {
	rsp, err := c.EventList(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventListResponse(rsp)
}

// EventKeyListWithResponse request returning *EventKeyListResponse
func (c *ClientWithResponses) EventKeyListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*EventKeyListResponse, error) {
	rsp, err := c.EventKeyList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventKeyListResponse(rsp)
}

// EventUpdateReplayWithBodyWithResponse request with arbitrary body returning *EventUpdateReplayResponse
func (c *ClientWithResponses) EventUpdateReplayWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventUpdateReplayResponse, error) {
	rsp, err := c.EventUpdateReplayWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventUpdateReplayResponse(rsp)
}

func (c *ClientWithResponses) EventUpdateReplayWithResponse(ctx context.Context, tenant openapi_types.UUID, body EventUpdateReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*EventUpdateReplayResponse, error) {
	rsp, err := c.EventUpdateReplay(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventUpdateReplayResponse(rsp)
}

// TenantInviteListWithResponse request returning *TenantInviteListResponse
func (c *ClientWithResponses) TenantInviteListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantInviteListResponse, error) {
	rsp, err := c.TenantInviteList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteListResponse(rsp)
}

// TenantInviteCreateWithBodyWithResponse request with arbitrary body returning *TenantInviteCreateResponse
func (c *ClientWithResponses) TenantInviteCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteCreateResponse, error) {
	rsp, err := c.TenantInviteCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteCreateResponse(rsp)
}

func (c *ClientWithResponses) TenantInviteCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body TenantInviteCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteCreateResponse, error) {
	rsp, err := c.TenantInviteCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteCreateResponse(rsp)
}

// TenantInviteDeleteWithResponse request returning *TenantInviteDeleteResponse
func (c *ClientWithResponses) TenantInviteDeleteWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantInviteDeleteResponse, error) {
	rsp, err := c.TenantInviteDelete(ctx, tenant, tenantInvite, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteDeleteResponse(rsp)
}

// TenantInviteUpdateWithBodyWithResponse request with arbitrary body returning *TenantInviteUpdateResponse
func (c *ClientWithResponses) TenantInviteUpdateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteUpdateResponse, error) {
	rsp, err := c.TenantInviteUpdateWithBody(ctx, tenant, tenantInvite, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteUpdateResponse(rsp)
}

func (c *ClientWithResponses) TenantInviteUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, body TenantInviteUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteUpdateResponse, error) {
	rsp, err := c.TenantInviteUpdate(ctx, tenant, tenantInvite, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteUpdateResponse(rsp)
}

// TenantMemberListWithResponse request returning *TenantMemberListResponse
func (c *ClientWithResponses) TenantMemberListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantMemberListResponse, error) {
	rsp, err := c.TenantMemberList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantMemberListResponse(rsp)
}

// SnsListWithResponse request returning *SnsListResponse
func (c *ClientWithResponses) SnsListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*SnsListResponse, error) {
	rsp, err := c.SnsList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnsListResponse(rsp)
}

// SnsCreateWithBodyWithResponse request with arbitrary body returning *SnsCreateResponse
func (c *ClientWithResponses) SnsCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnsCreateResponse, error) {
	rsp, err := c.SnsCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnsCreateResponse(rsp)
}

func (c *ClientWithResponses) SnsCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body SnsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SnsCreateResponse, error) {
	rsp, err := c.SnsCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnsCreateResponse(rsp)
}

// StepRunGetWithResponse request returning *StepRunGetResponse
func (c *ClientWithResponses) StepRunGetWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunGetResponse, error) {
	rsp, err := c.StepRunGet(ctx, tenant, stepRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunGetResponse(rsp)
}

// StepRunUpdateCancelWithResponse request returning *StepRunUpdateCancelResponse
func (c *ClientWithResponses) StepRunUpdateCancelWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunUpdateCancelResponse, error) {
	rsp, err := c.StepRunUpdateCancel(ctx, tenant, stepRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunUpdateCancelResponse(rsp)
}

// StepRunUpdateRerunWithBodyWithResponse request with arbitrary body returning *StepRunUpdateRerunResponse
func (c *ClientWithResponses) StepRunUpdateRerunWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StepRunUpdateRerunResponse, error) {
	rsp, err := c.StepRunUpdateRerunWithBody(ctx, tenant, stepRun, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunUpdateRerunResponse(rsp)
}

func (c *ClientWithResponses) StepRunUpdateRerunWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, body StepRunUpdateRerunJSONRequestBody, reqEditors ...RequestEditorFn) (*StepRunUpdateRerunResponse, error) {
	rsp, err := c.StepRunUpdateRerun(ctx, tenant, stepRun, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunUpdateRerunResponse(rsp)
}

// StepRunGetSchemaWithResponse request returning *StepRunGetSchemaResponse
func (c *ClientWithResponses) StepRunGetSchemaWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunGetSchemaResponse, error) {
	rsp, err := c.StepRunGetSchema(ctx, tenant, stepRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunGetSchemaResponse(rsp)
}

// WorkerListWithResponse request returning *WorkerListResponse
func (c *ClientWithResponses) WorkerListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkerListResponse, error) {
	rsp, err := c.WorkerList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerListResponse(rsp)
}

// WorkflowRunGetWithResponse request returning *WorkflowRunGetResponse
func (c *ClientWithResponses) WorkflowRunGetWithResponse(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowRunGetResponse, error) {
	rsp, err := c.WorkflowRunGet(ctx, tenant, workflowRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunGetResponse(rsp)
}

// WorkflowRunListPullRequestsWithResponse request returning *WorkflowRunListPullRequestsResponse
func (c *ClientWithResponses) WorkflowRunListPullRequestsWithResponse(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, params *WorkflowRunListPullRequestsParams, reqEditors ...RequestEditorFn) (*WorkflowRunListPullRequestsResponse, error) {
	rsp, err := c.WorkflowRunListPullRequests(ctx, tenant, workflowRun, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunListPullRequestsResponse(rsp)
}

// WorkflowListWithResponse request returning *WorkflowListResponse
func (c *ClientWithResponses) WorkflowListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowListResponse, error) {
	rsp, err := c.WorkflowList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowListResponse(rsp)
}

// WorkflowRunListWithResponse request returning *WorkflowRunListResponse
func (c *ClientWithResponses) WorkflowRunListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunListParams, reqEditors ...RequestEditorFn) (*WorkflowRunListResponse, error) {
	rsp, err := c.WorkflowRunList(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunListResponse(rsp)
}

// UserGetCurrentWithResponse request returning *UserGetCurrentResponse
func (c *ClientWithResponses) UserGetCurrentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserGetCurrentResponse, error) {
	rsp, err := c.UserGetCurrent(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserGetCurrentResponse(rsp)
}

// UserUpdateGithubOauthCallbackWithResponse request returning *UserUpdateGithubOauthCallbackResponse
func (c *ClientWithResponses) UserUpdateGithubOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGithubOauthCallbackResponse, error) {
	rsp, err := c.UserUpdateGithubOauthCallback(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateGithubOauthCallbackResponse(rsp)
}

// UserUpdateGithubOauthStartWithResponse request returning *UserUpdateGithubOauthStartResponse
func (c *ClientWithResponses) UserUpdateGithubOauthStartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGithubOauthStartResponse, error) {
	rsp, err := c.UserUpdateGithubOauthStart(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateGithubOauthStartResponse(rsp)
}

// UserUpdateGoogleOauthCallbackWithResponse request returning *UserUpdateGoogleOauthCallbackResponse
func (c *ClientWithResponses) UserUpdateGoogleOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGoogleOauthCallbackResponse, error) {
	rsp, err := c.UserUpdateGoogleOauthCallback(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateGoogleOauthCallbackResponse(rsp)
}

// UserUpdateGoogleOauthStartWithResponse request returning *UserUpdateGoogleOauthStartResponse
func (c *ClientWithResponses) UserUpdateGoogleOauthStartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGoogleOauthStartResponse, error) {
	rsp, err := c.UserUpdateGoogleOauthStart(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateGoogleOauthStartResponse(rsp)
}

// UserListTenantInvitesWithResponse request returning *UserListTenantInvitesResponse
func (c *ClientWithResponses) UserListTenantInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserListTenantInvitesResponse, error) {
	rsp, err := c.UserListTenantInvites(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserListTenantInvitesResponse(rsp)
}

// TenantInviteAcceptWithBodyWithResponse request with arbitrary body returning *TenantInviteAcceptResponse
func (c *ClientWithResponses) TenantInviteAcceptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteAcceptResponse, error) {
	rsp, err := c.TenantInviteAcceptWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteAcceptResponse(rsp)
}

func (c *ClientWithResponses) TenantInviteAcceptWithResponse(ctx context.Context, body TenantInviteAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteAcceptResponse, error) {
	rsp, err := c.TenantInviteAccept(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteAcceptResponse(rsp)
}

// TenantInviteRejectWithBodyWithResponse request with arbitrary body returning *TenantInviteRejectResponse
func (c *ClientWithResponses) TenantInviteRejectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteRejectResponse, error) {
	rsp, err := c.TenantInviteRejectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteRejectResponse(rsp)
}

func (c *ClientWithResponses) TenantInviteRejectWithResponse(ctx context.Context, body TenantInviteRejectJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteRejectResponse, error) {
	rsp, err := c.TenantInviteReject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteRejectResponse(rsp)
}

// UserUpdateLoginWithBodyWithResponse request with arbitrary body returning *UserUpdateLoginResponse
func (c *ClientWithResponses) UserUpdateLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdateLoginResponse, error) {
	rsp, err := c.UserUpdateLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateLoginResponse(rsp)
}

func (c *ClientWithResponses) UserUpdateLoginWithResponse(ctx context.Context, body UserUpdateLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdateLoginResponse, error) {
	rsp, err := c.UserUpdateLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateLoginResponse(rsp)
}

// UserUpdateLogoutWithResponse request returning *UserUpdateLogoutResponse
func (c *ClientWithResponses) UserUpdateLogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateLogoutResponse, error) {
	rsp, err := c.UserUpdateLogout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateLogoutResponse(rsp)
}

// TenantMembershipsListWithResponse request returning *TenantMembershipsListResponse
func (c *ClientWithResponses) TenantMembershipsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TenantMembershipsListResponse, error) {
	rsp, err := c.TenantMembershipsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantMembershipsListResponse(rsp)
}

// UserUpdatePasswordWithBodyWithResponse request with arbitrary body returning *UserUpdatePasswordResponse
func (c *ClientWithResponses) UserUpdatePasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdatePasswordResponse, error) {
	rsp, err := c.UserUpdatePasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdatePasswordResponse(rsp)
}

func (c *ClientWithResponses) UserUpdatePasswordWithResponse(ctx context.Context, body UserUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdatePasswordResponse, error) {
	rsp, err := c.UserUpdatePassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdatePasswordResponse(rsp)
}

// UserCreateWithBodyWithResponse request with arbitrary body returning *UserCreateResponse
func (c *ClientWithResponses) UserCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserCreateResponse, error) {
	rsp, err := c.UserCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserCreateResponse(rsp)
}

func (c *ClientWithResponses) UserCreateWithResponse(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserCreateResponse, error) {
	rsp, err := c.UserCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserCreateResponse(rsp)
}

// WorkerGetWithResponse request returning *WorkerGetResponse
func (c *ClientWithResponses) WorkerGetWithResponse(ctx context.Context, worker openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkerGetResponse, error) {
	rsp, err := c.WorkerGet(ctx, worker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerGetResponse(rsp)
}

// WorkflowDeleteWithResponse request returning *WorkflowDeleteResponse
func (c *ClientWithResponses) WorkflowDeleteWithResponse(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowDeleteResponse, error) {
	rsp, err := c.WorkflowDelete(ctx, workflow, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowDeleteResponse(rsp)
}

// WorkflowGetWithResponse request returning *WorkflowGetResponse
func (c *ClientWithResponses) WorkflowGetWithResponse(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowGetResponse, error) {
	rsp, err := c.WorkflowGet(ctx, workflow, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowGetResponse(rsp)
}

// WorkflowUpdateLinkGithubWithBodyWithResponse request with arbitrary body returning *WorkflowUpdateLinkGithubResponse
func (c *ClientWithResponses) WorkflowUpdateLinkGithubWithBodyWithResponse(ctx context.Context, workflow openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkflowUpdateLinkGithubResponse, error) {
	rsp, err := c.WorkflowUpdateLinkGithubWithBody(ctx, workflow, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowUpdateLinkGithubResponse(rsp)
}

func (c *ClientWithResponses) WorkflowUpdateLinkGithubWithResponse(ctx context.Context, workflow openapi_types.UUID, body WorkflowUpdateLinkGithubJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkflowUpdateLinkGithubResponse, error) {
	rsp, err := c.WorkflowUpdateLinkGithub(ctx, workflow, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowUpdateLinkGithubResponse(rsp)
}

// WorkflowRunCreateWithBodyWithResponse request with arbitrary body returning *WorkflowRunCreateResponse
func (c *ClientWithResponses) WorkflowRunCreateWithBodyWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkflowRunCreateResponse, error) {
	rsp, err := c.WorkflowRunCreateWithBody(ctx, workflow, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunCreateResponse(rsp)
}

func (c *ClientWithResponses) WorkflowRunCreateWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, body WorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkflowRunCreateResponse, error) {
	rsp, err := c.WorkflowRunCreate(ctx, workflow, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunCreateResponse(rsp)
}

// WorkflowVersionGetWithResponse request returning *WorkflowVersionGetResponse
func (c *ClientWithResponses) WorkflowVersionGetWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetParams, reqEditors ...RequestEditorFn) (*WorkflowVersionGetResponse, error) {
	rsp, err := c.WorkflowVersionGet(ctx, workflow, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowVersionGetResponse(rsp)
}

// WorkflowVersionGetDefinitionWithResponse request returning *WorkflowVersionGetDefinitionResponse
func (c *ClientWithResponses) WorkflowVersionGetDefinitionWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetDefinitionParams, reqEditors ...RequestEditorFn) (*WorkflowVersionGetDefinitionResponse, error) {
	rsp, err := c.WorkflowVersionGetDefinition(ctx, workflow, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowVersionGetDefinitionResponse(rsp)
}

// ParseLivenessGetResponse parses an HTTP response from a LivenessGetWithResponse call
func ParseLivenessGetResponse(rsp *http.Response) (*LivenessGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LivenessGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadinessGetResponse parses an HTTP response from a ReadinessGetWithResponse call
func ParseReadinessGetResponse(rsp *http.Response) (*ReadinessGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadinessGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseApiTokenUpdateRevokeResponse parses an HTTP response from a ApiTokenUpdateRevokeWithResponse call
func ParseApiTokenUpdateRevokeResponse(rsp *http.Response) (*ApiTokenUpdateRevokeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiTokenUpdateRevokeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseEventDataGetResponse parses an HTTP response from a EventDataGetWithResponse call
func ParseEventDataGetResponse(rsp *http.Response) (*EventDataGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventDataGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGithubAppListInstallationsResponse parses an HTTP response from a GithubAppListInstallationsWithResponse call
func ParseGithubAppListInstallationsResponse(rsp *http.Response) (*GithubAppListInstallationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GithubAppListInstallationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListGithubAppInstallationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseGithubAppListReposResponse parses an HTTP response from a GithubAppListReposWithResponse call
func ParseGithubAppListReposResponse(rsp *http.Response) (*GithubAppListReposResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GithubAppListReposResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListGithubReposResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseGithubAppListBranchesResponse parses an HTTP response from a GithubAppListBranchesWithResponse call
func ParseGithubAppListBranchesResponse(rsp *http.Response) (*GithubAppListBranchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GithubAppListBranchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListGithubBranchesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseGithubUpdateGlobalWebhookResponse parses an HTTP response from a GithubUpdateGlobalWebhookWithResponse call
func ParseGithubUpdateGlobalWebhookResponse(rsp *http.Response) (*GithubUpdateGlobalWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GithubUpdateGlobalWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseGithubUpdateTenantWebhookResponse parses an HTTP response from a GithubUpdateTenantWebhookWithResponse call
func ParseGithubUpdateTenantWebhookResponse(rsp *http.Response) (*GithubUpdateTenantWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GithubUpdateTenantWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseMetadataGetResponse parses an HTTP response from a MetadataGetWithResponse call
func ParseMetadataGetResponse(rsp *http.Response) (*MetadataGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetadataGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest APIMeta
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMetadataListIntegrationsResponse parses an HTTP response from a MetadataListIntegrationsWithResponse call
func ParseMetadataListIntegrationsResponse(rsp *http.Response) (*MetadataListIntegrationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetadataListIntegrationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAPIMetaIntegration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSnsDeleteResponse parses an HTTP response from a SnsDeleteWithResponse call
func ParseSnsDeleteResponse(rsp *http.Response) (*SnsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseSnsUpdateResponse parses an HTTP response from a SnsUpdateWithResponse call
func ParseSnsUpdateResponse(rsp *http.Response) (*SnsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseStepRunUpdateCreatePrResponse parses an HTTP response from a StepRunUpdateCreatePrWithResponse call
func ParseStepRunUpdateCreatePrResponse(rsp *http.Response) (*StepRunUpdateCreatePrResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunUpdateCreatePrResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePullRequestFromStepRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStepRunGetDiffResponse parses an HTTP response from a StepRunGetDiffWithResponse call
func ParseStepRunGetDiffResponse(rsp *http.Response) (*StepRunGetDiffResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunGetDiffResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetStepRunDiffResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseLogLineListResponse parses an HTTP response from a LogLineListWithResponse call
func ParseLogLineListResponse(rsp *http.Response) (*LogLineListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogLineListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogLineList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantCreateResponse parses an HTTP response from a TenantCreateWithResponse call
func ParseTenantCreateResponse(rsp *http.Response) (*TenantCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tenant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseApiTokenListResponse parses an HTTP response from a ApiTokenListWithResponse call
func ParseApiTokenListResponse(rsp *http.Response) (*ApiTokenListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiTokenListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAPITokensResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseApiTokenCreateResponse parses an HTTP response from a ApiTokenCreateWithResponse call
func ParseApiTokenCreateResponse(rsp *http.Response) (*ApiTokenCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiTokenCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateAPITokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseEventListResponse parses an HTTP response from a EventListWithResponse call
func ParseEventListResponse(rsp *http.Response) (*EventListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseEventKeyListResponse parses an HTTP response from a EventKeyListWithResponse call
func ParseEventKeyListResponse(rsp *http.Response) (*EventKeyListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventKeyListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventKeyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseEventUpdateReplayResponse parses an HTTP response from a EventUpdateReplayWithResponse call
func ParseEventUpdateReplayResponse(rsp *http.Response) (*EventUpdateReplayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventUpdateReplayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantInviteListResponse parses an HTTP response from a TenantInviteListWithResponse call
func ParseTenantInviteListResponse(rsp *http.Response) (*TenantInviteListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantInviteList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantInviteCreateResponse parses an HTTP response from a TenantInviteCreateWithResponse call
func ParseTenantInviteCreateResponse(rsp *http.Response) (*TenantInviteCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TenantInvite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantInviteDeleteResponse parses an HTTP response from a TenantInviteDeleteWithResponse call
func ParseTenantInviteDeleteResponse(rsp *http.Response) (*TenantInviteDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantInvite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseTenantInviteUpdateResponse parses an HTTP response from a TenantInviteUpdateWithResponse call
func ParseTenantInviteUpdateResponse(rsp *http.Response) (*TenantInviteUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantInvite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseTenantMemberListResponse parses an HTTP response from a TenantMemberListWithResponse call
func ParseTenantMemberListResponse(rsp *http.Response) (*TenantMemberListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantMemberListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantMemberList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSnsListResponse parses an HTTP response from a SnsListWithResponse call
func ParseSnsListResponse(rsp *http.Response) (*SnsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSNSIntegrations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseSnsCreateResponse parses an HTTP response from a SnsCreateWithResponse call
func ParseSnsCreateResponse(rsp *http.Response) (*SnsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SNSIntegration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseStepRunGetResponse parses an HTTP response from a StepRunGetWithResponse call
func ParseStepRunGetResponse(rsp *http.Response) (*StepRunGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StepRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStepRunUpdateCancelResponse parses an HTTP response from a StepRunUpdateCancelWithResponse call
func ParseStepRunUpdateCancelResponse(rsp *http.Response) (*StepRunUpdateCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunUpdateCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StepRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseStepRunUpdateRerunResponse parses an HTTP response from a StepRunUpdateRerunWithResponse call
func ParseStepRunUpdateRerunResponse(rsp *http.Response) (*StepRunUpdateRerunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunUpdateRerunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StepRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseStepRunGetSchemaResponse parses an HTTP response from a StepRunGetSchemaWithResponse call
func ParseStepRunGetSchemaResponse(rsp *http.Response) (*StepRunGetSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunGetSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWorkerListResponse parses an HTTP response from a WorkerListWithResponse call
func ParseWorkerListResponse(rsp *http.Response) (*WorkerListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkerList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowRunGetResponse parses an HTTP response from a WorkflowRunGetWithResponse call
func ParseWorkflowRunGetResponse(rsp *http.Response) (*WorkflowRunGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowRunListPullRequestsResponse parses an HTTP response from a WorkflowRunListPullRequestsWithResponse call
func ParseWorkflowRunListPullRequestsResponse(rsp *http.Response) (*WorkflowRunListPullRequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunListPullRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPullRequestsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowListResponse parses an HTTP response from a WorkflowListWithResponse call
func ParseWorkflowListResponse(rsp *http.Response) (*WorkflowListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowRunListResponse parses an HTTP response from a WorkflowRunListWithResponse call
func ParseWorkflowRunListResponse(rsp *http.Response) (*WorkflowRunListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowRunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUserGetCurrentResponse parses an HTTP response from a UserGetCurrentWithResponse call
func ParseUserGetCurrentResponse(rsp *http.Response) (*UserGetCurrentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserGetCurrentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseUserUpdateGithubOauthCallbackResponse parses an HTTP response from a UserUpdateGithubOauthCallbackWithResponse call
func ParseUserUpdateGithubOauthCallbackResponse(rsp *http.Response) (*UserUpdateGithubOauthCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateGithubOauthCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserUpdateGithubOauthStartResponse parses an HTTP response from a UserUpdateGithubOauthStartWithResponse call
func ParseUserUpdateGithubOauthStartResponse(rsp *http.Response) (*UserUpdateGithubOauthStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateGithubOauthStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserUpdateGoogleOauthCallbackResponse parses an HTTP response from a UserUpdateGoogleOauthCallbackWithResponse call
func ParseUserUpdateGoogleOauthCallbackResponse(rsp *http.Response) (*UserUpdateGoogleOauthCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateGoogleOauthCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserUpdateGoogleOauthStartResponse parses an HTTP response from a UserUpdateGoogleOauthStartWithResponse call
func ParseUserUpdateGoogleOauthStartResponse(rsp *http.Response) (*UserUpdateGoogleOauthStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateGoogleOauthStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserListTenantInvitesResponse parses an HTTP response from a UserListTenantInvitesWithResponse call
func ParseUserListTenantInvitesResponse(rsp *http.Response) (*UserListTenantInvitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserListTenantInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantInviteList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantInviteAcceptResponse parses an HTTP response from a TenantInviteAcceptWithResponse call
func ParseTenantInviteAcceptResponse(rsp *http.Response) (*TenantInviteAcceptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteAcceptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantInviteRejectResponse parses an HTTP response from a TenantInviteRejectWithResponse call
func ParseTenantInviteRejectResponse(rsp *http.Response) (*TenantInviteRejectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteRejectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUserUpdateLoginResponse parses an HTTP response from a UserUpdateLoginWithResponse call
func ParseUserUpdateLoginResponse(rsp *http.Response) (*UserUpdateLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseUserUpdateLogoutResponse parses an HTTP response from a UserUpdateLogoutWithResponse call
func ParseUserUpdateLogoutResponse(rsp *http.Response) (*UserUpdateLogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateLogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseTenantMembershipsListResponse parses an HTTP response from a TenantMembershipsListWithResponse call
func ParseTenantMembershipsListResponse(rsp *http.Response) (*TenantMembershipsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantMembershipsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserTenantMembershipsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUserUpdatePasswordResponse parses an HTTP response from a UserUpdatePasswordWithResponse call
func ParseUserUpdatePasswordResponse(rsp *http.Response) (*UserUpdatePasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdatePasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseUserCreateResponse parses an HTTP response from a UserCreateWithResponse call
func ParseUserCreateResponse(rsp *http.Response) (*UserCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseWorkerGetResponse parses an HTTP response from a WorkerGetWithResponse call
func ParseWorkerGetResponse(rsp *http.Response) (*WorkerGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Worker
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowDeleteResponse parses an HTTP response from a WorkflowDeleteWithResponse call
func ParseWorkflowDeleteResponse(rsp *http.Response) (*WorkflowDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWorkflowGetResponse parses an HTTP response from a WorkflowGetWithResponse call
func ParseWorkflowGetResponse(rsp *http.Response) (*WorkflowGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workflow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowUpdateLinkGithubResponse parses an HTTP response from a WorkflowUpdateLinkGithubWithResponse call
func ParseWorkflowUpdateLinkGithubResponse(rsp *http.Response) (*WorkflowUpdateLinkGithubResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowUpdateLinkGithubResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workflow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWorkflowRunCreateResponse parses an HTTP response from a WorkflowRunCreateWithResponse call
func ParseWorkflowRunCreateResponse(rsp *http.Response) (*WorkflowRunCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWorkflowVersionGetResponse parses an HTTP response from a WorkflowVersionGetWithResponse call
func ParseWorkflowVersionGetResponse(rsp *http.Response) (*WorkflowVersionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowVersionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWorkflowVersionGetDefinitionResponse parses an HTTP response from a WorkflowVersionGetDefinitionWithResponse call
func ParseWorkflowVersionGetDefinitionResponse(rsp *http.Response) (*WorkflowVersionGetDefinitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowVersionGetDefinitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowVersionDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
