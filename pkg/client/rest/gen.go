// Package rest provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package rest

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	CookieAuthScopes = "cookieAuth.Scopes"
)

// Defines values for EventOrderByDirection.
const (
	EventOrderByDirectionAsc  EventOrderByDirection = "asc"
	EventOrderByDirectionDesc EventOrderByDirection = "desc"
)

// Defines values for EventOrderByField.
const (
	EventOrderByFieldCreatedAt EventOrderByField = "createdAt"
)

// Defines values for JobRunStatus.
const (
	JobRunStatusCANCELLED JobRunStatus = "CANCELLED"
	JobRunStatusFAILED    JobRunStatus = "FAILED"
	JobRunStatusPENDING   JobRunStatus = "PENDING"
	JobRunStatusRUNNING   JobRunStatus = "RUNNING"
	JobRunStatusSUCCEEDED JobRunStatus = "SUCCEEDED"
)

// Defines values for LogLineLevel.
const (
	LogLineLevelDEBUG LogLineLevel = "DEBUG"
	LogLineLevelERROR LogLineLevel = "ERROR"
	LogLineLevelINFO  LogLineLevel = "INFO"
	LogLineLevelWARN  LogLineLevel = "WARN"
)

// Defines values for LogLineOrderByDirection.
const (
	LogLineOrderByDirectionAsc  LogLineOrderByDirection = "asc"
	LogLineOrderByDirectionDesc LogLineOrderByDirection = "desc"
)

// Defines values for LogLineOrderByField.
const (
	LogLineOrderByFieldCreatedAt LogLineOrderByField = "createdAt"
)

// Defines values for StepRunEventReason.
const (
	StepRunEventReasonASSIGNED           StepRunEventReason = "ASSIGNED"
	StepRunEventReasonCANCELLED          StepRunEventReason = "CANCELLED"
	StepRunEventReasonFAILED             StepRunEventReason = "FAILED"
	StepRunEventReasonFINISHED           StepRunEventReason = "FINISHED"
	StepRunEventReasonREASSIGNED         StepRunEventReason = "REASSIGNED"
	StepRunEventReasonREQUEUEDNOWORKER   StepRunEventReason = "REQUEUED_NO_WORKER"
	StepRunEventReasonREQUEUEDRATELIMIT  StepRunEventReason = "REQUEUED_RATE_LIMIT"
	StepRunEventReasonRETRIEDBYUSER      StepRunEventReason = "RETRIED_BY_USER"
	StepRunEventReasonRETRYING           StepRunEventReason = "RETRYING"
	StepRunEventReasonSCHEDULINGTIMEDOUT StepRunEventReason = "SCHEDULING_TIMED_OUT"
	StepRunEventReasonSLOTRELEASED       StepRunEventReason = "SLOT_RELEASED"
	StepRunEventReasonSTARTED            StepRunEventReason = "STARTED"
	StepRunEventReasonTIMEDOUT           StepRunEventReason = "TIMED_OUT"
	StepRunEventReasonTIMEOUTREFRESHED   StepRunEventReason = "TIMEOUT_REFRESHED"
)

// Defines values for StepRunEventSeverity.
const (
	StepRunEventSeverityCRITICAL StepRunEventSeverity = "CRITICAL"
	StepRunEventSeverityINFO     StepRunEventSeverity = "INFO"
	StepRunEventSeverityWARNING  StepRunEventSeverity = "WARNING"
)

// Defines values for StepRunStatus.
const (
	StepRunStatusASSIGNED          StepRunStatus = "ASSIGNED"
	StepRunStatusCANCELLED         StepRunStatus = "CANCELLED"
	StepRunStatusFAILED            StepRunStatus = "FAILED"
	StepRunStatusPENDING           StepRunStatus = "PENDING"
	StepRunStatusPENDINGASSIGNMENT StepRunStatus = "PENDING_ASSIGNMENT"
	StepRunStatusRUNNING           StepRunStatus = "RUNNING"
	StepRunStatusSUCCEEDED         StepRunStatus = "SUCCEEDED"
)

// Defines values for TenantMemberRole.
const (
	ADMIN  TenantMemberRole = "ADMIN"
	MEMBER TenantMemberRole = "MEMBER"
	OWNER  TenantMemberRole = "OWNER"
)

// Defines values for TenantResource.
const (
	CRON        TenantResource = "CRON"
	EVENT       TenantResource = "EVENT"
	SCHEDULE    TenantResource = "SCHEDULE"
	WORKER      TenantResource = "WORKER"
	WORKFLOWRUN TenantResource = "WORKFLOW_RUN"
)

// Defines values for WorkerStatus.
const (
	ACTIVE   WorkerStatus = "ACTIVE"
	INACTIVE WorkerStatus = "INACTIVE"
)

// Defines values for WorkflowConcurrencyLimitStrategy.
const (
	CANCELINPROGRESS WorkflowConcurrencyLimitStrategy = "CANCEL_IN_PROGRESS"
	DROPNEWEST       WorkflowConcurrencyLimitStrategy = "DROP_NEWEST"
	GROUPROUNDROBIN  WorkflowConcurrencyLimitStrategy = "GROUP_ROUND_ROBIN"
	QUEUENEWEST      WorkflowConcurrencyLimitStrategy = "QUEUE_NEWEST"
)

// Defines values for WorkflowRunStatus.
const (
	WorkflowRunStatusCANCELLED WorkflowRunStatus = "CANCELLED"
	WorkflowRunStatusFAILED    WorkflowRunStatus = "FAILED"
	WorkflowRunStatusPENDING   WorkflowRunStatus = "PENDING"
	WorkflowRunStatusQUEUED    WorkflowRunStatus = "QUEUED"
	WorkflowRunStatusRUNNING   WorkflowRunStatus = "RUNNING"
	WorkflowRunStatusSUCCEEDED WorkflowRunStatus = "SUCCEEDED"
)

// APIError defines model for APIError.
type APIError struct {
	// Code a custom Hatchet error code
	Code *uint64 `json:"code,omitempty"`

	// Description a description for this error
	Description string `json:"description"`

	// DocsLink a link to the documentation for this error, if it exists
	DocsLink *string `json:"docs_link,omitempty"`

	// Field the field that this error is associated with, if applicable
	Field *string `json:"field,omitempty"`
}

// APIErrors defines model for APIErrors.
type APIErrors struct {
	Errors []APIError `json:"errors"`
}

// APIMeta defines model for APIMeta.
type APIMeta struct {
	// AllowChangePassword whether or not users can change their password
	AllowChangePassword *bool `json:"allowChangePassword,omitempty"`

	// AllowCreateTenant whether or not users can create new tenants
	AllowCreateTenant *bool `json:"allowCreateTenant,omitempty"`

	// AllowInvites whether or not users can invite other users to this instance
	AllowInvites *bool `json:"allowInvites,omitempty"`

	// AllowSignup whether or not users can sign up for this instance
	AllowSignup *bool           `json:"allowSignup,omitempty"`
	Auth        *APIMetaAuth    `json:"auth,omitempty"`
	Posthog     *APIMetaPosthog `json:"posthog,omitempty"`

	// PylonAppId the Pylon app ID for usepylon.com chat support
	PylonAppId *string `json:"pylonAppId,omitempty"`
}

// APIMetaAuth defines model for APIMetaAuth.
type APIMetaAuth struct {
	// Schemes the supported types of authentication
	Schemes *[]string `json:"schemes,omitempty"`
}

// APIMetaIntegration defines model for APIMetaIntegration.
type APIMetaIntegration struct {
	// Enabled whether this integration is enabled on the instance
	Enabled bool `json:"enabled"`

	// Name the name of the integration
	Name string `json:"name"`
}

// APIMetaPosthog defines model for APIMetaPosthog.
type APIMetaPosthog struct {
	// ApiHost the PostHog API host
	ApiHost *string `json:"apiHost,omitempty"`

	// ApiKey the PostHog API key
	ApiKey *string `json:"apiKey,omitempty"`
}

// APIResourceMeta defines model for APIResourceMeta.
type APIResourceMeta struct {
	// CreatedAt the time that this resource was created
	CreatedAt time.Time `json:"createdAt"`

	// Id the id of this resource, in UUID format
	Id openapi_types.UUID `json:"id"`

	// UpdatedAt the time that this resource was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// APIToken defines model for APIToken.
type APIToken struct {
	// ExpiresAt When the API token expires.
	ExpiresAt time.Time       `json:"expiresAt"`
	Metadata  APIResourceMeta `json:"metadata"`

	// Name The name of the API token.
	Name string `json:"name"`
}

// AcceptInviteRequest defines model for AcceptInviteRequest.
type AcceptInviteRequest struct {
	Invite string `json:"invite" validate:"required,uuid"`
}

// CreateAPITokenRequest defines model for CreateAPITokenRequest.
type CreateAPITokenRequest struct {
	// ExpiresIn The duration for which the token is valid.
	ExpiresIn *string `json:"expiresIn,omitempty" validate:"omitnil,duration"`

	// Name A name for the API token.
	Name string `json:"name"`
}

// CreateAPITokenResponse defines model for CreateAPITokenResponse.
type CreateAPITokenResponse struct {
	// Token The API token.
	Token string `json:"token"`
}

// CreateEventRequest defines model for CreateEventRequest.
type CreateEventRequest struct {
	// AdditionalMetadata Additional metadata for the event.
	AdditionalMetadata *map[string]interface{} `json:"additionalMetadata,omitempty"`

	// Data The data for the event.
	Data map[string]interface{} `json:"data"`

	// Key The key for the event.
	Key string `json:"key"`
}

// CreateSNSIntegrationRequest defines model for CreateSNSIntegrationRequest.
type CreateSNSIntegrationRequest struct {
	// TopicArn The Amazon Resource Name (ARN) of the SNS topic.
	TopicArn string `json:"topicArn" validate:"required,min=1,max=256"`
}

// CreateTenantAlertEmailGroupRequest defines model for CreateTenantAlertEmailGroupRequest.
type CreateTenantAlertEmailGroupRequest struct {
	// Emails A list of emails for users
	Emails []string `json:"emails" validate:"required,dive,email"`
}

// CreateTenantInviteRequest defines model for CreateTenantInviteRequest.
type CreateTenantInviteRequest struct {
	// Email The email of the user to invite.
	Email string           `json:"email" validate:"required,email"`
	Role  TenantMemberRole `json:"role"`
}

// CreateTenantRequest defines model for CreateTenantRequest.
type CreateTenantRequest struct {
	// Name The name of the tenant.
	Name string `json:"name" validate:"required"`

	// Slug The slug of the tenant.
	Slug string `json:"slug" validate:"required,hatchetName"`
}

// Event defines model for Event.
type Event struct {
	// AdditionalMetadata Additional metadata for the event.
	AdditionalMetadata *map[string]interface{} `json:"additionalMetadata,omitempty"`

	// Key The key for the event.
	Key      string          `json:"key"`
	Metadata APIResourceMeta `json:"metadata"`
	Tenant   *Tenant         `json:"tenant,omitempty"`

	// TenantId The ID of the tenant associated with this event.
	TenantId           string                   `json:"tenantId"`
	WorkflowRunSummary *EventWorkflowRunSummary `json:"workflowRunSummary,omitempty"`
}

// EventData defines model for EventData.
type EventData struct {
	// Data The data for the event (JSON bytes).
	Data string `json:"data"`
}

// EventKey The key for the event.
type EventKey = string

// EventKeyList defines model for EventKeyList.
type EventKeyList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]EventKey         `json:"rows,omitempty"`
}

// EventList defines model for EventList.
type EventList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]Event            `json:"rows,omitempty"`
}

// EventOrderByDirection defines model for EventOrderByDirection.
type EventOrderByDirection string

// EventOrderByField defines model for EventOrderByField.
type EventOrderByField string

// EventSearch defines model for EventSearch.
type EventSearch = string

// EventWorkflowRunSummary defines model for EventWorkflowRunSummary.
type EventWorkflowRunSummary struct {
	// Failed The number of failed runs.
	Failed *int64 `json:"failed,omitempty"`

	// Pending The number of pending runs.
	Pending *int64 `json:"pending,omitempty"`

	// Queued The number of queued runs.
	Queued *int64 `json:"queued,omitempty"`

	// Running The number of running runs.
	Running *int64 `json:"running,omitempty"`

	// Succeeded The number of succeeded runs.
	Succeeded *int64 `json:"succeeded,omitempty"`
}

// Job defines model for Job.
type Job struct {
	// Description The description of the job.
	Description *string         `json:"description,omitempty"`
	Metadata    APIResourceMeta `json:"metadata"`
	Name        string          `json:"name"`
	Steps       []Step          `json:"steps"`
	TenantId    string          `json:"tenantId"`

	// Timeout The timeout of the job.
	Timeout   *string `json:"timeout,omitempty"`
	VersionId string  `json:"versionId"`
}

// JobRun defines model for JobRun.
type JobRun struct {
	CancelledAt     *time.Time              `json:"cancelledAt,omitempty"`
	CancelledError  *string                 `json:"cancelledError,omitempty"`
	CancelledReason *string                 `json:"cancelledReason,omitempty"`
	FinishedAt      *time.Time              `json:"finishedAt,omitempty"`
	Job             *Job                    `json:"job,omitempty"`
	JobId           string                  `json:"jobId"`
	Metadata        APIResourceMeta         `json:"metadata"`
	Result          *map[string]interface{} `json:"result,omitempty"`
	StartedAt       *time.Time              `json:"startedAt,omitempty"`
	Status          JobRunStatus            `json:"status"`
	StepRuns        *[]StepRun              `json:"stepRuns,omitempty"`
	TenantId        string                  `json:"tenantId"`
	TickerId        *string                 `json:"tickerId,omitempty"`
	TimeoutAt       *time.Time              `json:"timeoutAt,omitempty"`
	WorkflowRun     *WorkflowRun            `json:"workflowRun,omitempty"`
	WorkflowRunId   string                  `json:"workflowRunId"`
}

// JobRunStatus defines model for JobRunStatus.
type JobRunStatus string

// ListAPIMetaIntegration defines model for ListAPIMetaIntegration.
type ListAPIMetaIntegration = []APIMetaIntegration

// ListAPITokensResponse defines model for ListAPITokensResponse.
type ListAPITokensResponse struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]APIToken         `json:"rows,omitempty"`
}

// ListSNSIntegrations defines model for ListSNSIntegrations.
type ListSNSIntegrations struct {
	Pagination PaginationResponse `json:"pagination"`
	Rows       []SNSIntegration   `json:"rows"`
}

// ListSlackWebhooks defines model for ListSlackWebhooks.
type ListSlackWebhooks struct {
	Pagination PaginationResponse `json:"pagination"`
	Rows       []SlackWebhook     `json:"rows"`
}

// LogLine defines model for LogLine.
type LogLine struct {
	// CreatedAt The creation date of the log line.
	CreatedAt time.Time `json:"createdAt"`

	// Message The log message.
	Message string `json:"message"`

	// Metadata The log metadata.
	Metadata map[string]interface{} `json:"metadata"`
}

// LogLineLevel defines model for LogLineLevel.
type LogLineLevel string

// LogLineLevelField defines model for LogLineLevelField.
type LogLineLevelField = []LogLineLevel

// LogLineList defines model for LogLineList.
type LogLineList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]LogLine          `json:"rows,omitempty"`
}

// LogLineOrderByDirection defines model for LogLineOrderByDirection.
type LogLineOrderByDirection string

// LogLineOrderByField defines model for LogLineOrderByField.
type LogLineOrderByField string

// LogLineSearch defines model for LogLineSearch.
type LogLineSearch = string

// PaginationResponse defines model for PaginationResponse.
type PaginationResponse struct {
	// CurrentPage the current page
	CurrentPage *int64 `json:"current_page,omitempty"`

	// NextPage the next page
	NextPage *int64 `json:"next_page,omitempty"`

	// NumPages the total number of pages for listing
	NumPages *int64 `json:"num_pages,omitempty"`
}

// QueueMetrics defines model for QueueMetrics.
type QueueMetrics struct {
	// NumPending The number of items pending.
	NumPending int `json:"numPending"`

	// NumQueued The number of items in the queue.
	NumQueued int `json:"numQueued"`

	// NumRunning The number of items running.
	NumRunning int `json:"numRunning"`
}

// RejectInviteRequest defines model for RejectInviteRequest.
type RejectInviteRequest struct {
	Invite string `json:"invite" validate:"required,uuid"`
}

// ReplayEventRequest defines model for ReplayEventRequest.
type ReplayEventRequest struct {
	EventIds []openapi_types.UUID `json:"eventIds"`
}

// RerunStepRunRequest defines model for RerunStepRunRequest.
type RerunStepRunRequest struct {
	Input map[string]interface{} `json:"input"`
}

// SNSIntegration defines model for SNSIntegration.
type SNSIntegration struct {
	// IngestUrl The URL to send SNS messages to.
	IngestUrl *string         `json:"ingestUrl,omitempty"`
	Metadata  APIResourceMeta `json:"metadata"`

	// TenantId The unique identifier for the tenant that the SNS integration belongs to.
	TenantId openapi_types.UUID `json:"tenantId"`

	// TopicArn The Amazon Resource Name (ARN) of the SNS topic.
	TopicArn string `json:"topicArn"`
}

// SlackWebhook defines model for SlackWebhook.
type SlackWebhook struct {
	// ChannelId The channel id associated with this slack webhook.
	ChannelId string `json:"channelId"`

	// ChannelName The channel name associated with this slack webhook.
	ChannelName string          `json:"channelName"`
	Metadata    APIResourceMeta `json:"metadata"`

	// TeamId The team id associated with this slack webhook.
	TeamId string `json:"teamId"`

	// TeamName The team name associated with this slack webhook.
	TeamName string `json:"teamName"`

	// TenantId The unique identifier for the tenant that the SNS integration belongs to.
	TenantId openapi_types.UUID `json:"tenantId"`
}

// Step defines model for Step.
type Step struct {
	Action   string          `json:"action"`
	Children *[]string       `json:"children,omitempty"`
	JobId    string          `json:"jobId"`
	Metadata APIResourceMeta `json:"metadata"`
	Parents  *[]string       `json:"parents,omitempty"`

	// ReadableId The readable id of the step.
	ReadableId string `json:"readableId"`
	TenantId   string `json:"tenantId"`

	// Timeout The timeout of the step.
	Timeout *string `json:"timeout,omitempty"`
}

// StepRun defines model for StepRun.
type StepRun struct {
	CancelledAt       *time.Time              `json:"cancelledAt,omitempty"`
	CancelledAtEpoch  *int                    `json:"cancelledAtEpoch,omitempty"`
	CancelledError    *string                 `json:"cancelledError,omitempty"`
	CancelledReason   *string                 `json:"cancelledReason,omitempty"`
	ChildWorkflowRuns *[]string               `json:"childWorkflowRuns,omitempty"`
	Children          *[]string               `json:"children,omitempty"`
	Error             *string                 `json:"error,omitempty"`
	FinishedAt        *time.Time              `json:"finishedAt,omitempty"`
	FinishedAtEpoch   *int                    `json:"finishedAtEpoch,omitempty"`
	Input             *string                 `json:"input,omitempty"`
	JobRun            *JobRun                 `json:"jobRun,omitempty"`
	JobRunId          string                  `json:"jobRunId"`
	Metadata          APIResourceMeta         `json:"metadata"`
	Output            *string                 `json:"output,omitempty"`
	Parents           *[]string               `json:"parents,omitempty"`
	RequeueAfter      *time.Time              `json:"requeueAfter,omitempty"`
	Result            *map[string]interface{} `json:"result,omitempty"`
	StartedAt         *time.Time              `json:"startedAt,omitempty"`
	StartedAtEpoch    *int                    `json:"startedAtEpoch,omitempty"`
	Status            StepRunStatus           `json:"status"`
	Step              *Step                   `json:"step,omitempty"`
	StepId            string                  `json:"stepId"`
	TenantId          string                  `json:"tenantId"`
	TimeoutAt         *time.Time              `json:"timeoutAt,omitempty"`
	TimeoutAtEpoch    *int                    `json:"timeoutAtEpoch,omitempty"`
	WorkerId          *string                 `json:"workerId,omitempty"`
}

// StepRunArchive defines model for StepRunArchive.
type StepRunArchive struct {
	CancelledAt      *time.Time `json:"cancelledAt,omitempty"`
	CancelledAtEpoch *int       `json:"cancelledAtEpoch,omitempty"`
	CancelledError   *string    `json:"cancelledError,omitempty"`
	CancelledReason  *string    `json:"cancelledReason,omitempty"`
	CreatedAt        time.Time  `json:"createdAt"`
	Error            *string    `json:"error,omitempty"`
	FinishedAt       *time.Time `json:"finishedAt,omitempty"`
	FinishedAtEpoch  *int       `json:"finishedAtEpoch,omitempty"`
	Input            *string    `json:"input,omitempty"`
	Order            int        `json:"order"`
	Output           *string    `json:"output,omitempty"`
	StartedAt        *time.Time `json:"startedAt,omitempty"`
	StartedAtEpoch   *int       `json:"startedAtEpoch,omitempty"`
	StepRunId        string     `json:"stepRunId"`
	TimeoutAt        *time.Time `json:"timeoutAt,omitempty"`
	TimeoutAtEpoch   *int       `json:"timeoutAtEpoch,omitempty"`
}

// StepRunArchiveList defines model for StepRunArchiveList.
type StepRunArchiveList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]StepRunArchive   `json:"rows,omitempty"`
}

// StepRunEvent defines model for StepRunEvent.
type StepRunEvent struct {
	Count         int                     `json:"count"`
	Data          *map[string]interface{} `json:"data,omitempty"`
	Id            int                     `json:"id"`
	Message       string                  `json:"message"`
	Reason        StepRunEventReason      `json:"reason"`
	Severity      StepRunEventSeverity    `json:"severity"`
	StepRunId     string                  `json:"stepRunId"`
	TimeFirstSeen time.Time               `json:"timeFirstSeen"`
	TimeLastSeen  time.Time               `json:"timeLastSeen"`
}

// StepRunEventList defines model for StepRunEventList.
type StepRunEventList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]StepRunEvent     `json:"rows,omitempty"`
}

// StepRunEventReason defines model for StepRunEventReason.
type StepRunEventReason string

// StepRunEventSeverity defines model for StepRunEventSeverity.
type StepRunEventSeverity string

// StepRunStatus defines model for StepRunStatus.
type StepRunStatus string

// Tenant defines model for Tenant.
type Tenant struct {
	// AlertMemberEmails Whether to alert tenant members.
	AlertMemberEmails *bool `json:"alertMemberEmails,omitempty"`

	// AnalyticsOptOut Whether the tenant has opted out of analytics.
	AnalyticsOptOut *bool           `json:"analyticsOptOut,omitempty"`
	Metadata        APIResourceMeta `json:"metadata"`

	// Name The name of the tenant.
	Name string `json:"name"`

	// Slug The slug of the tenant.
	Slug string `json:"slug"`
}

// TenantAlertEmailGroup defines model for TenantAlertEmailGroup.
type TenantAlertEmailGroup struct {
	// Emails A list of emails for users
	Emails   []string        `json:"emails"`
	Metadata APIResourceMeta `json:"metadata"`
}

// TenantAlertEmailGroupList defines model for TenantAlertEmailGroupList.
type TenantAlertEmailGroupList struct {
	Pagination *PaginationResponse      `json:"pagination,omitempty"`
	Rows       *[]TenantAlertEmailGroup `json:"rows,omitempty"`
}

// TenantAlertingSettings defines model for TenantAlertingSettings.
type TenantAlertingSettings struct {
	// AlertMemberEmails Whether to alert tenant members.
	AlertMemberEmails *bool `json:"alertMemberEmails,omitempty"`

	// EnableExpiringTokenAlerts Whether to enable alerts when tokens are approaching expiration.
	EnableExpiringTokenAlerts *bool `json:"enableExpiringTokenAlerts,omitempty"`

	// EnableTenantResourceLimitAlerts Whether to enable alerts when tenant resources are approaching limits.
	EnableTenantResourceLimitAlerts *bool `json:"enableTenantResourceLimitAlerts,omitempty"`

	// EnableWorkflowRunFailureAlerts Whether to send alerts when workflow runs fail.
	EnableWorkflowRunFailureAlerts *bool `json:"enableWorkflowRunFailureAlerts,omitempty"`

	// LastAlertedAt The last time an alert was sent.
	LastAlertedAt *time.Time `json:"lastAlertedAt,omitempty"`

	// MaxAlertingFrequency The max frequency at which to alert.
	MaxAlertingFrequency string          `json:"maxAlertingFrequency"`
	Metadata             APIResourceMeta `json:"metadata"`
}

// TenantInvite defines model for TenantInvite.
type TenantInvite struct {
	// Email The email of the user to invite.
	Email string `json:"email"`

	// Expires The time that this invite expires.
	Expires  time.Time        `json:"expires"`
	Metadata APIResourceMeta  `json:"metadata"`
	Role     TenantMemberRole `json:"role"`

	// TenantId The tenant id associated with this tenant invite.
	TenantId string `json:"tenantId"`

	// TenantName The tenant name for the tenant.
	TenantName *string `json:"tenantName,omitempty"`
}

// TenantInviteList defines model for TenantInviteList.
type TenantInviteList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]TenantInvite     `json:"rows,omitempty"`
}

// TenantMember defines model for TenantMember.
type TenantMember struct {
	Metadata APIResourceMeta  `json:"metadata"`
	Role     TenantMemberRole `json:"role"`
	Tenant   *Tenant          `json:"tenant,omitempty"`
	User     UserTenantPublic `json:"user"`
}

// TenantMemberList defines model for TenantMemberList.
type TenantMemberList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]TenantMember     `json:"rows,omitempty"`
}

// TenantMemberRole defines model for TenantMemberRole.
type TenantMemberRole string

// TenantQueueMetrics defines model for TenantQueueMetrics.
type TenantQueueMetrics struct {
	Total    *QueueMetrics            `json:"total,omitempty"`
	Workflow *map[string]QueueMetrics `json:"workflow,omitempty"`
}

// TenantResource defines model for TenantResource.
type TenantResource string

// TenantResourceLimit defines model for TenantResourceLimit.
type TenantResourceLimit struct {
	// AlarmValue The alarm value associated with this limit to warn of approaching limit value.
	AlarmValue *int `json:"alarmValue,omitempty"`

	// LastRefill The last time the limit was refilled.
	LastRefill *time.Time `json:"lastRefill,omitempty"`

	// LimitValue The limit associated with this limit.
	LimitValue int             `json:"limitValue"`
	Metadata   APIResourceMeta `json:"metadata"`
	Resource   TenantResource  `json:"resource"`

	// Value The current value associated with this limit.
	Value int `json:"value"`

	// Window The meter window for the limit. (i.e. 1 day, 1 week, 1 month)
	Window *string `json:"window,omitempty"`
}

// TenantResourcePolicy defines model for TenantResourcePolicy.
type TenantResourcePolicy struct {
	// Limits A list of resource limits for the tenant.
	Limits []TenantResourceLimit `json:"limits"`
}

// TriggerWorkflowRunRequest defines model for TriggerWorkflowRunRequest.
type TriggerWorkflowRunRequest struct {
	AdditionalMetadata *map[string]interface{} `json:"additionalMetadata,omitempty"`
	Input              map[string]interface{}  `json:"input"`
}

// UpdateTenantAlertEmailGroupRequest defines model for UpdateTenantAlertEmailGroupRequest.
type UpdateTenantAlertEmailGroupRequest struct {
	// Emails A list of emails for users
	Emails []string `json:"emails" validate:"required,dive,email"`
}

// UpdateTenantInviteRequest defines model for UpdateTenantInviteRequest.
type UpdateTenantInviteRequest struct {
	Role TenantMemberRole `json:"role"`
}

// UpdateTenantRequest defines model for UpdateTenantRequest.
type UpdateTenantRequest struct {
	// AlertMemberEmails Whether to alert tenant members.
	AlertMemberEmails *bool `json:"alertMemberEmails,omitempty"`

	// AnalyticsOptOut Whether the tenant has opted out of analytics.
	AnalyticsOptOut *bool `json:"analyticsOptOut,omitempty"`

	// EnableExpiringTokenAlerts Whether to enable alerts when tokens are approaching expiration.
	EnableExpiringTokenAlerts *bool `json:"enableExpiringTokenAlerts,omitempty"`

	// EnableTenantResourceLimitAlerts Whether to enable alerts when tenant resources are approaching limits.
	EnableTenantResourceLimitAlerts *bool `json:"enableTenantResourceLimitAlerts,omitempty"`

	// EnableWorkflowRunFailureAlerts Whether to send alerts when workflow runs fail.
	EnableWorkflowRunFailureAlerts *bool `json:"enableWorkflowRunFailureAlerts,omitempty"`

	// MaxAlertingFrequency The max frequency at which to alert.
	MaxAlertingFrequency *string `json:"maxAlertingFrequency,omitempty" validate:"omitnil,duration"`

	// Name The name of the tenant.
	Name *string `json:"name,omitempty"`
}

// User defines model for User.
type User struct {
	// Email The email address of the user.
	Email openapi_types.Email `json:"email"`

	// EmailHash A hash of the user's email address for use with Pylon Support Chat
	EmailHash *string `json:"emailHash,omitempty"`

	// EmailVerified Whether the user has verified their email address.
	EmailVerified bool `json:"emailVerified"`

	// HasPassword Whether the user has a password set.
	HasPassword *bool           `json:"hasPassword,omitempty"`
	Metadata    APIResourceMeta `json:"metadata"`

	// Name The display name of the user.
	Name *string `json:"name,omitempty"`
}

// UserChangePasswordRequest defines model for UserChangePasswordRequest.
type UserChangePasswordRequest struct {
	// NewPassword The new password for the user.
	NewPassword string `json:"newPassword" validate:"required,password"`

	// Password The password of the user.
	Password string `json:"password" validate:"required,password"`
}

// UserLoginRequest defines model for UserLoginRequest.
type UserLoginRequest struct {
	// Email The email address of the user.
	Email openapi_types.Email `json:"email" validate:"required,email"`

	// Password The password of the user.
	Password string `json:"password" validate:"required,password"`
}

// UserRegisterRequest defines model for UserRegisterRequest.
type UserRegisterRequest struct {
	// Email The email address of the user.
	Email openapi_types.Email `json:"email" validate:"required,email"`

	// Name The name of the user.
	Name string `json:"name"`

	// Password The password of the user.
	Password string `json:"password" validate:"required,password"`
}

// UserTenantMembershipsList defines model for UserTenantMembershipsList.
type UserTenantMembershipsList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]TenantMember     `json:"rows,omitempty"`
}

// UserTenantPublic defines model for UserTenantPublic.
type UserTenantPublic struct {
	// Email The email address of the user.
	Email openapi_types.Email `json:"email"`

	// Name The display name of the user.
	Name *string `json:"name,omitempty"`
}

// WebhookWorker defines model for WebhookWorker.
type WebhookWorker struct {
	Metadata APIResourceMeta `json:"metadata"`

	// Name The name of the webhook worker.
	Name string `json:"name"`

	// Url The webhook url.
	Url string `json:"url"`
}

// WebhookWorkerCreateRequest defines model for WebhookWorkerCreateRequest.
type WebhookWorkerCreateRequest struct {
	// Name The name of the webhook worker.
	Name string `json:"name"`

	// Secret The secret key for validation. If not provided, a random secret will be generated.
	Secret *string `json:"secret,omitempty"`

	// Url The webhook url.
	Url string `json:"url"`
}

// WebhookWorkerCreated defines model for WebhookWorkerCreated.
type WebhookWorkerCreated struct {
	Metadata APIResourceMeta `json:"metadata"`

	// Name The name of the webhook worker.
	Name string `json:"name"`

	// Secret The secret key for validation.
	Secret string `json:"secret"`

	// Url The webhook url.
	Url string `json:"url"`
}

// WebhookWorkerListResponse defines model for WebhookWorkerListResponse.
type WebhookWorkerListResponse struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]WebhookWorker    `json:"rows,omitempty"`
}

// Worker defines model for Worker.
type Worker struct {
	// Actions The actions this worker can perform.
	Actions *[]string `json:"actions,omitempty"`

	// AvailableRuns The number of runs this worker can execute concurrently.
	AvailableRuns *int `json:"availableRuns,omitempty"`

	// DispatcherId the id of the assigned dispatcher, in UUID format
	DispatcherId *openapi_types.UUID `json:"dispatcherId,omitempty"`

	// LastHeartbeatAt The time this worker last sent a heartbeat.
	LastHeartbeatAt *time.Time `json:"lastHeartbeatAt,omitempty"`

	// LastListenerEstablished The time this worker last sent a heartbeat.
	LastListenerEstablished *time.Time `json:"lastListenerEstablished,omitempty"`

	// MaxRuns The maximum number of runs this worker can execute concurrently.
	MaxRuns  *int            `json:"maxRuns,omitempty"`
	Metadata APIResourceMeta `json:"metadata"`

	// Name The name of the worker.
	Name string `json:"name"`

	// RecentStepRuns The recent step runs for this worker.
	RecentStepRuns *[]StepRun `json:"recentStepRuns,omitempty"`

	// Status The status of the worker.
	Status *WorkerStatus `json:"status,omitempty"`
}

// WorkerStatus The status of the worker.
type WorkerStatus string

// WorkerList defines model for WorkerList.
type WorkerList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]Worker           `json:"rows,omitempty"`
}

// Workflow defines model for Workflow.
type Workflow struct {
	// Description The description of the workflow.
	Description *string `json:"description,omitempty"`

	// Jobs The jobs of the workflow.
	Jobs     *[]Job          `json:"jobs,omitempty"`
	LastRun  *WorkflowRun    `json:"lastRun,omitempty"`
	Metadata APIResourceMeta `json:"metadata"`

	// Name The name of the workflow.
	Name string `json:"name"`

	// Tags The tags of the workflow.
	Tags     *[]WorkflowTag         `json:"tags,omitempty"`
	Versions *[]WorkflowVersionMeta `json:"versions,omitempty"`
}

// WorkflowConcurrency defines model for WorkflowConcurrency.
type WorkflowConcurrency struct {
	// GetConcurrencyGroup An action which gets the concurrency group for the WorkflowRun.
	GetConcurrencyGroup string `json:"getConcurrencyGroup"`

	// LimitStrategy The strategy to use when the concurrency limit is reached.
	LimitStrategy WorkflowConcurrencyLimitStrategy `json:"limitStrategy"`

	// MaxRuns The maximum number of concurrent workflow runs.
	MaxRuns int32 `json:"maxRuns"`
}

// WorkflowConcurrencyLimitStrategy The strategy to use when the concurrency limit is reached.
type WorkflowConcurrencyLimitStrategy string

// WorkflowID A workflow ID.
type WorkflowID = string

// WorkflowList defines model for WorkflowList.
type WorkflowList struct {
	Metadata   *APIResourceMeta    `json:"metadata,omitempty"`
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]Workflow         `json:"rows,omitempty"`
}

// WorkflowMetrics defines model for WorkflowMetrics.
type WorkflowMetrics struct {
	// GroupKeyCount The total number of concurrency group keys.
	GroupKeyCount *int `json:"groupKeyCount,omitempty"`

	// GroupKeyRunsCount The number of runs for a specific group key (passed via filter)
	GroupKeyRunsCount *int `json:"groupKeyRunsCount,omitempty"`
}

// WorkflowRun defines model for WorkflowRun.
type WorkflowRun struct {
	AdditionalMetadata *map[string]interface{} `json:"additionalMetadata,omitempty"`
	DisplayName        *string                 `json:"displayName,omitempty"`
	Error              *string                 `json:"error,omitempty"`
	FinishedAt         *time.Time              `json:"finishedAt,omitempty"`
	Input              *map[string]interface{} `json:"input,omitempty"`
	JobRuns            *[]JobRun               `json:"jobRuns,omitempty"`
	Metadata           APIResourceMeta         `json:"metadata"`
	ParentId           *openapi_types.UUID     `json:"parentId,omitempty"`
	ParentStepRunId    *openapi_types.UUID     `json:"parentStepRunId,omitempty"`
	StartedAt          *time.Time              `json:"startedAt,omitempty"`
	Status             WorkflowRunStatus       `json:"status"`
	TenantId           string                  `json:"tenantId"`
	TriggeredBy        WorkflowRunTriggeredBy  `json:"triggeredBy"`
	WorkflowVersion    *WorkflowVersion        `json:"workflowVersion,omitempty"`
	WorkflowVersionId  string                  `json:"workflowVersionId"`
}

// WorkflowRunList defines model for WorkflowRunList.
type WorkflowRunList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]WorkflowRun      `json:"rows,omitempty"`
}

// WorkflowRunStatus defines model for WorkflowRunStatus.
type WorkflowRunStatus string

// WorkflowRunStatusList defines model for WorkflowRunStatusList.
type WorkflowRunStatusList = []WorkflowRunStatus

// WorkflowRunTriggeredBy defines model for WorkflowRunTriggeredBy.
type WorkflowRunTriggeredBy struct {
	CronParentId *string         `json:"cronParentId,omitempty"`
	CronSchedule *string         `json:"cronSchedule,omitempty"`
	Event        *Event          `json:"event,omitempty"`
	EventId      *string         `json:"eventId,omitempty"`
	Metadata     APIResourceMeta `json:"metadata"`
	ParentId     string          `json:"parentId"`
}

// WorkflowRunsCancelRequest defines model for WorkflowRunsCancelRequest.
type WorkflowRunsCancelRequest struct {
	WorkflowRunIds []openapi_types.UUID `json:"workflowRunIds"`
}

// WorkflowRunsMetrics defines model for WorkflowRunsMetrics.
type WorkflowRunsMetrics struct {
	Counts *WorkflowRunsMetricsCounts `json:"counts,omitempty"`
}

// WorkflowRunsMetricsCounts defines model for WorkflowRunsMetricsCounts.
type WorkflowRunsMetricsCounts struct {
	FAILED    *int `json:"FAILED,omitempty"`
	PENDING   *int `json:"PENDING,omitempty"`
	QUEUED    *int `json:"QUEUED,omitempty"`
	RUNNING   *int `json:"RUNNING,omitempty"`
	SUCCEEDED *int `json:"SUCCEEDED,omitempty"`
}

// WorkflowTag defines model for WorkflowTag.
type WorkflowTag struct {
	// Color The description of the workflow.
	Color string `json:"color"`

	// Name The name of the workflow.
	Name string `json:"name"`
}

// WorkflowTriggerCronRef defines model for WorkflowTriggerCronRef.
type WorkflowTriggerCronRef struct {
	Cron     *string `json:"cron,omitempty"`
	ParentId *string `json:"parent_id,omitempty"`
}

// WorkflowTriggerEventRef defines model for WorkflowTriggerEventRef.
type WorkflowTriggerEventRef struct {
	EventKey *string `json:"event_key,omitempty"`
	ParentId *string `json:"parent_id,omitempty"`
}

// WorkflowTriggers defines model for WorkflowTriggers.
type WorkflowTriggers struct {
	Crons             *[]WorkflowTriggerCronRef  `json:"crons,omitempty"`
	Events            *[]WorkflowTriggerEventRef `json:"events,omitempty"`
	Metadata          *APIResourceMeta           `json:"metadata,omitempty"`
	TenantId          *string                    `json:"tenant_id,omitempty"`
	WorkflowVersionId *string                    `json:"workflow_version_id,omitempty"`
}

// WorkflowVersion defines model for WorkflowVersion.
type WorkflowVersion struct {
	Concurrency     *WorkflowConcurrency `json:"concurrency,omitempty"`
	Jobs            *[]Job               `json:"jobs,omitempty"`
	Metadata        APIResourceMeta      `json:"metadata"`
	Order           int32                `json:"order"`
	ScheduleTimeout *string              `json:"scheduleTimeout,omitempty"`
	Triggers        *WorkflowTriggers    `json:"triggers,omitempty"`

	// Version The version of the workflow.
	Version    string    `json:"version"`
	Workflow   *Workflow `json:"workflow,omitempty"`
	WorkflowId string    `json:"workflowId"`
}

// WorkflowVersionDefinition defines model for WorkflowVersionDefinition.
type WorkflowVersionDefinition struct {
	// RawDefinition The raw YAML definition of the workflow.
	RawDefinition string `json:"rawDefinition"`
}

// WorkflowVersionMeta defines model for WorkflowVersionMeta.
type WorkflowVersionMeta struct {
	Metadata APIResourceMeta `json:"metadata"`
	Order    int32           `json:"order"`

	// Version The version of the workflow.
	Version    string    `json:"version"`
	Workflow   *Workflow `json:"workflow,omitempty"`
	WorkflowId string    `json:"workflowId"`
}

// StepRunListArchivesParams defines parameters for StepRunListArchives.
type StepRunListArchivesParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`
}

// StepRunListEventsParams defines parameters for StepRunListEvents.
type StepRunListEventsParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`
}

// LogLineListParams defines parameters for LogLineList.
type LogLineListParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Levels A list of levels to filter by
	Levels *LogLineLevelField `form:"levels,omitempty" json:"levels,omitempty"`

	// Search The search query to filter for
	Search *LogLineSearch `form:"search,omitempty" json:"search,omitempty"`

	// OrderByField What to order by
	OrderByField *LogLineOrderByField `form:"orderByField,omitempty" json:"orderByField,omitempty"`

	// OrderByDirection The order direction
	OrderByDirection *LogLineOrderByDirection `form:"orderByDirection,omitempty" json:"orderByDirection,omitempty"`
}

// EventListParams defines parameters for EventList.
type EventListParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Keys A list of keys to filter by
	Keys *[]EventKey `form:"keys,omitempty" json:"keys,omitempty"`

	// Workflows A list of workflow IDs to filter by
	Workflows *[]WorkflowID `form:"workflows,omitempty" json:"workflows,omitempty"`

	// Statuses A list of workflow run statuses to filter by
	Statuses *WorkflowRunStatusList `form:"statuses,omitempty" json:"statuses,omitempty"`

	// Search The search query to filter for
	Search *EventSearch `form:"search,omitempty" json:"search,omitempty"`

	// OrderByField What to order by
	OrderByField *EventOrderByField `form:"orderByField,omitempty" json:"orderByField,omitempty"`

	// OrderByDirection The order direction
	OrderByDirection *EventOrderByDirection `form:"orderByDirection,omitempty" json:"orderByDirection,omitempty"`

	// AdditionalMetadata A list of metadata key value pairs to filter by
	AdditionalMetadata *[]string `form:"additionalMetadata,omitempty" json:"additionalMetadata,omitempty"`
}

// TenantGetQueueMetricsParams defines parameters for TenantGetQueueMetrics.
type TenantGetQueueMetricsParams struct {
	// Workflows A list of workflow IDs to filter by
	Workflows *[]WorkflowID `form:"workflows,omitempty" json:"workflows,omitempty"`

	// AdditionalMetadata A list of metadata key value pairs to filter by
	AdditionalMetadata *[]string `form:"additionalMetadata,omitempty" json:"additionalMetadata,omitempty"`
}

// WorkflowRunListParams defines parameters for WorkflowRunList.
type WorkflowRunListParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// EventId The event id to get runs for.
	EventId *openapi_types.UUID `form:"eventId,omitempty" json:"eventId,omitempty"`

	// WorkflowId The workflow id to get runs for.
	WorkflowId *openapi_types.UUID `form:"workflowId,omitempty" json:"workflowId,omitempty"`

	// ParentWorkflowRunId The parent workflow run id
	ParentWorkflowRunId *openapi_types.UUID `form:"parentWorkflowRunId,omitempty" json:"parentWorkflowRunId,omitempty"`

	// ParentStepRunId The parent step run id
	ParentStepRunId *openapi_types.UUID `form:"parentStepRunId,omitempty" json:"parentStepRunId,omitempty"`

	// Statuses A list of workflow run statuses to filter by
	Statuses *WorkflowRunStatusList `form:"statuses,omitempty" json:"statuses,omitempty"`

	// AdditionalMetadata A list of metadata key value pairs to filter by
	AdditionalMetadata *[]string `form:"additionalMetadata,omitempty" json:"additionalMetadata,omitempty"`
}

// WorkflowRunGetMetricsParams defines parameters for WorkflowRunGetMetrics.
type WorkflowRunGetMetricsParams struct {
	// EventId The event id to get runs for.
	EventId *openapi_types.UUID `form:"eventId,omitempty" json:"eventId,omitempty"`

	// WorkflowId The workflow id to get runs for.
	WorkflowId *openapi_types.UUID `form:"workflowId,omitempty" json:"workflowId,omitempty"`

	// ParentWorkflowRunId The parent workflow run id
	ParentWorkflowRunId *openapi_types.UUID `form:"parentWorkflowRunId,omitempty" json:"parentWorkflowRunId,omitempty"`

	// ParentStepRunId The parent step run id
	ParentStepRunId *openapi_types.UUID `form:"parentStepRunId,omitempty" json:"parentStepRunId,omitempty"`

	// AdditionalMetadata A list of metadata key value pairs to filter by
	AdditionalMetadata *[]string `form:"additionalMetadata,omitempty" json:"additionalMetadata,omitempty"`
}

// WorkflowGetMetricsParams defines parameters for WorkflowGetMetrics.
type WorkflowGetMetricsParams struct {
	// Status A status of workflow run statuses to filter by
	Status *WorkflowRunStatus `form:"status,omitempty" json:"status,omitempty"`

	// GroupKey A group key to filter metrics by
	GroupKey *string `form:"groupKey,omitempty" json:"groupKey,omitempty"`
}

// WorkflowRunCreateParams defines parameters for WorkflowRunCreate.
type WorkflowRunCreateParams struct {
	// Version The workflow version. If not supplied, the latest version is fetched.
	Version *openapi_types.UUID `form:"version,omitempty" json:"version,omitempty"`
}

// WorkflowVersionGetParams defines parameters for WorkflowVersionGet.
type WorkflowVersionGetParams struct {
	// Version The workflow version. If not supplied, the latest version is fetched.
	Version *openapi_types.UUID `form:"version,omitempty" json:"version,omitempty"`
}

// WorkflowVersionGetDefinitionParams defines parameters for WorkflowVersionGetDefinition.
type WorkflowVersionGetDefinitionParams struct {
	// Version The workflow version. If not supplied, the latest version is fetched.
	Version *openapi_types.UUID `form:"version,omitempty" json:"version,omitempty"`
}

// AlertEmailGroupUpdateJSONRequestBody defines body for AlertEmailGroupUpdate for application/json ContentType.
type AlertEmailGroupUpdateJSONRequestBody = UpdateTenantAlertEmailGroupRequest

// TenantCreateJSONRequestBody defines body for TenantCreate for application/json ContentType.
type TenantCreateJSONRequestBody = CreateTenantRequest

// TenantUpdateJSONRequestBody defines body for TenantUpdate for application/json ContentType.
type TenantUpdateJSONRequestBody = UpdateTenantRequest

// AlertEmailGroupCreateJSONRequestBody defines body for AlertEmailGroupCreate for application/json ContentType.
type AlertEmailGroupCreateJSONRequestBody = CreateTenantAlertEmailGroupRequest

// ApiTokenCreateJSONRequestBody defines body for ApiTokenCreate for application/json ContentType.
type ApiTokenCreateJSONRequestBody = CreateAPITokenRequest

// EventCreateJSONRequestBody defines body for EventCreate for application/json ContentType.
type EventCreateJSONRequestBody = CreateEventRequest

// EventUpdateReplayJSONRequestBody defines body for EventUpdateReplay for application/json ContentType.
type EventUpdateReplayJSONRequestBody = ReplayEventRequest

// TenantInviteCreateJSONRequestBody defines body for TenantInviteCreate for application/json ContentType.
type TenantInviteCreateJSONRequestBody = CreateTenantInviteRequest

// TenantInviteUpdateJSONRequestBody defines body for TenantInviteUpdate for application/json ContentType.
type TenantInviteUpdateJSONRequestBody = UpdateTenantInviteRequest

// SnsCreateJSONRequestBody defines body for SnsCreate for application/json ContentType.
type SnsCreateJSONRequestBody = CreateSNSIntegrationRequest

// StepRunUpdateRerunJSONRequestBody defines body for StepRunUpdateRerun for application/json ContentType.
type StepRunUpdateRerunJSONRequestBody = RerunStepRunRequest

// WebhookCreateJSONRequestBody defines body for WebhookCreate for application/json ContentType.
type WebhookCreateJSONRequestBody = WebhookWorkerCreateRequest

// WorkflowRunCancelJSONRequestBody defines body for WorkflowRunCancel for application/json ContentType.
type WorkflowRunCancelJSONRequestBody = WorkflowRunsCancelRequest

// TenantInviteAcceptJSONRequestBody defines body for TenantInviteAccept for application/json ContentType.
type TenantInviteAcceptJSONRequestBody = AcceptInviteRequest

// TenantInviteRejectJSONRequestBody defines body for TenantInviteReject for application/json ContentType.
type TenantInviteRejectJSONRequestBody = RejectInviteRequest

// UserUpdateLoginJSONRequestBody defines body for UserUpdateLogin for application/json ContentType.
type UserUpdateLoginJSONRequestBody = UserLoginRequest

// UserUpdatePasswordJSONRequestBody defines body for UserUpdatePassword for application/json ContentType.
type UserUpdatePasswordJSONRequestBody = UserChangePasswordRequest

// UserCreateJSONRequestBody defines body for UserCreate for application/json ContentType.
type UserCreateJSONRequestBody = UserRegisterRequest

// WorkflowRunCreateJSONRequestBody defines body for WorkflowRunCreate for application/json ContentType.
type WorkflowRunCreateJSONRequestBody = TriggerWorkflowRunRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// LivenessGet request
	LivenessGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadinessGet request
	ReadinessGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertEmailGroupDelete request
	AlertEmailGroupDelete(ctx context.Context, alertEmailGroup openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertEmailGroupUpdateWithBody request with any body
	AlertEmailGroupUpdateWithBody(ctx context.Context, alertEmailGroup openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AlertEmailGroupUpdate(ctx context.Context, alertEmailGroup openapi_types.UUID, body AlertEmailGroupUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiTokenUpdateRevoke request
	ApiTokenUpdateRevoke(ctx context.Context, apiToken openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CloudMetadataGet request
	CloudMetadataGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventDataGet request
	EventDataGet(ctx context.Context, event openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetadataGet request
	MetadataGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetadataListIntegrations request
	MetadataListIntegrations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlackWebhookDelete request
	SlackWebhookDelete(ctx context.Context, slack openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnsDelete request
	SnsDelete(ctx context.Context, sns openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnsUpdate request
	SnsUpdate(ctx context.Context, tenant openapi_types.UUID, event string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunListArchives request
	StepRunListArchives(ctx context.Context, stepRun openapi_types.UUID, params *StepRunListArchivesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunListEvents request
	StepRunListEvents(ctx context.Context, stepRun openapi_types.UUID, params *StepRunListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogLineList request
	LogLineList(ctx context.Context, stepRun openapi_types.UUID, params *LogLineListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantCreateWithBody request with any body
	TenantCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantCreate(ctx context.Context, body TenantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantUpdateWithBody request with any body
	TenantUpdateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantUpdate(ctx context.Context, tenant openapi_types.UUID, body TenantUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertEmailGroupList request
	AlertEmailGroupList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertEmailGroupCreateWithBody request with any body
	AlertEmailGroupCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AlertEmailGroupCreate(ctx context.Context, tenant openapi_types.UUID, body AlertEmailGroupCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantAlertingSettingsGet request
	TenantAlertingSettingsGet(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiTokenList request
	ApiTokenList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiTokenCreateWithBody request with any body
	ApiTokenCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApiTokenCreate(ctx context.Context, tenant openapi_types.UUID, body ApiTokenCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventList request
	EventList(ctx context.Context, tenant openapi_types.UUID, params *EventListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventCreateWithBody request with any body
	EventCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EventCreate(ctx context.Context, tenant openapi_types.UUID, body EventCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventKeyList request
	EventKeyList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventUpdateReplayWithBody request with any body
	EventUpdateReplayWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EventUpdateReplay(ctx context.Context, tenant openapi_types.UUID, body EventUpdateReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteList request
	TenantInviteList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteCreateWithBody request with any body
	TenantInviteCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantInviteCreate(ctx context.Context, tenant openapi_types.UUID, body TenantInviteCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteDelete request
	TenantInviteDelete(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteUpdateWithBody request with any body
	TenantInviteUpdateWithBody(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantInviteUpdate(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, body TenantInviteUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantMemberList request
	TenantMemberList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantMemberDelete request
	TenantMemberDelete(ctx context.Context, tenant openapi_types.UUID, member openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantGetQueueMetrics request
	TenantGetQueueMetrics(ctx context.Context, tenant openapi_types.UUID, params *TenantGetQueueMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantResourcePolicyGet request
	TenantResourcePolicyGet(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlackWebhookList request
	SlackWebhookList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateSlackOauthStart request
	UserUpdateSlackOauthStart(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnsList request
	SnsList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnsCreateWithBody request with any body
	SnsCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SnsCreate(ctx context.Context, tenant openapi_types.UUID, body SnsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunGet request
	StepRunGet(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunUpdateCancel request
	StepRunUpdateCancel(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunUpdateRerunWithBody request with any body
	StepRunUpdateRerunWithBody(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StepRunUpdateRerun(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, body StepRunUpdateRerunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunGetSchema request
	StepRunGetSchema(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhookList request
	WebhookList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhookCreateWithBody request with any body
	WebhookCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhookCreate(ctx context.Context, tenant openapi_types.UUID, body WebhookCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerList request
	WorkerList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunGet request
	WorkflowRunGet(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowList request
	WorkflowList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunCancelWithBody request with any body
	WorkflowRunCancelWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorkflowRunCancel(ctx context.Context, tenant openapi_types.UUID, body WorkflowRunCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunList request
	WorkflowRunList(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunGetMetrics request
	WorkflowRunGetMetrics(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunGetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserGetCurrent request
	UserGetCurrent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateGithubOauthCallback request
	UserUpdateGithubOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateGithubOauthStart request
	UserUpdateGithubOauthStart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateGoogleOauthCallback request
	UserUpdateGoogleOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateGoogleOauthStart request
	UserUpdateGoogleOauthStart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserListTenantInvites request
	UserListTenantInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteAcceptWithBody request with any body
	TenantInviteAcceptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantInviteAccept(ctx context.Context, body TenantInviteAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteRejectWithBody request with any body
	TenantInviteRejectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantInviteReject(ctx context.Context, body TenantInviteRejectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateLoginWithBody request with any body
	UserUpdateLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserUpdateLogin(ctx context.Context, body UserUpdateLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateLogout request
	UserUpdateLogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantMembershipsList request
	TenantMembershipsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdatePasswordWithBody request with any body
	UserUpdatePasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserUpdatePassword(ctx context.Context, body UserUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserCreateWithBody request with any body
	UserCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserCreate(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateSlackOauthCallback request
	UserUpdateSlackOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhookDelete request
	WebhookDelete(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerGet request
	WorkerGet(ctx context.Context, worker openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowDelete request
	WorkflowDelete(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowGet request
	WorkflowGet(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowGetMetrics request
	WorkflowGetMetrics(ctx context.Context, workflow openapi_types.UUID, params *WorkflowGetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunCreateWithBody request with any body
	WorkflowRunCreateWithBody(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorkflowRunCreate(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, body WorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowVersionGet request
	WorkflowVersionGet(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowVersionGetDefinition request
	WorkflowVersionGetDefinition(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetDefinitionParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) LivenessGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLivenessGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadinessGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadinessGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertEmailGroupDelete(ctx context.Context, alertEmailGroup openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertEmailGroupDeleteRequest(c.Server, alertEmailGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertEmailGroupUpdateWithBody(ctx context.Context, alertEmailGroup openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertEmailGroupUpdateRequestWithBody(c.Server, alertEmailGroup, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertEmailGroupUpdate(ctx context.Context, alertEmailGroup openapi_types.UUID, body AlertEmailGroupUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertEmailGroupUpdateRequest(c.Server, alertEmailGroup, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiTokenUpdateRevoke(ctx context.Context, apiToken openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiTokenUpdateRevokeRequest(c.Server, apiToken)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloudMetadataGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloudMetadataGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventDataGet(ctx context.Context, event openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventDataGetRequest(c.Server, event)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataListIntegrations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataListIntegrationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlackWebhookDelete(ctx context.Context, slack openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlackWebhookDeleteRequest(c.Server, slack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnsDelete(ctx context.Context, sns openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnsDeleteRequest(c.Server, sns)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnsUpdate(ctx context.Context, tenant openapi_types.UUID, event string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnsUpdateRequest(c.Server, tenant, event)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunListArchives(ctx context.Context, stepRun openapi_types.UUID, params *StepRunListArchivesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunListArchivesRequest(c.Server, stepRun, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunListEvents(ctx context.Context, stepRun openapi_types.UUID, params *StepRunListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunListEventsRequest(c.Server, stepRun, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogLineList(ctx context.Context, stepRun openapi_types.UUID, params *LogLineListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogLineListRequest(c.Server, stepRun, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantCreate(ctx context.Context, body TenantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantUpdateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantUpdateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantUpdate(ctx context.Context, tenant openapi_types.UUID, body TenantUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantUpdateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertEmailGroupList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertEmailGroupListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertEmailGroupCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertEmailGroupCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertEmailGroupCreate(ctx context.Context, tenant openapi_types.UUID, body AlertEmailGroupCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertEmailGroupCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantAlertingSettingsGet(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantAlertingSettingsGetRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiTokenList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiTokenListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiTokenCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiTokenCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiTokenCreate(ctx context.Context, tenant openapi_types.UUID, body ApiTokenCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiTokenCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventList(ctx context.Context, tenant openapi_types.UUID, params *EventListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventListRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventCreate(ctx context.Context, tenant openapi_types.UUID, body EventCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventKeyList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventKeyListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventUpdateReplayWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventUpdateReplayRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventUpdateReplay(ctx context.Context, tenant openapi_types.UUID, body EventUpdateReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventUpdateReplayRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteCreate(ctx context.Context, tenant openapi_types.UUID, body TenantInviteCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteDelete(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteDeleteRequest(c.Server, tenant, tenantInvite)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteUpdateWithBody(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteUpdateRequestWithBody(c.Server, tenant, tenantInvite, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteUpdate(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, body TenantInviteUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteUpdateRequest(c.Server, tenant, tenantInvite, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantMemberList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantMemberListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantMemberDelete(ctx context.Context, tenant openapi_types.UUID, member openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantMemberDeleteRequest(c.Server, tenant, member)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantGetQueueMetrics(ctx context.Context, tenant openapi_types.UUID, params *TenantGetQueueMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantGetQueueMetricsRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantResourcePolicyGet(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantResourcePolicyGetRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlackWebhookList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlackWebhookListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateSlackOauthStart(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateSlackOauthStartRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnsList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnsListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnsCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnsCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnsCreate(ctx context.Context, tenant openapi_types.UUID, body SnsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnsCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunGet(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunGetRequest(c.Server, tenant, stepRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunUpdateCancel(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunUpdateCancelRequest(c.Server, tenant, stepRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunUpdateRerunWithBody(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunUpdateRerunRequestWithBody(c.Server, tenant, stepRun, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunUpdateRerun(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, body StepRunUpdateRerunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunUpdateRerunRequest(c.Server, tenant, stepRun, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunGetSchema(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunGetSchemaRequest(c.Server, tenant, stepRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhookList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhookListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhookCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhookCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhookCreate(ctx context.Context, tenant openapi_types.UUID, body WebhookCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhookCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunGet(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunGetRequest(c.Server, tenant, workflowRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunCancelWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunCancelRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunCancel(ctx context.Context, tenant openapi_types.UUID, body WorkflowRunCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunCancelRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunList(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunListRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunGetMetrics(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunGetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunGetMetricsRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserGetCurrent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserGetCurrentRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateGithubOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateGithubOauthCallbackRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateGithubOauthStart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateGithubOauthStartRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateGoogleOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateGoogleOauthCallbackRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateGoogleOauthStart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateGoogleOauthStartRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserListTenantInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserListTenantInvitesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteAcceptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteAcceptRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteAccept(ctx context.Context, body TenantInviteAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteAcceptRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteRejectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteRejectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteReject(ctx context.Context, body TenantInviteRejectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteRejectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateLogin(ctx context.Context, body UserUpdateLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateLogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantMembershipsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantMembershipsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdatePasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdatePasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdatePassword(ctx context.Context, body UserUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdatePasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserCreate(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateSlackOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateSlackOauthCallbackRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhookDelete(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhookDeleteRequest(c.Server, webhook)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerGet(ctx context.Context, worker openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerGetRequest(c.Server, worker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowDelete(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowDeleteRequest(c.Server, workflow)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowGet(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowGetRequest(c.Server, workflow)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowGetMetrics(ctx context.Context, workflow openapi_types.UUID, params *WorkflowGetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowGetMetricsRequest(c.Server, workflow, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunCreateWithBody(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunCreateRequestWithBody(c.Server, workflow, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunCreate(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, body WorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunCreateRequest(c.Server, workflow, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowVersionGet(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowVersionGetRequest(c.Server, workflow, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowVersionGetDefinition(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetDefinitionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowVersionGetDefinitionRequest(c.Server, workflow, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewLivenessGetRequest generates requests for LivenessGet
func NewLivenessGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/live")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadinessGetRequest generates requests for ReadinessGet
func NewReadinessGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertEmailGroupDeleteRequest generates requests for AlertEmailGroupDelete
func NewAlertEmailGroupDeleteRequest(server string, alertEmailGroup openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alert-email-group", runtime.ParamLocationPath, alertEmailGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/alerting-email-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertEmailGroupUpdateRequest calls the generic AlertEmailGroupUpdate builder with application/json body
func NewAlertEmailGroupUpdateRequest(server string, alertEmailGroup openapi_types.UUID, body AlertEmailGroupUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAlertEmailGroupUpdateRequestWithBody(server, alertEmailGroup, "application/json", bodyReader)
}

// NewAlertEmailGroupUpdateRequestWithBody generates requests for AlertEmailGroupUpdate with any type of body
func NewAlertEmailGroupUpdateRequestWithBody(server string, alertEmailGroup openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alert-email-group", runtime.ParamLocationPath, alertEmailGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/alerting-email-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewApiTokenUpdateRevokeRequest generates requests for ApiTokenUpdateRevoke
func NewApiTokenUpdateRevokeRequest(server string, apiToken openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "api-token", runtime.ParamLocationPath, apiToken)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/api-tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCloudMetadataGetRequest generates requests for CloudMetadataGet
func NewCloudMetadataGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/metadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEventDataGetRequest generates requests for EventDataGet
func NewEventDataGetRequest(server string, event openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event", runtime.ParamLocationPath, event)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/events/%s/data", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetadataGetRequest generates requests for MetadataGet
func NewMetadataGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meta")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetadataListIntegrationsRequest generates requests for MetadataListIntegrations
func NewMetadataListIntegrationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meta/integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlackWebhookDeleteRequest generates requests for SlackWebhookDelete
func NewSlackWebhookDeleteRequest(server string, slack openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slack", runtime.ParamLocationPath, slack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/slack/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnsDeleteRequest generates requests for SnsDelete
func NewSnsDeleteRequest(server string, sns openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sns", runtime.ParamLocationPath, sns)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnsUpdateRequest generates requests for SnsUpdate
func NewSnsUpdateRequest(server string, tenant openapi_types.UUID, event string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "event", runtime.ParamLocationPath, event)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sns/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStepRunListArchivesRequest generates requests for StepRunListArchives
func NewStepRunListArchivesRequest(server string, stepRun openapi_types.UUID, params *StepRunListArchivesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/step-runs/%s/archives", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStepRunListEventsRequest generates requests for StepRunListEvents
func NewStepRunListEventsRequest(server string, stepRun openapi_types.UUID, params *StepRunListEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/step-runs/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogLineListRequest generates requests for LogLineList
func NewLogLineListRequest(server string, stepRun openapi_types.UUID, params *LogLineListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/step-runs/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Levels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "levels", runtime.ParamLocationQuery, *params.Levels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByField", runtime.ParamLocationQuery, *params.OrderByField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByDirection", runtime.ParamLocationQuery, *params.OrderByDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantCreateRequest calls the generic TenantCreate builder with application/json body
func NewTenantCreateRequest(server string, body TenantCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewTenantCreateRequestWithBody generates requests for TenantCreate with any type of body
func NewTenantCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantUpdateRequest calls the generic TenantUpdate builder with application/json body
func NewTenantUpdateRequest(server string, tenant openapi_types.UUID, body TenantUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantUpdateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewTenantUpdateRequestWithBody generates requests for TenantUpdate with any type of body
func NewTenantUpdateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAlertEmailGroupListRequest generates requests for AlertEmailGroupList
func NewAlertEmailGroupListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/alerting-email-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertEmailGroupCreateRequest calls the generic AlertEmailGroupCreate builder with application/json body
func NewAlertEmailGroupCreateRequest(server string, tenant openapi_types.UUID, body AlertEmailGroupCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAlertEmailGroupCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewAlertEmailGroupCreateRequestWithBody generates requests for AlertEmailGroupCreate with any type of body
func NewAlertEmailGroupCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/alerting-email-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantAlertingSettingsGetRequest generates requests for TenantAlertingSettingsGet
func NewTenantAlertingSettingsGetRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/alerting/settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApiTokenListRequest generates requests for ApiTokenList
func NewApiTokenListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/api-tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApiTokenCreateRequest calls the generic ApiTokenCreate builder with application/json body
func NewApiTokenCreateRequest(server string, tenant openapi_types.UUID, body ApiTokenCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApiTokenCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewApiTokenCreateRequestWithBody generates requests for ApiTokenCreate with any type of body
func NewApiTokenCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/api-tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEventListRequest generates requests for EventList
func NewEventListRequest(server string, tenant openapi_types.UUID, params *EventListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keys", runtime.ParamLocationQuery, *params.Keys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Workflows != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflows", runtime.ParamLocationQuery, *params.Workflows); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Statuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statuses", runtime.ParamLocationQuery, *params.Statuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByField", runtime.ParamLocationQuery, *params.OrderByField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByDirection", runtime.ParamLocationQuery, *params.OrderByDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdditionalMetadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additionalMetadata", runtime.ParamLocationQuery, *params.AdditionalMetadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEventCreateRequest calls the generic EventCreate builder with application/json body
func NewEventCreateRequest(server string, tenant openapi_types.UUID, body EventCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEventCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewEventCreateRequestWithBody generates requests for EventCreate with any type of body
func NewEventCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEventKeyListRequest generates requests for EventKeyList
func NewEventKeyListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/events/keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEventUpdateReplayRequest calls the generic EventUpdateReplay builder with application/json body
func NewEventUpdateReplayRequest(server string, tenant openapi_types.UUID, body EventUpdateReplayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEventUpdateReplayRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewEventUpdateReplayRequestWithBody generates requests for EventUpdateReplay with any type of body
func NewEventUpdateReplayRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/events/replay", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantInviteListRequest generates requests for TenantInviteList
func NewTenantInviteListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/invites", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantInviteCreateRequest calls the generic TenantInviteCreate builder with application/json body
func NewTenantInviteCreateRequest(server string, tenant openapi_types.UUID, body TenantInviteCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantInviteCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewTenantInviteCreateRequestWithBody generates requests for TenantInviteCreate with any type of body
func NewTenantInviteCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/invites", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantInviteDeleteRequest generates requests for TenantInviteDelete
func NewTenantInviteDeleteRequest(server string, tenant openapi_types.UUID, tenantInvite openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-invite", runtime.ParamLocationPath, tenantInvite)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/invites/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantInviteUpdateRequest calls the generic TenantInviteUpdate builder with application/json body
func NewTenantInviteUpdateRequest(server string, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, body TenantInviteUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantInviteUpdateRequestWithBody(server, tenant, tenantInvite, "application/json", bodyReader)
}

// NewTenantInviteUpdateRequestWithBody generates requests for TenantInviteUpdate with any type of body
func NewTenantInviteUpdateRequestWithBody(server string, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-invite", runtime.ParamLocationPath, tenantInvite)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/invites/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantMemberListRequest generates requests for TenantMemberList
func NewTenantMemberListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantMemberDeleteRequest generates requests for TenantMemberDelete
func NewTenantMemberDeleteRequest(server string, tenant openapi_types.UUID, member openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "member", runtime.ParamLocationPath, member)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantGetQueueMetricsRequest generates requests for TenantGetQueueMetrics
func NewTenantGetQueueMetricsRequest(server string, tenant openapi_types.UUID, params *TenantGetQueueMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/queue-metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Workflows != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflows", runtime.ParamLocationQuery, *params.Workflows); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdditionalMetadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additionalMetadata", runtime.ParamLocationQuery, *params.AdditionalMetadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantResourcePolicyGetRequest generates requests for TenantResourcePolicyGet
func NewTenantResourcePolicyGetRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/resource-policy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlackWebhookListRequest generates requests for SlackWebhookList
func NewSlackWebhookListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/slack", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateSlackOauthStartRequest generates requests for UserUpdateSlackOauthStart
func NewUserUpdateSlackOauthStartRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/slack/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnsListRequest generates requests for SnsList
func NewSnsListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/sns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnsCreateRequest calls the generic SnsCreate builder with application/json body
func NewSnsCreateRequest(server string, tenant openapi_types.UUID, body SnsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSnsCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewSnsCreateRequestWithBody generates requests for SnsCreate with any type of body
func NewSnsCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/sns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStepRunGetRequest generates requests for StepRunGet
func NewStepRunGetRequest(server string, tenant openapi_types.UUID, stepRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/step-runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStepRunUpdateCancelRequest generates requests for StepRunUpdateCancel
func NewStepRunUpdateCancelRequest(server string, tenant openapi_types.UUID, stepRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/step-runs/%s/cancel", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStepRunUpdateRerunRequest calls the generic StepRunUpdateRerun builder with application/json body
func NewStepRunUpdateRerunRequest(server string, tenant openapi_types.UUID, stepRun openapi_types.UUID, body StepRunUpdateRerunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStepRunUpdateRerunRequestWithBody(server, tenant, stepRun, "application/json", bodyReader)
}

// NewStepRunUpdateRerunRequestWithBody generates requests for StepRunUpdateRerun with any type of body
func NewStepRunUpdateRerunRequestWithBody(server string, tenant openapi_types.UUID, stepRun openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/step-runs/%s/rerun", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStepRunGetSchemaRequest generates requests for StepRunGetSchema
func NewStepRunGetSchemaRequest(server string, tenant openapi_types.UUID, stepRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/step-runs/%s/schema", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhookListRequest generates requests for WebhookList
func NewWebhookListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/webhook-workers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhookCreateRequest calls the generic WebhookCreate builder with application/json body
func NewWebhookCreateRequest(server string, tenant openapi_types.UUID, body WebhookCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhookCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewWebhookCreateRequestWithBody generates requests for WebhookCreate with any type of body
func NewWebhookCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/webhook-workers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorkerListRequest generates requests for WorkerList
func NewWorkerListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/worker", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowRunGetRequest generates requests for WorkflowRunGet
func NewWorkflowRunGetRequest(server string, tenant openapi_types.UUID, workflowRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workflow-run", runtime.ParamLocationPath, workflowRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflow-runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowListRequest generates requests for WorkflowList
func NewWorkflowListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowRunCancelRequest calls the generic WorkflowRunCancel builder with application/json body
func NewWorkflowRunCancelRequest(server string, tenant openapi_types.UUID, body WorkflowRunCancelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorkflowRunCancelRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewWorkflowRunCancelRequestWithBody generates requests for WorkflowRunCancel with any type of body
func NewWorkflowRunCancelRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorkflowRunListRequest generates requests for WorkflowRunList
func NewWorkflowRunListRequest(server string, tenant openapi_types.UUID, params *WorkflowRunListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventId", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkflowId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflowId", runtime.ParamLocationQuery, *params.WorkflowId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentWorkflowRunId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentWorkflowRunId", runtime.ParamLocationQuery, *params.ParentWorkflowRunId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentStepRunId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentStepRunId", runtime.ParamLocationQuery, *params.ParentStepRunId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Statuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statuses", runtime.ParamLocationQuery, *params.Statuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdditionalMetadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additionalMetadata", runtime.ParamLocationQuery, *params.AdditionalMetadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowRunGetMetricsRequest generates requests for WorkflowRunGetMetrics
func NewWorkflowRunGetMetricsRequest(server string, tenant openapi_types.UUID, params *WorkflowRunGetMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows/runs/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventId", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkflowId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflowId", runtime.ParamLocationQuery, *params.WorkflowId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentWorkflowRunId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentWorkflowRunId", runtime.ParamLocationQuery, *params.ParentWorkflowRunId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentStepRunId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentStepRunId", runtime.ParamLocationQuery, *params.ParentStepRunId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdditionalMetadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additionalMetadata", runtime.ParamLocationQuery, *params.AdditionalMetadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserGetCurrentRequest generates requests for UserGetCurrent
func NewUserGetCurrentRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/current")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateGithubOauthCallbackRequest generates requests for UserUpdateGithubOauthCallback
func NewUserUpdateGithubOauthCallbackRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/github/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateGithubOauthStartRequest generates requests for UserUpdateGithubOauthStart
func NewUserUpdateGithubOauthStartRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/github/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateGoogleOauthCallbackRequest generates requests for UserUpdateGoogleOauthCallback
func NewUserUpdateGoogleOauthCallbackRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/google/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateGoogleOauthStartRequest generates requests for UserUpdateGoogleOauthStart
func NewUserUpdateGoogleOauthStartRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/google/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserListTenantInvitesRequest generates requests for UserListTenantInvites
func NewUserListTenantInvitesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantInviteAcceptRequest calls the generic TenantInviteAccept builder with application/json body
func NewTenantInviteAcceptRequest(server string, body TenantInviteAcceptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantInviteAcceptRequestWithBody(server, "application/json", bodyReader)
}

// NewTenantInviteAcceptRequestWithBody generates requests for TenantInviteAccept with any type of body
func NewTenantInviteAcceptRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/invites/accept")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantInviteRejectRequest calls the generic TenantInviteReject builder with application/json body
func NewTenantInviteRejectRequest(server string, body TenantInviteRejectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantInviteRejectRequestWithBody(server, "application/json", bodyReader)
}

// NewTenantInviteRejectRequestWithBody generates requests for TenantInviteReject with any type of body
func NewTenantInviteRejectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/invites/reject")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserUpdateLoginRequest calls the generic UserUpdateLogin builder with application/json body
func NewUserUpdateLoginRequest(server string, body UserUpdateLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserUpdateLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewUserUpdateLoginRequestWithBody generates requests for UserUpdateLogin with any type of body
func NewUserUpdateLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserUpdateLogoutRequest generates requests for UserUpdateLogout
func NewUserUpdateLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantMembershipsListRequest generates requests for TenantMembershipsList
func NewTenantMembershipsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/memberships")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdatePasswordRequest calls the generic UserUpdatePassword builder with application/json body
func NewUserUpdatePasswordRequest(server string, body UserUpdatePasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserUpdatePasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewUserUpdatePasswordRequestWithBody generates requests for UserUpdatePassword with any type of body
func NewUserUpdatePasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserCreateRequest calls the generic UserCreate builder with application/json body
func NewUserCreateRequest(server string, body UserCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewUserCreateRequestWithBody generates requests for UserCreate with any type of body
func NewUserCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserUpdateSlackOauthCallbackRequest generates requests for UserUpdateSlackOauthCallback
func NewUserUpdateSlackOauthCallbackRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/slack/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhookDeleteRequest generates requests for WebhookDelete
func NewWebhookDeleteRequest(server string, webhook openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhook", runtime.ParamLocationPath, webhook)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/webhook-workers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerGetRequest generates requests for WorkerGet
func NewWorkerGetRequest(server string, worker openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "worker", runtime.ParamLocationPath, worker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowDeleteRequest generates requests for WorkflowDelete
func NewWorkflowDeleteRequest(server string, workflow openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowGetRequest generates requests for WorkflowGet
func NewWorkflowGetRequest(server string, workflow openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowGetMetricsRequest generates requests for WorkflowGetMetrics
func NewWorkflowGetMetricsRequest(server string, workflow openapi_types.UUID, params *WorkflowGetMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupKey", runtime.ParamLocationQuery, *params.GroupKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowRunCreateRequest calls the generic WorkflowRunCreate builder with application/json body
func NewWorkflowRunCreateRequest(server string, workflow openapi_types.UUID, params *WorkflowRunCreateParams, body WorkflowRunCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorkflowRunCreateRequestWithBody(server, workflow, params, "application/json", bodyReader)
}

// NewWorkflowRunCreateRequestWithBody generates requests for WorkflowRunCreate with any type of body
func NewWorkflowRunCreateRequestWithBody(server string, workflow openapi_types.UUID, params *WorkflowRunCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s/trigger", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorkflowVersionGetRequest generates requests for WorkflowVersionGet
func NewWorkflowVersionGetRequest(server string, workflow openapi_types.UUID, params *WorkflowVersionGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowVersionGetDefinitionRequest generates requests for WorkflowVersionGetDefinition
func NewWorkflowVersionGetDefinitionRequest(server string, workflow openapi_types.UUID, params *WorkflowVersionGetDefinitionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s/versions/definition", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// LivenessGetWithResponse request
	LivenessGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LivenessGetResponse, error)

	// ReadinessGetWithResponse request
	ReadinessGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReadinessGetResponse, error)

	// AlertEmailGroupDeleteWithResponse request
	AlertEmailGroupDeleteWithResponse(ctx context.Context, alertEmailGroup openapi_types.UUID, reqEditors ...RequestEditorFn) (*AlertEmailGroupDeleteResponse, error)

	// AlertEmailGroupUpdateWithBodyWithResponse request with any body
	AlertEmailGroupUpdateWithBodyWithResponse(ctx context.Context, alertEmailGroup openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AlertEmailGroupUpdateResponse, error)

	AlertEmailGroupUpdateWithResponse(ctx context.Context, alertEmailGroup openapi_types.UUID, body AlertEmailGroupUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AlertEmailGroupUpdateResponse, error)

	// ApiTokenUpdateRevokeWithResponse request
	ApiTokenUpdateRevokeWithResponse(ctx context.Context, apiToken openapi_types.UUID, reqEditors ...RequestEditorFn) (*ApiTokenUpdateRevokeResponse, error)

	// CloudMetadataGetWithResponse request
	CloudMetadataGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CloudMetadataGetResponse, error)

	// EventDataGetWithResponse request
	EventDataGetWithResponse(ctx context.Context, event openapi_types.UUID, reqEditors ...RequestEditorFn) (*EventDataGetResponse, error)

	// MetadataGetWithResponse request
	MetadataGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetadataGetResponse, error)

	// MetadataListIntegrationsWithResponse request
	MetadataListIntegrationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetadataListIntegrationsResponse, error)

	// SlackWebhookDeleteWithResponse request
	SlackWebhookDeleteWithResponse(ctx context.Context, slack openapi_types.UUID, reqEditors ...RequestEditorFn) (*SlackWebhookDeleteResponse, error)

	// SnsDeleteWithResponse request
	SnsDeleteWithResponse(ctx context.Context, sns openapi_types.UUID, reqEditors ...RequestEditorFn) (*SnsDeleteResponse, error)

	// SnsUpdateWithResponse request
	SnsUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, event string, reqEditors ...RequestEditorFn) (*SnsUpdateResponse, error)

	// StepRunListArchivesWithResponse request
	StepRunListArchivesWithResponse(ctx context.Context, stepRun openapi_types.UUID, params *StepRunListArchivesParams, reqEditors ...RequestEditorFn) (*StepRunListArchivesResponse, error)

	// StepRunListEventsWithResponse request
	StepRunListEventsWithResponse(ctx context.Context, stepRun openapi_types.UUID, params *StepRunListEventsParams, reqEditors ...RequestEditorFn) (*StepRunListEventsResponse, error)

	// LogLineListWithResponse request
	LogLineListWithResponse(ctx context.Context, stepRun openapi_types.UUID, params *LogLineListParams, reqEditors ...RequestEditorFn) (*LogLineListResponse, error)

	// TenantCreateWithBodyWithResponse request with any body
	TenantCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantCreateResponse, error)

	TenantCreateWithResponse(ctx context.Context, body TenantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantCreateResponse, error)

	// TenantUpdateWithBodyWithResponse request with any body
	TenantUpdateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantUpdateResponse, error)

	TenantUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, body TenantUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantUpdateResponse, error)

	// AlertEmailGroupListWithResponse request
	AlertEmailGroupListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*AlertEmailGroupListResponse, error)

	// AlertEmailGroupCreateWithBodyWithResponse request with any body
	AlertEmailGroupCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AlertEmailGroupCreateResponse, error)

	AlertEmailGroupCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body AlertEmailGroupCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AlertEmailGroupCreateResponse, error)

	// TenantAlertingSettingsGetWithResponse request
	TenantAlertingSettingsGetWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantAlertingSettingsGetResponse, error)

	// ApiTokenListWithResponse request
	ApiTokenListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*ApiTokenListResponse, error)

	// ApiTokenCreateWithBodyWithResponse request with any body
	ApiTokenCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApiTokenCreateResponse, error)

	ApiTokenCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body ApiTokenCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ApiTokenCreateResponse, error)

	// EventListWithResponse request
	EventListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *EventListParams, reqEditors ...RequestEditorFn) (*EventListResponse, error)

	// EventCreateWithBodyWithResponse request with any body
	EventCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventCreateResponse, error)

	EventCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body EventCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EventCreateResponse, error)

	// EventKeyListWithResponse request
	EventKeyListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*EventKeyListResponse, error)

	// EventUpdateReplayWithBodyWithResponse request with any body
	EventUpdateReplayWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventUpdateReplayResponse, error)

	EventUpdateReplayWithResponse(ctx context.Context, tenant openapi_types.UUID, body EventUpdateReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*EventUpdateReplayResponse, error)

	// TenantInviteListWithResponse request
	TenantInviteListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantInviteListResponse, error)

	// TenantInviteCreateWithBodyWithResponse request with any body
	TenantInviteCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteCreateResponse, error)

	TenantInviteCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body TenantInviteCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteCreateResponse, error)

	// TenantInviteDeleteWithResponse request
	TenantInviteDeleteWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantInviteDeleteResponse, error)

	// TenantInviteUpdateWithBodyWithResponse request with any body
	TenantInviteUpdateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteUpdateResponse, error)

	TenantInviteUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, body TenantInviteUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteUpdateResponse, error)

	// TenantMemberListWithResponse request
	TenantMemberListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantMemberListResponse, error)

	// TenantMemberDeleteWithResponse request
	TenantMemberDeleteWithResponse(ctx context.Context, tenant openapi_types.UUID, member openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantMemberDeleteResponse, error)

	// TenantGetQueueMetricsWithResponse request
	TenantGetQueueMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, params *TenantGetQueueMetricsParams, reqEditors ...RequestEditorFn) (*TenantGetQueueMetricsResponse, error)

	// TenantResourcePolicyGetWithResponse request
	TenantResourcePolicyGetWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantResourcePolicyGetResponse, error)

	// SlackWebhookListWithResponse request
	SlackWebhookListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*SlackWebhookListResponse, error)

	// UserUpdateSlackOauthStartWithResponse request
	UserUpdateSlackOauthStartWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*UserUpdateSlackOauthStartResponse, error)

	// SnsListWithResponse request
	SnsListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*SnsListResponse, error)

	// SnsCreateWithBodyWithResponse request with any body
	SnsCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnsCreateResponse, error)

	SnsCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body SnsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SnsCreateResponse, error)

	// StepRunGetWithResponse request
	StepRunGetWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunGetResponse, error)

	// StepRunUpdateCancelWithResponse request
	StepRunUpdateCancelWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunUpdateCancelResponse, error)

	// StepRunUpdateRerunWithBodyWithResponse request with any body
	StepRunUpdateRerunWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StepRunUpdateRerunResponse, error)

	StepRunUpdateRerunWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, body StepRunUpdateRerunJSONRequestBody, reqEditors ...RequestEditorFn) (*StepRunUpdateRerunResponse, error)

	// StepRunGetSchemaWithResponse request
	StepRunGetSchemaWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunGetSchemaResponse, error)

	// WebhookListWithResponse request
	WebhookListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*WebhookListResponse, error)

	// WebhookCreateWithBodyWithResponse request with any body
	WebhookCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhookCreateResponse, error)

	WebhookCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body WebhookCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhookCreateResponse, error)

	// WorkerListWithResponse request
	WorkerListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkerListResponse, error)

	// WorkflowRunGetWithResponse request
	WorkflowRunGetWithResponse(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowRunGetResponse, error)

	// WorkflowListWithResponse request
	WorkflowListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowListResponse, error)

	// WorkflowRunCancelWithBodyWithResponse request with any body
	WorkflowRunCancelWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkflowRunCancelResponse, error)

	WorkflowRunCancelWithResponse(ctx context.Context, tenant openapi_types.UUID, body WorkflowRunCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkflowRunCancelResponse, error)

	// WorkflowRunListWithResponse request
	WorkflowRunListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunListParams, reqEditors ...RequestEditorFn) (*WorkflowRunListResponse, error)

	// WorkflowRunGetMetricsWithResponse request
	WorkflowRunGetMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunGetMetricsParams, reqEditors ...RequestEditorFn) (*WorkflowRunGetMetricsResponse, error)

	// UserGetCurrentWithResponse request
	UserGetCurrentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserGetCurrentResponse, error)

	// UserUpdateGithubOauthCallbackWithResponse request
	UserUpdateGithubOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGithubOauthCallbackResponse, error)

	// UserUpdateGithubOauthStartWithResponse request
	UserUpdateGithubOauthStartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGithubOauthStartResponse, error)

	// UserUpdateGoogleOauthCallbackWithResponse request
	UserUpdateGoogleOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGoogleOauthCallbackResponse, error)

	// UserUpdateGoogleOauthStartWithResponse request
	UserUpdateGoogleOauthStartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGoogleOauthStartResponse, error)

	// UserListTenantInvitesWithResponse request
	UserListTenantInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserListTenantInvitesResponse, error)

	// TenantInviteAcceptWithBodyWithResponse request with any body
	TenantInviteAcceptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteAcceptResponse, error)

	TenantInviteAcceptWithResponse(ctx context.Context, body TenantInviteAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteAcceptResponse, error)

	// TenantInviteRejectWithBodyWithResponse request with any body
	TenantInviteRejectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteRejectResponse, error)

	TenantInviteRejectWithResponse(ctx context.Context, body TenantInviteRejectJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteRejectResponse, error)

	// UserUpdateLoginWithBodyWithResponse request with any body
	UserUpdateLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdateLoginResponse, error)

	UserUpdateLoginWithResponse(ctx context.Context, body UserUpdateLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdateLoginResponse, error)

	// UserUpdateLogoutWithResponse request
	UserUpdateLogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateLogoutResponse, error)

	// TenantMembershipsListWithResponse request
	TenantMembershipsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TenantMembershipsListResponse, error)

	// UserUpdatePasswordWithBodyWithResponse request with any body
	UserUpdatePasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdatePasswordResponse, error)

	UserUpdatePasswordWithResponse(ctx context.Context, body UserUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdatePasswordResponse, error)

	// UserCreateWithBodyWithResponse request with any body
	UserCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserCreateResponse, error)

	UserCreateWithResponse(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserCreateResponse, error)

	// UserUpdateSlackOauthCallbackWithResponse request
	UserUpdateSlackOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateSlackOauthCallbackResponse, error)

	// WebhookDeleteWithResponse request
	WebhookDeleteWithResponse(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*WebhookDeleteResponse, error)

	// WorkerGetWithResponse request
	WorkerGetWithResponse(ctx context.Context, worker openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkerGetResponse, error)

	// WorkflowDeleteWithResponse request
	WorkflowDeleteWithResponse(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowDeleteResponse, error)

	// WorkflowGetWithResponse request
	WorkflowGetWithResponse(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowGetResponse, error)

	// WorkflowGetMetricsWithResponse request
	WorkflowGetMetricsWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowGetMetricsParams, reqEditors ...RequestEditorFn) (*WorkflowGetMetricsResponse, error)

	// WorkflowRunCreateWithBodyWithResponse request with any body
	WorkflowRunCreateWithBodyWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkflowRunCreateResponse, error)

	WorkflowRunCreateWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, body WorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkflowRunCreateResponse, error)

	// WorkflowVersionGetWithResponse request
	WorkflowVersionGetWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetParams, reqEditors ...RequestEditorFn) (*WorkflowVersionGetResponse, error)

	// WorkflowVersionGetDefinitionWithResponse request
	WorkflowVersionGetDefinitionWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetDefinitionParams, reqEditors ...RequestEditorFn) (*WorkflowVersionGetDefinitionResponse, error)
}

type LivenessGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LivenessGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LivenessGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadinessGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReadinessGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadinessGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertEmailGroupDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r AlertEmailGroupDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertEmailGroupDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertEmailGroupUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantAlertEmailGroup
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r AlertEmailGroupUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertEmailGroupUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiTokenUpdateRevokeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r ApiTokenUpdateRevokeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiTokenUpdateRevokeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CloudMetadataGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *APIErrors
	JSON400      *APIErrors
}

// Status returns HTTPResponse.Status
func (r CloudMetadataGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CloudMetadataGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventDataGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventData
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r EventDataGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventDataGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetadataGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *APIMeta
	JSON400      *APIErrors
}

// Status returns HTTPResponse.Status
func (r MetadataGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetadataGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetadataListIntegrationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAPIMetaIntegration
	JSON400      *APIErrors
}

// Status returns HTTPResponse.Status
func (r MetadataListIntegrationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetadataListIntegrationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlackWebhookDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r SlackWebhookDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlackWebhookDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r SnsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r SnsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunListArchivesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StepRunArchiveList
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunListArchivesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunListArchivesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunListEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StepRunEventList
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunListEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunListEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogLineListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogLineList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r LogLineListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogLineListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tenant
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tenant
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertEmailGroupListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantAlertEmailGroupList
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r AlertEmailGroupListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertEmailGroupListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertEmailGroupCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TenantAlertEmailGroup
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r AlertEmailGroupCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertEmailGroupCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantAlertingSettingsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantAlertingSettings
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantAlertingSettingsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantAlertingSettingsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiTokenListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAPITokensResponse
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r ApiTokenListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiTokenListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiTokenCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateAPITokenResponse
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r ApiTokenCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiTokenCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r EventListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Event
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON429      *APIErrors
}

// Status returns HTTPResponse.Status
func (r EventCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventKeyListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventKeyList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r EventKeyListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventKeyListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventUpdateReplayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventList
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON429      *APIErrors
}

// Status returns HTTPResponse.Status
func (r EventUpdateReplayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventUpdateReplayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantInviteList
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantInviteListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TenantInvite
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantInviteCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantInvite
	JSON400      *APIErrors
}

// Status returns HTTPResponse.Status
func (r TenantInviteDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantInvite
	JSON400      *APIErrors
}

// Status returns HTTPResponse.Status
func (r TenantInviteUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantMemberListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantMemberList
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantMemberListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantMemberListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantMemberDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *TenantMember
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r TenantMemberDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantMemberDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantGetQueueMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantQueueMetrics
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r TenantGetQueueMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantGetQueueMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantResourcePolicyGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantResourcePolicy
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantResourcePolicyGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantResourcePolicyGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlackWebhookListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSlackWebhooks
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r SlackWebhookListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlackWebhookListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateSlackOauthStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateSlackOauthStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateSlackOauthStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSNSIntegrations
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r SnsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SNSIntegration
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r SnsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StepRun
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunUpdateCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StepRun
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunUpdateCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunUpdateCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunUpdateRerunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StepRun
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunUpdateRerunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunUpdateRerunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunGetSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunGetSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunGetSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhookListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookWorkerListResponse
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WebhookListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhookListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhookCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookWorkerCreated
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WebhookCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhookCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkerList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkerListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowRun
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		WorkflowRunIds *[]openapi_types.UUID `json:"workflowRunIds,omitempty"`
	}
	JSON400 *APIErrors
	JSON403 *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowRunList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunGetMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowRunsMetrics
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunGetMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunGetMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserGetCurrentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserGetCurrentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserGetCurrentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateGithubOauthCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateGithubOauthCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateGithubOauthCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateGithubOauthStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateGithubOauthStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateGithubOauthStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateGoogleOauthCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateGoogleOauthCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateGoogleOauthCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateGoogleOauthStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateGoogleOauthStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateGoogleOauthStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserListTenantInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantInviteList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserListTenantInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserListTenantInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteAcceptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantInviteAcceptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteAcceptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteRejectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantInviteRejectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteRejectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserUpdateLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateLogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserUpdateLogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateLogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantMembershipsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserTenantMembershipsList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r TenantMembershipsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantMembershipsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdatePasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserUpdatePasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdatePasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateSlackOauthCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateSlackOauthCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateSlackOauthCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhookDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WebhookDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhookDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Worker
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkerGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workflow
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowGetMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowMetrics
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowGetMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowGetMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowRun
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
	JSON429      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowVersionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowVersion
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowVersionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowVersionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowVersionGetDefinitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowVersionDefinition
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowVersionGetDefinitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowVersionGetDefinitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// LivenessGetWithResponse request returning *LivenessGetResponse
func (c *ClientWithResponses) LivenessGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LivenessGetResponse, error) {
	rsp, err := c.LivenessGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLivenessGetResponse(rsp)
}

// ReadinessGetWithResponse request returning *ReadinessGetResponse
func (c *ClientWithResponses) ReadinessGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReadinessGetResponse, error) {
	rsp, err := c.ReadinessGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadinessGetResponse(rsp)
}

// AlertEmailGroupDeleteWithResponse request returning *AlertEmailGroupDeleteResponse
func (c *ClientWithResponses) AlertEmailGroupDeleteWithResponse(ctx context.Context, alertEmailGroup openapi_types.UUID, reqEditors ...RequestEditorFn) (*AlertEmailGroupDeleteResponse, error) {
	rsp, err := c.AlertEmailGroupDelete(ctx, alertEmailGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertEmailGroupDeleteResponse(rsp)
}

// AlertEmailGroupUpdateWithBodyWithResponse request with arbitrary body returning *AlertEmailGroupUpdateResponse
func (c *ClientWithResponses) AlertEmailGroupUpdateWithBodyWithResponse(ctx context.Context, alertEmailGroup openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AlertEmailGroupUpdateResponse, error) {
	rsp, err := c.AlertEmailGroupUpdateWithBody(ctx, alertEmailGroup, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertEmailGroupUpdateResponse(rsp)
}

func (c *ClientWithResponses) AlertEmailGroupUpdateWithResponse(ctx context.Context, alertEmailGroup openapi_types.UUID, body AlertEmailGroupUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AlertEmailGroupUpdateResponse, error) {
	rsp, err := c.AlertEmailGroupUpdate(ctx, alertEmailGroup, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertEmailGroupUpdateResponse(rsp)
}

// ApiTokenUpdateRevokeWithResponse request returning *ApiTokenUpdateRevokeResponse
func (c *ClientWithResponses) ApiTokenUpdateRevokeWithResponse(ctx context.Context, apiToken openapi_types.UUID, reqEditors ...RequestEditorFn) (*ApiTokenUpdateRevokeResponse, error) {
	rsp, err := c.ApiTokenUpdateRevoke(ctx, apiToken, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiTokenUpdateRevokeResponse(rsp)
}

// CloudMetadataGetWithResponse request returning *CloudMetadataGetResponse
func (c *ClientWithResponses) CloudMetadataGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CloudMetadataGetResponse, error) {
	rsp, err := c.CloudMetadataGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloudMetadataGetResponse(rsp)
}

// EventDataGetWithResponse request returning *EventDataGetResponse
func (c *ClientWithResponses) EventDataGetWithResponse(ctx context.Context, event openapi_types.UUID, reqEditors ...RequestEditorFn) (*EventDataGetResponse, error) {
	rsp, err := c.EventDataGet(ctx, event, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventDataGetResponse(rsp)
}

// MetadataGetWithResponse request returning *MetadataGetResponse
func (c *ClientWithResponses) MetadataGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetadataGetResponse, error) {
	rsp, err := c.MetadataGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataGetResponse(rsp)
}

// MetadataListIntegrationsWithResponse request returning *MetadataListIntegrationsResponse
func (c *ClientWithResponses) MetadataListIntegrationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetadataListIntegrationsResponse, error) {
	rsp, err := c.MetadataListIntegrations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataListIntegrationsResponse(rsp)
}

// SlackWebhookDeleteWithResponse request returning *SlackWebhookDeleteResponse
func (c *ClientWithResponses) SlackWebhookDeleteWithResponse(ctx context.Context, slack openapi_types.UUID, reqEditors ...RequestEditorFn) (*SlackWebhookDeleteResponse, error) {
	rsp, err := c.SlackWebhookDelete(ctx, slack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlackWebhookDeleteResponse(rsp)
}

// SnsDeleteWithResponse request returning *SnsDeleteResponse
func (c *ClientWithResponses) SnsDeleteWithResponse(ctx context.Context, sns openapi_types.UUID, reqEditors ...RequestEditorFn) (*SnsDeleteResponse, error) {
	rsp, err := c.SnsDelete(ctx, sns, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnsDeleteResponse(rsp)
}

// SnsUpdateWithResponse request returning *SnsUpdateResponse
func (c *ClientWithResponses) SnsUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, event string, reqEditors ...RequestEditorFn) (*SnsUpdateResponse, error) {
	rsp, err := c.SnsUpdate(ctx, tenant, event, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnsUpdateResponse(rsp)
}

// StepRunListArchivesWithResponse request returning *StepRunListArchivesResponse
func (c *ClientWithResponses) StepRunListArchivesWithResponse(ctx context.Context, stepRun openapi_types.UUID, params *StepRunListArchivesParams, reqEditors ...RequestEditorFn) (*StepRunListArchivesResponse, error) {
	rsp, err := c.StepRunListArchives(ctx, stepRun, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunListArchivesResponse(rsp)
}

// StepRunListEventsWithResponse request returning *StepRunListEventsResponse
func (c *ClientWithResponses) StepRunListEventsWithResponse(ctx context.Context, stepRun openapi_types.UUID, params *StepRunListEventsParams, reqEditors ...RequestEditorFn) (*StepRunListEventsResponse, error) {
	rsp, err := c.StepRunListEvents(ctx, stepRun, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunListEventsResponse(rsp)
}

// LogLineListWithResponse request returning *LogLineListResponse
func (c *ClientWithResponses) LogLineListWithResponse(ctx context.Context, stepRun openapi_types.UUID, params *LogLineListParams, reqEditors ...RequestEditorFn) (*LogLineListResponse, error) {
	rsp, err := c.LogLineList(ctx, stepRun, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogLineListResponse(rsp)
}

// TenantCreateWithBodyWithResponse request with arbitrary body returning *TenantCreateResponse
func (c *ClientWithResponses) TenantCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantCreateResponse, error) {
	rsp, err := c.TenantCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantCreateResponse(rsp)
}

func (c *ClientWithResponses) TenantCreateWithResponse(ctx context.Context, body TenantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantCreateResponse, error) {
	rsp, err := c.TenantCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantCreateResponse(rsp)
}

// TenantUpdateWithBodyWithResponse request with arbitrary body returning *TenantUpdateResponse
func (c *ClientWithResponses) TenantUpdateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantUpdateResponse, error) {
	rsp, err := c.TenantUpdateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantUpdateResponse(rsp)
}

func (c *ClientWithResponses) TenantUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, body TenantUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantUpdateResponse, error) {
	rsp, err := c.TenantUpdate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantUpdateResponse(rsp)
}

// AlertEmailGroupListWithResponse request returning *AlertEmailGroupListResponse
func (c *ClientWithResponses) AlertEmailGroupListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*AlertEmailGroupListResponse, error) {
	rsp, err := c.AlertEmailGroupList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertEmailGroupListResponse(rsp)
}

// AlertEmailGroupCreateWithBodyWithResponse request with arbitrary body returning *AlertEmailGroupCreateResponse
func (c *ClientWithResponses) AlertEmailGroupCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AlertEmailGroupCreateResponse, error) {
	rsp, err := c.AlertEmailGroupCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertEmailGroupCreateResponse(rsp)
}

func (c *ClientWithResponses) AlertEmailGroupCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body AlertEmailGroupCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AlertEmailGroupCreateResponse, error) {
	rsp, err := c.AlertEmailGroupCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertEmailGroupCreateResponse(rsp)
}

// TenantAlertingSettingsGetWithResponse request returning *TenantAlertingSettingsGetResponse
func (c *ClientWithResponses) TenantAlertingSettingsGetWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantAlertingSettingsGetResponse, error) {
	rsp, err := c.TenantAlertingSettingsGet(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantAlertingSettingsGetResponse(rsp)
}

// ApiTokenListWithResponse request returning *ApiTokenListResponse
func (c *ClientWithResponses) ApiTokenListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*ApiTokenListResponse, error) {
	rsp, err := c.ApiTokenList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiTokenListResponse(rsp)
}

// ApiTokenCreateWithBodyWithResponse request with arbitrary body returning *ApiTokenCreateResponse
func (c *ClientWithResponses) ApiTokenCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApiTokenCreateResponse, error) {
	rsp, err := c.ApiTokenCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiTokenCreateResponse(rsp)
}

func (c *ClientWithResponses) ApiTokenCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body ApiTokenCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ApiTokenCreateResponse, error) {
	rsp, err := c.ApiTokenCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiTokenCreateResponse(rsp)
}

// EventListWithResponse request returning *EventListResponse
func (c *ClientWithResponses) EventListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *EventListParams, reqEditors ...RequestEditorFn) (*EventListResponse, error) {
	rsp, err := c.EventList(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventListResponse(rsp)
}

// EventCreateWithBodyWithResponse request with arbitrary body returning *EventCreateResponse
func (c *ClientWithResponses) EventCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventCreateResponse, error) {
	rsp, err := c.EventCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventCreateResponse(rsp)
}

func (c *ClientWithResponses) EventCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body EventCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EventCreateResponse, error) {
	rsp, err := c.EventCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventCreateResponse(rsp)
}

// EventKeyListWithResponse request returning *EventKeyListResponse
func (c *ClientWithResponses) EventKeyListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*EventKeyListResponse, error) {
	rsp, err := c.EventKeyList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventKeyListResponse(rsp)
}

// EventUpdateReplayWithBodyWithResponse request with arbitrary body returning *EventUpdateReplayResponse
func (c *ClientWithResponses) EventUpdateReplayWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventUpdateReplayResponse, error) {
	rsp, err := c.EventUpdateReplayWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventUpdateReplayResponse(rsp)
}

func (c *ClientWithResponses) EventUpdateReplayWithResponse(ctx context.Context, tenant openapi_types.UUID, body EventUpdateReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*EventUpdateReplayResponse, error) {
	rsp, err := c.EventUpdateReplay(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventUpdateReplayResponse(rsp)
}

// TenantInviteListWithResponse request returning *TenantInviteListResponse
func (c *ClientWithResponses) TenantInviteListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantInviteListResponse, error) {
	rsp, err := c.TenantInviteList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteListResponse(rsp)
}

// TenantInviteCreateWithBodyWithResponse request with arbitrary body returning *TenantInviteCreateResponse
func (c *ClientWithResponses) TenantInviteCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteCreateResponse, error) {
	rsp, err := c.TenantInviteCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteCreateResponse(rsp)
}

func (c *ClientWithResponses) TenantInviteCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body TenantInviteCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteCreateResponse, error) {
	rsp, err := c.TenantInviteCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteCreateResponse(rsp)
}

// TenantInviteDeleteWithResponse request returning *TenantInviteDeleteResponse
func (c *ClientWithResponses) TenantInviteDeleteWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantInviteDeleteResponse, error) {
	rsp, err := c.TenantInviteDelete(ctx, tenant, tenantInvite, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteDeleteResponse(rsp)
}

// TenantInviteUpdateWithBodyWithResponse request with arbitrary body returning *TenantInviteUpdateResponse
func (c *ClientWithResponses) TenantInviteUpdateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteUpdateResponse, error) {
	rsp, err := c.TenantInviteUpdateWithBody(ctx, tenant, tenantInvite, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteUpdateResponse(rsp)
}

func (c *ClientWithResponses) TenantInviteUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, body TenantInviteUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteUpdateResponse, error) {
	rsp, err := c.TenantInviteUpdate(ctx, tenant, tenantInvite, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteUpdateResponse(rsp)
}

// TenantMemberListWithResponse request returning *TenantMemberListResponse
func (c *ClientWithResponses) TenantMemberListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantMemberListResponse, error) {
	rsp, err := c.TenantMemberList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantMemberListResponse(rsp)
}

// TenantMemberDeleteWithResponse request returning *TenantMemberDeleteResponse
func (c *ClientWithResponses) TenantMemberDeleteWithResponse(ctx context.Context, tenant openapi_types.UUID, member openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantMemberDeleteResponse, error) {
	rsp, err := c.TenantMemberDelete(ctx, tenant, member, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantMemberDeleteResponse(rsp)
}

// TenantGetQueueMetricsWithResponse request returning *TenantGetQueueMetricsResponse
func (c *ClientWithResponses) TenantGetQueueMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, params *TenantGetQueueMetricsParams, reqEditors ...RequestEditorFn) (*TenantGetQueueMetricsResponse, error) {
	rsp, err := c.TenantGetQueueMetrics(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantGetQueueMetricsResponse(rsp)
}

// TenantResourcePolicyGetWithResponse request returning *TenantResourcePolicyGetResponse
func (c *ClientWithResponses) TenantResourcePolicyGetWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantResourcePolicyGetResponse, error) {
	rsp, err := c.TenantResourcePolicyGet(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantResourcePolicyGetResponse(rsp)
}

// SlackWebhookListWithResponse request returning *SlackWebhookListResponse
func (c *ClientWithResponses) SlackWebhookListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*SlackWebhookListResponse, error) {
	rsp, err := c.SlackWebhookList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlackWebhookListResponse(rsp)
}

// UserUpdateSlackOauthStartWithResponse request returning *UserUpdateSlackOauthStartResponse
func (c *ClientWithResponses) UserUpdateSlackOauthStartWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*UserUpdateSlackOauthStartResponse, error) {
	rsp, err := c.UserUpdateSlackOauthStart(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateSlackOauthStartResponse(rsp)
}

// SnsListWithResponse request returning *SnsListResponse
func (c *ClientWithResponses) SnsListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*SnsListResponse, error) {
	rsp, err := c.SnsList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnsListResponse(rsp)
}

// SnsCreateWithBodyWithResponse request with arbitrary body returning *SnsCreateResponse
func (c *ClientWithResponses) SnsCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnsCreateResponse, error) {
	rsp, err := c.SnsCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnsCreateResponse(rsp)
}

func (c *ClientWithResponses) SnsCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body SnsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SnsCreateResponse, error) {
	rsp, err := c.SnsCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnsCreateResponse(rsp)
}

// StepRunGetWithResponse request returning *StepRunGetResponse
func (c *ClientWithResponses) StepRunGetWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunGetResponse, error) {
	rsp, err := c.StepRunGet(ctx, tenant, stepRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunGetResponse(rsp)
}

// StepRunUpdateCancelWithResponse request returning *StepRunUpdateCancelResponse
func (c *ClientWithResponses) StepRunUpdateCancelWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunUpdateCancelResponse, error) {
	rsp, err := c.StepRunUpdateCancel(ctx, tenant, stepRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunUpdateCancelResponse(rsp)
}

// StepRunUpdateRerunWithBodyWithResponse request with arbitrary body returning *StepRunUpdateRerunResponse
func (c *ClientWithResponses) StepRunUpdateRerunWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StepRunUpdateRerunResponse, error) {
	rsp, err := c.StepRunUpdateRerunWithBody(ctx, tenant, stepRun, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunUpdateRerunResponse(rsp)
}

func (c *ClientWithResponses) StepRunUpdateRerunWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, body StepRunUpdateRerunJSONRequestBody, reqEditors ...RequestEditorFn) (*StepRunUpdateRerunResponse, error) {
	rsp, err := c.StepRunUpdateRerun(ctx, tenant, stepRun, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunUpdateRerunResponse(rsp)
}

// StepRunGetSchemaWithResponse request returning *StepRunGetSchemaResponse
func (c *ClientWithResponses) StepRunGetSchemaWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunGetSchemaResponse, error) {
	rsp, err := c.StepRunGetSchema(ctx, tenant, stepRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunGetSchemaResponse(rsp)
}

// WebhookListWithResponse request returning *WebhookListResponse
func (c *ClientWithResponses) WebhookListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*WebhookListResponse, error) {
	rsp, err := c.WebhookList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhookListResponse(rsp)
}

// WebhookCreateWithBodyWithResponse request with arbitrary body returning *WebhookCreateResponse
func (c *ClientWithResponses) WebhookCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhookCreateResponse, error) {
	rsp, err := c.WebhookCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhookCreateResponse(rsp)
}

func (c *ClientWithResponses) WebhookCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body WebhookCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhookCreateResponse, error) {
	rsp, err := c.WebhookCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhookCreateResponse(rsp)
}

// WorkerListWithResponse request returning *WorkerListResponse
func (c *ClientWithResponses) WorkerListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkerListResponse, error) {
	rsp, err := c.WorkerList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerListResponse(rsp)
}

// WorkflowRunGetWithResponse request returning *WorkflowRunGetResponse
func (c *ClientWithResponses) WorkflowRunGetWithResponse(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowRunGetResponse, error) {
	rsp, err := c.WorkflowRunGet(ctx, tenant, workflowRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunGetResponse(rsp)
}

// WorkflowListWithResponse request returning *WorkflowListResponse
func (c *ClientWithResponses) WorkflowListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowListResponse, error) {
	rsp, err := c.WorkflowList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowListResponse(rsp)
}

// WorkflowRunCancelWithBodyWithResponse request with arbitrary body returning *WorkflowRunCancelResponse
func (c *ClientWithResponses) WorkflowRunCancelWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkflowRunCancelResponse, error) {
	rsp, err := c.WorkflowRunCancelWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunCancelResponse(rsp)
}

func (c *ClientWithResponses) WorkflowRunCancelWithResponse(ctx context.Context, tenant openapi_types.UUID, body WorkflowRunCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkflowRunCancelResponse, error) {
	rsp, err := c.WorkflowRunCancel(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunCancelResponse(rsp)
}

// WorkflowRunListWithResponse request returning *WorkflowRunListResponse
func (c *ClientWithResponses) WorkflowRunListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunListParams, reqEditors ...RequestEditorFn) (*WorkflowRunListResponse, error) {
	rsp, err := c.WorkflowRunList(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunListResponse(rsp)
}

// WorkflowRunGetMetricsWithResponse request returning *WorkflowRunGetMetricsResponse
func (c *ClientWithResponses) WorkflowRunGetMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunGetMetricsParams, reqEditors ...RequestEditorFn) (*WorkflowRunGetMetricsResponse, error) {
	rsp, err := c.WorkflowRunGetMetrics(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunGetMetricsResponse(rsp)
}

// UserGetCurrentWithResponse request returning *UserGetCurrentResponse
func (c *ClientWithResponses) UserGetCurrentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserGetCurrentResponse, error) {
	rsp, err := c.UserGetCurrent(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserGetCurrentResponse(rsp)
}

// UserUpdateGithubOauthCallbackWithResponse request returning *UserUpdateGithubOauthCallbackResponse
func (c *ClientWithResponses) UserUpdateGithubOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGithubOauthCallbackResponse, error) {
	rsp, err := c.UserUpdateGithubOauthCallback(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateGithubOauthCallbackResponse(rsp)
}

// UserUpdateGithubOauthStartWithResponse request returning *UserUpdateGithubOauthStartResponse
func (c *ClientWithResponses) UserUpdateGithubOauthStartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGithubOauthStartResponse, error) {
	rsp, err := c.UserUpdateGithubOauthStart(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateGithubOauthStartResponse(rsp)
}

// UserUpdateGoogleOauthCallbackWithResponse request returning *UserUpdateGoogleOauthCallbackResponse
func (c *ClientWithResponses) UserUpdateGoogleOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGoogleOauthCallbackResponse, error) {
	rsp, err := c.UserUpdateGoogleOauthCallback(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateGoogleOauthCallbackResponse(rsp)
}

// UserUpdateGoogleOauthStartWithResponse request returning *UserUpdateGoogleOauthStartResponse
func (c *ClientWithResponses) UserUpdateGoogleOauthStartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGoogleOauthStartResponse, error) {
	rsp, err := c.UserUpdateGoogleOauthStart(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateGoogleOauthStartResponse(rsp)
}

// UserListTenantInvitesWithResponse request returning *UserListTenantInvitesResponse
func (c *ClientWithResponses) UserListTenantInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserListTenantInvitesResponse, error) {
	rsp, err := c.UserListTenantInvites(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserListTenantInvitesResponse(rsp)
}

// TenantInviteAcceptWithBodyWithResponse request with arbitrary body returning *TenantInviteAcceptResponse
func (c *ClientWithResponses) TenantInviteAcceptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteAcceptResponse, error) {
	rsp, err := c.TenantInviteAcceptWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteAcceptResponse(rsp)
}

func (c *ClientWithResponses) TenantInviteAcceptWithResponse(ctx context.Context, body TenantInviteAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteAcceptResponse, error) {
	rsp, err := c.TenantInviteAccept(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteAcceptResponse(rsp)
}

// TenantInviteRejectWithBodyWithResponse request with arbitrary body returning *TenantInviteRejectResponse
func (c *ClientWithResponses) TenantInviteRejectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteRejectResponse, error) {
	rsp, err := c.TenantInviteRejectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteRejectResponse(rsp)
}

func (c *ClientWithResponses) TenantInviteRejectWithResponse(ctx context.Context, body TenantInviteRejectJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteRejectResponse, error) {
	rsp, err := c.TenantInviteReject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteRejectResponse(rsp)
}

// UserUpdateLoginWithBodyWithResponse request with arbitrary body returning *UserUpdateLoginResponse
func (c *ClientWithResponses) UserUpdateLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdateLoginResponse, error) {
	rsp, err := c.UserUpdateLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateLoginResponse(rsp)
}

func (c *ClientWithResponses) UserUpdateLoginWithResponse(ctx context.Context, body UserUpdateLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdateLoginResponse, error) {
	rsp, err := c.UserUpdateLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateLoginResponse(rsp)
}

// UserUpdateLogoutWithResponse request returning *UserUpdateLogoutResponse
func (c *ClientWithResponses) UserUpdateLogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateLogoutResponse, error) {
	rsp, err := c.UserUpdateLogout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateLogoutResponse(rsp)
}

// TenantMembershipsListWithResponse request returning *TenantMembershipsListResponse
func (c *ClientWithResponses) TenantMembershipsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TenantMembershipsListResponse, error) {
	rsp, err := c.TenantMembershipsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantMembershipsListResponse(rsp)
}

// UserUpdatePasswordWithBodyWithResponse request with arbitrary body returning *UserUpdatePasswordResponse
func (c *ClientWithResponses) UserUpdatePasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdatePasswordResponse, error) {
	rsp, err := c.UserUpdatePasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdatePasswordResponse(rsp)
}

func (c *ClientWithResponses) UserUpdatePasswordWithResponse(ctx context.Context, body UserUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdatePasswordResponse, error) {
	rsp, err := c.UserUpdatePassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdatePasswordResponse(rsp)
}

// UserCreateWithBodyWithResponse request with arbitrary body returning *UserCreateResponse
func (c *ClientWithResponses) UserCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserCreateResponse, error) {
	rsp, err := c.UserCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserCreateResponse(rsp)
}

func (c *ClientWithResponses) UserCreateWithResponse(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserCreateResponse, error) {
	rsp, err := c.UserCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserCreateResponse(rsp)
}

// UserUpdateSlackOauthCallbackWithResponse request returning *UserUpdateSlackOauthCallbackResponse
func (c *ClientWithResponses) UserUpdateSlackOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateSlackOauthCallbackResponse, error) {
	rsp, err := c.UserUpdateSlackOauthCallback(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateSlackOauthCallbackResponse(rsp)
}

// WebhookDeleteWithResponse request returning *WebhookDeleteResponse
func (c *ClientWithResponses) WebhookDeleteWithResponse(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*WebhookDeleteResponse, error) {
	rsp, err := c.WebhookDelete(ctx, webhook, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhookDeleteResponse(rsp)
}

// WorkerGetWithResponse request returning *WorkerGetResponse
func (c *ClientWithResponses) WorkerGetWithResponse(ctx context.Context, worker openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkerGetResponse, error) {
	rsp, err := c.WorkerGet(ctx, worker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerGetResponse(rsp)
}

// WorkflowDeleteWithResponse request returning *WorkflowDeleteResponse
func (c *ClientWithResponses) WorkflowDeleteWithResponse(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowDeleteResponse, error) {
	rsp, err := c.WorkflowDelete(ctx, workflow, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowDeleteResponse(rsp)
}

// WorkflowGetWithResponse request returning *WorkflowGetResponse
func (c *ClientWithResponses) WorkflowGetWithResponse(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowGetResponse, error) {
	rsp, err := c.WorkflowGet(ctx, workflow, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowGetResponse(rsp)
}

// WorkflowGetMetricsWithResponse request returning *WorkflowGetMetricsResponse
func (c *ClientWithResponses) WorkflowGetMetricsWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowGetMetricsParams, reqEditors ...RequestEditorFn) (*WorkflowGetMetricsResponse, error) {
	rsp, err := c.WorkflowGetMetrics(ctx, workflow, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowGetMetricsResponse(rsp)
}

// WorkflowRunCreateWithBodyWithResponse request with arbitrary body returning *WorkflowRunCreateResponse
func (c *ClientWithResponses) WorkflowRunCreateWithBodyWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkflowRunCreateResponse, error) {
	rsp, err := c.WorkflowRunCreateWithBody(ctx, workflow, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunCreateResponse(rsp)
}

func (c *ClientWithResponses) WorkflowRunCreateWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, body WorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkflowRunCreateResponse, error) {
	rsp, err := c.WorkflowRunCreate(ctx, workflow, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunCreateResponse(rsp)
}

// WorkflowVersionGetWithResponse request returning *WorkflowVersionGetResponse
func (c *ClientWithResponses) WorkflowVersionGetWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetParams, reqEditors ...RequestEditorFn) (*WorkflowVersionGetResponse, error) {
	rsp, err := c.WorkflowVersionGet(ctx, workflow, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowVersionGetResponse(rsp)
}

// WorkflowVersionGetDefinitionWithResponse request returning *WorkflowVersionGetDefinitionResponse
func (c *ClientWithResponses) WorkflowVersionGetDefinitionWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetDefinitionParams, reqEditors ...RequestEditorFn) (*WorkflowVersionGetDefinitionResponse, error) {
	rsp, err := c.WorkflowVersionGetDefinition(ctx, workflow, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowVersionGetDefinitionResponse(rsp)
}

// ParseLivenessGetResponse parses an HTTP response from a LivenessGetWithResponse call
func ParseLivenessGetResponse(rsp *http.Response) (*LivenessGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LivenessGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadinessGetResponse parses an HTTP response from a ReadinessGetWithResponse call
func ParseReadinessGetResponse(rsp *http.Response) (*ReadinessGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadinessGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAlertEmailGroupDeleteResponse parses an HTTP response from a AlertEmailGroupDeleteWithResponse call
func ParseAlertEmailGroupDeleteResponse(rsp *http.Response) (*AlertEmailGroupDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertEmailGroupDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAlertEmailGroupUpdateResponse parses an HTTP response from a AlertEmailGroupUpdateWithResponse call
func ParseAlertEmailGroupUpdateResponse(rsp *http.Response) (*AlertEmailGroupUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertEmailGroupUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantAlertEmailGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseApiTokenUpdateRevokeResponse parses an HTTP response from a ApiTokenUpdateRevokeWithResponse call
func ParseApiTokenUpdateRevokeResponse(rsp *http.Response) (*ApiTokenUpdateRevokeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiTokenUpdateRevokeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCloudMetadataGetResponse parses an HTTP response from a CloudMetadataGetWithResponse call
func ParseCloudMetadataGetResponse(rsp *http.Response) (*CloudMetadataGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CloudMetadataGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseEventDataGetResponse parses an HTTP response from a EventDataGetWithResponse call
func ParseEventDataGetResponse(rsp *http.Response) (*EventDataGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventDataGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseMetadataGetResponse parses an HTTP response from a MetadataGetWithResponse call
func ParseMetadataGetResponse(rsp *http.Response) (*MetadataGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetadataGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest APIMeta
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMetadataListIntegrationsResponse parses an HTTP response from a MetadataListIntegrationsWithResponse call
func ParseMetadataListIntegrationsResponse(rsp *http.Response) (*MetadataListIntegrationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetadataListIntegrationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAPIMetaIntegration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSlackWebhookDeleteResponse parses an HTTP response from a SlackWebhookDeleteWithResponse call
func ParseSlackWebhookDeleteResponse(rsp *http.Response) (*SlackWebhookDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlackWebhookDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseSnsDeleteResponse parses an HTTP response from a SnsDeleteWithResponse call
func ParseSnsDeleteResponse(rsp *http.Response) (*SnsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseSnsUpdateResponse parses an HTTP response from a SnsUpdateWithResponse call
func ParseSnsUpdateResponse(rsp *http.Response) (*SnsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseStepRunListArchivesResponse parses an HTTP response from a StepRunListArchivesWithResponse call
func ParseStepRunListArchivesResponse(rsp *http.Response) (*StepRunListArchivesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunListArchivesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StepRunArchiveList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStepRunListEventsResponse parses an HTTP response from a StepRunListEventsWithResponse call
func ParseStepRunListEventsResponse(rsp *http.Response) (*StepRunListEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunListEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StepRunEventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseLogLineListResponse parses an HTTP response from a LogLineListWithResponse call
func ParseLogLineListResponse(rsp *http.Response) (*LogLineListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogLineListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogLineList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantCreateResponse parses an HTTP response from a TenantCreateWithResponse call
func ParseTenantCreateResponse(rsp *http.Response) (*TenantCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tenant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantUpdateResponse parses an HTTP response from a TenantUpdateWithResponse call
func ParseTenantUpdateResponse(rsp *http.Response) (*TenantUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tenant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAlertEmailGroupListResponse parses an HTTP response from a AlertEmailGroupListWithResponse call
func ParseAlertEmailGroupListResponse(rsp *http.Response) (*AlertEmailGroupListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertEmailGroupListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantAlertEmailGroupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAlertEmailGroupCreateResponse parses an HTTP response from a AlertEmailGroupCreateWithResponse call
func ParseAlertEmailGroupCreateResponse(rsp *http.Response) (*AlertEmailGroupCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertEmailGroupCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TenantAlertEmailGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantAlertingSettingsGetResponse parses an HTTP response from a TenantAlertingSettingsGetWithResponse call
func ParseTenantAlertingSettingsGetResponse(rsp *http.Response) (*TenantAlertingSettingsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantAlertingSettingsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantAlertingSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseApiTokenListResponse parses an HTTP response from a ApiTokenListWithResponse call
func ParseApiTokenListResponse(rsp *http.Response) (*ApiTokenListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiTokenListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAPITokensResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseApiTokenCreateResponse parses an HTTP response from a ApiTokenCreateWithResponse call
func ParseApiTokenCreateResponse(rsp *http.Response) (*ApiTokenCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiTokenCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateAPITokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseEventListResponse parses an HTTP response from a EventListWithResponse call
func ParseEventListResponse(rsp *http.Response) (*EventListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseEventCreateResponse parses an HTTP response from a EventCreateWithResponse call
func ParseEventCreateResponse(rsp *http.Response) (*EventCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseEventKeyListResponse parses an HTTP response from a EventKeyListWithResponse call
func ParseEventKeyListResponse(rsp *http.Response) (*EventKeyListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventKeyListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventKeyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseEventUpdateReplayResponse parses an HTTP response from a EventUpdateReplayWithResponse call
func ParseEventUpdateReplayResponse(rsp *http.Response) (*EventUpdateReplayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventUpdateReplayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseTenantInviteListResponse parses an HTTP response from a TenantInviteListWithResponse call
func ParseTenantInviteListResponse(rsp *http.Response) (*TenantInviteListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantInviteList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantInviteCreateResponse parses an HTTP response from a TenantInviteCreateWithResponse call
func ParseTenantInviteCreateResponse(rsp *http.Response) (*TenantInviteCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TenantInvite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantInviteDeleteResponse parses an HTTP response from a TenantInviteDeleteWithResponse call
func ParseTenantInviteDeleteResponse(rsp *http.Response) (*TenantInviteDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantInvite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseTenantInviteUpdateResponse parses an HTTP response from a TenantInviteUpdateWithResponse call
func ParseTenantInviteUpdateResponse(rsp *http.Response) (*TenantInviteUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantInvite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseTenantMemberListResponse parses an HTTP response from a TenantMemberListWithResponse call
func ParseTenantMemberListResponse(rsp *http.Response) (*TenantMemberListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantMemberListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantMemberList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantMemberDeleteResponse parses an HTTP response from a TenantMemberDeleteWithResponse call
func ParseTenantMemberDeleteResponse(rsp *http.Response) (*TenantMemberDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantMemberDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest TenantMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTenantGetQueueMetricsResponse parses an HTTP response from a TenantGetQueueMetricsWithResponse call
func ParseTenantGetQueueMetricsResponse(rsp *http.Response) (*TenantGetQueueMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantGetQueueMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantQueueMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTenantResourcePolicyGetResponse parses an HTTP response from a TenantResourcePolicyGetWithResponse call
func ParseTenantResourcePolicyGetResponse(rsp *http.Response) (*TenantResourcePolicyGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantResourcePolicyGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantResourcePolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSlackWebhookListResponse parses an HTTP response from a SlackWebhookListWithResponse call
func ParseSlackWebhookListResponse(rsp *http.Response) (*SlackWebhookListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlackWebhookListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSlackWebhooks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseUserUpdateSlackOauthStartResponse parses an HTTP response from a UserUpdateSlackOauthStartWithResponse call
func ParseUserUpdateSlackOauthStartResponse(rsp *http.Response) (*UserUpdateSlackOauthStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateSlackOauthStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSnsListResponse parses an HTTP response from a SnsListWithResponse call
func ParseSnsListResponse(rsp *http.Response) (*SnsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSNSIntegrations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseSnsCreateResponse parses an HTTP response from a SnsCreateWithResponse call
func ParseSnsCreateResponse(rsp *http.Response) (*SnsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SNSIntegration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseStepRunGetResponse parses an HTTP response from a StepRunGetWithResponse call
func ParseStepRunGetResponse(rsp *http.Response) (*StepRunGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StepRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStepRunUpdateCancelResponse parses an HTTP response from a StepRunUpdateCancelWithResponse call
func ParseStepRunUpdateCancelResponse(rsp *http.Response) (*StepRunUpdateCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunUpdateCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StepRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseStepRunUpdateRerunResponse parses an HTTP response from a StepRunUpdateRerunWithResponse call
func ParseStepRunUpdateRerunResponse(rsp *http.Response) (*StepRunUpdateRerunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunUpdateRerunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StepRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseStepRunGetSchemaResponse parses an HTTP response from a StepRunGetSchemaWithResponse call
func ParseStepRunGetSchemaResponse(rsp *http.Response) (*StepRunGetSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunGetSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWebhookListResponse parses an HTTP response from a WebhookListWithResponse call
func ParseWebhookListResponse(rsp *http.Response) (*WebhookListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhookListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookWorkerListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseWebhookCreateResponse parses an HTTP response from a WebhookCreateWithResponse call
func ParseWebhookCreateResponse(rsp *http.Response) (*WebhookCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhookCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookWorkerCreated
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseWorkerListResponse parses an HTTP response from a WorkerListWithResponse call
func ParseWorkerListResponse(rsp *http.Response) (*WorkerListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkerList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowRunGetResponse parses an HTTP response from a WorkflowRunGetWithResponse call
func ParseWorkflowRunGetResponse(rsp *http.Response) (*WorkflowRunGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowListResponse parses an HTTP response from a WorkflowListWithResponse call
func ParseWorkflowListResponse(rsp *http.Response) (*WorkflowListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowRunCancelResponse parses an HTTP response from a WorkflowRunCancelWithResponse call
func ParseWorkflowRunCancelResponse(rsp *http.Response) (*WorkflowRunCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			WorkflowRunIds *[]openapi_types.UUID `json:"workflowRunIds,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowRunListResponse parses an HTTP response from a WorkflowRunListWithResponse call
func ParseWorkflowRunListResponse(rsp *http.Response) (*WorkflowRunListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowRunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowRunGetMetricsResponse parses an HTTP response from a WorkflowRunGetMetricsWithResponse call
func ParseWorkflowRunGetMetricsResponse(rsp *http.Response) (*WorkflowRunGetMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunGetMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowRunsMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUserGetCurrentResponse parses an HTTP response from a UserGetCurrentWithResponse call
func ParseUserGetCurrentResponse(rsp *http.Response) (*UserGetCurrentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserGetCurrentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseUserUpdateGithubOauthCallbackResponse parses an HTTP response from a UserUpdateGithubOauthCallbackWithResponse call
func ParseUserUpdateGithubOauthCallbackResponse(rsp *http.Response) (*UserUpdateGithubOauthCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateGithubOauthCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserUpdateGithubOauthStartResponse parses an HTTP response from a UserUpdateGithubOauthStartWithResponse call
func ParseUserUpdateGithubOauthStartResponse(rsp *http.Response) (*UserUpdateGithubOauthStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateGithubOauthStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserUpdateGoogleOauthCallbackResponse parses an HTTP response from a UserUpdateGoogleOauthCallbackWithResponse call
func ParseUserUpdateGoogleOauthCallbackResponse(rsp *http.Response) (*UserUpdateGoogleOauthCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateGoogleOauthCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserUpdateGoogleOauthStartResponse parses an HTTP response from a UserUpdateGoogleOauthStartWithResponse call
func ParseUserUpdateGoogleOauthStartResponse(rsp *http.Response) (*UserUpdateGoogleOauthStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateGoogleOauthStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserListTenantInvitesResponse parses an HTTP response from a UserListTenantInvitesWithResponse call
func ParseUserListTenantInvitesResponse(rsp *http.Response) (*UserListTenantInvitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserListTenantInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantInviteList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantInviteAcceptResponse parses an HTTP response from a TenantInviteAcceptWithResponse call
func ParseTenantInviteAcceptResponse(rsp *http.Response) (*TenantInviteAcceptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteAcceptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantInviteRejectResponse parses an HTTP response from a TenantInviteRejectWithResponse call
func ParseTenantInviteRejectResponse(rsp *http.Response) (*TenantInviteRejectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteRejectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUserUpdateLoginResponse parses an HTTP response from a UserUpdateLoginWithResponse call
func ParseUserUpdateLoginResponse(rsp *http.Response) (*UserUpdateLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseUserUpdateLogoutResponse parses an HTTP response from a UserUpdateLogoutWithResponse call
func ParseUserUpdateLogoutResponse(rsp *http.Response) (*UserUpdateLogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateLogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseTenantMembershipsListResponse parses an HTTP response from a TenantMembershipsListWithResponse call
func ParseTenantMembershipsListResponse(rsp *http.Response) (*TenantMembershipsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantMembershipsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserTenantMembershipsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUserUpdatePasswordResponse parses an HTTP response from a UserUpdatePasswordWithResponse call
func ParseUserUpdatePasswordResponse(rsp *http.Response) (*UserUpdatePasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdatePasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseUserCreateResponse parses an HTTP response from a UserCreateWithResponse call
func ParseUserCreateResponse(rsp *http.Response) (*UserCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseUserUpdateSlackOauthCallbackResponse parses an HTTP response from a UserUpdateSlackOauthCallbackWithResponse call
func ParseUserUpdateSlackOauthCallbackResponse(rsp *http.Response) (*UserUpdateSlackOauthCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateSlackOauthCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWebhookDeleteResponse parses an HTTP response from a WebhookDeleteWithResponse call
func ParseWebhookDeleteResponse(rsp *http.Response) (*WebhookDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhookDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseWorkerGetResponse parses an HTTP response from a WorkerGetWithResponse call
func ParseWorkerGetResponse(rsp *http.Response) (*WorkerGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Worker
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowDeleteResponse parses an HTTP response from a WorkflowDeleteWithResponse call
func ParseWorkflowDeleteResponse(rsp *http.Response) (*WorkflowDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWorkflowGetResponse parses an HTTP response from a WorkflowGetWithResponse call
func ParseWorkflowGetResponse(rsp *http.Response) (*WorkflowGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workflow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowGetMetricsResponse parses an HTTP response from a WorkflowGetMetricsWithResponse call
func ParseWorkflowGetMetricsResponse(rsp *http.Response) (*WorkflowGetMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowGetMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWorkflowRunCreateResponse parses an HTTP response from a WorkflowRunCreateWithResponse call
func ParseWorkflowRunCreateResponse(rsp *http.Response) (*WorkflowRunCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseWorkflowVersionGetResponse parses an HTTP response from a WorkflowVersionGetWithResponse call
func ParseWorkflowVersionGetResponse(rsp *http.Response) (*WorkflowVersionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowVersionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWorkflowVersionGetDefinitionResponse parses an HTTP response from a WorkflowVersionGetDefinitionWithResponse call
func ParseWorkflowVersionGetDefinitionResponse(rsp *http.Response) (*WorkflowVersionGetDefinitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowVersionGetDefinitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowVersionDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
