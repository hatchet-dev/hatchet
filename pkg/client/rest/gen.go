// Package rest provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package rest

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/hatchet-dev/hatchet/api/v1/server/oas/openapi"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	CookieAuthScopes = "cookieAuth.Scopes"
)

// Defines values for ConcurrencyLimitStrategy.
const (
	CANCELINPROGRESS ConcurrencyLimitStrategy = "CANCEL_IN_PROGRESS"
	DROPNEWEST       ConcurrencyLimitStrategy = "DROP_NEWEST"
	GROUPROUNDROBIN  ConcurrencyLimitStrategy = "GROUP_ROUND_ROBIN"
	QUEUENEWEST      ConcurrencyLimitStrategy = "QUEUE_NEWEST"
)

// Defines values for CronWorkflowsMethod.
const (
	CronWorkflowsMethodAPI     CronWorkflowsMethod = "API"
	CronWorkflowsMethodDEFAULT CronWorkflowsMethod = "DEFAULT"
)

// Defines values for CronWorkflowsOrderByField.
const (
	CronWorkflowsOrderByFieldCreatedAt CronWorkflowsOrderByField = "createdAt"
	CronWorkflowsOrderByFieldName      CronWorkflowsOrderByField = "name"
)

// Defines values for EventOrderByDirection.
const (
	EventOrderByDirectionAsc  EventOrderByDirection = "asc"
	EventOrderByDirectionDesc EventOrderByDirection = "desc"
)

// Defines values for EventOrderByField.
const (
	EventOrderByFieldCreatedAt EventOrderByField = "createdAt"
)

// Defines values for JobRunStatus.
const (
	JobRunStatusBACKOFF   JobRunStatus = "BACKOFF"
	JobRunStatusCANCELLED JobRunStatus = "CANCELLED"
	JobRunStatusFAILED    JobRunStatus = "FAILED"
	JobRunStatusPENDING   JobRunStatus = "PENDING"
	JobRunStatusRUNNING   JobRunStatus = "RUNNING"
	JobRunStatusSUCCEEDED JobRunStatus = "SUCCEEDED"
)

// Defines values for LogLineLevel.
const (
	LogLineLevelDEBUG LogLineLevel = "DEBUG"
	LogLineLevelERROR LogLineLevel = "ERROR"
	LogLineLevelINFO  LogLineLevel = "INFO"
	LogLineLevelWARN  LogLineLevel = "WARN"
)

// Defines values for LogLineOrderByDirection.
const (
	LogLineOrderByDirectionAsc  LogLineOrderByDirection = "asc"
	LogLineOrderByDirectionDesc LogLineOrderByDirection = "desc"
)

// Defines values for LogLineOrderByField.
const (
	LogLineOrderByFieldCreatedAt LogLineOrderByField = "createdAt"
)

// Defines values for RateLimitOrderByDirection.
const (
	Asc  RateLimitOrderByDirection = "asc"
	Desc RateLimitOrderByDirection = "desc"
)

// Defines values for RateLimitOrderByField.
const (
	Key        RateLimitOrderByField = "key"
	LimitValue RateLimitOrderByField = "limitValue"
	Value      RateLimitOrderByField = "value"
)

// Defines values for ScheduledRunStatus.
const (
	ScheduledRunStatusCANCELLED ScheduledRunStatus = "CANCELLED"
	ScheduledRunStatusFAILED    ScheduledRunStatus = "FAILED"
	ScheduledRunStatusPENDING   ScheduledRunStatus = "PENDING"
	ScheduledRunStatusQUEUED    ScheduledRunStatus = "QUEUED"
	ScheduledRunStatusRUNNING   ScheduledRunStatus = "RUNNING"
	ScheduledRunStatusSCHEDULED ScheduledRunStatus = "SCHEDULED"
	ScheduledRunStatusSUCCEEDED ScheduledRunStatus = "SUCCEEDED"
)

// Defines values for ScheduledWorkflowsMethod.
const (
	ScheduledWorkflowsMethodAPI     ScheduledWorkflowsMethod = "API"
	ScheduledWorkflowsMethodDEFAULT ScheduledWorkflowsMethod = "DEFAULT"
)

// Defines values for ScheduledWorkflowsOrderByField.
const (
	ScheduledWorkflowsOrderByFieldCreatedAt ScheduledWorkflowsOrderByField = "createdAt"
	ScheduledWorkflowsOrderByFieldTriggerAt ScheduledWorkflowsOrderByField = "triggerAt"
)

// Defines values for StepRunEventReason.
const (
	StepRunEventReasonACKNOWLEDGED                 StepRunEventReason = "ACKNOWLEDGED"
	StepRunEventReasonASSIGNED                     StepRunEventReason = "ASSIGNED"
	StepRunEventReasonCANCELLED                    StepRunEventReason = "CANCELLED"
	StepRunEventReasonFAILED                       StepRunEventReason = "FAILED"
	StepRunEventReasonFINISHED                     StepRunEventReason = "FINISHED"
	StepRunEventReasonREASSIGNED                   StepRunEventReason = "REASSIGNED"
	StepRunEventReasonREQUEUEDNOWORKER             StepRunEventReason = "REQUEUED_NO_WORKER"
	StepRunEventReasonREQUEUEDRATELIMIT            StepRunEventReason = "REQUEUED_RATE_LIMIT"
	StepRunEventReasonRETRIEDBYUSER                StepRunEventReason = "RETRIED_BY_USER"
	StepRunEventReasonRETRYING                     StepRunEventReason = "RETRYING"
	StepRunEventReasonSCHEDULINGTIMEDOUT           StepRunEventReason = "SCHEDULING_TIMED_OUT"
	StepRunEventReasonSLOTRELEASED                 StepRunEventReason = "SLOT_RELEASED"
	StepRunEventReasonSTARTED                      StepRunEventReason = "STARTED"
	StepRunEventReasonTIMEDOUT                     StepRunEventReason = "TIMED_OUT"
	StepRunEventReasonTIMEOUTREFRESHED             StepRunEventReason = "TIMEOUT_REFRESHED"
	StepRunEventReasonWORKFLOWRUNGROUPKEYFAILED    StepRunEventReason = "WORKFLOW_RUN_GROUP_KEY_FAILED"
	StepRunEventReasonWORKFLOWRUNGROUPKEYSUCCEEDED StepRunEventReason = "WORKFLOW_RUN_GROUP_KEY_SUCCEEDED"
)

// Defines values for StepRunEventSeverity.
const (
	StepRunEventSeverityCRITICAL StepRunEventSeverity = "CRITICAL"
	StepRunEventSeverityINFO     StepRunEventSeverity = "INFO"
	StepRunEventSeverityWARNING  StepRunEventSeverity = "WARNING"
)

// Defines values for StepRunStatus.
const (
	StepRunStatusASSIGNED          StepRunStatus = "ASSIGNED"
	StepRunStatusBACKOFF           StepRunStatus = "BACKOFF"
	StepRunStatusCANCELLED         StepRunStatus = "CANCELLED"
	StepRunStatusCANCELLING        StepRunStatus = "CANCELLING"
	StepRunStatusFAILED            StepRunStatus = "FAILED"
	StepRunStatusPENDING           StepRunStatus = "PENDING"
	StepRunStatusPENDINGASSIGNMENT StepRunStatus = "PENDING_ASSIGNMENT"
	StepRunStatusRUNNING           StepRunStatus = "RUNNING"
	StepRunStatusSUCCEEDED         StepRunStatus = "SUCCEEDED"
)

// Defines values for TenantMemberRole.
const (
	ADMIN  TenantMemberRole = "ADMIN"
	MEMBER TenantMemberRole = "MEMBER"
	OWNER  TenantMemberRole = "OWNER"
)

// Defines values for TenantResource.
const (
	CRON        TenantResource = "CRON"
	EVENT       TenantResource = "EVENT"
	SCHEDULE    TenantResource = "SCHEDULE"
	TASKRUN     TenantResource = "TASK_RUN"
	WORKER      TenantResource = "WORKER"
	WORKERSLOT  TenantResource = "WORKER_SLOT"
	WORKFLOWRUN TenantResource = "WORKFLOW_RUN"
)

// Defines values for TenantUIVersion.
const (
	TenantUIVersionV0 TenantUIVersion = "V0"
	TenantUIVersionV1 TenantUIVersion = "V1"
)

// Defines values for TenantVersion.
const (
	TenantVersionV0 TenantVersion = "V0"
	TenantVersionV1 TenantVersion = "V1"
)

// Defines values for V1LogLineLevel.
const (
	DEBUG V1LogLineLevel = "DEBUG"
	ERROR V1LogLineLevel = "ERROR"
	INFO  V1LogLineLevel = "INFO"
	WARN  V1LogLineLevel = "WARN"
)

// Defines values for V1TaskEventType.
const (
	V1TaskEventTypeACKNOWLEDGED       V1TaskEventType = "ACKNOWLEDGED"
	V1TaskEventTypeASSIGNED           V1TaskEventType = "ASSIGNED"
	V1TaskEventTypeCANCELLED          V1TaskEventType = "CANCELLED"
	V1TaskEventTypeCREATED            V1TaskEventType = "CREATED"
	V1TaskEventTypeFAILED             V1TaskEventType = "FAILED"
	V1TaskEventTypeFINISHED           V1TaskEventType = "FINISHED"
	V1TaskEventTypeQUEUED             V1TaskEventType = "QUEUED"
	V1TaskEventTypeRATELIMITERROR     V1TaskEventType = "RATE_LIMIT_ERROR"
	V1TaskEventTypeREASSIGNED         V1TaskEventType = "REASSIGNED"
	V1TaskEventTypeREQUEUEDNOWORKER   V1TaskEventType = "REQUEUED_NO_WORKER"
	V1TaskEventTypeREQUEUEDRATELIMIT  V1TaskEventType = "REQUEUED_RATE_LIMIT"
	V1TaskEventTypeRETRIEDBYUSER      V1TaskEventType = "RETRIED_BY_USER"
	V1TaskEventTypeRETRYING           V1TaskEventType = "RETRYING"
	V1TaskEventTypeSCHEDULINGTIMEDOUT V1TaskEventType = "SCHEDULING_TIMED_OUT"
	V1TaskEventTypeSENTTOWORKER       V1TaskEventType = "SENT_TO_WORKER"
	V1TaskEventTypeSKIPPED            V1TaskEventType = "SKIPPED"
	V1TaskEventTypeSLOTRELEASED       V1TaskEventType = "SLOT_RELEASED"
	V1TaskEventTypeSTARTED            V1TaskEventType = "STARTED"
	V1TaskEventTypeTIMEDOUT           V1TaskEventType = "TIMED_OUT"
	V1TaskEventTypeTIMEOUTREFRESHED   V1TaskEventType = "TIMEOUT_REFRESHED"
)

// Defines values for V1TaskStatus.
const (
	V1TaskStatusCANCELLED V1TaskStatus = "CANCELLED"
	V1TaskStatusCOMPLETED V1TaskStatus = "COMPLETED"
	V1TaskStatusFAILED    V1TaskStatus = "FAILED"
	V1TaskStatusQUEUED    V1TaskStatus = "QUEUED"
	V1TaskStatusRUNNING   V1TaskStatus = "RUNNING"
)

// Defines values for V1WorkflowType.
const (
	V1WorkflowTypeDAG  V1WorkflowType = "DAG"
	V1WorkflowTypeTASK V1WorkflowType = "TASK"
)

// Defines values for WorkerStatus.
const (
	ACTIVE   WorkerStatus = "ACTIVE"
	INACTIVE WorkerStatus = "INACTIVE"
	PAUSED   WorkerStatus = "PAUSED"
)

// Defines values for WorkerRuntimeSDKs.
const (
	GOLANG     WorkerRuntimeSDKs = "GOLANG"
	PYTHON     WorkerRuntimeSDKs = "PYTHON"
	TYPESCRIPT WorkerRuntimeSDKs = "TYPESCRIPT"
)

// Defines values for WorkerType.
const (
	MANAGED    WorkerType = "MANAGED"
	SELFHOSTED WorkerType = "SELFHOSTED"
	WEBHOOK    WorkerType = "WEBHOOK"
)

// Defines values for WorkflowKind.
const (
	WorkflowKindDAG      WorkflowKind = "DAG"
	WorkflowKindDURABLE  WorkflowKind = "DURABLE"
	WorkflowKindFUNCTION WorkflowKind = "FUNCTION"
)

// Defines values for WorkflowRunOrderByDirection.
const (
	ASC  WorkflowRunOrderByDirection = "ASC"
	DESC WorkflowRunOrderByDirection = "DESC"
)

// Defines values for WorkflowRunOrderByField.
const (
	CreatedAt  WorkflowRunOrderByField = "createdAt"
	Duration   WorkflowRunOrderByField = "duration"
	FinishedAt WorkflowRunOrderByField = "finishedAt"
	StartedAt  WorkflowRunOrderByField = "startedAt"
)

// Defines values for WorkflowRunStatus.
const (
	BACKOFF   WorkflowRunStatus = "BACKOFF"
	CANCELLED WorkflowRunStatus = "CANCELLED"
	FAILED    WorkflowRunStatus = "FAILED"
	PENDING   WorkflowRunStatus = "PENDING"
	QUEUED    WorkflowRunStatus = "QUEUED"
	RUNNING   WorkflowRunStatus = "RUNNING"
	SUCCEEDED WorkflowRunStatus = "SUCCEEDED"
)

// APIError defines model for APIError.
type APIError struct {
	// Code a custom Hatchet error code
	Code *uint64 `json:"code,omitempty"`

	// Description a description for this error
	Description string `json:"description"`

	// DocsLink a link to the documentation for this error, if it exists
	DocsLink *string `json:"docs_link,omitempty"`

	// Field the field that this error is associated with, if applicable
	Field *string `json:"field,omitempty"`
}

// APIErrors defines model for APIErrors.
type APIErrors struct {
	Errors []APIError `json:"errors"`
}

// APIMeta defines model for APIMeta.
type APIMeta struct {
	// AllowChangePassword whether or not users can change their password
	AllowChangePassword *bool `json:"allowChangePassword,omitempty"`

	// AllowCreateTenant whether or not users can create new tenants
	AllowCreateTenant *bool `json:"allowCreateTenant,omitempty"`

	// AllowInvites whether or not users can invite other users to this instance
	AllowInvites *bool `json:"allowInvites,omitempty"`

	// AllowSignup whether or not users can sign up for this instance
	AllowSignup *bool           `json:"allowSignup,omitempty"`
	Auth        *APIMetaAuth    `json:"auth,omitempty"`
	Posthog     *APIMetaPosthog `json:"posthog,omitempty"`

	// PylonAppId the Pylon app ID for usepylon.com chat support
	PylonAppId *string `json:"pylonAppId,omitempty"`
}

// APIMetaAuth defines model for APIMetaAuth.
type APIMetaAuth struct {
	// Schemes the supported types of authentication
	Schemes *[]string `json:"schemes,omitempty"`
}

// APIMetaIntegration defines model for APIMetaIntegration.
type APIMetaIntegration struct {
	// Enabled whether this integration is enabled on the instance
	Enabled bool `json:"enabled"`

	// Name the name of the integration
	Name string `json:"name"`
}

// APIMetaPosthog defines model for APIMetaPosthog.
type APIMetaPosthog struct {
	// ApiHost the PostHog API host
	ApiHost *string `json:"apiHost,omitempty"`

	// ApiKey the PostHog API key
	ApiKey *string `json:"apiKey,omitempty"`
}

// APIResourceMeta defines model for APIResourceMeta.
type APIResourceMeta struct {
	// CreatedAt the time that this resource was created
	CreatedAt time.Time `json:"createdAt"`

	// Id the id of this resource, in UUID format
	Id string `json:"id"`

	// UpdatedAt the time that this resource was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// APIToken defines model for APIToken.
type APIToken struct {
	// ExpiresAt When the API token expires.
	ExpiresAt time.Time       `json:"expiresAt"`
	Metadata  APIResourceMeta `json:"metadata"`

	// Name The name of the API token.
	Name string `json:"name"`
}

// AcceptInviteRequest defines model for AcceptInviteRequest.
type AcceptInviteRequest struct {
	Invite string `json:"invite" validate:"required,uuid"`
}

// BulkCreateEventRequest defines model for BulkCreateEventRequest.
type BulkCreateEventRequest struct {
	Events []CreateEventRequest `json:"events"`
}

// CancelEventRequest defines model for CancelEventRequest.
type CancelEventRequest struct {
	EventIds []openapi_types.UUID `json:"eventIds"`
}

// ConcurrencyLimitStrategy defines model for ConcurrencyLimitStrategy.
type ConcurrencyLimitStrategy string

// CreateAPITokenRequest defines model for CreateAPITokenRequest.
type CreateAPITokenRequest struct {
	// ExpiresIn The duration for which the token is valid.
	ExpiresIn *string `json:"expiresIn,omitempty" validate:"omitnil,duration"`

	// Name A name for the API token.
	Name string `json:"name"`
}

// CreateAPITokenResponse defines model for CreateAPITokenResponse.
type CreateAPITokenResponse struct {
	// Token The API token.
	Token string `json:"token"`
}

// CreateCronWorkflowTriggerRequest defines model for CreateCronWorkflowTriggerRequest.
type CreateCronWorkflowTriggerRequest struct {
	AdditionalMetadata map[string]interface{} `json:"additionalMetadata"`
	CronExpression     string                 `json:"cronExpression"`
	CronName           string                 `json:"cronName"`
	Input              map[string]interface{} `json:"input"`
	Priority           *int32                 `json:"priority,omitempty"`
}

// CreateEventRequest defines model for CreateEventRequest.
type CreateEventRequest struct {
	// AdditionalMetadata Additional metadata for the event.
	AdditionalMetadata *map[string]interface{} `json:"additionalMetadata,omitempty"`

	// Data The data for the event.
	Data map[string]interface{} `json:"data"`

	// Key The key for the event.
	Key string `json:"key"`

	// Priority The priority of the event.
	Priority *int32 `json:"priority,omitempty"`

	// Scope The scope for event filtering.
	Scope *string `json:"scope,omitempty"`
}

// CreateSNSIntegrationRequest defines model for CreateSNSIntegrationRequest.
type CreateSNSIntegrationRequest struct {
	// TopicArn The Amazon Resource Name (ARN) of the SNS topic.
	TopicArn string `json:"topicArn" validate:"required,min=1,max=256"`
}

// CreateTenantAlertEmailGroupRequest defines model for CreateTenantAlertEmailGroupRequest.
type CreateTenantAlertEmailGroupRequest struct {
	// Emails A list of emails for users
	Emails []string `json:"emails" validate:"required,dive,email"`
}

// CreateTenantInviteRequest defines model for CreateTenantInviteRequest.
type CreateTenantInviteRequest struct {
	// Email The email of the user to invite.
	Email string           `json:"email" validate:"required,email"`
	Role  TenantMemberRole `json:"role"`
}

// CreateTenantRequest defines model for CreateTenantRequest.
type CreateTenantRequest struct {
	EngineVersion *TenantVersion `json:"engineVersion,omitempty"`

	// Name The name of the tenant.
	Name string `json:"name" validate:"required"`

	// Slug The slug of the tenant.
	Slug      string           `json:"slug" validate:"required,hatchetName"`
	UiVersion *TenantUIVersion `json:"uiVersion,omitempty"`
}

// CronWorkflows defines model for CronWorkflows.
type CronWorkflows struct {
	AdditionalMetadata *map[string]interface{} `json:"additionalMetadata,omitempty"`
	Cron               string                  `json:"cron"`
	Enabled            bool                    `json:"enabled"`
	Input              *map[string]interface{} `json:"input,omitempty"`
	Metadata           APIResourceMeta         `json:"metadata"`
	Method             CronWorkflowsMethod     `json:"method"`
	Name               *string                 `json:"name,omitempty"`
	Priority           *int32                  `json:"priority,omitempty"`
	TenantId           string                  `json:"tenantId"`
	WorkflowId         string                  `json:"workflowId"`
	WorkflowName       string                  `json:"workflowName"`
	WorkflowVersionId  string                  `json:"workflowVersionId"`
}

// CronWorkflowsList defines model for CronWorkflowsList.
type CronWorkflowsList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]CronWorkflows    `json:"rows,omitempty"`
}

// CronWorkflowsMethod defines model for CronWorkflowsMethod.
type CronWorkflowsMethod string

// CronWorkflowsOrderByField defines model for CronWorkflowsOrderByField.
type CronWorkflowsOrderByField string

// Event defines model for Event.
type Event struct {
	// AdditionalMetadata Additional metadata for the event.
	AdditionalMetadata *map[string]interface{} `json:"additionalMetadata,omitempty"`

	// Key The key for the event.
	Key      string          `json:"key"`
	Metadata APIResourceMeta `json:"metadata"`
	Tenant   *Tenant         `json:"tenant,omitempty"`

	// TenantId The ID of the tenant associated with this event.
	TenantId           string                   `json:"tenantId"`
	WorkflowRunSummary *EventWorkflowRunSummary `json:"workflowRunSummary,omitempty"`
}

// EventData defines model for EventData.
type EventData struct {
	// Data The data for the event (JSON bytes).
	Data string `json:"data"`
}

// EventKey The key for the event.
type EventKey = string

// EventKeyList defines model for EventKeyList.
type EventKeyList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]EventKey         `json:"rows,omitempty"`
}

// EventList defines model for EventList.
type EventList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]Event            `json:"rows,omitempty"`
}

// EventOrderByDirection defines model for EventOrderByDirection.
type EventOrderByDirection string

// EventOrderByField defines model for EventOrderByField.
type EventOrderByField string

// EventSearch defines model for EventSearch.
type EventSearch = string

// EventWorkflowRunSummary defines model for EventWorkflowRunSummary.
type EventWorkflowRunSummary struct {
	// Cancelled The number of cancelled runs.
	Cancelled *int64 `json:"cancelled,omitempty"`

	// Failed The number of failed runs.
	Failed *int64 `json:"failed,omitempty"`

	// Pending The number of pending runs.
	Pending *int64 `json:"pending,omitempty"`

	// Queued The number of queued runs.
	Queued *int64 `json:"queued,omitempty"`

	// Running The number of running runs.
	Running *int64 `json:"running,omitempty"`

	// Succeeded The number of succeeded runs.
	Succeeded *int64 `json:"succeeded,omitempty"`
}

// Events defines model for Events.
type Events struct {
	// Events The events.
	Events   []Event         `json:"events"`
	Metadata APIResourceMeta `json:"metadata"`
}

// Job defines model for Job.
type Job struct {
	// Description The description of the job.
	Description *string         `json:"description,omitempty"`
	Metadata    APIResourceMeta `json:"metadata"`
	Name        string          `json:"name"`
	Steps       []Step          `json:"steps"`
	TenantId    string          `json:"tenantId"`

	// Timeout The timeout of the job.
	Timeout   *string `json:"timeout,omitempty"`
	VersionId string  `json:"versionId"`
}

// JobRun defines model for JobRun.
type JobRun struct {
	CancelledAt     *time.Time              `json:"cancelledAt,omitempty"`
	CancelledError  *string                 `json:"cancelledError,omitempty"`
	CancelledReason *string                 `json:"cancelledReason,omitempty"`
	FinishedAt      *time.Time              `json:"finishedAt,omitempty"`
	Job             *Job                    `json:"job,omitempty"`
	JobId           string                  `json:"jobId"`
	Metadata        APIResourceMeta         `json:"metadata"`
	Result          *map[string]interface{} `json:"result,omitempty"`
	StartedAt       *time.Time              `json:"startedAt,omitempty"`
	Status          JobRunStatus            `json:"status"`
	StepRuns        *[]StepRun              `json:"stepRuns,omitempty"`
	TenantId        string                  `json:"tenantId"`
	TickerId        *string                 `json:"tickerId,omitempty"`
	TimeoutAt       *time.Time              `json:"timeoutAt,omitempty"`
	WorkflowRun     *WorkflowRun            `json:"workflowRun,omitempty"`
	WorkflowRunId   string                  `json:"workflowRunId"`
}

// JobRunStatus defines model for JobRunStatus.
type JobRunStatus string

// ListAPIMetaIntegration defines model for ListAPIMetaIntegration.
type ListAPIMetaIntegration = []APIMetaIntegration

// ListAPITokensResponse defines model for ListAPITokensResponse.
type ListAPITokensResponse struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]APIToken         `json:"rows,omitempty"`
}

// ListSNSIntegrations defines model for ListSNSIntegrations.
type ListSNSIntegrations struct {
	Pagination PaginationResponse `json:"pagination"`
	Rows       []SNSIntegration   `json:"rows"`
}

// ListSlackWebhooks defines model for ListSlackWebhooks.
type ListSlackWebhooks struct {
	Pagination PaginationResponse `json:"pagination"`
	Rows       []SlackWebhook     `json:"rows"`
}

// LogLine defines model for LogLine.
type LogLine struct {
	// CreatedAt The creation date of the log line.
	CreatedAt time.Time `json:"createdAt"`

	// Message The log message.
	Message string `json:"message"`

	// Metadata The log metadata.
	Metadata map[string]interface{} `json:"metadata"`
}

// LogLineLevel defines model for LogLineLevel.
type LogLineLevel string

// LogLineLevelField defines model for LogLineLevelField.
type LogLineLevelField = []LogLineLevel

// LogLineList defines model for LogLineList.
type LogLineList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]LogLine          `json:"rows,omitempty"`
}

// LogLineOrderByDirection defines model for LogLineOrderByDirection.
type LogLineOrderByDirection string

// LogLineOrderByField defines model for LogLineOrderByField.
type LogLineOrderByField string

// LogLineSearch defines model for LogLineSearch.
type LogLineSearch = string

// PaginationResponse defines model for PaginationResponse.
type PaginationResponse struct {
	// CurrentPage the current page
	CurrentPage *int64 `json:"current_page,omitempty"`

	// NextPage the next page
	NextPage *int64 `json:"next_page,omitempty"`

	// NumPages the total number of pages for listing
	NumPages *int64 `json:"num_pages,omitempty"`
}

// QueueMetrics defines model for QueueMetrics.
type QueueMetrics struct {
	// NumPending The number of items pending.
	NumPending int `json:"numPending"`

	// NumQueued The number of items in the queue.
	NumQueued int `json:"numQueued"`

	// NumRunning The number of items running.
	NumRunning int `json:"numRunning"`
}

// RateLimit defines model for RateLimit.
type RateLimit struct {
	// Key The key for the rate limit.
	Key string `json:"key"`

	// LastRefill The last time the rate limit was refilled.
	LastRefill time.Time `json:"lastRefill"`

	// LimitValue The maximum number of requests allowed within the window.
	LimitValue int `json:"limitValue"`

	// TenantId The ID of the tenant associated with this rate limit.
	TenantId string `json:"tenantId"`

	// Value The current number of requests made within the window.
	Value int `json:"value"`

	// Window The window of time in which the limitValue is enforced.
	Window string `json:"window"`
}

// RateLimitList defines model for RateLimitList.
type RateLimitList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]RateLimit        `json:"rows,omitempty"`
}

// RateLimitOrderByDirection defines model for RateLimitOrderByDirection.
type RateLimitOrderByDirection string

// RateLimitOrderByField defines model for RateLimitOrderByField.
type RateLimitOrderByField string

// RecentStepRuns defines model for RecentStepRuns.
type RecentStepRuns struct {
	// ActionId The action id.
	ActionId      string             `json:"actionId"`
	CancelledAt   *time.Time         `json:"cancelledAt,omitempty"`
	FinishedAt    *time.Time         `json:"finishedAt,omitempty"`
	Metadata      APIResourceMeta    `json:"metadata"`
	StartedAt     *time.Time         `json:"startedAt,omitempty"`
	Status        StepRunStatus      `json:"status"`
	WorkflowRunId openapi_types.UUID `json:"workflowRunId"`
}

// RejectInviteRequest defines model for RejectInviteRequest.
type RejectInviteRequest struct {
	Invite string `json:"invite" validate:"required,uuid"`
}

// ReplayEventRequest defines model for ReplayEventRequest.
type ReplayEventRequest struct {
	EventIds []openapi_types.UUID `json:"eventIds"`
}

// ReplayWorkflowRunsRequest defines model for ReplayWorkflowRunsRequest.
type ReplayWorkflowRunsRequest struct {
	WorkflowRunIds []openapi_types.UUID `json:"workflowRunIds"`
}

// ReplayWorkflowRunsResponse defines model for ReplayWorkflowRunsResponse.
type ReplayWorkflowRunsResponse struct {
	WorkflowRuns []WorkflowRun `json:"workflowRuns"`
}

// RerunStepRunRequest defines model for RerunStepRunRequest.
type RerunStepRunRequest struct {
	Input map[string]interface{} `json:"input"`
}

// SNSIntegration defines model for SNSIntegration.
type SNSIntegration struct {
	// IngestUrl The URL to send SNS messages to.
	IngestUrl *string         `json:"ingestUrl,omitempty"`
	Metadata  APIResourceMeta `json:"metadata"`

	// TenantId The unique identifier for the tenant that the SNS integration belongs to.
	TenantId openapi_types.UUID `json:"tenantId"`

	// TopicArn The Amazon Resource Name (ARN) of the SNS topic.
	TopicArn string `json:"topicArn"`
}

// ScheduleWorkflowRunRequest defines model for ScheduleWorkflowRunRequest.
type ScheduleWorkflowRunRequest struct {
	AdditionalMetadata map[string]interface{} `json:"additionalMetadata"`
	Input              map[string]interface{} `json:"input"`
	Priority           *int32                 `json:"priority,omitempty"`
	TriggerAt          time.Time              `json:"triggerAt"`
}

// ScheduledRunStatus defines model for ScheduledRunStatus.
type ScheduledRunStatus string

// ScheduledWorkflows defines model for ScheduledWorkflows.
type ScheduledWorkflows struct {
	AdditionalMetadata   *map[string]interface{}  `json:"additionalMetadata,omitempty"`
	Input                *map[string]interface{}  `json:"input,omitempty"`
	Metadata             APIResourceMeta          `json:"metadata"`
	Method               ScheduledWorkflowsMethod `json:"method"`
	Priority             *int32                   `json:"priority,omitempty"`
	TenantId             string                   `json:"tenantId"`
	TriggerAt            time.Time                `json:"triggerAt"`
	WorkflowId           string                   `json:"workflowId"`
	WorkflowName         string                   `json:"workflowName"`
	WorkflowRunCreatedAt *time.Time               `json:"workflowRunCreatedAt,omitempty"`
	WorkflowRunId        *openapi_types.UUID      `json:"workflowRunId,omitempty"`
	WorkflowRunName      *string                  `json:"workflowRunName,omitempty"`
	WorkflowRunStatus    *WorkflowRunStatus       `json:"workflowRunStatus,omitempty"`
	WorkflowVersionId    string                   `json:"workflowVersionId"`
}

// ScheduledWorkflowsList defines model for ScheduledWorkflowsList.
type ScheduledWorkflowsList struct {
	Pagination *PaginationResponse   `json:"pagination,omitempty"`
	Rows       *[]ScheduledWorkflows `json:"rows,omitempty"`
}

// ScheduledWorkflowsMethod defines model for ScheduledWorkflowsMethod.
type ScheduledWorkflowsMethod string

// ScheduledWorkflowsOrderByField defines model for ScheduledWorkflowsOrderByField.
type ScheduledWorkflowsOrderByField string

// SemaphoreSlots defines model for SemaphoreSlots.
type SemaphoreSlots struct {
	// ActionId The action id.
	ActionId string `json:"actionId"`

	// StartedAt The time this slot was started.
	StartedAt *time.Time    `json:"startedAt,omitempty"`
	Status    StepRunStatus `json:"status"`

	// StepRunId The step run id.
	StepRunId openapi_types.UUID `json:"stepRunId"`

	// TimeoutAt The time this slot will timeout.
	TimeoutAt *time.Time `json:"timeoutAt,omitempty"`

	// WorkflowRunId The workflow run id.
	WorkflowRunId openapi_types.UUID `json:"workflowRunId"`
}

// SlackWebhook defines model for SlackWebhook.
type SlackWebhook struct {
	// ChannelId The channel id associated with this slack webhook.
	ChannelId string `json:"channelId"`

	// ChannelName The channel name associated with this slack webhook.
	ChannelName string          `json:"channelName"`
	Metadata    APIResourceMeta `json:"metadata"`

	// TeamId The team id associated with this slack webhook.
	TeamId string `json:"teamId"`

	// TeamName The team name associated with this slack webhook.
	TeamName string `json:"teamName"`

	// TenantId The unique identifier for the tenant that the SNS integration belongs to.
	TenantId openapi_types.UUID `json:"tenantId"`
}

// Step defines model for Step.
type Step struct {
	Action   string          `json:"action"`
	Children *[]string       `json:"children,omitempty"`
	JobId    string          `json:"jobId"`
	Metadata APIResourceMeta `json:"metadata"`
	Parents  *[]string       `json:"parents,omitempty"`

	// ReadableId The readable id of the step.
	ReadableId string `json:"readableId"`
	TenantId   string `json:"tenantId"`

	// Timeout The timeout of the step.
	Timeout *string `json:"timeout,omitempty"`
}

// StepRun defines model for StepRun.
type StepRun struct {
	CancelledAt         *time.Time              `json:"cancelledAt,omitempty"`
	CancelledAtEpoch    *int                    `json:"cancelledAtEpoch,omitempty"`
	CancelledError      *string                 `json:"cancelledError,omitempty"`
	CancelledReason     *string                 `json:"cancelledReason,omitempty"`
	ChildWorkflowRuns   *[]string               `json:"childWorkflowRuns,omitempty"`
	ChildWorkflowsCount *int                    `json:"childWorkflowsCount,omitempty"`
	Error               *string                 `json:"error,omitempty"`
	FinishedAt          *time.Time              `json:"finishedAt,omitempty"`
	FinishedAtEpoch     *int                    `json:"finishedAtEpoch,omitempty"`
	Input               *string                 `json:"input,omitempty"`
	JobRun              *JobRun                 `json:"jobRun,omitempty"`
	JobRunId            string                  `json:"jobRunId"`
	Metadata            APIResourceMeta         `json:"metadata"`
	Output              *string                 `json:"output,omitempty"`
	Parents             *[]string               `json:"parents,omitempty"`
	RequeueAfter        *time.Time              `json:"requeueAfter,omitempty"`
	Result              *map[string]interface{} `json:"result,omitempty"`
	StartedAt           *time.Time              `json:"startedAt,omitempty"`
	StartedAtEpoch      *int                    `json:"startedAtEpoch,omitempty"`
	Status              StepRunStatus           `json:"status"`
	Step                *Step                   `json:"step,omitempty"`
	StepId              string                  `json:"stepId"`
	TenantId            string                  `json:"tenantId"`
	TimeoutAt           *time.Time              `json:"timeoutAt,omitempty"`
	TimeoutAtEpoch      *int                    `json:"timeoutAtEpoch,omitempty"`
	WorkerId            *string                 `json:"workerId,omitempty"`
}

// StepRunArchive defines model for StepRunArchive.
type StepRunArchive struct {
	CancelledAt      *time.Time `json:"cancelledAt,omitempty"`
	CancelledAtEpoch *int       `json:"cancelledAtEpoch,omitempty"`
	CancelledError   *string    `json:"cancelledError,omitempty"`
	CancelledReason  *string    `json:"cancelledReason,omitempty"`
	CreatedAt        time.Time  `json:"createdAt"`
	Error            *string    `json:"error,omitempty"`
	FinishedAt       *time.Time `json:"finishedAt,omitempty"`
	FinishedAtEpoch  *int       `json:"finishedAtEpoch,omitempty"`
	Input            *string    `json:"input,omitempty"`
	Order            int        `json:"order"`
	Output           *string    `json:"output,omitempty"`
	RetryCount       int        `json:"retryCount"`
	StartedAt        *time.Time `json:"startedAt,omitempty"`
	StartedAtEpoch   *int       `json:"startedAtEpoch,omitempty"`
	StepRunId        string     `json:"stepRunId"`
	TimeoutAt        *time.Time `json:"timeoutAt,omitempty"`
	TimeoutAtEpoch   *int       `json:"timeoutAtEpoch,omitempty"`
}

// StepRunArchiveList defines model for StepRunArchiveList.
type StepRunArchiveList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]StepRunArchive   `json:"rows,omitempty"`
}

// StepRunEvent defines model for StepRunEvent.
type StepRunEvent struct {
	Count         int                     `json:"count"`
	Data          *map[string]interface{} `json:"data,omitempty"`
	Id            int                     `json:"id"`
	Message       string                  `json:"message"`
	Reason        StepRunEventReason      `json:"reason"`
	Severity      StepRunEventSeverity    `json:"severity"`
	StepRunId     *string                 `json:"stepRunId,omitempty"`
	TimeFirstSeen time.Time               `json:"timeFirstSeen"`
	TimeLastSeen  time.Time               `json:"timeLastSeen"`
	WorkflowRunId *string                 `json:"workflowRunId,omitempty"`
}

// StepRunEventList defines model for StepRunEventList.
type StepRunEventList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]StepRunEvent     `json:"rows,omitempty"`
}

// StepRunEventReason defines model for StepRunEventReason.
type StepRunEventReason string

// StepRunEventSeverity defines model for StepRunEventSeverity.
type StepRunEventSeverity string

// StepRunStatus defines model for StepRunStatus.
type StepRunStatus string

// Tenant defines model for Tenant.
type Tenant struct {
	// AlertMemberEmails Whether to alert tenant members.
	AlertMemberEmails *bool `json:"alertMemberEmails,omitempty"`

	// AnalyticsOptOut Whether the tenant has opted out of analytics.
	AnalyticsOptOut *bool           `json:"analyticsOptOut,omitempty"`
	Metadata        APIResourceMeta `json:"metadata"`

	// Name The name of the tenant.
	Name string `json:"name"`

	// Slug The slug of the tenant.
	Slug      string           `json:"slug"`
	UiVersion *TenantUIVersion `json:"uiVersion,omitempty"`
	Version   TenantVersion    `json:"version"`
}

// TenantAlertEmailGroup defines model for TenantAlertEmailGroup.
type TenantAlertEmailGroup struct {
	// Emails A list of emails for users
	Emails   []string        `json:"emails"`
	Metadata APIResourceMeta `json:"metadata"`
}

// TenantAlertEmailGroupList defines model for TenantAlertEmailGroupList.
type TenantAlertEmailGroupList struct {
	Pagination *PaginationResponse      `json:"pagination,omitempty"`
	Rows       *[]TenantAlertEmailGroup `json:"rows,omitempty"`
}

// TenantAlertingSettings defines model for TenantAlertingSettings.
type TenantAlertingSettings struct {
	// AlertMemberEmails Whether to alert tenant members.
	AlertMemberEmails *bool `json:"alertMemberEmails,omitempty"`

	// EnableExpiringTokenAlerts Whether to enable alerts when tokens are approaching expiration.
	EnableExpiringTokenAlerts *bool `json:"enableExpiringTokenAlerts,omitempty"`

	// EnableTenantResourceLimitAlerts Whether to enable alerts when tenant resources are approaching limits.
	EnableTenantResourceLimitAlerts *bool `json:"enableTenantResourceLimitAlerts,omitempty"`

	// EnableWorkflowRunFailureAlerts Whether to send alerts when workflow runs fail.
	EnableWorkflowRunFailureAlerts *bool `json:"enableWorkflowRunFailureAlerts,omitempty"`

	// LastAlertedAt The last time an alert was sent.
	LastAlertedAt *time.Time `json:"lastAlertedAt,omitempty"`

	// MaxAlertingFrequency The max frequency at which to alert.
	MaxAlertingFrequency string          `json:"maxAlertingFrequency"`
	Metadata             APIResourceMeta `json:"metadata"`
}

// TenantInvite defines model for TenantInvite.
type TenantInvite struct {
	// Email The email of the user to invite.
	Email string `json:"email"`

	// Expires The time that this invite expires.
	Expires  time.Time        `json:"expires"`
	Metadata APIResourceMeta  `json:"metadata"`
	Role     TenantMemberRole `json:"role"`

	// TenantId The tenant id associated with this tenant invite.
	TenantId string `json:"tenantId"`

	// TenantName The tenant name for the tenant.
	TenantName *string `json:"tenantName,omitempty"`
}

// TenantInviteList defines model for TenantInviteList.
type TenantInviteList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]TenantInvite     `json:"rows,omitempty"`
}

// TenantMember defines model for TenantMember.
type TenantMember struct {
	Metadata APIResourceMeta  `json:"metadata"`
	Role     TenantMemberRole `json:"role"`
	Tenant   *Tenant          `json:"tenant,omitempty"`
	User     UserTenantPublic `json:"user"`
}

// TenantMemberList defines model for TenantMemberList.
type TenantMemberList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]TenantMember     `json:"rows,omitempty"`
}

// TenantMemberRole defines model for TenantMemberRole.
type TenantMemberRole string

// TenantQueueMetrics defines model for TenantQueueMetrics.
type TenantQueueMetrics struct {
	Queues   *map[string]int          `json:"queues,omitempty"`
	Total    *QueueMetrics            `json:"total,omitempty"`
	Workflow *map[string]QueueMetrics `json:"workflow,omitempty"`
}

// TenantResource defines model for TenantResource.
type TenantResource string

// TenantResourceLimit defines model for TenantResourceLimit.
type TenantResourceLimit struct {
	// AlarmValue The alarm value associated with this limit to warn of approaching limit value.
	AlarmValue *int `json:"alarmValue,omitempty"`

	// LastRefill The last time the limit was refilled.
	LastRefill *time.Time `json:"lastRefill,omitempty"`

	// LimitValue The limit associated with this limit.
	LimitValue int             `json:"limitValue"`
	Metadata   APIResourceMeta `json:"metadata"`
	Resource   TenantResource  `json:"resource"`

	// Value The current value associated with this limit.
	Value int `json:"value"`

	// Window The meter window for the limit. (i.e. 1 day, 1 week, 1 month)
	Window *string `json:"window,omitempty"`
}

// TenantResourcePolicy defines model for TenantResourcePolicy.
type TenantResourcePolicy struct {
	// Limits A list of resource limits for the tenant.
	Limits []TenantResourceLimit `json:"limits"`
}

// TenantStepRunQueueMetrics defines model for TenantStepRunQueueMetrics.
type TenantStepRunQueueMetrics struct {
	Queues *map[string]interface{} `json:"queues,omitempty"`
}

// TenantUIVersion defines model for TenantUIVersion.
type TenantUIVersion string

// TenantVersion defines model for TenantVersion.
type TenantVersion string

// TriggerWorkflowRunRequest defines model for TriggerWorkflowRunRequest.
type TriggerWorkflowRunRequest struct {
	AdditionalMetadata *map[string]interface{} `json:"additionalMetadata,omitempty"`
	Input              map[string]interface{}  `json:"input"`
}

// UpdateTenantAlertEmailGroupRequest defines model for UpdateTenantAlertEmailGroupRequest.
type UpdateTenantAlertEmailGroupRequest struct {
	// Emails A list of emails for users
	Emails []string `json:"emails" validate:"required,dive,email"`
}

// UpdateTenantInviteRequest defines model for UpdateTenantInviteRequest.
type UpdateTenantInviteRequest struct {
	Role TenantMemberRole `json:"role"`
}

// UpdateTenantRequest defines model for UpdateTenantRequest.
type UpdateTenantRequest struct {
	// AlertMemberEmails Whether to alert tenant members.
	AlertMemberEmails *bool `json:"alertMemberEmails,omitempty"`

	// AnalyticsOptOut Whether the tenant has opted out of analytics.
	AnalyticsOptOut *bool `json:"analyticsOptOut,omitempty"`

	// EnableExpiringTokenAlerts Whether to enable alerts when tokens are approaching expiration.
	EnableExpiringTokenAlerts *bool `json:"enableExpiringTokenAlerts,omitempty"`

	// EnableTenantResourceLimitAlerts Whether to enable alerts when tenant resources are approaching limits.
	EnableTenantResourceLimitAlerts *bool `json:"enableTenantResourceLimitAlerts,omitempty"`

	// EnableWorkflowRunFailureAlerts Whether to send alerts when workflow runs fail.
	EnableWorkflowRunFailureAlerts *bool `json:"enableWorkflowRunFailureAlerts,omitempty"`

	// MaxAlertingFrequency The max frequency at which to alert.
	MaxAlertingFrequency *string `json:"maxAlertingFrequency,omitempty" validate:"omitnil,duration"`

	// Name The name of the tenant.
	Name      *string          `json:"name,omitempty"`
	UiVersion *TenantUIVersion `json:"uiVersion,omitempty"`
	Version   *TenantVersion   `json:"version,omitempty"`
}

// UpdateWorkerRequest defines model for UpdateWorkerRequest.
type UpdateWorkerRequest struct {
	// IsPaused Whether the worker is paused and cannot accept new runs.
	IsPaused *bool `json:"isPaused,omitempty"`
}

// User defines model for User.
type User struct {
	// Email The email address of the user.
	Email openapi_types.Email `json:"email"`

	// EmailHash A hash of the user's email address for use with Pylon Support Chat
	EmailHash *string `json:"emailHash,omitempty"`

	// EmailVerified Whether the user has verified their email address.
	EmailVerified bool `json:"emailVerified"`

	// HasPassword Whether the user has a password set.
	HasPassword *bool           `json:"hasPassword,omitempty"`
	Metadata    APIResourceMeta `json:"metadata"`

	// Name The display name of the user.
	Name *string `json:"name,omitempty"`
}

// UserChangePasswordRequest defines model for UserChangePasswordRequest.
type UserChangePasswordRequest struct {
	// NewPassword The new password for the user.
	NewPassword string `json:"newPassword" validate:"required,password"`

	// Password The password of the user.
	Password string `json:"password" validate:"required,password"`
}

// UserLoginRequest defines model for UserLoginRequest.
type UserLoginRequest struct {
	// Email The email address of the user.
	Email openapi_types.Email `json:"email" validate:"required,email"`

	// Password The password of the user.
	Password string `json:"password" validate:"required,password"`
}

// UserRegisterRequest defines model for UserRegisterRequest.
type UserRegisterRequest struct {
	// Email The email address of the user.
	Email openapi_types.Email `json:"email" validate:"required,email"`

	// Name The name of the user.
	Name string `json:"name"`

	// Password The password of the user.
	Password string `json:"password" validate:"required,password"`
}

// UserTenantMembershipsList defines model for UserTenantMembershipsList.
type UserTenantMembershipsList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]TenantMember     `json:"rows,omitempty"`
}

// UserTenantPublic defines model for UserTenantPublic.
type UserTenantPublic struct {
	// Email The email address of the user.
	Email openapi_types.Email `json:"email"`

	// Name The display name of the user.
	Name *string `json:"name,omitempty"`
}

// V1CancelTaskRequest defines model for V1CancelTaskRequest.
type V1CancelTaskRequest struct {
	// ExternalIds A list of external IDs, which can refer to either task or workflow run external IDs
	ExternalIds *[]openapi_types.UUID `json:"externalIds,omitempty"`
	Filter      *V1TaskFilter         `json:"filter,omitempty"`
}

// V1CreateFilterRequest defines model for V1CreateFilterRequest.
type V1CreateFilterRequest struct {
	// Expression The expression for the filter
	Expression string `json:"expression"`

	// Payload The payload for the filter
	Payload *map[string]interface{} `json:"payload,omitempty"`

	// Scope The scope associated with this filter. Used for subsetting candidate filters at evaluation time
	Scope string `json:"scope"`

	// WorkflowId The workflow id
	WorkflowId openapi_types.UUID `json:"workflowId"`
}

// V1DagChildren defines model for V1DagChildren.
type V1DagChildren struct {
	Children *[]V1TaskSummary    `json:"children,omitempty"`
	DagId    *openapi_types.UUID `json:"dagId,omitempty"`
}

// V1Event defines model for V1Event.
type V1Event struct {
	// AdditionalMetadata Additional metadata for the event.
	AdditionalMetadata *map[string]interface{} `json:"additionalMetadata,omitempty"`

	// Key The key for the event.
	Key      string          `json:"key"`
	Metadata APIResourceMeta `json:"metadata"`

	// Payload The payload of the event, which can be any JSON-serializable object.
	Payload *map[string]interface{} `json:"payload,omitempty"`

	// Scope The scope of the event, which can be used to filter or categorize events.
	Scope *string `json:"scope,omitempty"`

	// SeenAt The timestamp when the event was seen.
	SeenAt *time.Time `json:"seenAt,omitempty"`
	Tenant *Tenant    `json:"tenant,omitempty"`

	// TenantId The ID of the tenant associated with this event.
	TenantId string `json:"tenantId"`

	// TriggeredRuns The external IDs of the runs that were triggered by this event.
	TriggeredRuns      *[]V1EventTriggeredRun    `json:"triggeredRuns,omitempty"`
	WorkflowRunSummary V1EventWorkflowRunSummary `json:"workflowRunSummary"`
}

// V1EventList defines model for V1EventList.
type V1EventList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]V1Event          `json:"rows,omitempty"`
}

// V1EventTriggeredRun defines model for V1EventTriggeredRun.
type V1EventTriggeredRun struct {
	// FilterId The ID of the filter that triggered the run, if applicable.
	FilterId *openapi_types.UUID `json:"filterId,omitempty"`

	// WorkflowRunId The external ID of the triggered run.
	WorkflowRunId openapi_types.UUID `json:"workflowRunId"`
}

// V1EventWorkflowRunSummary defines model for V1EventWorkflowRunSummary.
type V1EventWorkflowRunSummary struct {
	// Cancelled The number of cancelled runs.
	Cancelled int64 `json:"cancelled"`

	// Failed The number of failed runs.
	Failed int64 `json:"failed"`

	// Queued The number of queued runs.
	Queued int64 `json:"queued"`

	// Running The number of running runs.
	Running int64 `json:"running"`

	// Succeeded The number of succeeded runs.
	Succeeded int64 `json:"succeeded"`
}

// V1Filter defines model for V1Filter.
type V1Filter struct {
	// Expression The expression associated with this filter.
	Expression string          `json:"expression"`
	Metadata   APIResourceMeta `json:"metadata"`

	// Payload Additional payload data associated with the filter
	Payload map[string]interface{} `json:"payload"`

	// Scope The scope associated with this filter. Used for subsetting candidate filters at evaluation time
	Scope string `json:"scope"`

	// TenantId The ID of the tenant associated with this filter.
	TenantId string `json:"tenantId"`

	// WorkflowId The workflow id associated with this filter.
	WorkflowId openapi_types.UUID `json:"workflowId"`
}

// V1FilterList defines model for V1FilterList.
type V1FilterList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]V1Filter         `json:"rows,omitempty"`
}

// V1LogLine defines model for V1LogLine.
type V1LogLine struct {
	// Attempt The attempt number of the log line.
	Attempt *int `json:"attempt,omitempty"`

	// CreatedAt The creation date of the log line.
	CreatedAt time.Time       `json:"createdAt"`
	Level     *V1LogLineLevel `json:"level,omitempty"`

	// Message The log message.
	Message string `json:"message"`

	// Metadata The log metadata.
	Metadata map[string]interface{} `json:"metadata"`

	// RetryCount The retry count of the log line.
	RetryCount *int `json:"retryCount,omitempty"`
}

// V1LogLineLevel defines model for V1LogLineLevel.
type V1LogLineLevel string

// V1LogLineList defines model for V1LogLineList.
type V1LogLineList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]V1LogLine        `json:"rows,omitempty"`
}

// V1ReplayTaskRequest defines model for V1ReplayTaskRequest.
type V1ReplayTaskRequest struct {
	// ExternalIds A list of external IDs, which can refer to either task or workflow run external IDs
	ExternalIds *[]openapi_types.UUID `json:"externalIds,omitempty"`
	Filter      *V1TaskFilter         `json:"filter,omitempty"`
}

// V1TaskEvent defines model for V1TaskEvent.
type V1TaskEvent struct {
	// Attempt The attempt number of the task.
	Attempt      *int            `json:"attempt,omitempty"`
	ErrorMessage *string         `json:"errorMessage,omitempty"`
	EventType    V1TaskEventType `json:"eventType"`
	Id           int             `json:"id"`
	Message      string          `json:"message"`
	Output       *string         `json:"output,omitempty"`

	// RetryCount The number of retries of the task.
	RetryCount      *int                `json:"retryCount,omitempty"`
	TaskDisplayName *string             `json:"taskDisplayName,omitempty"`
	TaskId          openapi_types.UUID  `json:"taskId"`
	Timestamp       time.Time           `json:"timestamp"`
	WorkerId        *openapi_types.UUID `json:"workerId,omitempty"`
}

// V1TaskEventList defines model for V1TaskEventList.
type V1TaskEventList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]V1TaskEvent      `json:"rows,omitempty"`
}

// V1TaskEventType defines model for V1TaskEventType.
type V1TaskEventType string

// V1TaskFilter defines model for V1TaskFilter.
type V1TaskFilter struct {
	AdditionalMetadata *[]string             `json:"additionalMetadata,omitempty"`
	Since              time.Time             `json:"since"`
	Statuses           *[]V1TaskStatus       `json:"statuses,omitempty"`
	Until              *time.Time            `json:"until,omitempty"`
	WorkflowIds        *[]openapi_types.UUID `json:"workflowIds,omitempty"`
}

// V1TaskPointMetric defines model for V1TaskPointMetric.
type V1TaskPointMetric struct {
	FAILED    int       `json:"FAILED"`
	SUCCEEDED int       `json:"SUCCEEDED"`
	Time      time.Time `json:"time"`
}

// V1TaskPointMetrics defines model for V1TaskPointMetrics.
type V1TaskPointMetrics struct {
	Results *[]V1TaskPointMetric `json:"results,omitempty"`
}

// V1TaskRunMetric defines model for V1TaskRunMetric.
type V1TaskRunMetric struct {
	Count  int          `json:"count"`
	Status V1TaskStatus `json:"status"`
}

// V1TaskRunMetrics defines model for V1TaskRunMetrics.
type V1TaskRunMetrics = []V1TaskRunMetric

// V1TaskStatus defines model for V1TaskStatus.
type V1TaskStatus string

// V1TaskSummary defines model for V1TaskSummary.
type V1TaskSummary struct {
	// ActionId The action ID of the task.
	ActionId *string `json:"actionId,omitempty"`

	// AdditionalMetadata Additional metadata for the task run.
	AdditionalMetadata *map[string]interface{} `json:"additionalMetadata,omitempty"`

	// Attempt The attempt number of the task.
	Attempt *int `json:"attempt,omitempty"`

	// Children The list of children tasks
	Children *[]V1TaskSummary `json:"children,omitempty"`

	// CreatedAt The timestamp the task was created.
	CreatedAt time.Time `json:"createdAt"`

	// DisplayName The display name of the task run.
	DisplayName string `json:"displayName"`

	// Duration The duration of the task run, in milliseconds.
	Duration *int `json:"duration,omitempty"`

	// ErrorMessage The error message of the task run (for the latest run)
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// FinishedAt The timestamp the task run finished.
	FinishedAt *time.Time `json:"finishedAt,omitempty"`

	// Input The input of the task run.
	Input    openapi.NonNullableJSON `json:"input"`
	Metadata APIResourceMeta         `json:"metadata"`

	// NumSpawnedChildren The number of spawned children tasks
	NumSpawnedChildren int `json:"numSpawnedChildren"`

	// Output The output of the task run (for the latest run)
	Output openapi.NonNullableJSON `json:"output"`

	// RetryCount The number of retries of the task.
	RetryCount *int `json:"retryCount,omitempty"`

	// StartedAt The timestamp the task run started.
	StartedAt *time.Time   `json:"startedAt,omitempty"`
	Status    V1TaskStatus `json:"status"`

	// StepId The step ID of the task.
	StepId *openapi_types.UUID `json:"stepId,omitempty"`

	// TaskExternalId The external ID of the task.
	TaskExternalId openapi_types.UUID `json:"taskExternalId"`

	// TaskId The ID of the task.
	TaskId int `json:"taskId"`

	// TaskInsertedAt The timestamp the task was inserted.
	TaskInsertedAt time.Time `json:"taskInsertedAt"`

	// TenantId The ID of the tenant.
	TenantId       openapi_types.UUID      `json:"tenantId"`
	Type           V1WorkflowType          `json:"type"`
	WorkflowConfig *map[string]interface{} `json:"workflowConfig,omitempty"`
	WorkflowId     openapi_types.UUID      `json:"workflowId"`
	WorkflowName   *string                 `json:"workflowName,omitempty"`

	// WorkflowRunExternalId The external ID of the workflow run
	WorkflowRunExternalId openapi_types.UUID `json:"workflowRunExternalId"`

	// WorkflowVersionId The version ID of the workflow
	WorkflowVersionId *openapi_types.UUID `json:"workflowVersionId,omitempty"`
}

// V1TaskSummaryList defines model for V1TaskSummaryList.
type V1TaskSummaryList struct {
	Pagination PaginationResponse `json:"pagination"`

	// Rows The list of tasks
	Rows []V1TaskSummary `json:"rows"`
}

// V1TaskTiming defines model for V1TaskTiming.
type V1TaskTiming struct {
	// Attempt The attempt number of the task.
	Attempt *int `json:"attempt,omitempty"`

	// Depth The depth of the task in the waterfall.
	Depth int `json:"depth"`

	// FinishedAt The timestamp the task run finished.
	FinishedAt *time.Time      `json:"finishedAt,omitempty"`
	Metadata   APIResourceMeta `json:"metadata"`

	// ParentTaskExternalId The external ID of the parent task.
	ParentTaskExternalId *openapi_types.UUID `json:"parentTaskExternalId,omitempty"`

	// QueuedAt The timestamp the task run was queued.
	QueuedAt *time.Time `json:"queuedAt,omitempty"`

	// RetryCount The number of retries of the task.
	RetryCount *int `json:"retryCount,omitempty"`

	// StartedAt The timestamp the task run started.
	StartedAt *time.Time   `json:"startedAt,omitempty"`
	Status    V1TaskStatus `json:"status"`

	// TaskDisplayName The display name of the task run.
	TaskDisplayName string `json:"taskDisplayName"`

	// TaskExternalId The external ID of the task.
	TaskExternalId openapi_types.UUID `json:"taskExternalId"`

	// TaskId The ID of the task.
	TaskId int `json:"taskId"`

	// TaskInsertedAt The timestamp the task was inserted.
	TaskInsertedAt time.Time `json:"taskInsertedAt"`

	// TenantId The ID of the tenant.
	TenantId openapi_types.UUID `json:"tenantId"`

	// WorkflowRunId The external ID of the workflow run.
	WorkflowRunId *openapi_types.UUID `json:"workflowRunId,omitempty"`
}

// V1TaskTimingList defines model for V1TaskTimingList.
type V1TaskTimingList struct {
	Pagination PaginationResponse `json:"pagination"`

	// Rows The list of task timings
	Rows []V1TaskTiming `json:"rows"`
}

// V1TriggerWorkflowRunRequest defines model for V1TriggerWorkflowRunRequest.
type V1TriggerWorkflowRunRequest struct {
	AdditionalMetadata *map[string]interface{} `json:"additionalMetadata,omitempty"`
	Input              map[string]interface{}  `json:"input"`

	// Priority The priority of the workflow run.
	Priority *int `json:"priority,omitempty"`

	// WorkflowName The name of the workflow.
	WorkflowName string `json:"workflowName"`
}

// V1UpdateFilterRequest defines model for V1UpdateFilterRequest.
type V1UpdateFilterRequest struct {
	// Expression The expression for the filter
	Expression *string `json:"expression,omitempty"`

	// Payload The payload for the filter
	Payload *map[string]interface{} `json:"payload,omitempty"`

	// Scope The scope associated with this filter. Used for subsetting candidate filters at evaluation time
	Scope *string `json:"scope,omitempty"`
}

// V1WorkflowRun defines model for V1WorkflowRun.
type V1WorkflowRun struct {
	// AdditionalMetadata Additional metadata for the task run.
	AdditionalMetadata *map[string]interface{} `json:"additionalMetadata,omitempty"`

	// CreatedAt The timestamp the task run was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// DisplayName The display name of the task run.
	DisplayName string `json:"displayName"`

	// Duration The duration of the task run, in milliseconds.
	Duration *int `json:"duration,omitempty"`

	// ErrorMessage The error message of the task run (for the latest run)
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// FinishedAt The timestamp the task run finished.
	FinishedAt *time.Time `json:"finishedAt,omitempty"`

	// Input The input of the task run.
	Input    openapi.NonNullableJSON `json:"input"`
	Metadata APIResourceMeta         `json:"metadata"`

	// Output The output of the task run (for the latest run)
	Output               openapi.NonNullableJSON `json:"output"`
	ParentTaskExternalId *openapi_types.UUID     `json:"parentTaskExternalId,omitempty"`

	// StartedAt The timestamp the task run started.
	StartedAt *time.Time   `json:"startedAt,omitempty"`
	Status    V1TaskStatus `json:"status"`

	// TenantId The ID of the tenant.
	TenantId   openapi_types.UUID `json:"tenantId"`
	WorkflowId openapi_types.UUID `json:"workflowId"`

	// WorkflowVersionId The ID of the workflow version.
	WorkflowVersionId *openapi_types.UUID `json:"workflowVersionId,omitempty"`
}

// V1WorkflowRunDetails defines model for V1WorkflowRunDetails.
type V1WorkflowRunDetails struct {
	Run   V1WorkflowRun                         `json:"run"`
	Shape WorkflowRunShapeForWorkflowRunDetails `json:"shape"`

	// TaskEvents The list of task events for the workflow run
	TaskEvents     []V1TaskEvent           `json:"taskEvents"`
	Tasks          []V1TaskSummary         `json:"tasks"`
	WorkflowConfig *map[string]interface{} `json:"workflowConfig,omitempty"`
}

// V1WorkflowRunDisplayName defines model for V1WorkflowRunDisplayName.
type V1WorkflowRunDisplayName struct {
	DisplayName string          `json:"displayName"`
	Metadata    APIResourceMeta `json:"metadata"`
}

// V1WorkflowRunDisplayNameList defines model for V1WorkflowRunDisplayNameList.
type V1WorkflowRunDisplayNameList struct {
	Pagination PaginationResponse `json:"pagination"`

	// Rows The list of display names
	Rows []V1WorkflowRunDisplayName `json:"rows"`
}

// V1WorkflowType defines model for V1WorkflowType.
type V1WorkflowType string

// WebhookWorker defines model for WebhookWorker.
type WebhookWorker struct {
	Metadata APIResourceMeta `json:"metadata"`

	// Name The name of the webhook worker.
	Name string `json:"name"`

	// Url The webhook url.
	Url string `json:"url"`
}

// WebhookWorkerCreateRequest defines model for WebhookWorkerCreateRequest.
type WebhookWorkerCreateRequest struct {
	// Name The name of the webhook worker.
	Name string `json:"name"`

	// Secret The secret key for validation. If not provided, a random secret will be generated.
	Secret *string `json:"secret,omitempty"`

	// Url The webhook url.
	Url string `json:"url"`
}

// WebhookWorkerCreated defines model for WebhookWorkerCreated.
type WebhookWorkerCreated struct {
	Metadata APIResourceMeta `json:"metadata"`

	// Name The name of the webhook worker.
	Name string `json:"name"`

	// Secret The secret key for validation.
	Secret string `json:"secret"`

	// Url The webhook url.
	Url string `json:"url"`
}

// WebhookWorkerListResponse defines model for WebhookWorkerListResponse.
type WebhookWorkerListResponse struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]WebhookWorker    `json:"rows,omitempty"`
}

// WebhookWorkerRequest defines model for WebhookWorkerRequest.
type WebhookWorkerRequest struct {
	// CreatedAt The date and time the request was created.
	CreatedAt time.Time                  `json:"created_at"`
	Method    WebhookWorkerRequestMethod `json:"method"`

	// StatusCode The HTTP status code of the response.
	StatusCode int `json:"statusCode"`
}

// WebhookWorkerRequestListResponse defines model for WebhookWorkerRequestListResponse.
type WebhookWorkerRequestListResponse struct {
	// Requests The list of webhook requests.
	Requests *[]WebhookWorkerRequest `json:"requests,omitempty"`
}

// WebhookWorkerRequestMethod defines model for WebhookWorkerRequestMethod.
type WebhookWorkerRequestMethod = interface{}

// Worker defines model for Worker.
type Worker struct {
	// Actions The actions this worker can perform.
	Actions *[]string `json:"actions,omitempty"`

	// AvailableRuns The number of runs this worker can execute concurrently.
	AvailableRuns *int `json:"availableRuns,omitempty"`

	// DispatcherId the id of the assigned dispatcher, in UUID format
	DispatcherId *openapi_types.UUID `json:"dispatcherId,omitempty"`

	// Labels The current label state of the worker.
	Labels *[]WorkerLabel `json:"labels,omitempty"`

	// LastHeartbeatAt The time this worker last sent a heartbeat.
	LastHeartbeatAt *time.Time `json:"lastHeartbeatAt,omitempty"`

	// LastListenerEstablished The time this worker last sent a heartbeat.
	LastListenerEstablished *time.Time `json:"lastListenerEstablished,omitempty"`

	// MaxRuns The maximum number of runs this worker can execute concurrently.
	MaxRuns  *int            `json:"maxRuns,omitempty"`
	Metadata APIResourceMeta `json:"metadata"`

	// Name The name of the worker.
	Name string `json:"name"`

	// RecentStepRuns The recent step runs for the worker.
	RecentStepRuns *[]RecentStepRuns  `json:"recentStepRuns,omitempty"`
	RuntimeInfo    *WorkerRuntimeInfo `json:"runtimeInfo,omitempty"`

	// Slots The semaphore slot state for the worker.
	Slots *[]SemaphoreSlots `json:"slots,omitempty"`

	// Status The status of the worker.
	Status *WorkerStatus `json:"status,omitempty"`
	Type   WorkerType    `json:"type"`

	// WebhookId The webhook ID for the worker.
	WebhookId *openapi_types.UUID `json:"webhookId,omitempty"`

	// WebhookUrl The webhook URL for the worker.
	WebhookUrl *string `json:"webhookUrl,omitempty"`
}

// WorkerStatus The status of the worker.
type WorkerStatus string

// WorkerLabel defines model for WorkerLabel.
type WorkerLabel struct {
	// Key The key of the label.
	Key      string          `json:"key"`
	Metadata APIResourceMeta `json:"metadata"`

	// Value The value of the label.
	Value *string `json:"value,omitempty"`
}

// WorkerList defines model for WorkerList.
type WorkerList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]Worker           `json:"rows,omitempty"`
}

// WorkerRuntimeInfo defines model for WorkerRuntimeInfo.
type WorkerRuntimeInfo struct {
	Language        *WorkerRuntimeSDKs `json:"language,omitempty"`
	LanguageVersion *string            `json:"languageVersion,omitempty"`
	Os              *string            `json:"os,omitempty"`
	RuntimeExtra    *string            `json:"runtimeExtra,omitempty"`
	SdkVersion      *string            `json:"sdkVersion,omitempty"`
}

// WorkerRuntimeSDKs defines model for WorkerRuntimeSDKs.
type WorkerRuntimeSDKs string

// WorkerType defines model for WorkerType.
type WorkerType string

// Workflow defines model for Workflow.
type Workflow struct {
	// Description The description of the workflow.
	Description *string `json:"description,omitempty"`

	// IsPaused Whether the workflow is paused.
	IsPaused *bool `json:"isPaused,omitempty"`

	// Jobs The jobs of the workflow.
	Jobs     *[]Job          `json:"jobs,omitempty"`
	Metadata APIResourceMeta `json:"metadata"`

	// Name The name of the workflow.
	Name string `json:"name"`

	// Tags The tags of the workflow.
	Tags *[]WorkflowTag `json:"tags,omitempty"`

	// TenantId The tenant id of the workflow.
	TenantId string                 `json:"tenantId"`
	Versions *[]WorkflowVersionMeta `json:"versions,omitempty"`
}

// WorkflowConcurrency defines model for WorkflowConcurrency.
type WorkflowConcurrency struct {
	// GetConcurrencyGroup An action which gets the concurrency group for the WorkflowRun.
	GetConcurrencyGroup string                   `json:"getConcurrencyGroup"`
	LimitStrategy       ConcurrencyLimitStrategy `json:"limitStrategy"`

	// MaxRuns The maximum number of concurrent workflow runs.
	MaxRuns int32 `json:"maxRuns"`
}

// WorkflowID A workflow ID.
type WorkflowID = string

// WorkflowKind defines model for WorkflowKind.
type WorkflowKind string

// WorkflowKindList defines model for WorkflowKindList.
type WorkflowKindList = []WorkflowKind

// WorkflowList defines model for WorkflowList.
type WorkflowList struct {
	Metadata   *APIResourceMeta    `json:"metadata,omitempty"`
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]Workflow         `json:"rows,omitempty"`
}

// WorkflowMetrics defines model for WorkflowMetrics.
type WorkflowMetrics struct {
	// GroupKeyCount The total number of concurrency group keys.
	GroupKeyCount *int `json:"groupKeyCount,omitempty"`

	// GroupKeyRunsCount The number of runs for a specific group key (passed via filter)
	GroupKeyRunsCount *int `json:"groupKeyRunsCount,omitempty"`
}

// WorkflowRun defines model for WorkflowRun.
type WorkflowRun struct {
	AdditionalMetadata *map[string]interface{} `json:"additionalMetadata,omitempty"`
	DisplayName        *string                 `json:"displayName,omitempty"`
	Duration           *int                    `json:"duration,omitempty"`
	Error              *string                 `json:"error,omitempty"`
	FinishedAt         *time.Time              `json:"finishedAt,omitempty"`
	Input              *map[string]interface{} `json:"input,omitempty"`
	JobRuns            *[]JobRun               `json:"jobRuns,omitempty"`
	Metadata           APIResourceMeta         `json:"metadata"`
	ParentId           *openapi_types.UUID     `json:"parentId,omitempty"`
	ParentStepRunId    *openapi_types.UUID     `json:"parentStepRunId,omitempty"`
	StartedAt          *time.Time              `json:"startedAt,omitempty"`
	Status             WorkflowRunStatus       `json:"status"`
	TenantId           string                  `json:"tenantId"`
	TriggeredBy        WorkflowRunTriggeredBy  `json:"triggeredBy"`
	WorkflowVersion    *WorkflowVersion        `json:"workflowVersion,omitempty"`
	WorkflowVersionId  string                  `json:"workflowVersionId"`
}

// WorkflowRunList defines model for WorkflowRunList.
type WorkflowRunList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]WorkflowRun      `json:"rows,omitempty"`
}

// WorkflowRunOrderByDirection defines model for WorkflowRunOrderByDirection.
type WorkflowRunOrderByDirection string

// WorkflowRunOrderByField defines model for WorkflowRunOrderByField.
type WorkflowRunOrderByField string

// WorkflowRunShape defines model for WorkflowRunShape.
type WorkflowRunShape struct {
	AdditionalMetadata *map[string]interface{} `json:"additionalMetadata,omitempty"`
	DisplayName        *string                 `json:"displayName,omitempty"`
	Duration           *int                    `json:"duration,omitempty"`
	Error              *string                 `json:"error,omitempty"`
	FinishedAt         *time.Time              `json:"finishedAt,omitempty"`
	Input              *map[string]interface{} `json:"input,omitempty"`
	JobRuns            *[]JobRun               `json:"jobRuns,omitempty"`
	Metadata           APIResourceMeta         `json:"metadata"`
	ParentId           *openapi_types.UUID     `json:"parentId,omitempty"`
	ParentStepRunId    *openapi_types.UUID     `json:"parentStepRunId,omitempty"`
	StartedAt          *time.Time              `json:"startedAt,omitempty"`
	Status             WorkflowRunStatus       `json:"status"`
	TenantId           string                  `json:"tenantId"`
	TriggeredBy        WorkflowRunTriggeredBy  `json:"triggeredBy"`
	WorkflowId         *string                 `json:"workflowId,omitempty"`
	WorkflowVersion    *WorkflowVersion        `json:"workflowVersion,omitempty"`
	WorkflowVersionId  string                  `json:"workflowVersionId"`
}

// WorkflowRunShapeForWorkflowRunDetails defines model for WorkflowRunShapeForWorkflowRunDetails.
type WorkflowRunShapeForWorkflowRunDetails = []WorkflowRunShapeItemForWorkflowRunDetails

// WorkflowRunShapeItemForWorkflowRunDetails defines model for WorkflowRunShapeItemForWorkflowRunDetails.
type WorkflowRunShapeItemForWorkflowRunDetails struct {
	ChildrenStepIds []openapi_types.UUID `json:"childrenStepIds"`
	StepId          openapi_types.UUID   `json:"stepId"`
	TaskExternalId  openapi_types.UUID   `json:"taskExternalId"`
	TaskName        string               `json:"taskName"`
}

// WorkflowRunStatus defines model for WorkflowRunStatus.
type WorkflowRunStatus string

// WorkflowRunStatusList defines model for WorkflowRunStatusList.
type WorkflowRunStatusList = []WorkflowRunStatus

// WorkflowRunTriggeredBy defines model for WorkflowRunTriggeredBy.
type WorkflowRunTriggeredBy struct {
	CronParentId        *string         `json:"cronParentId,omitempty"`
	CronSchedule        *string         `json:"cronSchedule,omitempty"`
	EventId             *string         `json:"eventId,omitempty"`
	Metadata            APIResourceMeta `json:"metadata"`
	ParentWorkflowRunId *string         `json:"parentWorkflowRunId,omitempty"`
}

// WorkflowRunsCancelRequest defines model for WorkflowRunsCancelRequest.
type WorkflowRunsCancelRequest struct {
	WorkflowRunIds []openapi_types.UUID `json:"workflowRunIds"`
}

// WorkflowRunsMetrics defines model for WorkflowRunsMetrics.
type WorkflowRunsMetrics struct {
	Counts *WorkflowRunsMetricsCounts `json:"counts,omitempty"`
}

// WorkflowRunsMetricsCounts defines model for WorkflowRunsMetricsCounts.
type WorkflowRunsMetricsCounts struct {
	CANCELLED *int `json:"CANCELLED,omitempty"`
	FAILED    *int `json:"FAILED,omitempty"`
	PENDING   *int `json:"PENDING,omitempty"`
	QUEUED    *int `json:"QUEUED,omitempty"`
	RUNNING   *int `json:"RUNNING,omitempty"`
	SUCCEEDED *int `json:"SUCCEEDED,omitempty"`
}

// WorkflowTag defines model for WorkflowTag.
type WorkflowTag struct {
	// Color The description of the workflow.
	Color string `json:"color"`

	// Name The name of the workflow.
	Name string `json:"name"`
}

// WorkflowTriggerCronRef defines model for WorkflowTriggerCronRef.
type WorkflowTriggerCronRef struct {
	Cron     *string `json:"cron,omitempty"`
	ParentId *string `json:"parent_id,omitempty"`
}

// WorkflowTriggerEventRef defines model for WorkflowTriggerEventRef.
type WorkflowTriggerEventRef struct {
	EventKey *string `json:"event_key,omitempty"`
	ParentId *string `json:"parent_id,omitempty"`
}

// WorkflowTriggers defines model for WorkflowTriggers.
type WorkflowTriggers struct {
	Crons             *[]WorkflowTriggerCronRef  `json:"crons,omitempty"`
	Events            *[]WorkflowTriggerEventRef `json:"events,omitempty"`
	Metadata          *APIResourceMeta           `json:"metadata,omitempty"`
	TenantId          *string                    `json:"tenant_id,omitempty"`
	WorkflowVersionId *string                    `json:"workflow_version_id,omitempty"`
}

// WorkflowUpdateRequest defines model for WorkflowUpdateRequest.
type WorkflowUpdateRequest struct {
	// IsPaused Whether the workflow is paused.
	IsPaused *bool `json:"isPaused,omitempty"`
}

// WorkflowVersion defines model for WorkflowVersion.
type WorkflowVersion struct {
	Concurrency *WorkflowConcurrency `json:"concurrency,omitempty"`

	// DefaultPriority The default priority of the workflow.
	DefaultPriority *int32          `json:"defaultPriority,omitempty"`
	Jobs            *[]Job          `json:"jobs,omitempty"`
	Metadata        APIResourceMeta `json:"metadata"`
	Order           int32           `json:"order"`
	ScheduleTimeout *string         `json:"scheduleTimeout,omitempty"`

	// Sticky The sticky strategy of the workflow.
	Sticky   *string           `json:"sticky,omitempty"`
	Triggers *WorkflowTriggers `json:"triggers,omitempty"`

	// Version The version of the workflow.
	Version        string                  `json:"version"`
	Workflow       *Workflow               `json:"workflow,omitempty"`
	WorkflowConfig *map[string]interface{} `json:"workflowConfig,omitempty"`
	WorkflowId     string                  `json:"workflowId"`
}

// WorkflowVersionMeta defines model for WorkflowVersionMeta.
type WorkflowVersionMeta struct {
	Metadata APIResourceMeta `json:"metadata"`
	Order    int32           `json:"order"`

	// Version The version of the workflow.
	Version    string    `json:"version"`
	Workflow   *Workflow `json:"workflow,omitempty"`
	WorkflowId string    `json:"workflowId"`
}

// WorkflowWorkersCount defines model for WorkflowWorkersCount.
type WorkflowWorkersCount struct {
	FreeSlotCount *int    `json:"freeSlotCount,omitempty"`
	MaxSlotCount  *int    `json:"maxSlotCount,omitempty"`
	WorkflowRunId *string `json:"workflowRunId,omitempty"`
}

// V1DagListTasksParams defines parameters for V1DagListTasks.
type V1DagListTasksParams struct {
	// DagIds The external id of the DAG
	DagIds []openapi_types.UUID `form:"dag_ids" json:"dag_ids"`

	// Tenant The tenant id
	Tenant openapi_types.UUID `form:"tenant" json:"tenant"`
}

// V1TaskGetParams defines parameters for V1TaskGet.
type V1TaskGetParams struct {
	// Attempt The attempt number
	Attempt *int `form:"attempt,omitempty" json:"attempt,omitempty"`
}

// V1TaskEventListParams defines parameters for V1TaskEventList.
type V1TaskEventListParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`
}

// V1EventListParams defines parameters for V1EventList.
type V1EventListParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Keys A list of keys to filter by
	Keys *[]EventKey `form:"keys,omitempty" json:"keys,omitempty"`

	// Since Consider events that occurred after this time
	Since *time.Time `form:"since,omitempty" json:"since,omitempty"`

	// Until Consider events that occurred before this time
	Until *time.Time `form:"until,omitempty" json:"until,omitempty"`

	// WorkflowIds Filter to events that are associated with a specific workflow run
	WorkflowIds *[]openapi_types.UUID `form:"workflowIds,omitempty" json:"workflowIds,omitempty"`

	// WorkflowRunStatuses Filter to events that are associated with workflow runs matching a certain status
	WorkflowRunStatuses *[]V1TaskStatus `form:"workflowRunStatuses,omitempty" json:"workflowRunStatuses,omitempty"`

	// EventIds Filter to specific events by their ids
	EventIds *[]openapi_types.UUID `form:"eventIds,omitempty" json:"eventIds,omitempty"`

	// AdditionalMetadata Filter by additional metadata on the events
	AdditionalMetadata *[]string `form:"additionalMetadata,omitempty" json:"additionalMetadata,omitempty"`

	// Scopes The scopes to filter by
	Scopes *[]string `form:"scopes,omitempty" json:"scopes,omitempty"`
}

// V1FilterListParams defines parameters for V1FilterList.
type V1FilterListParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// WorkflowIds The workflow ids to filter by
	WorkflowIds *[]openapi_types.UUID `form:"workflowIds,omitempty" json:"workflowIds,omitempty"`

	// Scopes The scopes to subset candidate filters by
	Scopes *[]string `form:"scopes,omitempty" json:"scopes,omitempty"`
}

// V1TaskListStatusMetricsParams defines parameters for V1TaskListStatusMetrics.
type V1TaskListStatusMetricsParams struct {
	// Since The start time to get metrics for
	Since time.Time `form:"since" json:"since"`

	// Until The end time to get metrics for
	Until *time.Time `form:"until,omitempty" json:"until,omitempty"`

	// WorkflowIds The workflow id to find runs for
	WorkflowIds *[]openapi_types.UUID `form:"workflow_ids,omitempty" json:"workflow_ids,omitempty"`

	// ParentTaskExternalId The parent task's external id
	ParentTaskExternalId *openapi_types.UUID `form:"parent_task_external_id,omitempty" json:"parent_task_external_id,omitempty"`

	// TriggeringEventExternalId The id of the event that triggered the task
	TriggeringEventExternalId *openapi_types.UUID `form:"triggering_event_external_id,omitempty" json:"triggering_event_external_id,omitempty"`
}

// V1TaskGetPointMetricsParams defines parameters for V1TaskGetPointMetrics.
type V1TaskGetPointMetricsParams struct {
	// CreatedAfter The time after the task was created
	CreatedAfter *time.Time `form:"createdAfter,omitempty" json:"createdAfter,omitempty"`

	// FinishedBefore The time before the task was completed
	FinishedBefore *time.Time `form:"finishedBefore,omitempty" json:"finishedBefore,omitempty"`
}

// V1WorkflowRunListParams defines parameters for V1WorkflowRunList.
type V1WorkflowRunListParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Statuses A list of statuses to filter by
	Statuses *[]V1TaskStatus `form:"statuses,omitempty" json:"statuses,omitempty"`

	// Since The earliest date to filter by
	Since time.Time `form:"since" json:"since"`

	// Until The latest date to filter by
	Until *time.Time `form:"until,omitempty" json:"until,omitempty"`

	// AdditionalMetadata Additional metadata k-v pairs to filter by
	AdditionalMetadata *[]string `form:"additional_metadata,omitempty" json:"additional_metadata,omitempty"`

	// WorkflowIds The workflow ids to find runs for
	WorkflowIds *[]openapi_types.UUID `form:"workflow_ids,omitempty" json:"workflow_ids,omitempty"`

	// WorkerId The worker id to filter by
	WorkerId *openapi_types.UUID `form:"worker_id,omitempty" json:"worker_id,omitempty"`

	// OnlyTasks Whether to include DAGs or only to include tasks
	OnlyTasks bool `form:"only_tasks" json:"only_tasks"`

	// ParentTaskExternalId The parent task external id to filter by
	ParentTaskExternalId *openapi_types.UUID `form:"parent_task_external_id,omitempty" json:"parent_task_external_id,omitempty"`

	// TriggeringEventExternalId The external id of the event that triggered the workflow run
	TriggeringEventExternalId *openapi_types.UUID `form:"triggering_event_external_id,omitempty" json:"triggering_event_external_id,omitempty"`

	// IncludePayloads A flag for whether or not to include the input and output payloads in the response. Defaults to `true` if unset.
	IncludePayloads *bool `form:"include_payloads,omitempty" json:"include_payloads,omitempty"`
}

// V1WorkflowRunDisplayNamesListParams defines parameters for V1WorkflowRunDisplayNamesList.
type V1WorkflowRunDisplayNamesListParams struct {
	// ExternalIds The external ids of the workflow runs to get display names for
	ExternalIds []openapi_types.UUID `form:"external_ids" json:"external_ids"`
}

// V1WorkflowRunTaskEventsListParams defines parameters for V1WorkflowRunTaskEventsList.
type V1WorkflowRunTaskEventsListParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`
}

// V1WorkflowRunGetTimingsParams defines parameters for V1WorkflowRunGetTimings.
type V1WorkflowRunGetTimingsParams struct {
	// Depth The depth to retrieve children
	Depth *int64 `form:"depth,omitempty" json:"depth,omitempty"`
}

// StepRunListArchivesParams defines parameters for StepRunListArchives.
type StepRunListArchivesParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`
}

// StepRunListEventsParams defines parameters for StepRunListEvents.
type StepRunListEventsParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`
}

// LogLineListParams defines parameters for LogLineList.
type LogLineListParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Levels A list of levels to filter by
	Levels *LogLineLevelField `form:"levels,omitempty" json:"levels,omitempty"`

	// Search The search query to filter for
	Search *LogLineSearch `form:"search,omitempty" json:"search,omitempty"`

	// OrderByField What to order by
	OrderByField *LogLineOrderByField `form:"orderByField,omitempty" json:"orderByField,omitempty"`

	// OrderByDirection The order direction
	OrderByDirection *LogLineOrderByDirection `form:"orderByDirection,omitempty" json:"orderByDirection,omitempty"`
}

// EventListParams defines parameters for EventList.
type EventListParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Keys A list of keys to filter by
	Keys *[]EventKey `form:"keys,omitempty" json:"keys,omitempty"`

	// Workflows A list of workflow IDs to filter by
	Workflows *[]WorkflowID `form:"workflows,omitempty" json:"workflows,omitempty"`

	// Statuses A list of workflow run statuses to filter by
	Statuses *WorkflowRunStatusList `form:"statuses,omitempty" json:"statuses,omitempty"`

	// Search The search query to filter for
	Search *EventSearch `form:"search,omitempty" json:"search,omitempty"`

	// OrderByField What to order by
	OrderByField *EventOrderByField `form:"orderByField,omitempty" json:"orderByField,omitempty"`

	// OrderByDirection The order direction
	OrderByDirection *EventOrderByDirection `form:"orderByDirection,omitempty" json:"orderByDirection,omitempty"`

	// AdditionalMetadata A list of metadata key value pairs to filter by
	AdditionalMetadata *[]string `form:"additionalMetadata,omitempty" json:"additionalMetadata,omitempty"`

	// EventIds A list of event ids to filter by
	EventIds *[]openapi_types.UUID `form:"eventIds,omitempty" json:"eventIds,omitempty"`
}

// TenantGetQueueMetricsParams defines parameters for TenantGetQueueMetrics.
type TenantGetQueueMetricsParams struct {
	// Workflows A list of workflow IDs to filter by
	Workflows *[]WorkflowID `form:"workflows,omitempty" json:"workflows,omitempty"`

	// AdditionalMetadata A list of metadata key value pairs to filter by
	AdditionalMetadata *[]string `form:"additionalMetadata,omitempty" json:"additionalMetadata,omitempty"`
}

// RateLimitListParams defines parameters for RateLimitList.
type RateLimitListParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Search The search query to filter for
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// OrderByField What to order by
	OrderByField *RateLimitOrderByField `form:"orderByField,omitempty" json:"orderByField,omitempty"`

	// OrderByDirection The order direction
	OrderByDirection *RateLimitOrderByDirection `form:"orderByDirection,omitempty" json:"orderByDirection,omitempty"`
}

// WorkflowRunListStepRunEventsParams defines parameters for WorkflowRunListStepRunEvents.
type WorkflowRunListStepRunEventsParams struct {
	// LastId Last ID of the last event
	LastId *int32 `form:"lastId,omitempty" json:"lastId,omitempty"`
}

// WorkflowListParams defines parameters for WorkflowList.
type WorkflowListParams struct {
	// Offset The number to skip
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Name Search by name
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// CronWorkflowListParams defines parameters for CronWorkflowList.
type CronWorkflowListParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// WorkflowId The workflow id to get runs for.
	WorkflowId *openapi_types.UUID `form:"workflowId,omitempty" json:"workflowId,omitempty"`

	// WorkflowName The workflow name to get runs for.
	WorkflowName *string `form:"workflowName,omitempty" json:"workflowName,omitempty"`

	// CronName The cron name to get runs for.
	CronName *string `form:"cronName,omitempty" json:"cronName,omitempty"`

	// AdditionalMetadata A list of metadata key value pairs to filter by
	AdditionalMetadata *[]string `form:"additionalMetadata,omitempty" json:"additionalMetadata,omitempty"`

	// OrderByField The order by field
	OrderByField *CronWorkflowsOrderByField `form:"orderByField,omitempty" json:"orderByField,omitempty"`

	// OrderByDirection The order by direction
	OrderByDirection *WorkflowRunOrderByDirection `form:"orderByDirection,omitempty" json:"orderByDirection,omitempty"`
}

// WorkflowRunListParams defines parameters for WorkflowRunList.
type WorkflowRunListParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// EventId The event id to get runs for.
	EventId *openapi_types.UUID `form:"eventId,omitempty" json:"eventId,omitempty"`

	// WorkflowId The workflow id to get runs for.
	WorkflowId *openapi_types.UUID `form:"workflowId,omitempty" json:"workflowId,omitempty"`

	// ParentWorkflowRunId The parent workflow run id
	ParentWorkflowRunId *openapi_types.UUID `form:"parentWorkflowRunId,omitempty" json:"parentWorkflowRunId,omitempty"`

	// ParentStepRunId The parent step run id
	ParentStepRunId *openapi_types.UUID `form:"parentStepRunId,omitempty" json:"parentStepRunId,omitempty"`

	// Statuses A list of workflow run statuses to filter by
	Statuses *WorkflowRunStatusList `form:"statuses,omitempty" json:"statuses,omitempty"`

	// Kinds A list of workflow kinds to filter by
	Kinds *WorkflowKindList `form:"kinds,omitempty" json:"kinds,omitempty"`

	// AdditionalMetadata A list of metadata key value pairs to filter by
	AdditionalMetadata *[]string `form:"additionalMetadata,omitempty" json:"additionalMetadata,omitempty"`

	// CreatedAfter The time after the workflow run was created
	CreatedAfter *time.Time `form:"createdAfter,omitempty" json:"createdAfter,omitempty"`

	// CreatedBefore The time before the workflow run was created
	CreatedBefore *time.Time `form:"createdBefore,omitempty" json:"createdBefore,omitempty"`

	// FinishedAfter The time after the workflow run was finished
	FinishedAfter *time.Time `form:"finishedAfter,omitempty" json:"finishedAfter,omitempty"`

	// FinishedBefore The time before the workflow run was finished
	FinishedBefore *time.Time `form:"finishedBefore,omitempty" json:"finishedBefore,omitempty"`

	// OrderByField The order by field
	OrderByField *WorkflowRunOrderByField `form:"orderByField,omitempty" json:"orderByField,omitempty"`

	// OrderByDirection The order by direction
	OrderByDirection *WorkflowRunOrderByDirection `form:"orderByDirection,omitempty" json:"orderByDirection,omitempty"`
}

// WorkflowRunGetMetricsParams defines parameters for WorkflowRunGetMetrics.
type WorkflowRunGetMetricsParams struct {
	// EventId The event id to get runs for.
	EventId *openapi_types.UUID `form:"eventId,omitempty" json:"eventId,omitempty"`

	// WorkflowId The workflow id to get runs for.
	WorkflowId *openapi_types.UUID `form:"workflowId,omitempty" json:"workflowId,omitempty"`

	// ParentWorkflowRunId The parent workflow run id
	ParentWorkflowRunId *openapi_types.UUID `form:"parentWorkflowRunId,omitempty" json:"parentWorkflowRunId,omitempty"`

	// ParentStepRunId The parent step run id
	ParentStepRunId *openapi_types.UUID `form:"parentStepRunId,omitempty" json:"parentStepRunId,omitempty"`

	// AdditionalMetadata A list of metadata key value pairs to filter by
	AdditionalMetadata *[]string `form:"additionalMetadata,omitempty" json:"additionalMetadata,omitempty"`

	// CreatedAfter The time after the workflow run was created
	CreatedAfter *time.Time `form:"createdAfter,omitempty" json:"createdAfter,omitempty"`

	// CreatedBefore The time before the workflow run was created
	CreatedBefore *time.Time `form:"createdBefore,omitempty" json:"createdBefore,omitempty"`
}

// WorkflowScheduledListParams defines parameters for WorkflowScheduledList.
type WorkflowScheduledListParams struct {
	// Offset The number to skip
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number to limit by
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderByField The order by field
	OrderByField *ScheduledWorkflowsOrderByField `form:"orderByField,omitempty" json:"orderByField,omitempty"`

	// OrderByDirection The order by direction
	OrderByDirection *WorkflowRunOrderByDirection `form:"orderByDirection,omitempty" json:"orderByDirection,omitempty"`

	// WorkflowId The workflow id to get runs for.
	WorkflowId *openapi_types.UUID `form:"workflowId,omitempty" json:"workflowId,omitempty"`

	// ParentWorkflowRunId The parent workflow run id
	ParentWorkflowRunId *openapi_types.UUID `form:"parentWorkflowRunId,omitempty" json:"parentWorkflowRunId,omitempty"`

	// ParentStepRunId The parent step run id
	ParentStepRunId *openapi_types.UUID `form:"parentStepRunId,omitempty" json:"parentStepRunId,omitempty"`

	// AdditionalMetadata A list of metadata key value pairs to filter by
	AdditionalMetadata *[]string `form:"additionalMetadata,omitempty" json:"additionalMetadata,omitempty"`

	// Statuses A list of scheduled run statuses to filter by
	Statuses *[]ScheduledRunStatus `form:"statuses,omitempty" json:"statuses,omitempty"`
}

// WorkflowGetMetricsParams defines parameters for WorkflowGetMetrics.
type WorkflowGetMetricsParams struct {
	// Status A status of workflow run statuses to filter by
	Status *WorkflowRunStatus `form:"status,omitempty" json:"status,omitempty"`

	// GroupKey A group key to filter metrics by
	GroupKey *string `form:"groupKey,omitempty" json:"groupKey,omitempty"`
}

// WorkflowRunCreateParams defines parameters for WorkflowRunCreate.
type WorkflowRunCreateParams struct {
	// Version The workflow version. If not supplied, the latest version is fetched.
	Version *openapi_types.UUID `form:"version,omitempty" json:"version,omitempty"`
}

// WorkflowVersionGetParams defines parameters for WorkflowVersionGet.
type WorkflowVersionGetParams struct {
	// Version The workflow version. If not supplied, the latest version is fetched.
	Version *openapi_types.UUID `form:"version,omitempty" json:"version,omitempty"`
}

// AlertEmailGroupUpdateJSONRequestBody defines body for AlertEmailGroupUpdate for application/json ContentType.
type AlertEmailGroupUpdateJSONRequestBody = UpdateTenantAlertEmailGroupRequest

// V1FilterCreateJSONRequestBody defines body for V1FilterCreate for application/json ContentType.
type V1FilterCreateJSONRequestBody = V1CreateFilterRequest

// V1FilterUpdateJSONRequestBody defines body for V1FilterUpdate for application/json ContentType.
type V1FilterUpdateJSONRequestBody = V1UpdateFilterRequest

// V1TaskCancelJSONRequestBody defines body for V1TaskCancel for application/json ContentType.
type V1TaskCancelJSONRequestBody = V1CancelTaskRequest

// V1TaskReplayJSONRequestBody defines body for V1TaskReplay for application/json ContentType.
type V1TaskReplayJSONRequestBody = V1ReplayTaskRequest

// V1WorkflowRunCreateJSONRequestBody defines body for V1WorkflowRunCreate for application/json ContentType.
type V1WorkflowRunCreateJSONRequestBody = V1TriggerWorkflowRunRequest

// TenantCreateJSONRequestBody defines body for TenantCreate for application/json ContentType.
type TenantCreateJSONRequestBody = CreateTenantRequest

// TenantUpdateJSONRequestBody defines body for TenantUpdate for application/json ContentType.
type TenantUpdateJSONRequestBody = UpdateTenantRequest

// AlertEmailGroupCreateJSONRequestBody defines body for AlertEmailGroupCreate for application/json ContentType.
type AlertEmailGroupCreateJSONRequestBody = CreateTenantAlertEmailGroupRequest

// ApiTokenCreateJSONRequestBody defines body for ApiTokenCreate for application/json ContentType.
type ApiTokenCreateJSONRequestBody = CreateAPITokenRequest

// EventCreateJSONRequestBody defines body for EventCreate for application/json ContentType.
type EventCreateJSONRequestBody = CreateEventRequest

// EventCreateBulkJSONRequestBody defines body for EventCreateBulk for application/json ContentType.
type EventCreateBulkJSONRequestBody = BulkCreateEventRequest

// EventUpdateCancelJSONRequestBody defines body for EventUpdateCancel for application/json ContentType.
type EventUpdateCancelJSONRequestBody = CancelEventRequest

// EventUpdateReplayJSONRequestBody defines body for EventUpdateReplay for application/json ContentType.
type EventUpdateReplayJSONRequestBody = ReplayEventRequest

// TenantInviteCreateJSONRequestBody defines body for TenantInviteCreate for application/json ContentType.
type TenantInviteCreateJSONRequestBody = CreateTenantInviteRequest

// TenantInviteUpdateJSONRequestBody defines body for TenantInviteUpdate for application/json ContentType.
type TenantInviteUpdateJSONRequestBody = UpdateTenantInviteRequest

// SnsCreateJSONRequestBody defines body for SnsCreate for application/json ContentType.
type SnsCreateJSONRequestBody = CreateSNSIntegrationRequest

// StepRunUpdateRerunJSONRequestBody defines body for StepRunUpdateRerun for application/json ContentType.
type StepRunUpdateRerunJSONRequestBody = RerunStepRunRequest

// WebhookCreateJSONRequestBody defines body for WebhookCreate for application/json ContentType.
type WebhookCreateJSONRequestBody = WebhookWorkerCreateRequest

// WorkflowRunUpdateReplayJSONRequestBody defines body for WorkflowRunUpdateReplay for application/json ContentType.
type WorkflowRunUpdateReplayJSONRequestBody = ReplayWorkflowRunsRequest

// WorkflowRunCancelJSONRequestBody defines body for WorkflowRunCancel for application/json ContentType.
type WorkflowRunCancelJSONRequestBody = WorkflowRunsCancelRequest

// CronWorkflowTriggerCreateJSONRequestBody defines body for CronWorkflowTriggerCreate for application/json ContentType.
type CronWorkflowTriggerCreateJSONRequestBody = CreateCronWorkflowTriggerRequest

// ScheduledWorkflowRunCreateJSONRequestBody defines body for ScheduledWorkflowRunCreate for application/json ContentType.
type ScheduledWorkflowRunCreateJSONRequestBody = ScheduleWorkflowRunRequest

// TenantInviteAcceptJSONRequestBody defines body for TenantInviteAccept for application/json ContentType.
type TenantInviteAcceptJSONRequestBody = AcceptInviteRequest

// TenantInviteRejectJSONRequestBody defines body for TenantInviteReject for application/json ContentType.
type TenantInviteRejectJSONRequestBody = RejectInviteRequest

// UserUpdateLoginJSONRequestBody defines body for UserUpdateLogin for application/json ContentType.
type UserUpdateLoginJSONRequestBody = UserLoginRequest

// UserUpdatePasswordJSONRequestBody defines body for UserUpdatePassword for application/json ContentType.
type UserUpdatePasswordJSONRequestBody = UserChangePasswordRequest

// UserCreateJSONRequestBody defines body for UserCreate for application/json ContentType.
type UserCreateJSONRequestBody = UserRegisterRequest

// WorkerUpdateJSONRequestBody defines body for WorkerUpdate for application/json ContentType.
type WorkerUpdateJSONRequestBody = UpdateWorkerRequest

// WorkflowUpdateJSONRequestBody defines body for WorkflowUpdate for application/json ContentType.
type WorkflowUpdateJSONRequestBody = WorkflowUpdateRequest

// WorkflowRunCreateJSONRequestBody defines body for WorkflowRunCreate for application/json ContentType.
type WorkflowRunCreateJSONRequestBody = TriggerWorkflowRunRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// LivenessGet request
	LivenessGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadinessGet request
	ReadinessGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertEmailGroupDelete request
	AlertEmailGroupDelete(ctx context.Context, alertEmailGroup openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertEmailGroupUpdateWithBody request with any body
	AlertEmailGroupUpdateWithBody(ctx context.Context, alertEmailGroup openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AlertEmailGroupUpdate(ctx context.Context, alertEmailGroup openapi_types.UUID, body AlertEmailGroupUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiTokenUpdateRevoke request
	ApiTokenUpdateRevoke(ctx context.Context, apiToken openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CloudMetadataGet request
	CloudMetadataGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventGet request
	EventGet(ctx context.Context, event openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventDataGet request
	EventDataGet(ctx context.Context, event openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetadataGet request
	MetadataGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetadataListIntegrations request
	MetadataListIntegrations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MonitoringPostRunProbe request
	MonitoringPostRunProbe(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlackWebhookDelete request
	SlackWebhookDelete(ctx context.Context, slack openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnsDelete request
	SnsDelete(ctx context.Context, sns openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnsUpdate request
	SnsUpdate(ctx context.Context, tenant openapi_types.UUID, event string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1DagListTasks request
	V1DagListTasks(ctx context.Context, params *V1DagListTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1TaskGet request
	V1TaskGet(ctx context.Context, task openapi_types.UUID, params *V1TaskGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1LogLineList request
	V1LogLineList(ctx context.Context, task openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1TaskEventList request
	V1TaskEventList(ctx context.Context, task openapi_types.UUID, params *V1TaskEventListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1EventList request
	V1EventList(ctx context.Context, tenant openapi_types.UUID, params *V1EventListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1EventKeyList request
	V1EventKeyList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1FilterList request
	V1FilterList(ctx context.Context, tenant openapi_types.UUID, params *V1FilterListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1FilterCreateWithBody request with any body
	V1FilterCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	V1FilterCreate(ctx context.Context, tenant openapi_types.UUID, body V1FilterCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1FilterDelete request
	V1FilterDelete(ctx context.Context, tenant openapi_types.UUID, v1Filter openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1FilterGet request
	V1FilterGet(ctx context.Context, tenant openapi_types.UUID, v1Filter openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1FilterUpdateWithBody request with any body
	V1FilterUpdateWithBody(ctx context.Context, tenant openapi_types.UUID, v1Filter openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	V1FilterUpdate(ctx context.Context, tenant openapi_types.UUID, v1Filter openapi_types.UUID, body V1FilterUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1TaskListStatusMetrics request
	V1TaskListStatusMetrics(ctx context.Context, tenant openapi_types.UUID, params *V1TaskListStatusMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1TaskGetPointMetrics request
	V1TaskGetPointMetrics(ctx context.Context, tenant openapi_types.UUID, params *V1TaskGetPointMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1TaskCancelWithBody request with any body
	V1TaskCancelWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	V1TaskCancel(ctx context.Context, tenant openapi_types.UUID, body V1TaskCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1TaskReplayWithBody request with any body
	V1TaskReplayWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	V1TaskReplay(ctx context.Context, tenant openapi_types.UUID, body V1TaskReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1WorkflowRunList request
	V1WorkflowRunList(ctx context.Context, tenant openapi_types.UUID, params *V1WorkflowRunListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1WorkflowRunDisplayNamesList request
	V1WorkflowRunDisplayNamesList(ctx context.Context, tenant openapi_types.UUID, params *V1WorkflowRunDisplayNamesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1WorkflowRunCreateWithBody request with any body
	V1WorkflowRunCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	V1WorkflowRunCreate(ctx context.Context, tenant openapi_types.UUID, body V1WorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1WorkflowRunGet request
	V1WorkflowRunGet(ctx context.Context, v1WorkflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1WorkflowRunGetStatus request
	V1WorkflowRunGetStatus(ctx context.Context, v1WorkflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1WorkflowRunTaskEventsList request
	V1WorkflowRunTaskEventsList(ctx context.Context, v1WorkflowRun openapi_types.UUID, params *V1WorkflowRunTaskEventsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// V1WorkflowRunGetTimings request
	V1WorkflowRunGetTimings(ctx context.Context, v1WorkflowRun openapi_types.UUID, params *V1WorkflowRunGetTimingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunListArchives request
	StepRunListArchives(ctx context.Context, stepRun openapi_types.UUID, params *StepRunListArchivesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunListEvents request
	StepRunListEvents(ctx context.Context, stepRun openapi_types.UUID, params *StepRunListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogLineList request
	LogLineList(ctx context.Context, stepRun openapi_types.UUID, params *LogLineListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantCreateWithBody request with any body
	TenantCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantCreate(ctx context.Context, body TenantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantGet request
	TenantGet(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantUpdateWithBody request with any body
	TenantUpdateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantUpdate(ctx context.Context, tenant openapi_types.UUID, body TenantUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertEmailGroupList request
	AlertEmailGroupList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertEmailGroupCreateWithBody request with any body
	AlertEmailGroupCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AlertEmailGroupCreate(ctx context.Context, tenant openapi_types.UUID, body AlertEmailGroupCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantAlertingSettingsGet request
	TenantAlertingSettingsGet(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiTokenList request
	ApiTokenList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApiTokenCreateWithBody request with any body
	ApiTokenCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApiTokenCreate(ctx context.Context, tenant openapi_types.UUID, body ApiTokenCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventList request
	EventList(ctx context.Context, tenant openapi_types.UUID, params *EventListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventCreateWithBody request with any body
	EventCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EventCreate(ctx context.Context, tenant openapi_types.UUID, body EventCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventCreateBulkWithBody request with any body
	EventCreateBulkWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EventCreateBulk(ctx context.Context, tenant openapi_types.UUID, body EventCreateBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventUpdateCancelWithBody request with any body
	EventUpdateCancelWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EventUpdateCancel(ctx context.Context, tenant openapi_types.UUID, body EventUpdateCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventKeyList request
	EventKeyList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventUpdateReplayWithBody request with any body
	EventUpdateReplayWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EventUpdateReplay(ctx context.Context, tenant openapi_types.UUID, body EventUpdateReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteList request
	TenantInviteList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteCreateWithBody request with any body
	TenantInviteCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantInviteCreate(ctx context.Context, tenant openapi_types.UUID, body TenantInviteCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteDelete request
	TenantInviteDelete(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteUpdateWithBody request with any body
	TenantInviteUpdateWithBody(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantInviteUpdate(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, body TenantInviteUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantMemberList request
	TenantMemberList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantMemberDelete request
	TenantMemberDelete(ctx context.Context, tenant openapi_types.UUID, member openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantGetPrometheusMetrics request
	TenantGetPrometheusMetrics(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantGetQueueMetrics request
	TenantGetQueueMetrics(ctx context.Context, tenant openapi_types.UUID, params *TenantGetQueueMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RateLimitList request
	RateLimitList(ctx context.Context, tenant openapi_types.UUID, params *RateLimitListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantResourcePolicyGet request
	TenantResourcePolicyGet(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlackWebhookList request
	SlackWebhookList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateSlackOauthStart request
	UserUpdateSlackOauthStart(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnsList request
	SnsList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnsCreateWithBody request with any body
	SnsCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SnsCreate(ctx context.Context, tenant openapi_types.UUID, body SnsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantGetStepRunQueueMetrics request
	TenantGetStepRunQueueMetrics(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunGet request
	StepRunGet(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunUpdateCancel request
	StepRunUpdateCancel(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunUpdateRerunWithBody request with any body
	StepRunUpdateRerunWithBody(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StepRunUpdateRerun(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, body StepRunUpdateRerunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StepRunGetSchema request
	StepRunGetSchema(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhookList request
	WebhookList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhookCreateWithBody request with any body
	WebhookCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebhookCreate(ctx context.Context, tenant openapi_types.UUID, body WebhookCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerList request
	WorkerList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunUpdateReplayWithBody request with any body
	WorkflowRunUpdateReplayWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorkflowRunUpdateReplay(ctx context.Context, tenant openapi_types.UUID, body WorkflowRunUpdateReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunGet request
	WorkflowRunGet(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunGetInput request
	WorkflowRunGetInput(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunGetShape request
	WorkflowRunGetShape(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunListStepRunEvents request
	WorkflowRunListStepRunEvents(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, params *WorkflowRunListStepRunEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowList request
	WorkflowList(ctx context.Context, tenant openapi_types.UUID, params *WorkflowListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunCancelWithBody request with any body
	WorkflowRunCancelWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorkflowRunCancel(ctx context.Context, tenant openapi_types.UUID, body WorkflowRunCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CronWorkflowList request
	CronWorkflowList(ctx context.Context, tenant openapi_types.UUID, params *CronWorkflowListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowCronDelete request
	WorkflowCronDelete(ctx context.Context, tenant openapi_types.UUID, cronWorkflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowCronGet request
	WorkflowCronGet(ctx context.Context, tenant openapi_types.UUID, cronWorkflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunList request
	WorkflowRunList(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunGetMetrics request
	WorkflowRunGetMetrics(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunGetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowScheduledList request
	WorkflowScheduledList(ctx context.Context, tenant openapi_types.UUID, params *WorkflowScheduledListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowScheduledDelete request
	WorkflowScheduledDelete(ctx context.Context, tenant openapi_types.UUID, scheduledWorkflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowScheduledGet request
	WorkflowScheduledGet(ctx context.Context, tenant openapi_types.UUID, scheduledWorkflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CronWorkflowTriggerCreateWithBody request with any body
	CronWorkflowTriggerCreateWithBody(ctx context.Context, tenant openapi_types.UUID, workflow string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CronWorkflowTriggerCreate(ctx context.Context, tenant openapi_types.UUID, workflow string, body CronWorkflowTriggerCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScheduledWorkflowRunCreateWithBody request with any body
	ScheduledWorkflowRunCreateWithBody(ctx context.Context, tenant openapi_types.UUID, workflow string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScheduledWorkflowRunCreate(ctx context.Context, tenant openapi_types.UUID, workflow string, body ScheduledWorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowGetWorkersCount request
	WorkflowGetWorkersCount(ctx context.Context, tenant openapi_types.UUID, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserGetCurrent request
	UserGetCurrent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateGithubOauthCallback request
	UserUpdateGithubOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateGithubOauthStart request
	UserUpdateGithubOauthStart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateGoogleOauthCallback request
	UserUpdateGoogleOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateGoogleOauthStart request
	UserUpdateGoogleOauthStart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserListTenantInvites request
	UserListTenantInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteAcceptWithBody request with any body
	TenantInviteAcceptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantInviteAccept(ctx context.Context, body TenantInviteAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantInviteRejectWithBody request with any body
	TenantInviteRejectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantInviteReject(ctx context.Context, body TenantInviteRejectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateLoginWithBody request with any body
	UserUpdateLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserUpdateLogin(ctx context.Context, body UserUpdateLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateLogout request
	UserUpdateLogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantMembershipsList request
	TenantMembershipsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdatePasswordWithBody request with any body
	UserUpdatePasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserUpdatePassword(ctx context.Context, body UserUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserCreateWithBody request with any body
	UserCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserCreate(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateSlackOauthCallback request
	UserUpdateSlackOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InfoGetVersion request
	InfoGetVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhookDelete request
	WebhookDelete(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebhookRequestsList request
	WebhookRequestsList(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerGet request
	WorkerGet(ctx context.Context, worker openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerUpdateWithBody request with any body
	WorkerUpdateWithBody(ctx context.Context, worker openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorkerUpdate(ctx context.Context, worker openapi_types.UUID, body WorkerUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowDelete request
	WorkflowDelete(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowGet request
	WorkflowGet(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowUpdateWithBody request with any body
	WorkflowUpdateWithBody(ctx context.Context, workflow openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorkflowUpdate(ctx context.Context, workflow openapi_types.UUID, body WorkflowUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowGetMetrics request
	WorkflowGetMetrics(ctx context.Context, workflow openapi_types.UUID, params *WorkflowGetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunCreateWithBody request with any body
	WorkflowRunCreateWithBody(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WorkflowRunCreate(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, body WorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowVersionGet request
	WorkflowVersionGet(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) LivenessGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLivenessGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadinessGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadinessGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertEmailGroupDelete(ctx context.Context, alertEmailGroup openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertEmailGroupDeleteRequest(c.Server, alertEmailGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertEmailGroupUpdateWithBody(ctx context.Context, alertEmailGroup openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertEmailGroupUpdateRequestWithBody(c.Server, alertEmailGroup, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertEmailGroupUpdate(ctx context.Context, alertEmailGroup openapi_types.UUID, body AlertEmailGroupUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertEmailGroupUpdateRequest(c.Server, alertEmailGroup, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiTokenUpdateRevoke(ctx context.Context, apiToken openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiTokenUpdateRevokeRequest(c.Server, apiToken)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloudMetadataGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloudMetadataGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventGet(ctx context.Context, event openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventGetRequest(c.Server, event)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventDataGet(ctx context.Context, event openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventDataGetRequest(c.Server, event)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataListIntegrations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataListIntegrationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MonitoringPostRunProbe(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMonitoringPostRunProbeRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlackWebhookDelete(ctx context.Context, slack openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlackWebhookDeleteRequest(c.Server, slack)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnsDelete(ctx context.Context, sns openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnsDeleteRequest(c.Server, sns)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnsUpdate(ctx context.Context, tenant openapi_types.UUID, event string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnsUpdateRequest(c.Server, tenant, event)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1DagListTasks(ctx context.Context, params *V1DagListTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1DagListTasksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1TaskGet(ctx context.Context, task openapi_types.UUID, params *V1TaskGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1TaskGetRequest(c.Server, task, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1LogLineList(ctx context.Context, task openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1LogLineListRequest(c.Server, task)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1TaskEventList(ctx context.Context, task openapi_types.UUID, params *V1TaskEventListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1TaskEventListRequest(c.Server, task, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1EventList(ctx context.Context, tenant openapi_types.UUID, params *V1EventListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1EventListRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1EventKeyList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1EventKeyListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1FilterList(ctx context.Context, tenant openapi_types.UUID, params *V1FilterListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1FilterListRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1FilterCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1FilterCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1FilterCreate(ctx context.Context, tenant openapi_types.UUID, body V1FilterCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1FilterCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1FilterDelete(ctx context.Context, tenant openapi_types.UUID, v1Filter openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1FilterDeleteRequest(c.Server, tenant, v1Filter)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1FilterGet(ctx context.Context, tenant openapi_types.UUID, v1Filter openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1FilterGetRequest(c.Server, tenant, v1Filter)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1FilterUpdateWithBody(ctx context.Context, tenant openapi_types.UUID, v1Filter openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1FilterUpdateRequestWithBody(c.Server, tenant, v1Filter, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1FilterUpdate(ctx context.Context, tenant openapi_types.UUID, v1Filter openapi_types.UUID, body V1FilterUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1FilterUpdateRequest(c.Server, tenant, v1Filter, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1TaskListStatusMetrics(ctx context.Context, tenant openapi_types.UUID, params *V1TaskListStatusMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1TaskListStatusMetricsRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1TaskGetPointMetrics(ctx context.Context, tenant openapi_types.UUID, params *V1TaskGetPointMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1TaskGetPointMetricsRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1TaskCancelWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1TaskCancelRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1TaskCancel(ctx context.Context, tenant openapi_types.UUID, body V1TaskCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1TaskCancelRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1TaskReplayWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1TaskReplayRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1TaskReplay(ctx context.Context, tenant openapi_types.UUID, body V1TaskReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1TaskReplayRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1WorkflowRunList(ctx context.Context, tenant openapi_types.UUID, params *V1WorkflowRunListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1WorkflowRunListRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1WorkflowRunDisplayNamesList(ctx context.Context, tenant openapi_types.UUID, params *V1WorkflowRunDisplayNamesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1WorkflowRunDisplayNamesListRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1WorkflowRunCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1WorkflowRunCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1WorkflowRunCreate(ctx context.Context, tenant openapi_types.UUID, body V1WorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1WorkflowRunCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1WorkflowRunGet(ctx context.Context, v1WorkflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1WorkflowRunGetRequest(c.Server, v1WorkflowRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1WorkflowRunGetStatus(ctx context.Context, v1WorkflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1WorkflowRunGetStatusRequest(c.Server, v1WorkflowRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1WorkflowRunTaskEventsList(ctx context.Context, v1WorkflowRun openapi_types.UUID, params *V1WorkflowRunTaskEventsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1WorkflowRunTaskEventsListRequest(c.Server, v1WorkflowRun, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) V1WorkflowRunGetTimings(ctx context.Context, v1WorkflowRun openapi_types.UUID, params *V1WorkflowRunGetTimingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewV1WorkflowRunGetTimingsRequest(c.Server, v1WorkflowRun, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunListArchives(ctx context.Context, stepRun openapi_types.UUID, params *StepRunListArchivesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunListArchivesRequest(c.Server, stepRun, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunListEvents(ctx context.Context, stepRun openapi_types.UUID, params *StepRunListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunListEventsRequest(c.Server, stepRun, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogLineList(ctx context.Context, stepRun openapi_types.UUID, params *LogLineListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogLineListRequest(c.Server, stepRun, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantCreate(ctx context.Context, body TenantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantGet(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantGetRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantUpdateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantUpdateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantUpdate(ctx context.Context, tenant openapi_types.UUID, body TenantUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantUpdateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertEmailGroupList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertEmailGroupListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertEmailGroupCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertEmailGroupCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertEmailGroupCreate(ctx context.Context, tenant openapi_types.UUID, body AlertEmailGroupCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertEmailGroupCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantAlertingSettingsGet(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantAlertingSettingsGetRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiTokenList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiTokenListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiTokenCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiTokenCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApiTokenCreate(ctx context.Context, tenant openapi_types.UUID, body ApiTokenCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApiTokenCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventList(ctx context.Context, tenant openapi_types.UUID, params *EventListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventListRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventCreate(ctx context.Context, tenant openapi_types.UUID, body EventCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventCreateBulkWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventCreateBulkRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventCreateBulk(ctx context.Context, tenant openapi_types.UUID, body EventCreateBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventCreateBulkRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventUpdateCancelWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventUpdateCancelRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventUpdateCancel(ctx context.Context, tenant openapi_types.UUID, body EventUpdateCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventUpdateCancelRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventKeyList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventKeyListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventUpdateReplayWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventUpdateReplayRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventUpdateReplay(ctx context.Context, tenant openapi_types.UUID, body EventUpdateReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventUpdateReplayRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteCreate(ctx context.Context, tenant openapi_types.UUID, body TenantInviteCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteDelete(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteDeleteRequest(c.Server, tenant, tenantInvite)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteUpdateWithBody(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteUpdateRequestWithBody(c.Server, tenant, tenantInvite, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteUpdate(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, body TenantInviteUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteUpdateRequest(c.Server, tenant, tenantInvite, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantMemberList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantMemberListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantMemberDelete(ctx context.Context, tenant openapi_types.UUID, member openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantMemberDeleteRequest(c.Server, tenant, member)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantGetPrometheusMetrics(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantGetPrometheusMetricsRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantGetQueueMetrics(ctx context.Context, tenant openapi_types.UUID, params *TenantGetQueueMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantGetQueueMetricsRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RateLimitList(ctx context.Context, tenant openapi_types.UUID, params *RateLimitListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRateLimitListRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantResourcePolicyGet(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantResourcePolicyGetRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlackWebhookList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlackWebhookListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateSlackOauthStart(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateSlackOauthStartRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnsList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnsListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnsCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnsCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnsCreate(ctx context.Context, tenant openapi_types.UUID, body SnsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnsCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantGetStepRunQueueMetrics(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantGetStepRunQueueMetricsRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunGet(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunGetRequest(c.Server, tenant, stepRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunUpdateCancel(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunUpdateCancelRequest(c.Server, tenant, stepRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunUpdateRerunWithBody(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunUpdateRerunRequestWithBody(c.Server, tenant, stepRun, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunUpdateRerun(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, body StepRunUpdateRerunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunUpdateRerunRequest(c.Server, tenant, stepRun, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StepRunGetSchema(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStepRunGetSchemaRequest(c.Server, tenant, stepRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhookList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhookListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhookCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhookCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhookCreate(ctx context.Context, tenant openapi_types.UUID, body WebhookCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhookCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunUpdateReplayWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunUpdateReplayRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunUpdateReplay(ctx context.Context, tenant openapi_types.UUID, body WorkflowRunUpdateReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunUpdateReplayRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunGet(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunGetRequest(c.Server, tenant, workflowRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunGetInput(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunGetInputRequest(c.Server, tenant, workflowRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunGetShape(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunGetShapeRequest(c.Server, tenant, workflowRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunListStepRunEvents(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, params *WorkflowRunListStepRunEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunListStepRunEventsRequest(c.Server, tenant, workflowRun, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowList(ctx context.Context, tenant openapi_types.UUID, params *WorkflowListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowListRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunCancelWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunCancelRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunCancel(ctx context.Context, tenant openapi_types.UUID, body WorkflowRunCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunCancelRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CronWorkflowList(ctx context.Context, tenant openapi_types.UUID, params *CronWorkflowListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCronWorkflowListRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowCronDelete(ctx context.Context, tenant openapi_types.UUID, cronWorkflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowCronDeleteRequest(c.Server, tenant, cronWorkflow)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowCronGet(ctx context.Context, tenant openapi_types.UUID, cronWorkflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowCronGetRequest(c.Server, tenant, cronWorkflow)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunList(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunListRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunGetMetrics(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunGetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunGetMetricsRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowScheduledList(ctx context.Context, tenant openapi_types.UUID, params *WorkflowScheduledListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowScheduledListRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowScheduledDelete(ctx context.Context, tenant openapi_types.UUID, scheduledWorkflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowScheduledDeleteRequest(c.Server, tenant, scheduledWorkflowRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowScheduledGet(ctx context.Context, tenant openapi_types.UUID, scheduledWorkflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowScheduledGetRequest(c.Server, tenant, scheduledWorkflowRun)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CronWorkflowTriggerCreateWithBody(ctx context.Context, tenant openapi_types.UUID, workflow string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCronWorkflowTriggerCreateRequestWithBody(c.Server, tenant, workflow, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CronWorkflowTriggerCreate(ctx context.Context, tenant openapi_types.UUID, workflow string, body CronWorkflowTriggerCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCronWorkflowTriggerCreateRequest(c.Server, tenant, workflow, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScheduledWorkflowRunCreateWithBody(ctx context.Context, tenant openapi_types.UUID, workflow string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScheduledWorkflowRunCreateRequestWithBody(c.Server, tenant, workflow, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScheduledWorkflowRunCreate(ctx context.Context, tenant openapi_types.UUID, workflow string, body ScheduledWorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScheduledWorkflowRunCreateRequest(c.Server, tenant, workflow, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowGetWorkersCount(ctx context.Context, tenant openapi_types.UUID, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowGetWorkersCountRequest(c.Server, tenant, workflow)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserGetCurrent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserGetCurrentRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateGithubOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateGithubOauthCallbackRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateGithubOauthStart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateGithubOauthStartRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateGoogleOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateGoogleOauthCallbackRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateGoogleOauthStart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateGoogleOauthStartRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserListTenantInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserListTenantInvitesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteAcceptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteAcceptRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteAccept(ctx context.Context, body TenantInviteAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteAcceptRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteRejectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteRejectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantInviteReject(ctx context.Context, body TenantInviteRejectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantInviteRejectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateLogin(ctx context.Context, body UserUpdateLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateLogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantMembershipsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantMembershipsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdatePasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdatePasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdatePassword(ctx context.Context, body UserUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdatePasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserCreate(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateSlackOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateSlackOauthCallbackRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InfoGetVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInfoGetVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhookDelete(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhookDeleteRequest(c.Server, webhook)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebhookRequestsList(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebhookRequestsListRequest(c.Server, webhook)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerGet(ctx context.Context, worker openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerGetRequest(c.Server, worker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerUpdateWithBody(ctx context.Context, worker openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerUpdateRequestWithBody(c.Server, worker, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerUpdate(ctx context.Context, worker openapi_types.UUID, body WorkerUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerUpdateRequest(c.Server, worker, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowDelete(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowDeleteRequest(c.Server, workflow)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowGet(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowGetRequest(c.Server, workflow)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowUpdateWithBody(ctx context.Context, workflow openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowUpdateRequestWithBody(c.Server, workflow, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowUpdate(ctx context.Context, workflow openapi_types.UUID, body WorkflowUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowUpdateRequest(c.Server, workflow, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowGetMetrics(ctx context.Context, workflow openapi_types.UUID, params *WorkflowGetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowGetMetricsRequest(c.Server, workflow, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunCreateWithBody(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunCreateRequestWithBody(c.Server, workflow, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunCreate(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, body WorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunCreateRequest(c.Server, workflow, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowVersionGet(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowVersionGetRequest(c.Server, workflow, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewLivenessGetRequest generates requests for LivenessGet
func NewLivenessGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/live")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadinessGetRequest generates requests for ReadinessGet
func NewReadinessGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertEmailGroupDeleteRequest generates requests for AlertEmailGroupDelete
func NewAlertEmailGroupDeleteRequest(server string, alertEmailGroup openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alert-email-group", runtime.ParamLocationPath, alertEmailGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/alerting-email-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertEmailGroupUpdateRequest calls the generic AlertEmailGroupUpdate builder with application/json body
func NewAlertEmailGroupUpdateRequest(server string, alertEmailGroup openapi_types.UUID, body AlertEmailGroupUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAlertEmailGroupUpdateRequestWithBody(server, alertEmailGroup, "application/json", bodyReader)
}

// NewAlertEmailGroupUpdateRequestWithBody generates requests for AlertEmailGroupUpdate with any type of body
func NewAlertEmailGroupUpdateRequestWithBody(server string, alertEmailGroup openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alert-email-group", runtime.ParamLocationPath, alertEmailGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/alerting-email-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewApiTokenUpdateRevokeRequest generates requests for ApiTokenUpdateRevoke
func NewApiTokenUpdateRevokeRequest(server string, apiToken openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "api-token", runtime.ParamLocationPath, apiToken)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/api-tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCloudMetadataGetRequest generates requests for CloudMetadataGet
func NewCloudMetadataGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/metadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEventGetRequest generates requests for EventGet
func NewEventGetRequest(server string, event openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event", runtime.ParamLocationPath, event)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEventDataGetRequest generates requests for EventDataGet
func NewEventDataGetRequest(server string, event openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event", runtime.ParamLocationPath, event)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/events/%s/data", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetadataGetRequest generates requests for MetadataGet
func NewMetadataGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meta")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetadataListIntegrationsRequest generates requests for MetadataListIntegrations
func NewMetadataListIntegrationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/meta/integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMonitoringPostRunProbeRequest generates requests for MonitoringPostRunProbe
func NewMonitoringPostRunProbeRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/monitoring/%s/probe", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlackWebhookDeleteRequest generates requests for SlackWebhookDelete
func NewSlackWebhookDeleteRequest(server string, slack openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slack", runtime.ParamLocationPath, slack)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/slack/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnsDeleteRequest generates requests for SnsDelete
func NewSnsDeleteRequest(server string, sns openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sns", runtime.ParamLocationPath, sns)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnsUpdateRequest generates requests for SnsUpdate
func NewSnsUpdateRequest(server string, tenant openapi_types.UUID, event string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "event", runtime.ParamLocationPath, event)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sns/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1DagListTasksRequest generates requests for V1DagListTasks
func NewV1DagListTasksRequest(server string, params *V1DagListTasksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/dags/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dag_ids", runtime.ParamLocationQuery, params.DagIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenant", runtime.ParamLocationQuery, params.Tenant); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1TaskGetRequest generates requests for V1TaskGet
func NewV1TaskGetRequest(server string, task openapi_types.UUID, params *V1TaskGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task", runtime.ParamLocationPath, task)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Attempt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "attempt", runtime.ParamLocationQuery, *params.Attempt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1LogLineListRequest generates requests for V1LogLineList
func NewV1LogLineListRequest(server string, task openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task", runtime.ParamLocationPath, task)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/tasks/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1TaskEventListRequest generates requests for V1TaskEventList
func NewV1TaskEventListRequest(server string, task openapi_types.UUID, params *V1TaskEventListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task", runtime.ParamLocationPath, task)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/tasks/%s/task-events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1EventListRequest generates requests for V1EventList
func NewV1EventListRequest(server string, tenant openapi_types.UUID, params *V1EventListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/tenants/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keys", runtime.ParamLocationQuery, *params.Keys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkflowIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflowIds", runtime.ParamLocationQuery, *params.WorkflowIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkflowRunStatuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflowRunStatuses", runtime.ParamLocationQuery, *params.WorkflowRunStatuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventIds", runtime.ParamLocationQuery, *params.EventIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdditionalMetadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additionalMetadata", runtime.ParamLocationQuery, *params.AdditionalMetadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Scopes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scopes", runtime.ParamLocationQuery, *params.Scopes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1EventKeyListRequest generates requests for V1EventKeyList
func NewV1EventKeyListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/tenants/%s/events/keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1FilterListRequest generates requests for V1FilterList
func NewV1FilterListRequest(server string, tenant openapi_types.UUID, params *V1FilterListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/tenants/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkflowIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflowIds", runtime.ParamLocationQuery, *params.WorkflowIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Scopes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scopes", runtime.ParamLocationQuery, *params.Scopes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1FilterCreateRequest calls the generic V1FilterCreate builder with application/json body
func NewV1FilterCreateRequest(server string, tenant openapi_types.UUID, body V1FilterCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewV1FilterCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewV1FilterCreateRequestWithBody generates requests for V1FilterCreate with any type of body
func NewV1FilterCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/tenants/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewV1FilterDeleteRequest generates requests for V1FilterDelete
func NewV1FilterDeleteRequest(server string, tenant openapi_types.UUID, v1Filter openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "v1-filter", runtime.ParamLocationPath, v1Filter)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/tenants/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1FilterGetRequest generates requests for V1FilterGet
func NewV1FilterGetRequest(server string, tenant openapi_types.UUID, v1Filter openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "v1-filter", runtime.ParamLocationPath, v1Filter)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/tenants/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1FilterUpdateRequest calls the generic V1FilterUpdate builder with application/json body
func NewV1FilterUpdateRequest(server string, tenant openapi_types.UUID, v1Filter openapi_types.UUID, body V1FilterUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewV1FilterUpdateRequestWithBody(server, tenant, v1Filter, "application/json", bodyReader)
}

// NewV1FilterUpdateRequestWithBody generates requests for V1FilterUpdate with any type of body
func NewV1FilterUpdateRequestWithBody(server string, tenant openapi_types.UUID, v1Filter openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "v1-filter", runtime.ParamLocationPath, v1Filter)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/tenants/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewV1TaskListStatusMetricsRequest generates requests for V1TaskListStatusMetrics
func NewV1TaskListStatusMetricsRequest(server string, tenant openapi_types.UUID, params *V1TaskListStatusMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/tenants/%s/task-metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkflowIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflow_ids", runtime.ParamLocationQuery, *params.WorkflowIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentTaskExternalId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_task_external_id", runtime.ParamLocationQuery, *params.ParentTaskExternalId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TriggeringEventExternalId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "triggering_event_external_id", runtime.ParamLocationQuery, *params.TriggeringEventExternalId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1TaskGetPointMetricsRequest generates requests for V1TaskGetPointMetrics
func NewV1TaskGetPointMetricsRequest(server string, tenant openapi_types.UUID, params *V1TaskGetPointMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/tenants/%s/task-point-metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfter", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FinishedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finishedBefore", runtime.ParamLocationQuery, *params.FinishedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1TaskCancelRequest calls the generic V1TaskCancel builder with application/json body
func NewV1TaskCancelRequest(server string, tenant openapi_types.UUID, body V1TaskCancelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewV1TaskCancelRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewV1TaskCancelRequestWithBody generates requests for V1TaskCancel with any type of body
func NewV1TaskCancelRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/tenants/%s/tasks/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewV1TaskReplayRequest calls the generic V1TaskReplay builder with application/json body
func NewV1TaskReplayRequest(server string, tenant openapi_types.UUID, body V1TaskReplayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewV1TaskReplayRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewV1TaskReplayRequestWithBody generates requests for V1TaskReplay with any type of body
func NewV1TaskReplayRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/tenants/%s/tasks/replay", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewV1WorkflowRunListRequest generates requests for V1WorkflowRunList
func NewV1WorkflowRunListRequest(server string, tenant openapi_types.UUID, params *V1WorkflowRunListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/tenants/%s/workflow-runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Statuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statuses", runtime.ParamLocationQuery, *params.Statuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdditionalMetadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additional_metadata", runtime.ParamLocationQuery, *params.AdditionalMetadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkflowIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflow_ids", runtime.ParamLocationQuery, *params.WorkflowIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "worker_id", runtime.ParamLocationQuery, *params.WorkerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_tasks", runtime.ParamLocationQuery, params.OnlyTasks); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ParentTaskExternalId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_task_external_id", runtime.ParamLocationQuery, *params.ParentTaskExternalId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TriggeringEventExternalId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "triggering_event_external_id", runtime.ParamLocationQuery, *params.TriggeringEventExternalId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludePayloads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_payloads", runtime.ParamLocationQuery, *params.IncludePayloads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1WorkflowRunDisplayNamesListRequest generates requests for V1WorkflowRunDisplayNamesList
func NewV1WorkflowRunDisplayNamesListRequest(server string, tenant openapi_types.UUID, params *V1WorkflowRunDisplayNamesListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/tenants/%s/workflow-runs/display-names", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "external_ids", runtime.ParamLocationQuery, params.ExternalIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1WorkflowRunCreateRequest calls the generic V1WorkflowRunCreate builder with application/json body
func NewV1WorkflowRunCreateRequest(server string, tenant openapi_types.UUID, body V1WorkflowRunCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewV1WorkflowRunCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewV1WorkflowRunCreateRequestWithBody generates requests for V1WorkflowRunCreate with any type of body
func NewV1WorkflowRunCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/tenants/%s/workflow-runs/trigger", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewV1WorkflowRunGetRequest generates requests for V1WorkflowRunGet
func NewV1WorkflowRunGetRequest(server string, v1WorkflowRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "v1-workflow-run", runtime.ParamLocationPath, v1WorkflowRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/workflow-runs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1WorkflowRunGetStatusRequest generates requests for V1WorkflowRunGetStatus
func NewV1WorkflowRunGetStatusRequest(server string, v1WorkflowRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "v1-workflow-run", runtime.ParamLocationPath, v1WorkflowRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/workflow-runs/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1WorkflowRunTaskEventsListRequest generates requests for V1WorkflowRunTaskEventsList
func NewV1WorkflowRunTaskEventsListRequest(server string, v1WorkflowRun openapi_types.UUID, params *V1WorkflowRunTaskEventsListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "v1-workflow-run", runtime.ParamLocationPath, v1WorkflowRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/workflow-runs/%s/task-events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewV1WorkflowRunGetTimingsRequest generates requests for V1WorkflowRunGetTimings
func NewV1WorkflowRunGetTimingsRequest(server string, v1WorkflowRun openapi_types.UUID, params *V1WorkflowRunGetTimingsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "v1-workflow-run", runtime.ParamLocationPath, v1WorkflowRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/stable/workflow-runs/%s/task-timings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStepRunListArchivesRequest generates requests for StepRunListArchives
func NewStepRunListArchivesRequest(server string, stepRun openapi_types.UUID, params *StepRunListArchivesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/step-runs/%s/archives", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStepRunListEventsRequest generates requests for StepRunListEvents
func NewStepRunListEventsRequest(server string, stepRun openapi_types.UUID, params *StepRunListEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/step-runs/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogLineListRequest generates requests for LogLineList
func NewLogLineListRequest(server string, stepRun openapi_types.UUID, params *LogLineListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/step-runs/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Levels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "levels", runtime.ParamLocationQuery, *params.Levels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByField", runtime.ParamLocationQuery, *params.OrderByField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByDirection", runtime.ParamLocationQuery, *params.OrderByDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantCreateRequest calls the generic TenantCreate builder with application/json body
func NewTenantCreateRequest(server string, body TenantCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewTenantCreateRequestWithBody generates requests for TenantCreate with any type of body
func NewTenantCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantGetRequest generates requests for TenantGet
func NewTenantGetRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantUpdateRequest calls the generic TenantUpdate builder with application/json body
func NewTenantUpdateRequest(server string, tenant openapi_types.UUID, body TenantUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantUpdateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewTenantUpdateRequestWithBody generates requests for TenantUpdate with any type of body
func NewTenantUpdateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAlertEmailGroupListRequest generates requests for AlertEmailGroupList
func NewAlertEmailGroupListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/alerting-email-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertEmailGroupCreateRequest calls the generic AlertEmailGroupCreate builder with application/json body
func NewAlertEmailGroupCreateRequest(server string, tenant openapi_types.UUID, body AlertEmailGroupCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAlertEmailGroupCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewAlertEmailGroupCreateRequestWithBody generates requests for AlertEmailGroupCreate with any type of body
func NewAlertEmailGroupCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/alerting-email-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantAlertingSettingsGetRequest generates requests for TenantAlertingSettingsGet
func NewTenantAlertingSettingsGetRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/alerting/settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApiTokenListRequest generates requests for ApiTokenList
func NewApiTokenListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/api-tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApiTokenCreateRequest calls the generic ApiTokenCreate builder with application/json body
func NewApiTokenCreateRequest(server string, tenant openapi_types.UUID, body ApiTokenCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApiTokenCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewApiTokenCreateRequestWithBody generates requests for ApiTokenCreate with any type of body
func NewApiTokenCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/api-tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEventListRequest generates requests for EventList
func NewEventListRequest(server string, tenant openapi_types.UUID, params *EventListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keys", runtime.ParamLocationQuery, *params.Keys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Workflows != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflows", runtime.ParamLocationQuery, *params.Workflows); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Statuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statuses", runtime.ParamLocationQuery, *params.Statuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByField", runtime.ParamLocationQuery, *params.OrderByField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByDirection", runtime.ParamLocationQuery, *params.OrderByDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdditionalMetadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additionalMetadata", runtime.ParamLocationQuery, *params.AdditionalMetadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventIds", runtime.ParamLocationQuery, *params.EventIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEventCreateRequest calls the generic EventCreate builder with application/json body
func NewEventCreateRequest(server string, tenant openapi_types.UUID, body EventCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEventCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewEventCreateRequestWithBody generates requests for EventCreate with any type of body
func NewEventCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEventCreateBulkRequest calls the generic EventCreateBulk builder with application/json body
func NewEventCreateBulkRequest(server string, tenant openapi_types.UUID, body EventCreateBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEventCreateBulkRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewEventCreateBulkRequestWithBody generates requests for EventCreateBulk with any type of body
func NewEventCreateBulkRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/events/bulk", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEventUpdateCancelRequest calls the generic EventUpdateCancel builder with application/json body
func NewEventUpdateCancelRequest(server string, tenant openapi_types.UUID, body EventUpdateCancelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEventUpdateCancelRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewEventUpdateCancelRequestWithBody generates requests for EventUpdateCancel with any type of body
func NewEventUpdateCancelRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/events/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEventKeyListRequest generates requests for EventKeyList
func NewEventKeyListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/events/keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEventUpdateReplayRequest calls the generic EventUpdateReplay builder with application/json body
func NewEventUpdateReplayRequest(server string, tenant openapi_types.UUID, body EventUpdateReplayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEventUpdateReplayRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewEventUpdateReplayRequestWithBody generates requests for EventUpdateReplay with any type of body
func NewEventUpdateReplayRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/events/replay", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantInviteListRequest generates requests for TenantInviteList
func NewTenantInviteListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/invites", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantInviteCreateRequest calls the generic TenantInviteCreate builder with application/json body
func NewTenantInviteCreateRequest(server string, tenant openapi_types.UUID, body TenantInviteCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantInviteCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewTenantInviteCreateRequestWithBody generates requests for TenantInviteCreate with any type of body
func NewTenantInviteCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/invites", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantInviteDeleteRequest generates requests for TenantInviteDelete
func NewTenantInviteDeleteRequest(server string, tenant openapi_types.UUID, tenantInvite openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-invite", runtime.ParamLocationPath, tenantInvite)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/invites/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantInviteUpdateRequest calls the generic TenantInviteUpdate builder with application/json body
func NewTenantInviteUpdateRequest(server string, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, body TenantInviteUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantInviteUpdateRequestWithBody(server, tenant, tenantInvite, "application/json", bodyReader)
}

// NewTenantInviteUpdateRequestWithBody generates requests for TenantInviteUpdate with any type of body
func NewTenantInviteUpdateRequestWithBody(server string, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tenant-invite", runtime.ParamLocationPath, tenantInvite)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/invites/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantMemberListRequest generates requests for TenantMemberList
func NewTenantMemberListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantMemberDeleteRequest generates requests for TenantMemberDelete
func NewTenantMemberDeleteRequest(server string, tenant openapi_types.UUID, member openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "member", runtime.ParamLocationPath, member)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantGetPrometheusMetricsRequest generates requests for TenantGetPrometheusMetrics
func NewTenantGetPrometheusMetricsRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/prometheus-metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantGetQueueMetricsRequest generates requests for TenantGetQueueMetrics
func NewTenantGetQueueMetricsRequest(server string, tenant openapi_types.UUID, params *TenantGetQueueMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/queue-metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Workflows != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflows", runtime.ParamLocationQuery, *params.Workflows); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdditionalMetadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additionalMetadata", runtime.ParamLocationQuery, *params.AdditionalMetadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRateLimitListRequest generates requests for RateLimitList
func NewRateLimitListRequest(server string, tenant openapi_types.UUID, params *RateLimitListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/rate-limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByField", runtime.ParamLocationQuery, *params.OrderByField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByDirection", runtime.ParamLocationQuery, *params.OrderByDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantResourcePolicyGetRequest generates requests for TenantResourcePolicyGet
func NewTenantResourcePolicyGetRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/resource-policy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlackWebhookListRequest generates requests for SlackWebhookList
func NewSlackWebhookListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/slack", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateSlackOauthStartRequest generates requests for UserUpdateSlackOauthStart
func NewUserUpdateSlackOauthStartRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/slack/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnsListRequest generates requests for SnsList
func NewSnsListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/sns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnsCreateRequest calls the generic SnsCreate builder with application/json body
func NewSnsCreateRequest(server string, tenant openapi_types.UUID, body SnsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSnsCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewSnsCreateRequestWithBody generates requests for SnsCreate with any type of body
func NewSnsCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/sns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantGetStepRunQueueMetricsRequest generates requests for TenantGetStepRunQueueMetrics
func NewTenantGetStepRunQueueMetricsRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/step-run-queue-metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStepRunGetRequest generates requests for StepRunGet
func NewStepRunGetRequest(server string, tenant openapi_types.UUID, stepRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/step-runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStepRunUpdateCancelRequest generates requests for StepRunUpdateCancel
func NewStepRunUpdateCancelRequest(server string, tenant openapi_types.UUID, stepRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/step-runs/%s/cancel", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStepRunUpdateRerunRequest calls the generic StepRunUpdateRerun builder with application/json body
func NewStepRunUpdateRerunRequest(server string, tenant openapi_types.UUID, stepRun openapi_types.UUID, body StepRunUpdateRerunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStepRunUpdateRerunRequestWithBody(server, tenant, stepRun, "application/json", bodyReader)
}

// NewStepRunUpdateRerunRequestWithBody generates requests for StepRunUpdateRerun with any type of body
func NewStepRunUpdateRerunRequestWithBody(server string, tenant openapi_types.UUID, stepRun openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/step-runs/%s/rerun", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStepRunGetSchemaRequest generates requests for StepRunGetSchema
func NewStepRunGetSchemaRequest(server string, tenant openapi_types.UUID, stepRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "step-run", runtime.ParamLocationPath, stepRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/step-runs/%s/schema", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhookListRequest generates requests for WebhookList
func NewWebhookListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/webhook-workers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhookCreateRequest calls the generic WebhookCreate builder with application/json body
func NewWebhookCreateRequest(server string, tenant openapi_types.UUID, body WebhookCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebhookCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewWebhookCreateRequestWithBody generates requests for WebhookCreate with any type of body
func NewWebhookCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/webhook-workers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorkerListRequest generates requests for WorkerList
func NewWorkerListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/worker", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowRunUpdateReplayRequest calls the generic WorkflowRunUpdateReplay builder with application/json body
func NewWorkflowRunUpdateReplayRequest(server string, tenant openapi_types.UUID, body WorkflowRunUpdateReplayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorkflowRunUpdateReplayRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewWorkflowRunUpdateReplayRequestWithBody generates requests for WorkflowRunUpdateReplay with any type of body
func NewWorkflowRunUpdateReplayRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflow-runs/replay", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorkflowRunGetRequest generates requests for WorkflowRunGet
func NewWorkflowRunGetRequest(server string, tenant openapi_types.UUID, workflowRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workflow-run", runtime.ParamLocationPath, workflowRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflow-runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowRunGetInputRequest generates requests for WorkflowRunGetInput
func NewWorkflowRunGetInputRequest(server string, tenant openapi_types.UUID, workflowRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workflow-run", runtime.ParamLocationPath, workflowRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflow-runs/%s/input", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowRunGetShapeRequest generates requests for WorkflowRunGetShape
func NewWorkflowRunGetShapeRequest(server string, tenant openapi_types.UUID, workflowRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workflow-run", runtime.ParamLocationPath, workflowRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflow-runs/%s/shape", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowRunListStepRunEventsRequest generates requests for WorkflowRunListStepRunEvents
func NewWorkflowRunListStepRunEventsRequest(server string, tenant openapi_types.UUID, workflowRun openapi_types.UUID, params *WorkflowRunListStepRunEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workflow-run", runtime.ParamLocationPath, workflowRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflow-runs/%s/step-run-events", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LastId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastId", runtime.ParamLocationQuery, *params.LastId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowListRequest generates requests for WorkflowList
func NewWorkflowListRequest(server string, tenant openapi_types.UUID, params *WorkflowListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowRunCancelRequest calls the generic WorkflowRunCancel builder with application/json body
func NewWorkflowRunCancelRequest(server string, tenant openapi_types.UUID, body WorkflowRunCancelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorkflowRunCancelRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewWorkflowRunCancelRequestWithBody generates requests for WorkflowRunCancel with any type of body
func NewWorkflowRunCancelRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCronWorkflowListRequest generates requests for CronWorkflowList
func NewCronWorkflowListRequest(server string, tenant openapi_types.UUID, params *CronWorkflowListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows/crons", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkflowId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflowId", runtime.ParamLocationQuery, *params.WorkflowId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkflowName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflowName", runtime.ParamLocationQuery, *params.WorkflowName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CronName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cronName", runtime.ParamLocationQuery, *params.CronName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdditionalMetadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additionalMetadata", runtime.ParamLocationQuery, *params.AdditionalMetadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByField", runtime.ParamLocationQuery, *params.OrderByField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByDirection", runtime.ParamLocationQuery, *params.OrderByDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowCronDeleteRequest generates requests for WorkflowCronDelete
func NewWorkflowCronDeleteRequest(server string, tenant openapi_types.UUID, cronWorkflow openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cron-workflow", runtime.ParamLocationPath, cronWorkflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows/crons/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowCronGetRequest generates requests for WorkflowCronGet
func NewWorkflowCronGetRequest(server string, tenant openapi_types.UUID, cronWorkflow openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cron-workflow", runtime.ParamLocationPath, cronWorkflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows/crons/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowRunListRequest generates requests for WorkflowRunList
func NewWorkflowRunListRequest(server string, tenant openapi_types.UUID, params *WorkflowRunListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventId", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkflowId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflowId", runtime.ParamLocationQuery, *params.WorkflowId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentWorkflowRunId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentWorkflowRunId", runtime.ParamLocationQuery, *params.ParentWorkflowRunId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentStepRunId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentStepRunId", runtime.ParamLocationQuery, *params.ParentStepRunId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Statuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statuses", runtime.ParamLocationQuery, *params.Statuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kinds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kinds", runtime.ParamLocationQuery, *params.Kinds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdditionalMetadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additionalMetadata", runtime.ParamLocationQuery, *params.AdditionalMetadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfter", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdBefore", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FinishedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finishedAfter", runtime.ParamLocationQuery, *params.FinishedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FinishedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finishedBefore", runtime.ParamLocationQuery, *params.FinishedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByField", runtime.ParamLocationQuery, *params.OrderByField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByDirection", runtime.ParamLocationQuery, *params.OrderByDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowRunGetMetricsRequest generates requests for WorkflowRunGetMetrics
func NewWorkflowRunGetMetricsRequest(server string, tenant openapi_types.UUID, params *WorkflowRunGetMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows/runs/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventId", runtime.ParamLocationQuery, *params.EventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkflowId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflowId", runtime.ParamLocationQuery, *params.WorkflowId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentWorkflowRunId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentWorkflowRunId", runtime.ParamLocationQuery, *params.ParentWorkflowRunId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentStepRunId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentStepRunId", runtime.ParamLocationQuery, *params.ParentStepRunId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdditionalMetadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additionalMetadata", runtime.ParamLocationQuery, *params.AdditionalMetadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfter", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdBefore", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowScheduledListRequest generates requests for WorkflowScheduledList
func NewWorkflowScheduledListRequest(server string, tenant openapi_types.UUID, params *WorkflowScheduledListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows/scheduled", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByField", runtime.ParamLocationQuery, *params.OrderByField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderByDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderByDirection", runtime.ParamLocationQuery, *params.OrderByDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkflowId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflowId", runtime.ParamLocationQuery, *params.WorkflowId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentWorkflowRunId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentWorkflowRunId", runtime.ParamLocationQuery, *params.ParentWorkflowRunId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentStepRunId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentStepRunId", runtime.ParamLocationQuery, *params.ParentStepRunId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdditionalMetadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "additionalMetadata", runtime.ParamLocationQuery, *params.AdditionalMetadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Statuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statuses", runtime.ParamLocationQuery, *params.Statuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowScheduledDeleteRequest generates requests for WorkflowScheduledDelete
func NewWorkflowScheduledDeleteRequest(server string, tenant openapi_types.UUID, scheduledWorkflowRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scheduled-workflow-run", runtime.ParamLocationPath, scheduledWorkflowRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows/scheduled/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowScheduledGetRequest generates requests for WorkflowScheduledGet
func NewWorkflowScheduledGetRequest(server string, tenant openapi_types.UUID, scheduledWorkflowRun openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scheduled-workflow-run", runtime.ParamLocationPath, scheduledWorkflowRun)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows/scheduled/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCronWorkflowTriggerCreateRequest calls the generic CronWorkflowTriggerCreate builder with application/json body
func NewCronWorkflowTriggerCreateRequest(server string, tenant openapi_types.UUID, workflow string, body CronWorkflowTriggerCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCronWorkflowTriggerCreateRequestWithBody(server, tenant, workflow, "application/json", bodyReader)
}

// NewCronWorkflowTriggerCreateRequestWithBody generates requests for CronWorkflowTriggerCreate with any type of body
func NewCronWorkflowTriggerCreateRequestWithBody(server string, tenant openapi_types.UUID, workflow string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows/%s/crons", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScheduledWorkflowRunCreateRequest calls the generic ScheduledWorkflowRunCreate builder with application/json body
func NewScheduledWorkflowRunCreateRequest(server string, tenant openapi_types.UUID, workflow string, body ScheduledWorkflowRunCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScheduledWorkflowRunCreateRequestWithBody(server, tenant, workflow, "application/json", bodyReader)
}

// NewScheduledWorkflowRunCreateRequestWithBody generates requests for ScheduledWorkflowRunCreate with any type of body
func NewScheduledWorkflowRunCreateRequestWithBody(server string, tenant openapi_types.UUID, workflow string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows/%s/scheduled", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorkflowGetWorkersCountRequest generates requests for WorkflowGetWorkersCount
func NewWorkflowGetWorkersCountRequest(server string, tenant openapi_types.UUID, workflow openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tenants/%s/workflows/%s/worker-count", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserGetCurrentRequest generates requests for UserGetCurrent
func NewUserGetCurrentRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/current")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateGithubOauthCallbackRequest generates requests for UserUpdateGithubOauthCallback
func NewUserUpdateGithubOauthCallbackRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/github/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateGithubOauthStartRequest generates requests for UserUpdateGithubOauthStart
func NewUserUpdateGithubOauthStartRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/github/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateGoogleOauthCallbackRequest generates requests for UserUpdateGoogleOauthCallback
func NewUserUpdateGoogleOauthCallbackRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/google/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateGoogleOauthStartRequest generates requests for UserUpdateGoogleOauthStart
func NewUserUpdateGoogleOauthStartRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/google/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserListTenantInvitesRequest generates requests for UserListTenantInvites
func NewUserListTenantInvitesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantInviteAcceptRequest calls the generic TenantInviteAccept builder with application/json body
func NewTenantInviteAcceptRequest(server string, body TenantInviteAcceptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantInviteAcceptRequestWithBody(server, "application/json", bodyReader)
}

// NewTenantInviteAcceptRequestWithBody generates requests for TenantInviteAccept with any type of body
func NewTenantInviteAcceptRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/invites/accept")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantInviteRejectRequest calls the generic TenantInviteReject builder with application/json body
func NewTenantInviteRejectRequest(server string, body TenantInviteRejectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantInviteRejectRequestWithBody(server, "application/json", bodyReader)
}

// NewTenantInviteRejectRequestWithBody generates requests for TenantInviteReject with any type of body
func NewTenantInviteRejectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/invites/reject")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserUpdateLoginRequest calls the generic UserUpdateLogin builder with application/json body
func NewUserUpdateLoginRequest(server string, body UserUpdateLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserUpdateLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewUserUpdateLoginRequestWithBody generates requests for UserUpdateLogin with any type of body
func NewUserUpdateLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserUpdateLogoutRequest generates requests for UserUpdateLogout
func NewUserUpdateLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantMembershipsListRequest generates requests for TenantMembershipsList
func NewTenantMembershipsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/memberships")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdatePasswordRequest calls the generic UserUpdatePassword builder with application/json body
func NewUserUpdatePasswordRequest(server string, body UserUpdatePasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserUpdatePasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewUserUpdatePasswordRequestWithBody generates requests for UserUpdatePassword with any type of body
func NewUserUpdatePasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserCreateRequest calls the generic UserCreate builder with application/json body
func NewUserCreateRequest(server string, body UserCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewUserCreateRequestWithBody generates requests for UserCreate with any type of body
func NewUserCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserUpdateSlackOauthCallbackRequest generates requests for UserUpdateSlackOauthCallback
func NewUserUpdateSlackOauthCallbackRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users/slack/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInfoGetVersionRequest generates requests for InfoGetVersion
func NewInfoGetVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhookDeleteRequest generates requests for WebhookDelete
func NewWebhookDeleteRequest(server string, webhook openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhook", runtime.ParamLocationPath, webhook)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/webhook-workers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWebhookRequestsListRequest generates requests for WebhookRequestsList
func NewWebhookRequestsListRequest(server string, webhook openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhook", runtime.ParamLocationPath, webhook)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/webhook-workers/%s/requests", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerGetRequest generates requests for WorkerGet
func NewWorkerGetRequest(server string, worker openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "worker", runtime.ParamLocationPath, worker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerUpdateRequest calls the generic WorkerUpdate builder with application/json body
func NewWorkerUpdateRequest(server string, worker openapi_types.UUID, body WorkerUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorkerUpdateRequestWithBody(server, worker, "application/json", bodyReader)
}

// NewWorkerUpdateRequestWithBody generates requests for WorkerUpdate with any type of body
func NewWorkerUpdateRequestWithBody(server string, worker openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "worker", runtime.ParamLocationPath, worker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorkflowDeleteRequest generates requests for WorkflowDelete
func NewWorkflowDeleteRequest(server string, workflow openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowGetRequest generates requests for WorkflowGet
func NewWorkflowGetRequest(server string, workflow openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowUpdateRequest calls the generic WorkflowUpdate builder with application/json body
func NewWorkflowUpdateRequest(server string, workflow openapi_types.UUID, body WorkflowUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorkflowUpdateRequestWithBody(server, workflow, "application/json", bodyReader)
}

// NewWorkflowUpdateRequestWithBody generates requests for WorkflowUpdate with any type of body
func NewWorkflowUpdateRequestWithBody(server string, workflow openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorkflowGetMetricsRequest generates requests for WorkflowGetMetrics
func NewWorkflowGetMetricsRequest(server string, workflow openapi_types.UUID, params *WorkflowGetMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupKey", runtime.ParamLocationQuery, *params.GroupKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkflowRunCreateRequest calls the generic WorkflowRunCreate builder with application/json body
func NewWorkflowRunCreateRequest(server string, workflow openapi_types.UUID, params *WorkflowRunCreateParams, body WorkflowRunCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorkflowRunCreateRequestWithBody(server, workflow, params, "application/json", bodyReader)
}

// NewWorkflowRunCreateRequestWithBody generates requests for WorkflowRunCreate with any type of body
func NewWorkflowRunCreateRequestWithBody(server string, workflow openapi_types.UUID, params *WorkflowRunCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s/trigger", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorkflowVersionGetRequest generates requests for WorkflowVersionGet
func NewWorkflowVersionGetRequest(server string, workflow openapi_types.UUID, params *WorkflowVersionGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow", runtime.ParamLocationPath, workflow)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// LivenessGetWithResponse request
	LivenessGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LivenessGetResponse, error)

	// ReadinessGetWithResponse request
	ReadinessGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReadinessGetResponse, error)

	// AlertEmailGroupDeleteWithResponse request
	AlertEmailGroupDeleteWithResponse(ctx context.Context, alertEmailGroup openapi_types.UUID, reqEditors ...RequestEditorFn) (*AlertEmailGroupDeleteResponse, error)

	// AlertEmailGroupUpdateWithBodyWithResponse request with any body
	AlertEmailGroupUpdateWithBodyWithResponse(ctx context.Context, alertEmailGroup openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AlertEmailGroupUpdateResponse, error)

	AlertEmailGroupUpdateWithResponse(ctx context.Context, alertEmailGroup openapi_types.UUID, body AlertEmailGroupUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AlertEmailGroupUpdateResponse, error)

	// ApiTokenUpdateRevokeWithResponse request
	ApiTokenUpdateRevokeWithResponse(ctx context.Context, apiToken openapi_types.UUID, reqEditors ...RequestEditorFn) (*ApiTokenUpdateRevokeResponse, error)

	// CloudMetadataGetWithResponse request
	CloudMetadataGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CloudMetadataGetResponse, error)

	// EventGetWithResponse request
	EventGetWithResponse(ctx context.Context, event openapi_types.UUID, reqEditors ...RequestEditorFn) (*EventGetResponse, error)

	// EventDataGetWithResponse request
	EventDataGetWithResponse(ctx context.Context, event openapi_types.UUID, reqEditors ...RequestEditorFn) (*EventDataGetResponse, error)

	// MetadataGetWithResponse request
	MetadataGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetadataGetResponse, error)

	// MetadataListIntegrationsWithResponse request
	MetadataListIntegrationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetadataListIntegrationsResponse, error)

	// MonitoringPostRunProbeWithResponse request
	MonitoringPostRunProbeWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*MonitoringPostRunProbeResponse, error)

	// SlackWebhookDeleteWithResponse request
	SlackWebhookDeleteWithResponse(ctx context.Context, slack openapi_types.UUID, reqEditors ...RequestEditorFn) (*SlackWebhookDeleteResponse, error)

	// SnsDeleteWithResponse request
	SnsDeleteWithResponse(ctx context.Context, sns openapi_types.UUID, reqEditors ...RequestEditorFn) (*SnsDeleteResponse, error)

	// SnsUpdateWithResponse request
	SnsUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, event string, reqEditors ...RequestEditorFn) (*SnsUpdateResponse, error)

	// V1DagListTasksWithResponse request
	V1DagListTasksWithResponse(ctx context.Context, params *V1DagListTasksParams, reqEditors ...RequestEditorFn) (*V1DagListTasksResponse, error)

	// V1TaskGetWithResponse request
	V1TaskGetWithResponse(ctx context.Context, task openapi_types.UUID, params *V1TaskGetParams, reqEditors ...RequestEditorFn) (*V1TaskGetResponse, error)

	// V1LogLineListWithResponse request
	V1LogLineListWithResponse(ctx context.Context, task openapi_types.UUID, reqEditors ...RequestEditorFn) (*V1LogLineListResponse, error)

	// V1TaskEventListWithResponse request
	V1TaskEventListWithResponse(ctx context.Context, task openapi_types.UUID, params *V1TaskEventListParams, reqEditors ...RequestEditorFn) (*V1TaskEventListResponse, error)

	// V1EventListWithResponse request
	V1EventListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *V1EventListParams, reqEditors ...RequestEditorFn) (*V1EventListResponse, error)

	// V1EventKeyListWithResponse request
	V1EventKeyListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*V1EventKeyListResponse, error)

	// V1FilterListWithResponse request
	V1FilterListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *V1FilterListParams, reqEditors ...RequestEditorFn) (*V1FilterListResponse, error)

	// V1FilterCreateWithBodyWithResponse request with any body
	V1FilterCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*V1FilterCreateResponse, error)

	V1FilterCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body V1FilterCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*V1FilterCreateResponse, error)

	// V1FilterDeleteWithResponse request
	V1FilterDeleteWithResponse(ctx context.Context, tenant openapi_types.UUID, v1Filter openapi_types.UUID, reqEditors ...RequestEditorFn) (*V1FilterDeleteResponse, error)

	// V1FilterGetWithResponse request
	V1FilterGetWithResponse(ctx context.Context, tenant openapi_types.UUID, v1Filter openapi_types.UUID, reqEditors ...RequestEditorFn) (*V1FilterGetResponse, error)

	// V1FilterUpdateWithBodyWithResponse request with any body
	V1FilterUpdateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, v1Filter openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*V1FilterUpdateResponse, error)

	V1FilterUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, v1Filter openapi_types.UUID, body V1FilterUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*V1FilterUpdateResponse, error)

	// V1TaskListStatusMetricsWithResponse request
	V1TaskListStatusMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, params *V1TaskListStatusMetricsParams, reqEditors ...RequestEditorFn) (*V1TaskListStatusMetricsResponse, error)

	// V1TaskGetPointMetricsWithResponse request
	V1TaskGetPointMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, params *V1TaskGetPointMetricsParams, reqEditors ...RequestEditorFn) (*V1TaskGetPointMetricsResponse, error)

	// V1TaskCancelWithBodyWithResponse request with any body
	V1TaskCancelWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*V1TaskCancelResponse, error)

	V1TaskCancelWithResponse(ctx context.Context, tenant openapi_types.UUID, body V1TaskCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*V1TaskCancelResponse, error)

	// V1TaskReplayWithBodyWithResponse request with any body
	V1TaskReplayWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*V1TaskReplayResponse, error)

	V1TaskReplayWithResponse(ctx context.Context, tenant openapi_types.UUID, body V1TaskReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*V1TaskReplayResponse, error)

	// V1WorkflowRunListWithResponse request
	V1WorkflowRunListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *V1WorkflowRunListParams, reqEditors ...RequestEditorFn) (*V1WorkflowRunListResponse, error)

	// V1WorkflowRunDisplayNamesListWithResponse request
	V1WorkflowRunDisplayNamesListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *V1WorkflowRunDisplayNamesListParams, reqEditors ...RequestEditorFn) (*V1WorkflowRunDisplayNamesListResponse, error)

	// V1WorkflowRunCreateWithBodyWithResponse request with any body
	V1WorkflowRunCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*V1WorkflowRunCreateResponse, error)

	V1WorkflowRunCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body V1WorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*V1WorkflowRunCreateResponse, error)

	// V1WorkflowRunGetWithResponse request
	V1WorkflowRunGetWithResponse(ctx context.Context, v1WorkflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*V1WorkflowRunGetResponse, error)

	// V1WorkflowRunGetStatusWithResponse request
	V1WorkflowRunGetStatusWithResponse(ctx context.Context, v1WorkflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*V1WorkflowRunGetStatusResponse, error)

	// V1WorkflowRunTaskEventsListWithResponse request
	V1WorkflowRunTaskEventsListWithResponse(ctx context.Context, v1WorkflowRun openapi_types.UUID, params *V1WorkflowRunTaskEventsListParams, reqEditors ...RequestEditorFn) (*V1WorkflowRunTaskEventsListResponse, error)

	// V1WorkflowRunGetTimingsWithResponse request
	V1WorkflowRunGetTimingsWithResponse(ctx context.Context, v1WorkflowRun openapi_types.UUID, params *V1WorkflowRunGetTimingsParams, reqEditors ...RequestEditorFn) (*V1WorkflowRunGetTimingsResponse, error)

	// StepRunListArchivesWithResponse request
	StepRunListArchivesWithResponse(ctx context.Context, stepRun openapi_types.UUID, params *StepRunListArchivesParams, reqEditors ...RequestEditorFn) (*StepRunListArchivesResponse, error)

	// StepRunListEventsWithResponse request
	StepRunListEventsWithResponse(ctx context.Context, stepRun openapi_types.UUID, params *StepRunListEventsParams, reqEditors ...RequestEditorFn) (*StepRunListEventsResponse, error)

	// LogLineListWithResponse request
	LogLineListWithResponse(ctx context.Context, stepRun openapi_types.UUID, params *LogLineListParams, reqEditors ...RequestEditorFn) (*LogLineListResponse, error)

	// TenantCreateWithBodyWithResponse request with any body
	TenantCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantCreateResponse, error)

	TenantCreateWithResponse(ctx context.Context, body TenantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantCreateResponse, error)

	// TenantGetWithResponse request
	TenantGetWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantGetResponse, error)

	// TenantUpdateWithBodyWithResponse request with any body
	TenantUpdateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantUpdateResponse, error)

	TenantUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, body TenantUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantUpdateResponse, error)

	// AlertEmailGroupListWithResponse request
	AlertEmailGroupListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*AlertEmailGroupListResponse, error)

	// AlertEmailGroupCreateWithBodyWithResponse request with any body
	AlertEmailGroupCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AlertEmailGroupCreateResponse, error)

	AlertEmailGroupCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body AlertEmailGroupCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AlertEmailGroupCreateResponse, error)

	// TenantAlertingSettingsGetWithResponse request
	TenantAlertingSettingsGetWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantAlertingSettingsGetResponse, error)

	// ApiTokenListWithResponse request
	ApiTokenListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*ApiTokenListResponse, error)

	// ApiTokenCreateWithBodyWithResponse request with any body
	ApiTokenCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApiTokenCreateResponse, error)

	ApiTokenCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body ApiTokenCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ApiTokenCreateResponse, error)

	// EventListWithResponse request
	EventListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *EventListParams, reqEditors ...RequestEditorFn) (*EventListResponse, error)

	// EventCreateWithBodyWithResponse request with any body
	EventCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventCreateResponse, error)

	EventCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body EventCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EventCreateResponse, error)

	// EventCreateBulkWithBodyWithResponse request with any body
	EventCreateBulkWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventCreateBulkResponse, error)

	EventCreateBulkWithResponse(ctx context.Context, tenant openapi_types.UUID, body EventCreateBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*EventCreateBulkResponse, error)

	// EventUpdateCancelWithBodyWithResponse request with any body
	EventUpdateCancelWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventUpdateCancelResponse, error)

	EventUpdateCancelWithResponse(ctx context.Context, tenant openapi_types.UUID, body EventUpdateCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*EventUpdateCancelResponse, error)

	// EventKeyListWithResponse request
	EventKeyListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*EventKeyListResponse, error)

	// EventUpdateReplayWithBodyWithResponse request with any body
	EventUpdateReplayWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventUpdateReplayResponse, error)

	EventUpdateReplayWithResponse(ctx context.Context, tenant openapi_types.UUID, body EventUpdateReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*EventUpdateReplayResponse, error)

	// TenantInviteListWithResponse request
	TenantInviteListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantInviteListResponse, error)

	// TenantInviteCreateWithBodyWithResponse request with any body
	TenantInviteCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteCreateResponse, error)

	TenantInviteCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body TenantInviteCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteCreateResponse, error)

	// TenantInviteDeleteWithResponse request
	TenantInviteDeleteWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantInviteDeleteResponse, error)

	// TenantInviteUpdateWithBodyWithResponse request with any body
	TenantInviteUpdateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteUpdateResponse, error)

	TenantInviteUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, body TenantInviteUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteUpdateResponse, error)

	// TenantMemberListWithResponse request
	TenantMemberListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantMemberListResponse, error)

	// TenantMemberDeleteWithResponse request
	TenantMemberDeleteWithResponse(ctx context.Context, tenant openapi_types.UUID, member openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantMemberDeleteResponse, error)

	// TenantGetPrometheusMetricsWithResponse request
	TenantGetPrometheusMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantGetPrometheusMetricsResponse, error)

	// TenantGetQueueMetricsWithResponse request
	TenantGetQueueMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, params *TenantGetQueueMetricsParams, reqEditors ...RequestEditorFn) (*TenantGetQueueMetricsResponse, error)

	// RateLimitListWithResponse request
	RateLimitListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *RateLimitListParams, reqEditors ...RequestEditorFn) (*RateLimitListResponse, error)

	// TenantResourcePolicyGetWithResponse request
	TenantResourcePolicyGetWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantResourcePolicyGetResponse, error)

	// SlackWebhookListWithResponse request
	SlackWebhookListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*SlackWebhookListResponse, error)

	// UserUpdateSlackOauthStartWithResponse request
	UserUpdateSlackOauthStartWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*UserUpdateSlackOauthStartResponse, error)

	// SnsListWithResponse request
	SnsListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*SnsListResponse, error)

	// SnsCreateWithBodyWithResponse request with any body
	SnsCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnsCreateResponse, error)

	SnsCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body SnsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SnsCreateResponse, error)

	// TenantGetStepRunQueueMetricsWithResponse request
	TenantGetStepRunQueueMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantGetStepRunQueueMetricsResponse, error)

	// StepRunGetWithResponse request
	StepRunGetWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunGetResponse, error)

	// StepRunUpdateCancelWithResponse request
	StepRunUpdateCancelWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunUpdateCancelResponse, error)

	// StepRunUpdateRerunWithBodyWithResponse request with any body
	StepRunUpdateRerunWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StepRunUpdateRerunResponse, error)

	StepRunUpdateRerunWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, body StepRunUpdateRerunJSONRequestBody, reqEditors ...RequestEditorFn) (*StepRunUpdateRerunResponse, error)

	// StepRunGetSchemaWithResponse request
	StepRunGetSchemaWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunGetSchemaResponse, error)

	// WebhookListWithResponse request
	WebhookListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*WebhookListResponse, error)

	// WebhookCreateWithBodyWithResponse request with any body
	WebhookCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhookCreateResponse, error)

	WebhookCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body WebhookCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhookCreateResponse, error)

	// WorkerListWithResponse request
	WorkerListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkerListResponse, error)

	// WorkflowRunUpdateReplayWithBodyWithResponse request with any body
	WorkflowRunUpdateReplayWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkflowRunUpdateReplayResponse, error)

	WorkflowRunUpdateReplayWithResponse(ctx context.Context, tenant openapi_types.UUID, body WorkflowRunUpdateReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkflowRunUpdateReplayResponse, error)

	// WorkflowRunGetWithResponse request
	WorkflowRunGetWithResponse(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowRunGetResponse, error)

	// WorkflowRunGetInputWithResponse request
	WorkflowRunGetInputWithResponse(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowRunGetInputResponse, error)

	// WorkflowRunGetShapeWithResponse request
	WorkflowRunGetShapeWithResponse(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowRunGetShapeResponse, error)

	// WorkflowRunListStepRunEventsWithResponse request
	WorkflowRunListStepRunEventsWithResponse(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, params *WorkflowRunListStepRunEventsParams, reqEditors ...RequestEditorFn) (*WorkflowRunListStepRunEventsResponse, error)

	// WorkflowListWithResponse request
	WorkflowListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *WorkflowListParams, reqEditors ...RequestEditorFn) (*WorkflowListResponse, error)

	// WorkflowRunCancelWithBodyWithResponse request with any body
	WorkflowRunCancelWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkflowRunCancelResponse, error)

	WorkflowRunCancelWithResponse(ctx context.Context, tenant openapi_types.UUID, body WorkflowRunCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkflowRunCancelResponse, error)

	// CronWorkflowListWithResponse request
	CronWorkflowListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *CronWorkflowListParams, reqEditors ...RequestEditorFn) (*CronWorkflowListResponse, error)

	// WorkflowCronDeleteWithResponse request
	WorkflowCronDeleteWithResponse(ctx context.Context, tenant openapi_types.UUID, cronWorkflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowCronDeleteResponse, error)

	// WorkflowCronGetWithResponse request
	WorkflowCronGetWithResponse(ctx context.Context, tenant openapi_types.UUID, cronWorkflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowCronGetResponse, error)

	// WorkflowRunListWithResponse request
	WorkflowRunListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunListParams, reqEditors ...RequestEditorFn) (*WorkflowRunListResponse, error)

	// WorkflowRunGetMetricsWithResponse request
	WorkflowRunGetMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunGetMetricsParams, reqEditors ...RequestEditorFn) (*WorkflowRunGetMetricsResponse, error)

	// WorkflowScheduledListWithResponse request
	WorkflowScheduledListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *WorkflowScheduledListParams, reqEditors ...RequestEditorFn) (*WorkflowScheduledListResponse, error)

	// WorkflowScheduledDeleteWithResponse request
	WorkflowScheduledDeleteWithResponse(ctx context.Context, tenant openapi_types.UUID, scheduledWorkflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowScheduledDeleteResponse, error)

	// WorkflowScheduledGetWithResponse request
	WorkflowScheduledGetWithResponse(ctx context.Context, tenant openapi_types.UUID, scheduledWorkflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowScheduledGetResponse, error)

	// CronWorkflowTriggerCreateWithBodyWithResponse request with any body
	CronWorkflowTriggerCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, workflow string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CronWorkflowTriggerCreateResponse, error)

	CronWorkflowTriggerCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, workflow string, body CronWorkflowTriggerCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CronWorkflowTriggerCreateResponse, error)

	// ScheduledWorkflowRunCreateWithBodyWithResponse request with any body
	ScheduledWorkflowRunCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, workflow string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScheduledWorkflowRunCreateResponse, error)

	ScheduledWorkflowRunCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, workflow string, body ScheduledWorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ScheduledWorkflowRunCreateResponse, error)

	// WorkflowGetWorkersCountWithResponse request
	WorkflowGetWorkersCountWithResponse(ctx context.Context, tenant openapi_types.UUID, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowGetWorkersCountResponse, error)

	// UserGetCurrentWithResponse request
	UserGetCurrentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserGetCurrentResponse, error)

	// UserUpdateGithubOauthCallbackWithResponse request
	UserUpdateGithubOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGithubOauthCallbackResponse, error)

	// UserUpdateGithubOauthStartWithResponse request
	UserUpdateGithubOauthStartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGithubOauthStartResponse, error)

	// UserUpdateGoogleOauthCallbackWithResponse request
	UserUpdateGoogleOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGoogleOauthCallbackResponse, error)

	// UserUpdateGoogleOauthStartWithResponse request
	UserUpdateGoogleOauthStartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGoogleOauthStartResponse, error)

	// UserListTenantInvitesWithResponse request
	UserListTenantInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserListTenantInvitesResponse, error)

	// TenantInviteAcceptWithBodyWithResponse request with any body
	TenantInviteAcceptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteAcceptResponse, error)

	TenantInviteAcceptWithResponse(ctx context.Context, body TenantInviteAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteAcceptResponse, error)

	// TenantInviteRejectWithBodyWithResponse request with any body
	TenantInviteRejectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteRejectResponse, error)

	TenantInviteRejectWithResponse(ctx context.Context, body TenantInviteRejectJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteRejectResponse, error)

	// UserUpdateLoginWithBodyWithResponse request with any body
	UserUpdateLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdateLoginResponse, error)

	UserUpdateLoginWithResponse(ctx context.Context, body UserUpdateLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdateLoginResponse, error)

	// UserUpdateLogoutWithResponse request
	UserUpdateLogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateLogoutResponse, error)

	// TenantMembershipsListWithResponse request
	TenantMembershipsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TenantMembershipsListResponse, error)

	// UserUpdatePasswordWithBodyWithResponse request with any body
	UserUpdatePasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdatePasswordResponse, error)

	UserUpdatePasswordWithResponse(ctx context.Context, body UserUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdatePasswordResponse, error)

	// UserCreateWithBodyWithResponse request with any body
	UserCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserCreateResponse, error)

	UserCreateWithResponse(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserCreateResponse, error)

	// UserUpdateSlackOauthCallbackWithResponse request
	UserUpdateSlackOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateSlackOauthCallbackResponse, error)

	// InfoGetVersionWithResponse request
	InfoGetVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InfoGetVersionResponse, error)

	// WebhookDeleteWithResponse request
	WebhookDeleteWithResponse(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*WebhookDeleteResponse, error)

	// WebhookRequestsListWithResponse request
	WebhookRequestsListWithResponse(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*WebhookRequestsListResponse, error)

	// WorkerGetWithResponse request
	WorkerGetWithResponse(ctx context.Context, worker openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkerGetResponse, error)

	// WorkerUpdateWithBodyWithResponse request with any body
	WorkerUpdateWithBodyWithResponse(ctx context.Context, worker openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkerUpdateResponse, error)

	WorkerUpdateWithResponse(ctx context.Context, worker openapi_types.UUID, body WorkerUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkerUpdateResponse, error)

	// WorkflowDeleteWithResponse request
	WorkflowDeleteWithResponse(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowDeleteResponse, error)

	// WorkflowGetWithResponse request
	WorkflowGetWithResponse(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowGetResponse, error)

	// WorkflowUpdateWithBodyWithResponse request with any body
	WorkflowUpdateWithBodyWithResponse(ctx context.Context, workflow openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkflowUpdateResponse, error)

	WorkflowUpdateWithResponse(ctx context.Context, workflow openapi_types.UUID, body WorkflowUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkflowUpdateResponse, error)

	// WorkflowGetMetricsWithResponse request
	WorkflowGetMetricsWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowGetMetricsParams, reqEditors ...RequestEditorFn) (*WorkflowGetMetricsResponse, error)

	// WorkflowRunCreateWithBodyWithResponse request with any body
	WorkflowRunCreateWithBodyWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkflowRunCreateResponse, error)

	WorkflowRunCreateWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, body WorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkflowRunCreateResponse, error)

	// WorkflowVersionGetWithResponse request
	WorkflowVersionGetWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetParams, reqEditors ...RequestEditorFn) (*WorkflowVersionGetResponse, error)
}

type LivenessGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LivenessGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LivenessGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadinessGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReadinessGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadinessGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertEmailGroupDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r AlertEmailGroupDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertEmailGroupDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertEmailGroupUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantAlertEmailGroup
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r AlertEmailGroupUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertEmailGroupUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiTokenUpdateRevokeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r ApiTokenUpdateRevokeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiTokenUpdateRevokeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CloudMetadataGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *APIErrors
	JSON400      *APIErrors
}

// Status returns HTTPResponse.Status
func (r CloudMetadataGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CloudMetadataGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Event
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r EventGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventDataGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventData
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r EventDataGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventDataGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetadataGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *APIMeta
	JSON400      *APIErrors
}

// Status returns HTTPResponse.Status
func (r MetadataGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetadataGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetadataListIntegrationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAPIMetaIntegration
	JSON400      *APIErrors
}

// Status returns HTTPResponse.Status
func (r MetadataListIntegrationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetadataListIntegrationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MonitoringPostRunProbeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r MonitoringPostRunProbeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MonitoringPostRunProbeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlackWebhookDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r SlackWebhookDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlackWebhookDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r SnsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r SnsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1DagListTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]V1DagChildren
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON501      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1DagListTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1DagListTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1TaskGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1TaskSummary
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
	JSON501      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1TaskGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1TaskGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1LogLineListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1LogLineList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1LogLineListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1LogLineListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1TaskEventListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1TaskEventList
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
	JSON501      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1TaskEventListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1TaskEventListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1EventListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1EventList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1EventListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1EventListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1EventKeyListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventKeyList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1EventKeyListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1EventKeyListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1FilterListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1FilterList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1FilterListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1FilterListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1FilterCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1Filter
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1FilterCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1FilterCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1FilterDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1Filter
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1FilterDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1FilterDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1FilterGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1Filter
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1FilterGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1FilterGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1FilterUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1Filter
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1FilterUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1FilterUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1TaskListStatusMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1TaskRunMetrics
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON501      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1TaskListStatusMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1TaskListStatusMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1TaskGetPointMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1TaskPointMetrics
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON501      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1TaskGetPointMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1TaskGetPointMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1TaskCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
	JSON501      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1TaskCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1TaskCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1TaskReplayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
	JSON501      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1TaskReplayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1TaskReplayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1WorkflowRunListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1TaskSummaryList
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON501      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1WorkflowRunListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1WorkflowRunListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1WorkflowRunDisplayNamesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1WorkflowRunDisplayNameList
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON501      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1WorkflowRunDisplayNamesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1WorkflowRunDisplayNamesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1WorkflowRunCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1WorkflowRunDetails
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1WorkflowRunCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1WorkflowRunCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1WorkflowRunGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1WorkflowRunDetails
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON501      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1WorkflowRunGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1WorkflowRunGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1WorkflowRunGetStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1TaskStatus
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
	JSON501      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1WorkflowRunGetStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1WorkflowRunGetStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1WorkflowRunTaskEventsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1TaskEventList
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON501      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1WorkflowRunTaskEventsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1WorkflowRunTaskEventsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type V1WorkflowRunGetTimingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V1TaskTimingList
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON501      *APIErrors
}

// Status returns HTTPResponse.Status
func (r V1WorkflowRunGetTimingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r V1WorkflowRunGetTimingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunListArchivesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StepRunArchiveList
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunListArchivesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunListArchivesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunListEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StepRunEventList
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunListEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunListEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogLineListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogLineList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r LogLineListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogLineListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tenant
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tenant
	JSON400      *APIErrors
	JSON403      *APIError
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r TenantGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tenant
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertEmailGroupListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantAlertEmailGroupList
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r AlertEmailGroupListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertEmailGroupListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertEmailGroupCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TenantAlertEmailGroup
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r AlertEmailGroupCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertEmailGroupCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantAlertingSettingsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantAlertingSettings
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantAlertingSettingsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantAlertingSettingsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiTokenListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAPITokensResponse
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r ApiTokenListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiTokenListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApiTokenCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateAPITokenResponse
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r ApiTokenCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApiTokenCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r EventListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Event
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON429      *APIErrors
}

// Status returns HTTPResponse.Status
func (r EventCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventCreateBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Events
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON429      *APIErrors
}

// Status returns HTTPResponse.Status
func (r EventCreateBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventCreateBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventUpdateCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		WorkflowRunIds *[]openapi_types.UUID `json:"workflowRunIds,omitempty"`
	}
	JSON400 *APIErrors
	JSON403 *APIErrors
	JSON429 *APIErrors
}

// Status returns HTTPResponse.Status
func (r EventUpdateCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventUpdateCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventKeyListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventKeyList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r EventKeyListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventKeyListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventUpdateReplayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventList
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON429      *APIErrors
}

// Status returns HTTPResponse.Status
func (r EventUpdateReplayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventUpdateReplayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantInviteList
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantInviteListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TenantInvite
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantInviteCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantInvite
	JSON400      *APIErrors
}

// Status returns HTTPResponse.Status
func (r TenantInviteDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantInvite
	JSON400      *APIErrors
}

// Status returns HTTPResponse.Status
func (r TenantInviteUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantMemberListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantMemberList
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantMemberListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantMemberListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantMemberDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *TenantMember
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r TenantMemberDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantMemberDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantGetPrometheusMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r TenantGetPrometheusMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantGetPrometheusMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantGetQueueMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantQueueMetrics
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r TenantGetQueueMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantGetQueueMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RateLimitListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RateLimitList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r RateLimitListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RateLimitListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantResourcePolicyGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantResourcePolicy
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantResourcePolicyGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantResourcePolicyGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlackWebhookListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSlackWebhooks
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r SlackWebhookListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlackWebhookListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateSlackOauthStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateSlackOauthStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateSlackOauthStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSNSIntegrations
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r SnsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SNSIntegration
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r SnsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantGetStepRunQueueMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantStepRunQueueMetrics
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r TenantGetStepRunQueueMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantGetStepRunQueueMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StepRun
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunUpdateCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StepRun
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunUpdateCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunUpdateCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunUpdateRerunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StepRun
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunUpdateRerunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunUpdateRerunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StepRunGetSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r StepRunGetSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StepRunGetSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhookListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookWorkerListResponse
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WebhookListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhookListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhookCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookWorkerCreated
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WebhookCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhookCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkerList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkerListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunUpdateReplayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReplayWorkflowRunsResponse
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON429      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunUpdateReplayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunUpdateReplayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowRun
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunGetInputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunGetInputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunGetInputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunGetShapeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowRunShape
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunGetShapeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunGetShapeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunListStepRunEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StepRunEventList
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunListStepRunEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunListStepRunEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		WorkflowRunIds *[]openapi_types.UUID `json:"workflowRunIds,omitempty"`
	}
	JSON400 *APIErrors
	JSON403 *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CronWorkflowListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CronWorkflowsList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r CronWorkflowListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CronWorkflowListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowCronDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r WorkflowCronDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowCronDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowCronGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CronWorkflows
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowCronGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowCronGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowRunList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunGetMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowRunsMetrics
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunGetMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunGetMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowScheduledListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScheduledWorkflowsList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowScheduledListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowScheduledListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowScheduledDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r WorkflowScheduledDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowScheduledDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowScheduledGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScheduledWorkflows
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowScheduledGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowScheduledGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CronWorkflowTriggerCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CronWorkflows
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
	JSON429      *APIErrors
}

// Status returns HTTPResponse.Status
func (r CronWorkflowTriggerCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CronWorkflowTriggerCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScheduledWorkflowRunCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScheduledWorkflows
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
	JSON429      *APIErrors
}

// Status returns HTTPResponse.Status
func (r ScheduledWorkflowRunCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScheduledWorkflowRunCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowGetWorkersCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowWorkersCount
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowGetWorkersCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowGetWorkersCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserGetCurrentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserGetCurrentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserGetCurrentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateGithubOauthCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateGithubOauthCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateGithubOauthCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateGithubOauthStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateGithubOauthStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateGithubOauthStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateGoogleOauthCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateGoogleOauthCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateGoogleOauthCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateGoogleOauthStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateGoogleOauthStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateGoogleOauthStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserListTenantInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantInviteList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserListTenantInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserListTenantInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteAcceptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantInviteAcceptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteAcceptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantInviteRejectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIError
}

// Status returns HTTPResponse.Status
func (r TenantInviteRejectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantInviteRejectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserUpdateLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateLogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserUpdateLogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateLogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantMembershipsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserTenantMembershipsList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r TenantMembershipsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantMembershipsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdatePasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserUpdatePasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdatePasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r UserCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateSlackOauthCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateSlackOauthCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateSlackOauthCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InfoGetVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Version string `json:"version"`
	}
}

// Status returns HTTPResponse.Status
func (r InfoGetVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InfoGetVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhookDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WebhookDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhookDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebhookRequestsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookWorkerRequestListResponse
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WebhookRequestsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebhookRequestsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Worker
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkerGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Worker
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkerUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workflow
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workflow
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowGetMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowMetrics
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowGetMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowGetMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowRun
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
	JSON429      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowVersionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowVersion
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowVersionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowVersionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// LivenessGetWithResponse request returning *LivenessGetResponse
func (c *ClientWithResponses) LivenessGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LivenessGetResponse, error) {
	rsp, err := c.LivenessGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLivenessGetResponse(rsp)
}

// ReadinessGetWithResponse request returning *ReadinessGetResponse
func (c *ClientWithResponses) ReadinessGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReadinessGetResponse, error) {
	rsp, err := c.ReadinessGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadinessGetResponse(rsp)
}

// AlertEmailGroupDeleteWithResponse request returning *AlertEmailGroupDeleteResponse
func (c *ClientWithResponses) AlertEmailGroupDeleteWithResponse(ctx context.Context, alertEmailGroup openapi_types.UUID, reqEditors ...RequestEditorFn) (*AlertEmailGroupDeleteResponse, error) {
	rsp, err := c.AlertEmailGroupDelete(ctx, alertEmailGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertEmailGroupDeleteResponse(rsp)
}

// AlertEmailGroupUpdateWithBodyWithResponse request with arbitrary body returning *AlertEmailGroupUpdateResponse
func (c *ClientWithResponses) AlertEmailGroupUpdateWithBodyWithResponse(ctx context.Context, alertEmailGroup openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AlertEmailGroupUpdateResponse, error) {
	rsp, err := c.AlertEmailGroupUpdateWithBody(ctx, alertEmailGroup, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertEmailGroupUpdateResponse(rsp)
}

func (c *ClientWithResponses) AlertEmailGroupUpdateWithResponse(ctx context.Context, alertEmailGroup openapi_types.UUID, body AlertEmailGroupUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*AlertEmailGroupUpdateResponse, error) {
	rsp, err := c.AlertEmailGroupUpdate(ctx, alertEmailGroup, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertEmailGroupUpdateResponse(rsp)
}

// ApiTokenUpdateRevokeWithResponse request returning *ApiTokenUpdateRevokeResponse
func (c *ClientWithResponses) ApiTokenUpdateRevokeWithResponse(ctx context.Context, apiToken openapi_types.UUID, reqEditors ...RequestEditorFn) (*ApiTokenUpdateRevokeResponse, error) {
	rsp, err := c.ApiTokenUpdateRevoke(ctx, apiToken, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiTokenUpdateRevokeResponse(rsp)
}

// CloudMetadataGetWithResponse request returning *CloudMetadataGetResponse
func (c *ClientWithResponses) CloudMetadataGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CloudMetadataGetResponse, error) {
	rsp, err := c.CloudMetadataGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloudMetadataGetResponse(rsp)
}

// EventGetWithResponse request returning *EventGetResponse
func (c *ClientWithResponses) EventGetWithResponse(ctx context.Context, event openapi_types.UUID, reqEditors ...RequestEditorFn) (*EventGetResponse, error) {
	rsp, err := c.EventGet(ctx, event, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventGetResponse(rsp)
}

// EventDataGetWithResponse request returning *EventDataGetResponse
func (c *ClientWithResponses) EventDataGetWithResponse(ctx context.Context, event openapi_types.UUID, reqEditors ...RequestEditorFn) (*EventDataGetResponse, error) {
	rsp, err := c.EventDataGet(ctx, event, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventDataGetResponse(rsp)
}

// MetadataGetWithResponse request returning *MetadataGetResponse
func (c *ClientWithResponses) MetadataGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetadataGetResponse, error) {
	rsp, err := c.MetadataGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataGetResponse(rsp)
}

// MetadataListIntegrationsWithResponse request returning *MetadataListIntegrationsResponse
func (c *ClientWithResponses) MetadataListIntegrationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetadataListIntegrationsResponse, error) {
	rsp, err := c.MetadataListIntegrations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataListIntegrationsResponse(rsp)
}

// MonitoringPostRunProbeWithResponse request returning *MonitoringPostRunProbeResponse
func (c *ClientWithResponses) MonitoringPostRunProbeWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*MonitoringPostRunProbeResponse, error) {
	rsp, err := c.MonitoringPostRunProbe(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMonitoringPostRunProbeResponse(rsp)
}

// SlackWebhookDeleteWithResponse request returning *SlackWebhookDeleteResponse
func (c *ClientWithResponses) SlackWebhookDeleteWithResponse(ctx context.Context, slack openapi_types.UUID, reqEditors ...RequestEditorFn) (*SlackWebhookDeleteResponse, error) {
	rsp, err := c.SlackWebhookDelete(ctx, slack, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlackWebhookDeleteResponse(rsp)
}

// SnsDeleteWithResponse request returning *SnsDeleteResponse
func (c *ClientWithResponses) SnsDeleteWithResponse(ctx context.Context, sns openapi_types.UUID, reqEditors ...RequestEditorFn) (*SnsDeleteResponse, error) {
	rsp, err := c.SnsDelete(ctx, sns, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnsDeleteResponse(rsp)
}

// SnsUpdateWithResponse request returning *SnsUpdateResponse
func (c *ClientWithResponses) SnsUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, event string, reqEditors ...RequestEditorFn) (*SnsUpdateResponse, error) {
	rsp, err := c.SnsUpdate(ctx, tenant, event, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnsUpdateResponse(rsp)
}

// V1DagListTasksWithResponse request returning *V1DagListTasksResponse
func (c *ClientWithResponses) V1DagListTasksWithResponse(ctx context.Context, params *V1DagListTasksParams, reqEditors ...RequestEditorFn) (*V1DagListTasksResponse, error) {
	rsp, err := c.V1DagListTasks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1DagListTasksResponse(rsp)
}

// V1TaskGetWithResponse request returning *V1TaskGetResponse
func (c *ClientWithResponses) V1TaskGetWithResponse(ctx context.Context, task openapi_types.UUID, params *V1TaskGetParams, reqEditors ...RequestEditorFn) (*V1TaskGetResponse, error) {
	rsp, err := c.V1TaskGet(ctx, task, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1TaskGetResponse(rsp)
}

// V1LogLineListWithResponse request returning *V1LogLineListResponse
func (c *ClientWithResponses) V1LogLineListWithResponse(ctx context.Context, task openapi_types.UUID, reqEditors ...RequestEditorFn) (*V1LogLineListResponse, error) {
	rsp, err := c.V1LogLineList(ctx, task, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1LogLineListResponse(rsp)
}

// V1TaskEventListWithResponse request returning *V1TaskEventListResponse
func (c *ClientWithResponses) V1TaskEventListWithResponse(ctx context.Context, task openapi_types.UUID, params *V1TaskEventListParams, reqEditors ...RequestEditorFn) (*V1TaskEventListResponse, error) {
	rsp, err := c.V1TaskEventList(ctx, task, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1TaskEventListResponse(rsp)
}

// V1EventListWithResponse request returning *V1EventListResponse
func (c *ClientWithResponses) V1EventListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *V1EventListParams, reqEditors ...RequestEditorFn) (*V1EventListResponse, error) {
	rsp, err := c.V1EventList(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1EventListResponse(rsp)
}

// V1EventKeyListWithResponse request returning *V1EventKeyListResponse
func (c *ClientWithResponses) V1EventKeyListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*V1EventKeyListResponse, error) {
	rsp, err := c.V1EventKeyList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1EventKeyListResponse(rsp)
}

// V1FilterListWithResponse request returning *V1FilterListResponse
func (c *ClientWithResponses) V1FilterListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *V1FilterListParams, reqEditors ...RequestEditorFn) (*V1FilterListResponse, error) {
	rsp, err := c.V1FilterList(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1FilterListResponse(rsp)
}

// V1FilterCreateWithBodyWithResponse request with arbitrary body returning *V1FilterCreateResponse
func (c *ClientWithResponses) V1FilterCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*V1FilterCreateResponse, error) {
	rsp, err := c.V1FilterCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1FilterCreateResponse(rsp)
}

func (c *ClientWithResponses) V1FilterCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body V1FilterCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*V1FilterCreateResponse, error) {
	rsp, err := c.V1FilterCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1FilterCreateResponse(rsp)
}

// V1FilterDeleteWithResponse request returning *V1FilterDeleteResponse
func (c *ClientWithResponses) V1FilterDeleteWithResponse(ctx context.Context, tenant openapi_types.UUID, v1Filter openapi_types.UUID, reqEditors ...RequestEditorFn) (*V1FilterDeleteResponse, error) {
	rsp, err := c.V1FilterDelete(ctx, tenant, v1Filter, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1FilterDeleteResponse(rsp)
}

// V1FilterGetWithResponse request returning *V1FilterGetResponse
func (c *ClientWithResponses) V1FilterGetWithResponse(ctx context.Context, tenant openapi_types.UUID, v1Filter openapi_types.UUID, reqEditors ...RequestEditorFn) (*V1FilterGetResponse, error) {
	rsp, err := c.V1FilterGet(ctx, tenant, v1Filter, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1FilterGetResponse(rsp)
}

// V1FilterUpdateWithBodyWithResponse request with arbitrary body returning *V1FilterUpdateResponse
func (c *ClientWithResponses) V1FilterUpdateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, v1Filter openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*V1FilterUpdateResponse, error) {
	rsp, err := c.V1FilterUpdateWithBody(ctx, tenant, v1Filter, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1FilterUpdateResponse(rsp)
}

func (c *ClientWithResponses) V1FilterUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, v1Filter openapi_types.UUID, body V1FilterUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*V1FilterUpdateResponse, error) {
	rsp, err := c.V1FilterUpdate(ctx, tenant, v1Filter, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1FilterUpdateResponse(rsp)
}

// V1TaskListStatusMetricsWithResponse request returning *V1TaskListStatusMetricsResponse
func (c *ClientWithResponses) V1TaskListStatusMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, params *V1TaskListStatusMetricsParams, reqEditors ...RequestEditorFn) (*V1TaskListStatusMetricsResponse, error) {
	rsp, err := c.V1TaskListStatusMetrics(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1TaskListStatusMetricsResponse(rsp)
}

// V1TaskGetPointMetricsWithResponse request returning *V1TaskGetPointMetricsResponse
func (c *ClientWithResponses) V1TaskGetPointMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, params *V1TaskGetPointMetricsParams, reqEditors ...RequestEditorFn) (*V1TaskGetPointMetricsResponse, error) {
	rsp, err := c.V1TaskGetPointMetrics(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1TaskGetPointMetricsResponse(rsp)
}

// V1TaskCancelWithBodyWithResponse request with arbitrary body returning *V1TaskCancelResponse
func (c *ClientWithResponses) V1TaskCancelWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*V1TaskCancelResponse, error) {
	rsp, err := c.V1TaskCancelWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1TaskCancelResponse(rsp)
}

func (c *ClientWithResponses) V1TaskCancelWithResponse(ctx context.Context, tenant openapi_types.UUID, body V1TaskCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*V1TaskCancelResponse, error) {
	rsp, err := c.V1TaskCancel(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1TaskCancelResponse(rsp)
}

// V1TaskReplayWithBodyWithResponse request with arbitrary body returning *V1TaskReplayResponse
func (c *ClientWithResponses) V1TaskReplayWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*V1TaskReplayResponse, error) {
	rsp, err := c.V1TaskReplayWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1TaskReplayResponse(rsp)
}

func (c *ClientWithResponses) V1TaskReplayWithResponse(ctx context.Context, tenant openapi_types.UUID, body V1TaskReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*V1TaskReplayResponse, error) {
	rsp, err := c.V1TaskReplay(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1TaskReplayResponse(rsp)
}

// V1WorkflowRunListWithResponse request returning *V1WorkflowRunListResponse
func (c *ClientWithResponses) V1WorkflowRunListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *V1WorkflowRunListParams, reqEditors ...RequestEditorFn) (*V1WorkflowRunListResponse, error) {
	rsp, err := c.V1WorkflowRunList(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1WorkflowRunListResponse(rsp)
}

// V1WorkflowRunDisplayNamesListWithResponse request returning *V1WorkflowRunDisplayNamesListResponse
func (c *ClientWithResponses) V1WorkflowRunDisplayNamesListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *V1WorkflowRunDisplayNamesListParams, reqEditors ...RequestEditorFn) (*V1WorkflowRunDisplayNamesListResponse, error) {
	rsp, err := c.V1WorkflowRunDisplayNamesList(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1WorkflowRunDisplayNamesListResponse(rsp)
}

// V1WorkflowRunCreateWithBodyWithResponse request with arbitrary body returning *V1WorkflowRunCreateResponse
func (c *ClientWithResponses) V1WorkflowRunCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*V1WorkflowRunCreateResponse, error) {
	rsp, err := c.V1WorkflowRunCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1WorkflowRunCreateResponse(rsp)
}

func (c *ClientWithResponses) V1WorkflowRunCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body V1WorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*V1WorkflowRunCreateResponse, error) {
	rsp, err := c.V1WorkflowRunCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1WorkflowRunCreateResponse(rsp)
}

// V1WorkflowRunGetWithResponse request returning *V1WorkflowRunGetResponse
func (c *ClientWithResponses) V1WorkflowRunGetWithResponse(ctx context.Context, v1WorkflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*V1WorkflowRunGetResponse, error) {
	rsp, err := c.V1WorkflowRunGet(ctx, v1WorkflowRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1WorkflowRunGetResponse(rsp)
}

// V1WorkflowRunGetStatusWithResponse request returning *V1WorkflowRunGetStatusResponse
func (c *ClientWithResponses) V1WorkflowRunGetStatusWithResponse(ctx context.Context, v1WorkflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*V1WorkflowRunGetStatusResponse, error) {
	rsp, err := c.V1WorkflowRunGetStatus(ctx, v1WorkflowRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1WorkflowRunGetStatusResponse(rsp)
}

// V1WorkflowRunTaskEventsListWithResponse request returning *V1WorkflowRunTaskEventsListResponse
func (c *ClientWithResponses) V1WorkflowRunTaskEventsListWithResponse(ctx context.Context, v1WorkflowRun openapi_types.UUID, params *V1WorkflowRunTaskEventsListParams, reqEditors ...RequestEditorFn) (*V1WorkflowRunTaskEventsListResponse, error) {
	rsp, err := c.V1WorkflowRunTaskEventsList(ctx, v1WorkflowRun, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1WorkflowRunTaskEventsListResponse(rsp)
}

// V1WorkflowRunGetTimingsWithResponse request returning *V1WorkflowRunGetTimingsResponse
func (c *ClientWithResponses) V1WorkflowRunGetTimingsWithResponse(ctx context.Context, v1WorkflowRun openapi_types.UUID, params *V1WorkflowRunGetTimingsParams, reqEditors ...RequestEditorFn) (*V1WorkflowRunGetTimingsResponse, error) {
	rsp, err := c.V1WorkflowRunGetTimings(ctx, v1WorkflowRun, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseV1WorkflowRunGetTimingsResponse(rsp)
}

// StepRunListArchivesWithResponse request returning *StepRunListArchivesResponse
func (c *ClientWithResponses) StepRunListArchivesWithResponse(ctx context.Context, stepRun openapi_types.UUID, params *StepRunListArchivesParams, reqEditors ...RequestEditorFn) (*StepRunListArchivesResponse, error) {
	rsp, err := c.StepRunListArchives(ctx, stepRun, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunListArchivesResponse(rsp)
}

// StepRunListEventsWithResponse request returning *StepRunListEventsResponse
func (c *ClientWithResponses) StepRunListEventsWithResponse(ctx context.Context, stepRun openapi_types.UUID, params *StepRunListEventsParams, reqEditors ...RequestEditorFn) (*StepRunListEventsResponse, error) {
	rsp, err := c.StepRunListEvents(ctx, stepRun, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunListEventsResponse(rsp)
}

// LogLineListWithResponse request returning *LogLineListResponse
func (c *ClientWithResponses) LogLineListWithResponse(ctx context.Context, stepRun openapi_types.UUID, params *LogLineListParams, reqEditors ...RequestEditorFn) (*LogLineListResponse, error) {
	rsp, err := c.LogLineList(ctx, stepRun, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogLineListResponse(rsp)
}

// TenantCreateWithBodyWithResponse request with arbitrary body returning *TenantCreateResponse
func (c *ClientWithResponses) TenantCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantCreateResponse, error) {
	rsp, err := c.TenantCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantCreateResponse(rsp)
}

func (c *ClientWithResponses) TenantCreateWithResponse(ctx context.Context, body TenantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantCreateResponse, error) {
	rsp, err := c.TenantCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantCreateResponse(rsp)
}

// TenantGetWithResponse request returning *TenantGetResponse
func (c *ClientWithResponses) TenantGetWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantGetResponse, error) {
	rsp, err := c.TenantGet(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantGetResponse(rsp)
}

// TenantUpdateWithBodyWithResponse request with arbitrary body returning *TenantUpdateResponse
func (c *ClientWithResponses) TenantUpdateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantUpdateResponse, error) {
	rsp, err := c.TenantUpdateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantUpdateResponse(rsp)
}

func (c *ClientWithResponses) TenantUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, body TenantUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantUpdateResponse, error) {
	rsp, err := c.TenantUpdate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantUpdateResponse(rsp)
}

// AlertEmailGroupListWithResponse request returning *AlertEmailGroupListResponse
func (c *ClientWithResponses) AlertEmailGroupListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*AlertEmailGroupListResponse, error) {
	rsp, err := c.AlertEmailGroupList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertEmailGroupListResponse(rsp)
}

// AlertEmailGroupCreateWithBodyWithResponse request with arbitrary body returning *AlertEmailGroupCreateResponse
func (c *ClientWithResponses) AlertEmailGroupCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AlertEmailGroupCreateResponse, error) {
	rsp, err := c.AlertEmailGroupCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertEmailGroupCreateResponse(rsp)
}

func (c *ClientWithResponses) AlertEmailGroupCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body AlertEmailGroupCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AlertEmailGroupCreateResponse, error) {
	rsp, err := c.AlertEmailGroupCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertEmailGroupCreateResponse(rsp)
}

// TenantAlertingSettingsGetWithResponse request returning *TenantAlertingSettingsGetResponse
func (c *ClientWithResponses) TenantAlertingSettingsGetWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantAlertingSettingsGetResponse, error) {
	rsp, err := c.TenantAlertingSettingsGet(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantAlertingSettingsGetResponse(rsp)
}

// ApiTokenListWithResponse request returning *ApiTokenListResponse
func (c *ClientWithResponses) ApiTokenListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*ApiTokenListResponse, error) {
	rsp, err := c.ApiTokenList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiTokenListResponse(rsp)
}

// ApiTokenCreateWithBodyWithResponse request with arbitrary body returning *ApiTokenCreateResponse
func (c *ClientWithResponses) ApiTokenCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApiTokenCreateResponse, error) {
	rsp, err := c.ApiTokenCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiTokenCreateResponse(rsp)
}

func (c *ClientWithResponses) ApiTokenCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body ApiTokenCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ApiTokenCreateResponse, error) {
	rsp, err := c.ApiTokenCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApiTokenCreateResponse(rsp)
}

// EventListWithResponse request returning *EventListResponse
func (c *ClientWithResponses) EventListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *EventListParams, reqEditors ...RequestEditorFn) (*EventListResponse, error) {
	rsp, err := c.EventList(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventListResponse(rsp)
}

// EventCreateWithBodyWithResponse request with arbitrary body returning *EventCreateResponse
func (c *ClientWithResponses) EventCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventCreateResponse, error) {
	rsp, err := c.EventCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventCreateResponse(rsp)
}

func (c *ClientWithResponses) EventCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body EventCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*EventCreateResponse, error) {
	rsp, err := c.EventCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventCreateResponse(rsp)
}

// EventCreateBulkWithBodyWithResponse request with arbitrary body returning *EventCreateBulkResponse
func (c *ClientWithResponses) EventCreateBulkWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventCreateBulkResponse, error) {
	rsp, err := c.EventCreateBulkWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventCreateBulkResponse(rsp)
}

func (c *ClientWithResponses) EventCreateBulkWithResponse(ctx context.Context, tenant openapi_types.UUID, body EventCreateBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*EventCreateBulkResponse, error) {
	rsp, err := c.EventCreateBulk(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventCreateBulkResponse(rsp)
}

// EventUpdateCancelWithBodyWithResponse request with arbitrary body returning *EventUpdateCancelResponse
func (c *ClientWithResponses) EventUpdateCancelWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventUpdateCancelResponse, error) {
	rsp, err := c.EventUpdateCancelWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventUpdateCancelResponse(rsp)
}

func (c *ClientWithResponses) EventUpdateCancelWithResponse(ctx context.Context, tenant openapi_types.UUID, body EventUpdateCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*EventUpdateCancelResponse, error) {
	rsp, err := c.EventUpdateCancel(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventUpdateCancelResponse(rsp)
}

// EventKeyListWithResponse request returning *EventKeyListResponse
func (c *ClientWithResponses) EventKeyListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*EventKeyListResponse, error) {
	rsp, err := c.EventKeyList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventKeyListResponse(rsp)
}

// EventUpdateReplayWithBodyWithResponse request with arbitrary body returning *EventUpdateReplayResponse
func (c *ClientWithResponses) EventUpdateReplayWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EventUpdateReplayResponse, error) {
	rsp, err := c.EventUpdateReplayWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventUpdateReplayResponse(rsp)
}

func (c *ClientWithResponses) EventUpdateReplayWithResponse(ctx context.Context, tenant openapi_types.UUID, body EventUpdateReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*EventUpdateReplayResponse, error) {
	rsp, err := c.EventUpdateReplay(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventUpdateReplayResponse(rsp)
}

// TenantInviteListWithResponse request returning *TenantInviteListResponse
func (c *ClientWithResponses) TenantInviteListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantInviteListResponse, error) {
	rsp, err := c.TenantInviteList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteListResponse(rsp)
}

// TenantInviteCreateWithBodyWithResponse request with arbitrary body returning *TenantInviteCreateResponse
func (c *ClientWithResponses) TenantInviteCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteCreateResponse, error) {
	rsp, err := c.TenantInviteCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteCreateResponse(rsp)
}

func (c *ClientWithResponses) TenantInviteCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body TenantInviteCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteCreateResponse, error) {
	rsp, err := c.TenantInviteCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteCreateResponse(rsp)
}

// TenantInviteDeleteWithResponse request returning *TenantInviteDeleteResponse
func (c *ClientWithResponses) TenantInviteDeleteWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantInviteDeleteResponse, error) {
	rsp, err := c.TenantInviteDelete(ctx, tenant, tenantInvite, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteDeleteResponse(rsp)
}

// TenantInviteUpdateWithBodyWithResponse request with arbitrary body returning *TenantInviteUpdateResponse
func (c *ClientWithResponses) TenantInviteUpdateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteUpdateResponse, error) {
	rsp, err := c.TenantInviteUpdateWithBody(ctx, tenant, tenantInvite, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteUpdateResponse(rsp)
}

func (c *ClientWithResponses) TenantInviteUpdateWithResponse(ctx context.Context, tenant openapi_types.UUID, tenantInvite openapi_types.UUID, body TenantInviteUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteUpdateResponse, error) {
	rsp, err := c.TenantInviteUpdate(ctx, tenant, tenantInvite, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteUpdateResponse(rsp)
}

// TenantMemberListWithResponse request returning *TenantMemberListResponse
func (c *ClientWithResponses) TenantMemberListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantMemberListResponse, error) {
	rsp, err := c.TenantMemberList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantMemberListResponse(rsp)
}

// TenantMemberDeleteWithResponse request returning *TenantMemberDeleteResponse
func (c *ClientWithResponses) TenantMemberDeleteWithResponse(ctx context.Context, tenant openapi_types.UUID, member openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantMemberDeleteResponse, error) {
	rsp, err := c.TenantMemberDelete(ctx, tenant, member, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantMemberDeleteResponse(rsp)
}

// TenantGetPrometheusMetricsWithResponse request returning *TenantGetPrometheusMetricsResponse
func (c *ClientWithResponses) TenantGetPrometheusMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantGetPrometheusMetricsResponse, error) {
	rsp, err := c.TenantGetPrometheusMetrics(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantGetPrometheusMetricsResponse(rsp)
}

// TenantGetQueueMetricsWithResponse request returning *TenantGetQueueMetricsResponse
func (c *ClientWithResponses) TenantGetQueueMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, params *TenantGetQueueMetricsParams, reqEditors ...RequestEditorFn) (*TenantGetQueueMetricsResponse, error) {
	rsp, err := c.TenantGetQueueMetrics(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantGetQueueMetricsResponse(rsp)
}

// RateLimitListWithResponse request returning *RateLimitListResponse
func (c *ClientWithResponses) RateLimitListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *RateLimitListParams, reqEditors ...RequestEditorFn) (*RateLimitListResponse, error) {
	rsp, err := c.RateLimitList(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRateLimitListResponse(rsp)
}

// TenantResourcePolicyGetWithResponse request returning *TenantResourcePolicyGetResponse
func (c *ClientWithResponses) TenantResourcePolicyGetWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantResourcePolicyGetResponse, error) {
	rsp, err := c.TenantResourcePolicyGet(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantResourcePolicyGetResponse(rsp)
}

// SlackWebhookListWithResponse request returning *SlackWebhookListResponse
func (c *ClientWithResponses) SlackWebhookListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*SlackWebhookListResponse, error) {
	rsp, err := c.SlackWebhookList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlackWebhookListResponse(rsp)
}

// UserUpdateSlackOauthStartWithResponse request returning *UserUpdateSlackOauthStartResponse
func (c *ClientWithResponses) UserUpdateSlackOauthStartWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*UserUpdateSlackOauthStartResponse, error) {
	rsp, err := c.UserUpdateSlackOauthStart(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateSlackOauthStartResponse(rsp)
}

// SnsListWithResponse request returning *SnsListResponse
func (c *ClientWithResponses) SnsListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*SnsListResponse, error) {
	rsp, err := c.SnsList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnsListResponse(rsp)
}

// SnsCreateWithBodyWithResponse request with arbitrary body returning *SnsCreateResponse
func (c *ClientWithResponses) SnsCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SnsCreateResponse, error) {
	rsp, err := c.SnsCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnsCreateResponse(rsp)
}

func (c *ClientWithResponses) SnsCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body SnsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SnsCreateResponse, error) {
	rsp, err := c.SnsCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSnsCreateResponse(rsp)
}

// TenantGetStepRunQueueMetricsWithResponse request returning *TenantGetStepRunQueueMetricsResponse
func (c *ClientWithResponses) TenantGetStepRunQueueMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantGetStepRunQueueMetricsResponse, error) {
	rsp, err := c.TenantGetStepRunQueueMetrics(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantGetStepRunQueueMetricsResponse(rsp)
}

// StepRunGetWithResponse request returning *StepRunGetResponse
func (c *ClientWithResponses) StepRunGetWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunGetResponse, error) {
	rsp, err := c.StepRunGet(ctx, tenant, stepRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunGetResponse(rsp)
}

// StepRunUpdateCancelWithResponse request returning *StepRunUpdateCancelResponse
func (c *ClientWithResponses) StepRunUpdateCancelWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunUpdateCancelResponse, error) {
	rsp, err := c.StepRunUpdateCancel(ctx, tenant, stepRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunUpdateCancelResponse(rsp)
}

// StepRunUpdateRerunWithBodyWithResponse request with arbitrary body returning *StepRunUpdateRerunResponse
func (c *ClientWithResponses) StepRunUpdateRerunWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StepRunUpdateRerunResponse, error) {
	rsp, err := c.StepRunUpdateRerunWithBody(ctx, tenant, stepRun, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunUpdateRerunResponse(rsp)
}

func (c *ClientWithResponses) StepRunUpdateRerunWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, body StepRunUpdateRerunJSONRequestBody, reqEditors ...RequestEditorFn) (*StepRunUpdateRerunResponse, error) {
	rsp, err := c.StepRunUpdateRerun(ctx, tenant, stepRun, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunUpdateRerunResponse(rsp)
}

// StepRunGetSchemaWithResponse request returning *StepRunGetSchemaResponse
func (c *ClientWithResponses) StepRunGetSchemaWithResponse(ctx context.Context, tenant openapi_types.UUID, stepRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*StepRunGetSchemaResponse, error) {
	rsp, err := c.StepRunGetSchema(ctx, tenant, stepRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStepRunGetSchemaResponse(rsp)
}

// WebhookListWithResponse request returning *WebhookListResponse
func (c *ClientWithResponses) WebhookListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*WebhookListResponse, error) {
	rsp, err := c.WebhookList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhookListResponse(rsp)
}

// WebhookCreateWithBodyWithResponse request with arbitrary body returning *WebhookCreateResponse
func (c *ClientWithResponses) WebhookCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebhookCreateResponse, error) {
	rsp, err := c.WebhookCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhookCreateResponse(rsp)
}

func (c *ClientWithResponses) WebhookCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body WebhookCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WebhookCreateResponse, error) {
	rsp, err := c.WebhookCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhookCreateResponse(rsp)
}

// WorkerListWithResponse request returning *WorkerListResponse
func (c *ClientWithResponses) WorkerListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkerListResponse, error) {
	rsp, err := c.WorkerList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerListResponse(rsp)
}

// WorkflowRunUpdateReplayWithBodyWithResponse request with arbitrary body returning *WorkflowRunUpdateReplayResponse
func (c *ClientWithResponses) WorkflowRunUpdateReplayWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkflowRunUpdateReplayResponse, error) {
	rsp, err := c.WorkflowRunUpdateReplayWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunUpdateReplayResponse(rsp)
}

func (c *ClientWithResponses) WorkflowRunUpdateReplayWithResponse(ctx context.Context, tenant openapi_types.UUID, body WorkflowRunUpdateReplayJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkflowRunUpdateReplayResponse, error) {
	rsp, err := c.WorkflowRunUpdateReplay(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunUpdateReplayResponse(rsp)
}

// WorkflowRunGetWithResponse request returning *WorkflowRunGetResponse
func (c *ClientWithResponses) WorkflowRunGetWithResponse(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowRunGetResponse, error) {
	rsp, err := c.WorkflowRunGet(ctx, tenant, workflowRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunGetResponse(rsp)
}

// WorkflowRunGetInputWithResponse request returning *WorkflowRunGetInputResponse
func (c *ClientWithResponses) WorkflowRunGetInputWithResponse(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowRunGetInputResponse, error) {
	rsp, err := c.WorkflowRunGetInput(ctx, tenant, workflowRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunGetInputResponse(rsp)
}

// WorkflowRunGetShapeWithResponse request returning *WorkflowRunGetShapeResponse
func (c *ClientWithResponses) WorkflowRunGetShapeWithResponse(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowRunGetShapeResponse, error) {
	rsp, err := c.WorkflowRunGetShape(ctx, tenant, workflowRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunGetShapeResponse(rsp)
}

// WorkflowRunListStepRunEventsWithResponse request returning *WorkflowRunListStepRunEventsResponse
func (c *ClientWithResponses) WorkflowRunListStepRunEventsWithResponse(ctx context.Context, tenant openapi_types.UUID, workflowRun openapi_types.UUID, params *WorkflowRunListStepRunEventsParams, reqEditors ...RequestEditorFn) (*WorkflowRunListStepRunEventsResponse, error) {
	rsp, err := c.WorkflowRunListStepRunEvents(ctx, tenant, workflowRun, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunListStepRunEventsResponse(rsp)
}

// WorkflowListWithResponse request returning *WorkflowListResponse
func (c *ClientWithResponses) WorkflowListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *WorkflowListParams, reqEditors ...RequestEditorFn) (*WorkflowListResponse, error) {
	rsp, err := c.WorkflowList(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowListResponse(rsp)
}

// WorkflowRunCancelWithBodyWithResponse request with arbitrary body returning *WorkflowRunCancelResponse
func (c *ClientWithResponses) WorkflowRunCancelWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkflowRunCancelResponse, error) {
	rsp, err := c.WorkflowRunCancelWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunCancelResponse(rsp)
}

func (c *ClientWithResponses) WorkflowRunCancelWithResponse(ctx context.Context, tenant openapi_types.UUID, body WorkflowRunCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkflowRunCancelResponse, error) {
	rsp, err := c.WorkflowRunCancel(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunCancelResponse(rsp)
}

// CronWorkflowListWithResponse request returning *CronWorkflowListResponse
func (c *ClientWithResponses) CronWorkflowListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *CronWorkflowListParams, reqEditors ...RequestEditorFn) (*CronWorkflowListResponse, error) {
	rsp, err := c.CronWorkflowList(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCronWorkflowListResponse(rsp)
}

// WorkflowCronDeleteWithResponse request returning *WorkflowCronDeleteResponse
func (c *ClientWithResponses) WorkflowCronDeleteWithResponse(ctx context.Context, tenant openapi_types.UUID, cronWorkflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowCronDeleteResponse, error) {
	rsp, err := c.WorkflowCronDelete(ctx, tenant, cronWorkflow, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowCronDeleteResponse(rsp)
}

// WorkflowCronGetWithResponse request returning *WorkflowCronGetResponse
func (c *ClientWithResponses) WorkflowCronGetWithResponse(ctx context.Context, tenant openapi_types.UUID, cronWorkflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowCronGetResponse, error) {
	rsp, err := c.WorkflowCronGet(ctx, tenant, cronWorkflow, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowCronGetResponse(rsp)
}

// WorkflowRunListWithResponse request returning *WorkflowRunListResponse
func (c *ClientWithResponses) WorkflowRunListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunListParams, reqEditors ...RequestEditorFn) (*WorkflowRunListResponse, error) {
	rsp, err := c.WorkflowRunList(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunListResponse(rsp)
}

// WorkflowRunGetMetricsWithResponse request returning *WorkflowRunGetMetricsResponse
func (c *ClientWithResponses) WorkflowRunGetMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunGetMetricsParams, reqEditors ...RequestEditorFn) (*WorkflowRunGetMetricsResponse, error) {
	rsp, err := c.WorkflowRunGetMetrics(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunGetMetricsResponse(rsp)
}

// WorkflowScheduledListWithResponse request returning *WorkflowScheduledListResponse
func (c *ClientWithResponses) WorkflowScheduledListWithResponse(ctx context.Context, tenant openapi_types.UUID, params *WorkflowScheduledListParams, reqEditors ...RequestEditorFn) (*WorkflowScheduledListResponse, error) {
	rsp, err := c.WorkflowScheduledList(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowScheduledListResponse(rsp)
}

// WorkflowScheduledDeleteWithResponse request returning *WorkflowScheduledDeleteResponse
func (c *ClientWithResponses) WorkflowScheduledDeleteWithResponse(ctx context.Context, tenant openapi_types.UUID, scheduledWorkflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowScheduledDeleteResponse, error) {
	rsp, err := c.WorkflowScheduledDelete(ctx, tenant, scheduledWorkflowRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowScheduledDeleteResponse(rsp)
}

// WorkflowScheduledGetWithResponse request returning *WorkflowScheduledGetResponse
func (c *ClientWithResponses) WorkflowScheduledGetWithResponse(ctx context.Context, tenant openapi_types.UUID, scheduledWorkflowRun openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowScheduledGetResponse, error) {
	rsp, err := c.WorkflowScheduledGet(ctx, tenant, scheduledWorkflowRun, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowScheduledGetResponse(rsp)
}

// CronWorkflowTriggerCreateWithBodyWithResponse request with arbitrary body returning *CronWorkflowTriggerCreateResponse
func (c *ClientWithResponses) CronWorkflowTriggerCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, workflow string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CronWorkflowTriggerCreateResponse, error) {
	rsp, err := c.CronWorkflowTriggerCreateWithBody(ctx, tenant, workflow, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCronWorkflowTriggerCreateResponse(rsp)
}

func (c *ClientWithResponses) CronWorkflowTriggerCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, workflow string, body CronWorkflowTriggerCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CronWorkflowTriggerCreateResponse, error) {
	rsp, err := c.CronWorkflowTriggerCreate(ctx, tenant, workflow, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCronWorkflowTriggerCreateResponse(rsp)
}

// ScheduledWorkflowRunCreateWithBodyWithResponse request with arbitrary body returning *ScheduledWorkflowRunCreateResponse
func (c *ClientWithResponses) ScheduledWorkflowRunCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, workflow string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScheduledWorkflowRunCreateResponse, error) {
	rsp, err := c.ScheduledWorkflowRunCreateWithBody(ctx, tenant, workflow, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScheduledWorkflowRunCreateResponse(rsp)
}

func (c *ClientWithResponses) ScheduledWorkflowRunCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, workflow string, body ScheduledWorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ScheduledWorkflowRunCreateResponse, error) {
	rsp, err := c.ScheduledWorkflowRunCreate(ctx, tenant, workflow, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScheduledWorkflowRunCreateResponse(rsp)
}

// WorkflowGetWorkersCountWithResponse request returning *WorkflowGetWorkersCountResponse
func (c *ClientWithResponses) WorkflowGetWorkersCountWithResponse(ctx context.Context, tenant openapi_types.UUID, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowGetWorkersCountResponse, error) {
	rsp, err := c.WorkflowGetWorkersCount(ctx, tenant, workflow, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowGetWorkersCountResponse(rsp)
}

// UserGetCurrentWithResponse request returning *UserGetCurrentResponse
func (c *ClientWithResponses) UserGetCurrentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserGetCurrentResponse, error) {
	rsp, err := c.UserGetCurrent(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserGetCurrentResponse(rsp)
}

// UserUpdateGithubOauthCallbackWithResponse request returning *UserUpdateGithubOauthCallbackResponse
func (c *ClientWithResponses) UserUpdateGithubOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGithubOauthCallbackResponse, error) {
	rsp, err := c.UserUpdateGithubOauthCallback(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateGithubOauthCallbackResponse(rsp)
}

// UserUpdateGithubOauthStartWithResponse request returning *UserUpdateGithubOauthStartResponse
func (c *ClientWithResponses) UserUpdateGithubOauthStartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGithubOauthStartResponse, error) {
	rsp, err := c.UserUpdateGithubOauthStart(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateGithubOauthStartResponse(rsp)
}

// UserUpdateGoogleOauthCallbackWithResponse request returning *UserUpdateGoogleOauthCallbackResponse
func (c *ClientWithResponses) UserUpdateGoogleOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGoogleOauthCallbackResponse, error) {
	rsp, err := c.UserUpdateGoogleOauthCallback(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateGoogleOauthCallbackResponse(rsp)
}

// UserUpdateGoogleOauthStartWithResponse request returning *UserUpdateGoogleOauthStartResponse
func (c *ClientWithResponses) UserUpdateGoogleOauthStartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGoogleOauthStartResponse, error) {
	rsp, err := c.UserUpdateGoogleOauthStart(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateGoogleOauthStartResponse(rsp)
}

// UserListTenantInvitesWithResponse request returning *UserListTenantInvitesResponse
func (c *ClientWithResponses) UserListTenantInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserListTenantInvitesResponse, error) {
	rsp, err := c.UserListTenantInvites(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserListTenantInvitesResponse(rsp)
}

// TenantInviteAcceptWithBodyWithResponse request with arbitrary body returning *TenantInviteAcceptResponse
func (c *ClientWithResponses) TenantInviteAcceptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteAcceptResponse, error) {
	rsp, err := c.TenantInviteAcceptWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteAcceptResponse(rsp)
}

func (c *ClientWithResponses) TenantInviteAcceptWithResponse(ctx context.Context, body TenantInviteAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteAcceptResponse, error) {
	rsp, err := c.TenantInviteAccept(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteAcceptResponse(rsp)
}

// TenantInviteRejectWithBodyWithResponse request with arbitrary body returning *TenantInviteRejectResponse
func (c *ClientWithResponses) TenantInviteRejectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantInviteRejectResponse, error) {
	rsp, err := c.TenantInviteRejectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteRejectResponse(rsp)
}

func (c *ClientWithResponses) TenantInviteRejectWithResponse(ctx context.Context, body TenantInviteRejectJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantInviteRejectResponse, error) {
	rsp, err := c.TenantInviteReject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantInviteRejectResponse(rsp)
}

// UserUpdateLoginWithBodyWithResponse request with arbitrary body returning *UserUpdateLoginResponse
func (c *ClientWithResponses) UserUpdateLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdateLoginResponse, error) {
	rsp, err := c.UserUpdateLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateLoginResponse(rsp)
}

func (c *ClientWithResponses) UserUpdateLoginWithResponse(ctx context.Context, body UserUpdateLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdateLoginResponse, error) {
	rsp, err := c.UserUpdateLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateLoginResponse(rsp)
}

// UserUpdateLogoutWithResponse request returning *UserUpdateLogoutResponse
func (c *ClientWithResponses) UserUpdateLogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateLogoutResponse, error) {
	rsp, err := c.UserUpdateLogout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateLogoutResponse(rsp)
}

// TenantMembershipsListWithResponse request returning *TenantMembershipsListResponse
func (c *ClientWithResponses) TenantMembershipsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TenantMembershipsListResponse, error) {
	rsp, err := c.TenantMembershipsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantMembershipsListResponse(rsp)
}

// UserUpdatePasswordWithBodyWithResponse request with arbitrary body returning *UserUpdatePasswordResponse
func (c *ClientWithResponses) UserUpdatePasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdatePasswordResponse, error) {
	rsp, err := c.UserUpdatePasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdatePasswordResponse(rsp)
}

func (c *ClientWithResponses) UserUpdatePasswordWithResponse(ctx context.Context, body UserUpdatePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdatePasswordResponse, error) {
	rsp, err := c.UserUpdatePassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdatePasswordResponse(rsp)
}

// UserCreateWithBodyWithResponse request with arbitrary body returning *UserCreateResponse
func (c *ClientWithResponses) UserCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserCreateResponse, error) {
	rsp, err := c.UserCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserCreateResponse(rsp)
}

func (c *ClientWithResponses) UserCreateWithResponse(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserCreateResponse, error) {
	rsp, err := c.UserCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserCreateResponse(rsp)
}

// UserUpdateSlackOauthCallbackWithResponse request returning *UserUpdateSlackOauthCallbackResponse
func (c *ClientWithResponses) UserUpdateSlackOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateSlackOauthCallbackResponse, error) {
	rsp, err := c.UserUpdateSlackOauthCallback(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateSlackOauthCallbackResponse(rsp)
}

// InfoGetVersionWithResponse request returning *InfoGetVersionResponse
func (c *ClientWithResponses) InfoGetVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InfoGetVersionResponse, error) {
	rsp, err := c.InfoGetVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInfoGetVersionResponse(rsp)
}

// WebhookDeleteWithResponse request returning *WebhookDeleteResponse
func (c *ClientWithResponses) WebhookDeleteWithResponse(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*WebhookDeleteResponse, error) {
	rsp, err := c.WebhookDelete(ctx, webhook, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhookDeleteResponse(rsp)
}

// WebhookRequestsListWithResponse request returning *WebhookRequestsListResponse
func (c *ClientWithResponses) WebhookRequestsListWithResponse(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*WebhookRequestsListResponse, error) {
	rsp, err := c.WebhookRequestsList(ctx, webhook, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebhookRequestsListResponse(rsp)
}

// WorkerGetWithResponse request returning *WorkerGetResponse
func (c *ClientWithResponses) WorkerGetWithResponse(ctx context.Context, worker openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkerGetResponse, error) {
	rsp, err := c.WorkerGet(ctx, worker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerGetResponse(rsp)
}

// WorkerUpdateWithBodyWithResponse request with arbitrary body returning *WorkerUpdateResponse
func (c *ClientWithResponses) WorkerUpdateWithBodyWithResponse(ctx context.Context, worker openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkerUpdateResponse, error) {
	rsp, err := c.WorkerUpdateWithBody(ctx, worker, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerUpdateResponse(rsp)
}

func (c *ClientWithResponses) WorkerUpdateWithResponse(ctx context.Context, worker openapi_types.UUID, body WorkerUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkerUpdateResponse, error) {
	rsp, err := c.WorkerUpdate(ctx, worker, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerUpdateResponse(rsp)
}

// WorkflowDeleteWithResponse request returning *WorkflowDeleteResponse
func (c *ClientWithResponses) WorkflowDeleteWithResponse(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowDeleteResponse, error) {
	rsp, err := c.WorkflowDelete(ctx, workflow, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowDeleteResponse(rsp)
}

// WorkflowGetWithResponse request returning *WorkflowGetResponse
func (c *ClientWithResponses) WorkflowGetWithResponse(ctx context.Context, workflow openapi_types.UUID, reqEditors ...RequestEditorFn) (*WorkflowGetResponse, error) {
	rsp, err := c.WorkflowGet(ctx, workflow, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowGetResponse(rsp)
}

// WorkflowUpdateWithBodyWithResponse request with arbitrary body returning *WorkflowUpdateResponse
func (c *ClientWithResponses) WorkflowUpdateWithBodyWithResponse(ctx context.Context, workflow openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkflowUpdateResponse, error) {
	rsp, err := c.WorkflowUpdateWithBody(ctx, workflow, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowUpdateResponse(rsp)
}

func (c *ClientWithResponses) WorkflowUpdateWithResponse(ctx context.Context, workflow openapi_types.UUID, body WorkflowUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkflowUpdateResponse, error) {
	rsp, err := c.WorkflowUpdate(ctx, workflow, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowUpdateResponse(rsp)
}

// WorkflowGetMetricsWithResponse request returning *WorkflowGetMetricsResponse
func (c *ClientWithResponses) WorkflowGetMetricsWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowGetMetricsParams, reqEditors ...RequestEditorFn) (*WorkflowGetMetricsResponse, error) {
	rsp, err := c.WorkflowGetMetrics(ctx, workflow, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowGetMetricsResponse(rsp)
}

// WorkflowRunCreateWithBodyWithResponse request with arbitrary body returning *WorkflowRunCreateResponse
func (c *ClientWithResponses) WorkflowRunCreateWithBodyWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkflowRunCreateResponse, error) {
	rsp, err := c.WorkflowRunCreateWithBody(ctx, workflow, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunCreateResponse(rsp)
}

func (c *ClientWithResponses) WorkflowRunCreateWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowRunCreateParams, body WorkflowRunCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkflowRunCreateResponse, error) {
	rsp, err := c.WorkflowRunCreate(ctx, workflow, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunCreateResponse(rsp)
}

// WorkflowVersionGetWithResponse request returning *WorkflowVersionGetResponse
func (c *ClientWithResponses) WorkflowVersionGetWithResponse(ctx context.Context, workflow openapi_types.UUID, params *WorkflowVersionGetParams, reqEditors ...RequestEditorFn) (*WorkflowVersionGetResponse, error) {
	rsp, err := c.WorkflowVersionGet(ctx, workflow, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowVersionGetResponse(rsp)
}

// ParseLivenessGetResponse parses an HTTP response from a LivenessGetWithResponse call
func ParseLivenessGetResponse(rsp *http.Response) (*LivenessGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LivenessGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadinessGetResponse parses an HTTP response from a ReadinessGetWithResponse call
func ParseReadinessGetResponse(rsp *http.Response) (*ReadinessGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadinessGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAlertEmailGroupDeleteResponse parses an HTTP response from a AlertEmailGroupDeleteWithResponse call
func ParseAlertEmailGroupDeleteResponse(rsp *http.Response) (*AlertEmailGroupDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertEmailGroupDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAlertEmailGroupUpdateResponse parses an HTTP response from a AlertEmailGroupUpdateWithResponse call
func ParseAlertEmailGroupUpdateResponse(rsp *http.Response) (*AlertEmailGroupUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertEmailGroupUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantAlertEmailGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseApiTokenUpdateRevokeResponse parses an HTTP response from a ApiTokenUpdateRevokeWithResponse call
func ParseApiTokenUpdateRevokeResponse(rsp *http.Response) (*ApiTokenUpdateRevokeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiTokenUpdateRevokeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCloudMetadataGetResponse parses an HTTP response from a CloudMetadataGetWithResponse call
func ParseCloudMetadataGetResponse(rsp *http.Response) (*CloudMetadataGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CloudMetadataGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseEventGetResponse parses an HTTP response from a EventGetWithResponse call
func ParseEventGetResponse(rsp *http.Response) (*EventGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseEventDataGetResponse parses an HTTP response from a EventDataGetWithResponse call
func ParseEventDataGetResponse(rsp *http.Response) (*EventDataGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventDataGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseMetadataGetResponse parses an HTTP response from a MetadataGetWithResponse call
func ParseMetadataGetResponse(rsp *http.Response) (*MetadataGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetadataGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest APIMeta
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMetadataListIntegrationsResponse parses an HTTP response from a MetadataListIntegrationsWithResponse call
func ParseMetadataListIntegrationsResponse(rsp *http.Response) (*MetadataListIntegrationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetadataListIntegrationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAPIMetaIntegration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMonitoringPostRunProbeResponse parses an HTTP response from a MonitoringPostRunProbeWithResponse call
func ParseMonitoringPostRunProbeResponse(rsp *http.Response) (*MonitoringPostRunProbeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MonitoringPostRunProbeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSlackWebhookDeleteResponse parses an HTTP response from a SlackWebhookDeleteWithResponse call
func ParseSlackWebhookDeleteResponse(rsp *http.Response) (*SlackWebhookDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlackWebhookDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseSnsDeleteResponse parses an HTTP response from a SnsDeleteWithResponse call
func ParseSnsDeleteResponse(rsp *http.Response) (*SnsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseSnsUpdateResponse parses an HTTP response from a SnsUpdateWithResponse call
func ParseSnsUpdateResponse(rsp *http.Response) (*SnsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseV1DagListTasksResponse parses an HTTP response from a V1DagListTasksWithResponse call
func ParseV1DagListTasksResponse(rsp *http.Response) (*V1DagListTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1DagListTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []V1DagChildren
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseV1TaskGetResponse parses an HTTP response from a V1TaskGetWithResponse call
func ParseV1TaskGetResponse(rsp *http.Response) (*V1TaskGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1TaskGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1TaskSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseV1LogLineListResponse parses an HTTP response from a V1LogLineListWithResponse call
func ParseV1LogLineListResponse(rsp *http.Response) (*V1LogLineListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1LogLineListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1LogLineList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseV1TaskEventListResponse parses an HTTP response from a V1TaskEventListWithResponse call
func ParseV1TaskEventListResponse(rsp *http.Response) (*V1TaskEventListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1TaskEventListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1TaskEventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseV1EventListResponse parses an HTTP response from a V1EventListWithResponse call
func ParseV1EventListResponse(rsp *http.Response) (*V1EventListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1EventListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1EventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseV1EventKeyListResponse parses an HTTP response from a V1EventKeyListWithResponse call
func ParseV1EventKeyListResponse(rsp *http.Response) (*V1EventKeyListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1EventKeyListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventKeyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseV1FilterListResponse parses an HTTP response from a V1FilterListWithResponse call
func ParseV1FilterListResponse(rsp *http.Response) (*V1FilterListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1FilterListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1FilterList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseV1FilterCreateResponse parses an HTTP response from a V1FilterCreateWithResponse call
func ParseV1FilterCreateResponse(rsp *http.Response) (*V1FilterCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1FilterCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseV1FilterDeleteResponse parses an HTTP response from a V1FilterDeleteWithResponse call
func ParseV1FilterDeleteResponse(rsp *http.Response) (*V1FilterDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1FilterDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseV1FilterGetResponse parses an HTTP response from a V1FilterGetWithResponse call
func ParseV1FilterGetResponse(rsp *http.Response) (*V1FilterGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1FilterGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseV1FilterUpdateResponse parses an HTTP response from a V1FilterUpdateWithResponse call
func ParseV1FilterUpdateResponse(rsp *http.Response) (*V1FilterUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1FilterUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseV1TaskListStatusMetricsResponse parses an HTTP response from a V1TaskListStatusMetricsWithResponse call
func ParseV1TaskListStatusMetricsResponse(rsp *http.Response) (*V1TaskListStatusMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1TaskListStatusMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1TaskRunMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseV1TaskGetPointMetricsResponse parses an HTTP response from a V1TaskGetPointMetricsWithResponse call
func ParseV1TaskGetPointMetricsResponse(rsp *http.Response) (*V1TaskGetPointMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1TaskGetPointMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1TaskPointMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseV1TaskCancelResponse parses an HTTP response from a V1TaskCancelWithResponse call
func ParseV1TaskCancelResponse(rsp *http.Response) (*V1TaskCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1TaskCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseV1TaskReplayResponse parses an HTTP response from a V1TaskReplayWithResponse call
func ParseV1TaskReplayResponse(rsp *http.Response) (*V1TaskReplayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1TaskReplayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseV1WorkflowRunListResponse parses an HTTP response from a V1WorkflowRunListWithResponse call
func ParseV1WorkflowRunListResponse(rsp *http.Response) (*V1WorkflowRunListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1WorkflowRunListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1TaskSummaryList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseV1WorkflowRunDisplayNamesListResponse parses an HTTP response from a V1WorkflowRunDisplayNamesListWithResponse call
func ParseV1WorkflowRunDisplayNamesListResponse(rsp *http.Response) (*V1WorkflowRunDisplayNamesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1WorkflowRunDisplayNamesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1WorkflowRunDisplayNameList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseV1WorkflowRunCreateResponse parses an HTTP response from a V1WorkflowRunCreateWithResponse call
func ParseV1WorkflowRunCreateResponse(rsp *http.Response) (*V1WorkflowRunCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1WorkflowRunCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1WorkflowRunDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseV1WorkflowRunGetResponse parses an HTTP response from a V1WorkflowRunGetWithResponse call
func ParseV1WorkflowRunGetResponse(rsp *http.Response) (*V1WorkflowRunGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1WorkflowRunGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1WorkflowRunDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseV1WorkflowRunGetStatusResponse parses an HTTP response from a V1WorkflowRunGetStatusWithResponse call
func ParseV1WorkflowRunGetStatusResponse(rsp *http.Response) (*V1WorkflowRunGetStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1WorkflowRunGetStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1TaskStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseV1WorkflowRunTaskEventsListResponse parses an HTTP response from a V1WorkflowRunTaskEventsListWithResponse call
func ParseV1WorkflowRunTaskEventsListResponse(rsp *http.Response) (*V1WorkflowRunTaskEventsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1WorkflowRunTaskEventsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1TaskEventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseV1WorkflowRunGetTimingsResponse parses an HTTP response from a V1WorkflowRunGetTimingsWithResponse call
func ParseV1WorkflowRunGetTimingsResponse(rsp *http.Response) (*V1WorkflowRunGetTimingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &V1WorkflowRunGetTimingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V1TaskTimingList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseStepRunListArchivesResponse parses an HTTP response from a StepRunListArchivesWithResponse call
func ParseStepRunListArchivesResponse(rsp *http.Response) (*StepRunListArchivesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunListArchivesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StepRunArchiveList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStepRunListEventsResponse parses an HTTP response from a StepRunListEventsWithResponse call
func ParseStepRunListEventsResponse(rsp *http.Response) (*StepRunListEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunListEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StepRunEventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseLogLineListResponse parses an HTTP response from a LogLineListWithResponse call
func ParseLogLineListResponse(rsp *http.Response) (*LogLineListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogLineListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogLineList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantCreateResponse parses an HTTP response from a TenantCreateWithResponse call
func ParseTenantCreateResponse(rsp *http.Response) (*TenantCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tenant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantGetResponse parses an HTTP response from a TenantGetWithResponse call
func ParseTenantGetResponse(rsp *http.Response) (*TenantGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tenant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTenantUpdateResponse parses an HTTP response from a TenantUpdateWithResponse call
func ParseTenantUpdateResponse(rsp *http.Response) (*TenantUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tenant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAlertEmailGroupListResponse parses an HTTP response from a AlertEmailGroupListWithResponse call
func ParseAlertEmailGroupListResponse(rsp *http.Response) (*AlertEmailGroupListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertEmailGroupListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantAlertEmailGroupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAlertEmailGroupCreateResponse parses an HTTP response from a AlertEmailGroupCreateWithResponse call
func ParseAlertEmailGroupCreateResponse(rsp *http.Response) (*AlertEmailGroupCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertEmailGroupCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TenantAlertEmailGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantAlertingSettingsGetResponse parses an HTTP response from a TenantAlertingSettingsGetWithResponse call
func ParseTenantAlertingSettingsGetResponse(rsp *http.Response) (*TenantAlertingSettingsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantAlertingSettingsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantAlertingSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseApiTokenListResponse parses an HTTP response from a ApiTokenListWithResponse call
func ParseApiTokenListResponse(rsp *http.Response) (*ApiTokenListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiTokenListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAPITokensResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseApiTokenCreateResponse parses an HTTP response from a ApiTokenCreateWithResponse call
func ParseApiTokenCreateResponse(rsp *http.Response) (*ApiTokenCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApiTokenCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateAPITokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseEventListResponse parses an HTTP response from a EventListWithResponse call
func ParseEventListResponse(rsp *http.Response) (*EventListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseEventCreateResponse parses an HTTP response from a EventCreateWithResponse call
func ParseEventCreateResponse(rsp *http.Response) (*EventCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseEventCreateBulkResponse parses an HTTP response from a EventCreateBulkWithResponse call
func ParseEventCreateBulkResponse(rsp *http.Response) (*EventCreateBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventCreateBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Events
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseEventUpdateCancelResponse parses an HTTP response from a EventUpdateCancelWithResponse call
func ParseEventUpdateCancelResponse(rsp *http.Response) (*EventUpdateCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventUpdateCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			WorkflowRunIds *[]openapi_types.UUID `json:"workflowRunIds,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseEventKeyListResponse parses an HTTP response from a EventKeyListWithResponse call
func ParseEventKeyListResponse(rsp *http.Response) (*EventKeyListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventKeyListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventKeyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseEventUpdateReplayResponse parses an HTTP response from a EventUpdateReplayWithResponse call
func ParseEventUpdateReplayResponse(rsp *http.Response) (*EventUpdateReplayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventUpdateReplayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseTenantInviteListResponse parses an HTTP response from a TenantInviteListWithResponse call
func ParseTenantInviteListResponse(rsp *http.Response) (*TenantInviteListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantInviteList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantInviteCreateResponse parses an HTTP response from a TenantInviteCreateWithResponse call
func ParseTenantInviteCreateResponse(rsp *http.Response) (*TenantInviteCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TenantInvite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantInviteDeleteResponse parses an HTTP response from a TenantInviteDeleteWithResponse call
func ParseTenantInviteDeleteResponse(rsp *http.Response) (*TenantInviteDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantInvite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseTenantInviteUpdateResponse parses an HTTP response from a TenantInviteUpdateWithResponse call
func ParseTenantInviteUpdateResponse(rsp *http.Response) (*TenantInviteUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantInvite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseTenantMemberListResponse parses an HTTP response from a TenantMemberListWithResponse call
func ParseTenantMemberListResponse(rsp *http.Response) (*TenantMemberListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantMemberListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantMemberList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantMemberDeleteResponse parses an HTTP response from a TenantMemberDeleteWithResponse call
func ParseTenantMemberDeleteResponse(rsp *http.Response) (*TenantMemberDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantMemberDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest TenantMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTenantGetPrometheusMetricsResponse parses an HTTP response from a TenantGetPrometheusMetricsWithResponse call
func ParseTenantGetPrometheusMetricsResponse(rsp *http.Response) (*TenantGetPrometheusMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantGetPrometheusMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTenantGetQueueMetricsResponse parses an HTTP response from a TenantGetQueueMetricsWithResponse call
func ParseTenantGetQueueMetricsResponse(rsp *http.Response) (*TenantGetQueueMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantGetQueueMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantQueueMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRateLimitListResponse parses an HTTP response from a RateLimitListWithResponse call
func ParseRateLimitListResponse(rsp *http.Response) (*RateLimitListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RateLimitListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RateLimitList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantResourcePolicyGetResponse parses an HTTP response from a TenantResourcePolicyGetWithResponse call
func ParseTenantResourcePolicyGetResponse(rsp *http.Response) (*TenantResourcePolicyGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantResourcePolicyGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantResourcePolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSlackWebhookListResponse parses an HTTP response from a SlackWebhookListWithResponse call
func ParseSlackWebhookListResponse(rsp *http.Response) (*SlackWebhookListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlackWebhookListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSlackWebhooks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseUserUpdateSlackOauthStartResponse parses an HTTP response from a UserUpdateSlackOauthStartWithResponse call
func ParseUserUpdateSlackOauthStartResponse(rsp *http.Response) (*UserUpdateSlackOauthStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateSlackOauthStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSnsListResponse parses an HTTP response from a SnsListWithResponse call
func ParseSnsListResponse(rsp *http.Response) (*SnsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSNSIntegrations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseSnsCreateResponse parses an HTTP response from a SnsCreateWithResponse call
func ParseSnsCreateResponse(rsp *http.Response) (*SnsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SnsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SNSIntegration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseTenantGetStepRunQueueMetricsResponse parses an HTTP response from a TenantGetStepRunQueueMetricsWithResponse call
func ParseTenantGetStepRunQueueMetricsResponse(rsp *http.Response) (*TenantGetStepRunQueueMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantGetStepRunQueueMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantStepRunQueueMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStepRunGetResponse parses an HTTP response from a StepRunGetWithResponse call
func ParseStepRunGetResponse(rsp *http.Response) (*StepRunGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StepRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStepRunUpdateCancelResponse parses an HTTP response from a StepRunUpdateCancelWithResponse call
func ParseStepRunUpdateCancelResponse(rsp *http.Response) (*StepRunUpdateCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunUpdateCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StepRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseStepRunUpdateRerunResponse parses an HTTP response from a StepRunUpdateRerunWithResponse call
func ParseStepRunUpdateRerunResponse(rsp *http.Response) (*StepRunUpdateRerunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunUpdateRerunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StepRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseStepRunGetSchemaResponse parses an HTTP response from a StepRunGetSchemaWithResponse call
func ParseStepRunGetSchemaResponse(rsp *http.Response) (*StepRunGetSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StepRunGetSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWebhookListResponse parses an HTTP response from a WebhookListWithResponse call
func ParseWebhookListResponse(rsp *http.Response) (*WebhookListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhookListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookWorkerListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseWebhookCreateResponse parses an HTTP response from a WebhookCreateWithResponse call
func ParseWebhookCreateResponse(rsp *http.Response) (*WebhookCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhookCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookWorkerCreated
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseWorkerListResponse parses an HTTP response from a WorkerListWithResponse call
func ParseWorkerListResponse(rsp *http.Response) (*WorkerListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkerList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowRunUpdateReplayResponse parses an HTTP response from a WorkflowRunUpdateReplayWithResponse call
func ParseWorkflowRunUpdateReplayResponse(rsp *http.Response) (*WorkflowRunUpdateReplayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunUpdateReplayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReplayWorkflowRunsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseWorkflowRunGetResponse parses an HTTP response from a WorkflowRunGetWithResponse call
func ParseWorkflowRunGetResponse(rsp *http.Response) (*WorkflowRunGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowRunGetInputResponse parses an HTTP response from a WorkflowRunGetInputWithResponse call
func ParseWorkflowRunGetInputResponse(rsp *http.Response) (*WorkflowRunGetInputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunGetInputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWorkflowRunGetShapeResponse parses an HTTP response from a WorkflowRunGetShapeWithResponse call
func ParseWorkflowRunGetShapeResponse(rsp *http.Response) (*WorkflowRunGetShapeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunGetShapeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowRunShape
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowRunListStepRunEventsResponse parses an HTTP response from a WorkflowRunListStepRunEventsWithResponse call
func ParseWorkflowRunListStepRunEventsResponse(rsp *http.Response) (*WorkflowRunListStepRunEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunListStepRunEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StepRunEventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWorkflowListResponse parses an HTTP response from a WorkflowListWithResponse call
func ParseWorkflowListResponse(rsp *http.Response) (*WorkflowListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowRunCancelResponse parses an HTTP response from a WorkflowRunCancelWithResponse call
func ParseWorkflowRunCancelResponse(rsp *http.Response) (*WorkflowRunCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			WorkflowRunIds *[]openapi_types.UUID `json:"workflowRunIds,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCronWorkflowListResponse parses an HTTP response from a CronWorkflowListWithResponse call
func ParseCronWorkflowListResponse(rsp *http.Response) (*CronWorkflowListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CronWorkflowListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CronWorkflowsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowCronDeleteResponse parses an HTTP response from a WorkflowCronDeleteWithResponse call
func ParseWorkflowCronDeleteResponse(rsp *http.Response) (*WorkflowCronDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowCronDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowCronGetResponse parses an HTTP response from a WorkflowCronGetWithResponse call
func ParseWorkflowCronGetResponse(rsp *http.Response) (*WorkflowCronGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowCronGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CronWorkflows
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWorkflowRunListResponse parses an HTTP response from a WorkflowRunListWithResponse call
func ParseWorkflowRunListResponse(rsp *http.Response) (*WorkflowRunListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowRunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowRunGetMetricsResponse parses an HTTP response from a WorkflowRunGetMetricsWithResponse call
func ParseWorkflowRunGetMetricsResponse(rsp *http.Response) (*WorkflowRunGetMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunGetMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowRunsMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowScheduledListResponse parses an HTTP response from a WorkflowScheduledListWithResponse call
func ParseWorkflowScheduledListResponse(rsp *http.Response) (*WorkflowScheduledListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowScheduledListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScheduledWorkflowsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowScheduledDeleteResponse parses an HTTP response from a WorkflowScheduledDeleteWithResponse call
func ParseWorkflowScheduledDeleteResponse(rsp *http.Response) (*WorkflowScheduledDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowScheduledDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowScheduledGetResponse parses an HTTP response from a WorkflowScheduledGetWithResponse call
func ParseWorkflowScheduledGetResponse(rsp *http.Response) (*WorkflowScheduledGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowScheduledGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScheduledWorkflows
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCronWorkflowTriggerCreateResponse parses an HTTP response from a CronWorkflowTriggerCreateWithResponse call
func ParseCronWorkflowTriggerCreateResponse(rsp *http.Response) (*CronWorkflowTriggerCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CronWorkflowTriggerCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CronWorkflows
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseScheduledWorkflowRunCreateResponse parses an HTTP response from a ScheduledWorkflowRunCreateWithResponse call
func ParseScheduledWorkflowRunCreateResponse(rsp *http.Response) (*ScheduledWorkflowRunCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScheduledWorkflowRunCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScheduledWorkflows
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseWorkflowGetWorkersCountResponse parses an HTTP response from a WorkflowGetWorkersCountWithResponse call
func ParseWorkflowGetWorkersCountResponse(rsp *http.Response) (*WorkflowGetWorkersCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowGetWorkersCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowWorkersCount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUserGetCurrentResponse parses an HTTP response from a UserGetCurrentWithResponse call
func ParseUserGetCurrentResponse(rsp *http.Response) (*UserGetCurrentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserGetCurrentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseUserUpdateGithubOauthCallbackResponse parses an HTTP response from a UserUpdateGithubOauthCallbackWithResponse call
func ParseUserUpdateGithubOauthCallbackResponse(rsp *http.Response) (*UserUpdateGithubOauthCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateGithubOauthCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserUpdateGithubOauthStartResponse parses an HTTP response from a UserUpdateGithubOauthStartWithResponse call
func ParseUserUpdateGithubOauthStartResponse(rsp *http.Response) (*UserUpdateGithubOauthStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateGithubOauthStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserUpdateGoogleOauthCallbackResponse parses an HTTP response from a UserUpdateGoogleOauthCallbackWithResponse call
func ParseUserUpdateGoogleOauthCallbackResponse(rsp *http.Response) (*UserUpdateGoogleOauthCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateGoogleOauthCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserUpdateGoogleOauthStartResponse parses an HTTP response from a UserUpdateGoogleOauthStartWithResponse call
func ParseUserUpdateGoogleOauthStartResponse(rsp *http.Response) (*UserUpdateGoogleOauthStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateGoogleOauthStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserListTenantInvitesResponse parses an HTTP response from a UserListTenantInvitesWithResponse call
func ParseUserListTenantInvitesResponse(rsp *http.Response) (*UserListTenantInvitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserListTenantInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantInviteList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantInviteAcceptResponse parses an HTTP response from a TenantInviteAcceptWithResponse call
func ParseTenantInviteAcceptResponse(rsp *http.Response) (*TenantInviteAcceptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteAcceptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantInviteRejectResponse parses an HTTP response from a TenantInviteRejectWithResponse call
func ParseTenantInviteRejectResponse(rsp *http.Response) (*TenantInviteRejectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantInviteRejectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUserUpdateLoginResponse parses an HTTP response from a UserUpdateLoginWithResponse call
func ParseUserUpdateLoginResponse(rsp *http.Response) (*UserUpdateLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseUserUpdateLogoutResponse parses an HTTP response from a UserUpdateLogoutWithResponse call
func ParseUserUpdateLogoutResponse(rsp *http.Response) (*UserUpdateLogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateLogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseTenantMembershipsListResponse parses an HTTP response from a TenantMembershipsListWithResponse call
func ParseTenantMembershipsListResponse(rsp *http.Response) (*TenantMembershipsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantMembershipsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserTenantMembershipsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUserUpdatePasswordResponse parses an HTTP response from a UserUpdatePasswordWithResponse call
func ParseUserUpdatePasswordResponse(rsp *http.Response) (*UserUpdatePasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdatePasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseUserCreateResponse parses an HTTP response from a UserCreateWithResponse call
func ParseUserCreateResponse(rsp *http.Response) (*UserCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseUserUpdateSlackOauthCallbackResponse parses an HTTP response from a UserUpdateSlackOauthCallbackWithResponse call
func ParseUserUpdateSlackOauthCallbackResponse(rsp *http.Response) (*UserUpdateSlackOauthCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateSlackOauthCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInfoGetVersionResponse parses an HTTP response from a InfoGetVersionWithResponse call
func ParseInfoGetVersionResponse(rsp *http.Response) (*InfoGetVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InfoGetVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Version string `json:"version"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWebhookDeleteResponse parses an HTTP response from a WebhookDeleteWithResponse call
func ParseWebhookDeleteResponse(rsp *http.Response) (*WebhookDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhookDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseWebhookRequestsListResponse parses an HTTP response from a WebhookRequestsListWithResponse call
func ParseWebhookRequestsListResponse(rsp *http.Response) (*WebhookRequestsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebhookRequestsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookWorkerRequestListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseWorkerGetResponse parses an HTTP response from a WorkerGetWithResponse call
func ParseWorkerGetResponse(rsp *http.Response) (*WorkerGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Worker
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkerUpdateResponse parses an HTTP response from a WorkerUpdateWithResponse call
func ParseWorkerUpdateResponse(rsp *http.Response) (*WorkerUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Worker
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowDeleteResponse parses an HTTP response from a WorkflowDeleteWithResponse call
func ParseWorkflowDeleteResponse(rsp *http.Response) (*WorkflowDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWorkflowGetResponse parses an HTTP response from a WorkflowGetWithResponse call
func ParseWorkflowGetResponse(rsp *http.Response) (*WorkflowGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workflow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWorkflowUpdateResponse parses an HTTP response from a WorkflowUpdateWithResponse call
func ParseWorkflowUpdateResponse(rsp *http.Response) (*WorkflowUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workflow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowGetMetricsResponse parses an HTTP response from a WorkflowGetMetricsWithResponse call
func ParseWorkflowGetMetricsResponse(rsp *http.Response) (*WorkflowGetMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowGetMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseWorkflowRunCreateResponse parses an HTTP response from a WorkflowRunCreateWithResponse call
func ParseWorkflowRunCreateResponse(rsp *http.Response) (*WorkflowRunCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseWorkflowVersionGetResponse parses an HTTP response from a WorkflowVersionGetWithResponse call
func ParseWorkflowVersionGetResponse(rsp *http.Response) (*WorkflowVersionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowVersionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
