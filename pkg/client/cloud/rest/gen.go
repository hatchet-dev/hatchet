// Package rest provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package rest

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"

	"github.com/hatchet-dev/hatchet/pkg/client/rest"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	CookieAuthScopes = "cookieAuth.Scopes"
)

// Defines values for CouponFrequency.
const (
	Once      CouponFrequency = "once"
	Recurring CouponFrequency = "recurring"
)

// Defines values for CreateManagedWorkerRuntimeConfigRequestGpuKind.
const (
	A10      CreateManagedWorkerRuntimeConfigRequestGpuKind = "a10"
	A10040gb CreateManagedWorkerRuntimeConfigRequestGpuKind = "a100-40gb"
	A10080gb CreateManagedWorkerRuntimeConfigRequestGpuKind = "a100-80gb"
	L40s     CreateManagedWorkerRuntimeConfigRequestGpuKind = "l40s"
)

// Defines values for ManagedWorkerEventStatus.
const (
	CANCELLED  ManagedWorkerEventStatus = "CANCELLED"
	FAILED     ManagedWorkerEventStatus = "FAILED"
	INPROGRESS ManagedWorkerEventStatus = "IN_PROGRESS"
	SUCCEEDED  ManagedWorkerEventStatus = "SUCCEEDED"
)

// Defines values for ManagedWorkerRegion.
const (
	Ams ManagedWorkerRegion = "ams"
	Arn ManagedWorkerRegion = "arn"
	Atl ManagedWorkerRegion = "atl"
	Bog ManagedWorkerRegion = "bog"
	Bos ManagedWorkerRegion = "bos"
	Cdg ManagedWorkerRegion = "cdg"
	Den ManagedWorkerRegion = "den"
	Dfw ManagedWorkerRegion = "dfw"
	Ewr ManagedWorkerRegion = "ewr"
	Eze ManagedWorkerRegion = "eze"
	Gdl ManagedWorkerRegion = "gdl"
	Gig ManagedWorkerRegion = "gig"
	Gru ManagedWorkerRegion = "gru"
	Hkg ManagedWorkerRegion = "hkg"
	Iad ManagedWorkerRegion = "iad"
	Jnb ManagedWorkerRegion = "jnb"
	Lax ManagedWorkerRegion = "lax"
	Lhr ManagedWorkerRegion = "lhr"
	Mad ManagedWorkerRegion = "mad"
	Mia ManagedWorkerRegion = "mia"
	Nrt ManagedWorkerRegion = "nrt"
	Ord ManagedWorkerRegion = "ord"
	Otp ManagedWorkerRegion = "otp"
	Phx ManagedWorkerRegion = "phx"
	Qro ManagedWorkerRegion = "qro"
	Scl ManagedWorkerRegion = "scl"
	Sea ManagedWorkerRegion = "sea"
	Sin ManagedWorkerRegion = "sin"
	Sjc ManagedWorkerRegion = "sjc"
	Syd ManagedWorkerRegion = "syd"
	Waw ManagedWorkerRegion = "waw"
	Yul ManagedWorkerRegion = "yul"
	Yyz ManagedWorkerRegion = "yyz"
)

// Defines values for TenantSubscriptionStatus.
const (
	Active     TenantSubscriptionStatus = "active"
	Canceled   TenantSubscriptionStatus = "canceled"
	Pending    TenantSubscriptionStatus = "pending"
	Terminated TenantSubscriptionStatus = "terminated"
)

// Defines values for LogListParamsDirection.
const (
	Backward LogListParamsDirection = "backward"
	Forward  LogListParamsDirection = "forward"
)

// APICloudMetadata defines model for APICloudMetadata.
type APICloudMetadata struct {
	// CanBill whether the tenant can be billed
	CanBill *bool `json:"canBill,omitempty"`

	// CanLinkGithub whether the tenant can link to GitHub
	CanLinkGithub *bool `json:"canLinkGithub,omitempty"`

	// MetricsEnabled whether metrics are enabled for the tenant
	MetricsEnabled *bool `json:"metricsEnabled,omitempty"`
}

// APIError defines model for APIError.
type APIError = rest.APIError

// APIErrors defines model for APIErrors.
type APIErrors = rest.APIErrors

// APIResourceMeta defines model for APIResourceMeta.
type APIResourceMeta = rest.APIResourceMeta

// Build defines model for Build.
type Build struct {
	BuildConfigId openapi_types.UUID `json:"buildConfigId"`
	CreateTime    time.Time          `json:"createTime"`
	FinishTime    *time.Time         `json:"finishTime,omitempty"`
	Metadata      *APIResourceMeta   `json:"metadata,omitempty"`
	StartTime     *time.Time         `json:"startTime,omitempty"`
	Status        string             `json:"status"`
	StatusDetail  *string            `json:"statusDetail,omitempty"`
}

// BuildStep defines model for BuildStep.
type BuildStep struct {
	// BuildDir The relative path to the build directory
	BuildDir string `json:"buildDir"`

	// DockerfilePath The relative path from the build dir to the Dockerfile
	DockerfilePath string          `json:"dockerfilePath"`
	Metadata       APIResourceMeta `json:"metadata"`
}

// Coupon defines model for Coupon.
type Coupon struct {
	// AmountCents The amount off of the coupon.
	AmountCents *int `json:"amount_cents,omitempty"`

	// AmountCentsRemaining The amount remaining on the coupon.
	AmountCentsRemaining *int `json:"amount_cents_remaining,omitempty"`

	// AmountCurrency The currency of the coupon.
	AmountCurrency *string         `json:"amount_currency,omitempty"`
	Frequency      CouponFrequency `json:"frequency"`

	// FrequencyDuration The frequency duration of the coupon.
	FrequencyDuration *int `json:"frequency_duration,omitempty"`

	// FrequencyDurationRemaining The frequency duration remaining of the coupon.
	FrequencyDurationRemaining *int `json:"frequency_duration_remaining,omitempty"`

	// Name The name of the coupon.
	Name string `json:"name"`

	// Percent The percentage off of the coupon.
	Percent *float32 `json:"percent,omitempty"`
}

// CouponFrequency defines model for CouponFrequency.
type CouponFrequency string

// CreateBuildStepRequest defines model for CreateBuildStepRequest.
type CreateBuildStepRequest struct {
	// BuildDir The relative path to the build directory
	BuildDir string `json:"buildDir"`

	// DockerfilePath The relative path from the build dir to the Dockerfile
	DockerfilePath string `json:"dockerfilePath"`
}

// CreateManagedWorkerBuildConfigRequest defines model for CreateManagedWorkerBuildConfigRequest.
type CreateManagedWorkerBuildConfigRequest struct {
	GithubInstallationId   openapi_types.UUID       `json:"githubInstallationId"`
	GithubRepositoryBranch string                   `json:"githubRepositoryBranch"`
	GithubRepositoryName   string                   `json:"githubRepositoryName"`
	GithubRepositoryOwner  string                   `json:"githubRepositoryOwner"`
	Steps                  []CreateBuildStepRequest `json:"steps"`
}

// CreateManagedWorkerRequest defines model for CreateManagedWorkerRequest.
type CreateManagedWorkerRequest struct {
	BuildConfig CreateManagedWorkerBuildConfigRequest `json:"buildConfig"`

	// EnvVars A map of environment variables to set for the worker
	EnvVars       map[string]string                        `json:"envVars"`
	IsIac         bool                                     `json:"isIac"`
	Name          string                                   `json:"name" validate:"required,hatchetName,min=1,max=256"`
	RuntimeConfig *CreateManagedWorkerRuntimeConfigRequest `json:"runtimeConfig,omitempty"`
}

// CreateManagedWorkerRuntimeConfigRequest defines model for CreateManagedWorkerRuntimeConfigRequest.
type CreateManagedWorkerRuntimeConfigRequest struct {
	Actions *[]string `json:"actions,omitempty"`

	// CpuKind The kind of CPU to use for the worker
	CpuKind string `json:"cpuKind"`

	// Cpus The number of CPUs to use for the worker
	Cpus int `json:"cpus"`

	// GpuKind The kind of GPU to use for the worker
	GpuKind *CreateManagedWorkerRuntimeConfigRequestGpuKind `json:"gpuKind,omitempty"`

	// Gpus The number of GPUs to use for the worker
	Gpus *int `json:"gpus,omitempty"`

	// MemoryMb The amount of memory in MB to use for the worker
	MemoryMb    int `json:"memoryMb"`
	NumReplicas int `json:"numReplicas"`

	// Regions The region to deploy the worker to
	Regions *[]ManagedWorkerRegion `json:"regions,omitempty"`
	Slots   *int                   `json:"slots,omitempty"`
}

// CreateManagedWorkerRuntimeConfigRequestGpuKind The kind of GPU to use for the worker
type CreateManagedWorkerRuntimeConfigRequestGpuKind string

// EventObject defines model for EventObject.
type EventObject struct {
	Event *struct {
		Provider *string `json:"provider,omitempty"`
	} `json:"event,omitempty"`
	Fly *struct {
		App *struct {
			Instance *string `json:"instance,omitempty"`
			Name     *string `json:"name,omitempty"`
		} `json:"app,omitempty"`
		Region *string `json:"region,omitempty"`
	} `json:"fly,omitempty"`
	Host *string `json:"host,omitempty"`
	Log  *struct {
		Level *string `json:"level,omitempty"`
	} `json:"log,omitempty"`
	Message   *string    `json:"message,omitempty"`
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// FeatureFlags a map of feature flags for the tenant
type FeatureFlags map[string]string

// FloatString defines model for FloatString.
type FloatString = float32

// GithubAppInstallation defines model for GithubAppInstallation.
type GithubAppInstallation struct {
	AccountAvatarUrl        string          `json:"account_avatar_url"`
	AccountName             string          `json:"account_name"`
	InstallationSettingsUrl string          `json:"installation_settings_url"`
	Metadata                APIResourceMeta `json:"metadata"`
}

// GithubBranch defines model for GithubBranch.
type GithubBranch struct {
	BranchName string `json:"branch_name"`
	IsDefault  bool   `json:"is_default"`
}

// GithubRepo defines model for GithubRepo.
type GithubRepo struct {
	RepoName  string `json:"repo_name"`
	RepoOwner string `json:"repo_owner"`
}

// HistogramBucket defines model for HistogramBucket.
type HistogramBucket struct {
	Boundaries *int32       `json:"boundaries,omitempty"`
	Count      *FloatString `json:"count,omitempty"`
	Lower      *FloatString `json:"lower,omitempty"`
	Upper      *FloatString `json:"upper,omitempty"`
}

// HistogramBuckets defines model for HistogramBuckets.
type HistogramBuckets = []HistogramBucket

// InfraAsCodeRequest defines model for InfraAsCodeRequest.
type InfraAsCodeRequest struct {
	RuntimeConfigs []CreateManagedWorkerRuntimeConfigRequest `json:"runtimeConfigs"`
}

// Instance defines model for Instance.
type Instance struct {
	CommitSha  string `json:"commitSha"`
	CpuKind    string `json:"cpuKind"`
	Cpus       int    `json:"cpus"`
	DiskGb     int    `json:"diskGb"`
	InstanceId string `json:"instanceId"`
	MemoryMb   int    `json:"memoryMb"`
	Name       string `json:"name"`
	Region     string `json:"region"`
	State      string `json:"state"`
}

// InstanceList defines model for InstanceList.
type InstanceList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]Instance         `json:"rows,omitempty"`
}

// LabelValue defines model for LabelValue.
type LabelValue = string

// ListGithubAppInstallationsResponse defines model for ListGithubAppInstallationsResponse.
type ListGithubAppInstallationsResponse struct {
	Pagination PaginationResponse      `json:"pagination"`
	Rows       []GithubAppInstallation `json:"rows"`
}

// ListGithubBranchesResponse defines model for ListGithubBranchesResponse.
type ListGithubBranchesResponse = []GithubBranch

// ListGithubReposResponse defines model for ListGithubReposResponse.
type ListGithubReposResponse = []GithubRepo

// LogLine defines model for LogLine.
type LogLine struct {
	Instance  string    `json:"instance"`
	Line      string    `json:"line"`
	Timestamp time.Time `json:"timestamp"`
}

// LogLineList defines model for LogLineList.
type LogLineList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]LogLine          `json:"rows,omitempty"`
}

// ManagedWorker defines model for ManagedWorker.
type ManagedWorker struct {
	BuildConfig ManagedWorkerBuildConfig `json:"buildConfig"`

	// EnvVars A map of environment variables to set for the worker
	EnvVars        map[string]string             `json:"envVars"`
	IsIac          bool                          `json:"isIac"`
	Metadata       APIResourceMeta               `json:"metadata"`
	Name           string                        `json:"name"`
	RuntimeConfigs *[]ManagedWorkerRuntimeConfig `json:"runtimeConfigs,omitempty"`
}

// ManagedWorkerBuildConfig defines model for ManagedWorkerBuildConfig.
type ManagedWorkerBuildConfig struct {
	GithubInstallationId   openapi_types.UUID `json:"githubInstallationId"`
	GithubRepository       GithubRepo         `json:"githubRepository"`
	GithubRepositoryBranch string             `json:"githubRepositoryBranch"`
	Metadata               APIResourceMeta    `json:"metadata"`
	Steps                  *[]BuildStep       `json:"steps,omitempty"`
}

// ManagedWorkerEvent defines model for ManagedWorkerEvent.
type ManagedWorkerEvent struct {
	Data            map[string]interface{}   `json:"data"`
	Id              int                      `json:"id"`
	ManagedWorkerId string                   `json:"managedWorkerId"`
	Message         string                   `json:"message"`
	Status          ManagedWorkerEventStatus `json:"status"`
	TimeFirstSeen   time.Time                `json:"timeFirstSeen"`
	TimeLastSeen    time.Time                `json:"timeLastSeen"`
}

// ManagedWorkerEventList defines model for ManagedWorkerEventList.
type ManagedWorkerEventList struct {
	Pagination *PaginationResponse   `json:"pagination,omitempty"`
	Rows       *[]ManagedWorkerEvent `json:"rows,omitempty"`
}

// ManagedWorkerEventStatus defines model for ManagedWorkerEventStatus.
type ManagedWorkerEventStatus string

// ManagedWorkerList defines model for ManagedWorkerList.
type ManagedWorkerList struct {
	Pagination *PaginationResponse `json:"pagination,omitempty"`
	Rows       *[]ManagedWorker    `json:"rows,omitempty"`
}

// ManagedWorkerRegion defines model for ManagedWorkerRegion.
type ManagedWorkerRegion string

// ManagedWorkerRuntimeConfig defines model for ManagedWorkerRuntimeConfig.
type ManagedWorkerRuntimeConfig struct {
	// Actions A list of actions this runtime config corresponds to
	Actions *[]string `json:"actions,omitempty"`

	// CpuKind The kind of CPU to use for the worker
	CpuKind string `json:"cpuKind"`

	// Cpus The number of CPUs to use for the worker
	Cpus int `json:"cpus"`

	// MemoryMb The amount of memory in MB to use for the worker
	MemoryMb    int                 `json:"memoryMb"`
	Metadata    APIResourceMeta     `json:"metadata"`
	NumReplicas int                 `json:"numReplicas"`
	Region      ManagedWorkerRegion `json:"region"`
}

// Matrix defines model for Matrix.
type Matrix = []SampleStream

// Metric defines model for Metric.
type Metric map[string]LabelValue

// PaginationResponse defines model for PaginationResponse.
type PaginationResponse = rest.PaginationResponse

// RuntimeConfigActionsResponse defines model for RuntimeConfigActionsResponse.
type RuntimeConfigActionsResponse struct {
	Actions []string `json:"actions"`
}

// SampleHistogram defines model for SampleHistogram.
type SampleHistogram struct {
	Buckets *HistogramBuckets `json:"buckets,omitempty"`
	Count   *FloatString      `json:"count,omitempty"`
	Sum     *FloatString      `json:"sum,omitempty"`
}

// SampleHistogramPair defines model for SampleHistogramPair.
type SampleHistogramPair struct {
	Histogram *SampleHistogram `json:"histogram,omitempty"`
	Timestamp *Time            `json:"timestamp,omitempty"`
}

// SamplePair defines model for SamplePair.
type SamplePair = []interface{}

// SampleStream defines model for SampleStream.
type SampleStream struct {
	Histograms *[]SampleHistogramPair `json:"histograms,omitempty"`
	Metric     *Metric                `json:"metric,omitempty"`
	Values     *[]SamplePair          `json:"values,omitempty"`
}

// SubscriptionPlan defines model for SubscriptionPlan.
type SubscriptionPlan struct {
	// AmountCents The price of the plan.
	AmountCents int `json:"amount_cents"`

	// Description The description of the plan.
	Description string `json:"description"`

	// Name The name of the plan.
	Name string `json:"name"`

	// Period The period of the plan.
	Period *string `json:"period,omitempty"`

	// PlanCode The code of the plan.
	PlanCode string `json:"plan_code"`
}

// TenantBillingState defines model for TenantBillingState.
type TenantBillingState struct {
	// Coupons A list of coupons applied to the tenant.
	Coupons        *[]Coupon              `json:"coupons,omitempty"`
	PaymentMethods *[]TenantPaymentMethod `json:"paymentMethods,omitempty"`

	// Plans A list of plans available for the tenant.
	Plans        *[]SubscriptionPlan `json:"plans,omitempty"`
	Subscription TenantSubscription  `json:"subscription"`
}

// TenantPaymentMethod defines model for TenantPaymentMethod.
type TenantPaymentMethod struct {
	// Brand The brand of the payment method.
	Brand string `json:"brand"`

	// Description The description of the payment method.
	Description *string `json:"description,omitempty"`

	// Expiration The expiration date of the card.
	Expiration *string `json:"expiration,omitempty"`

	// Last4 The last 4 digits of the card.
	Last4 *string `json:"last4,omitempty"`
}

// TenantSubscription defines model for TenantSubscription.
type TenantSubscription struct {
	// Note A note associated with the tenant subscription.
	Note *string `json:"note,omitempty"`

	// Period The period associated with the tenant subscription.
	Period *string `json:"period,omitempty"`

	// Plan The plan code associated with the tenant subscription.
	Plan   *string                   `json:"plan,omitempty"`
	Status *TenantSubscriptionStatus `json:"status,omitempty"`
}

// TenantSubscriptionStatus defines model for TenantSubscriptionStatus.
type TenantSubscriptionStatus string

// Time defines model for Time.
type Time = int

// UpdateManagedWorkerRequest defines model for UpdateManagedWorkerRequest.
type UpdateManagedWorkerRequest struct {
	BuildConfig *CreateManagedWorkerBuildConfigRequest `json:"buildConfig,omitempty"`

	// EnvVars A map of environment variables to set for the worker
	EnvVars       *map[string]string                       `json:"envVars,omitempty"`
	IsIac         *bool                                    `json:"isIac,omitempty"`
	Name          *string                                  `json:"name,omitempty" validate:"required,hatchetName,min=1,max=256"`
	RuntimeConfig *CreateManagedWorkerRuntimeConfigRequest `json:"runtimeConfig,omitempty"`
}

// UpdateTenantSubscription defines model for UpdateTenantSubscription.
type UpdateTenantSubscription struct {
	// Period The period of the plan.
	Period *string `json:"period,omitempty"`

	// Plan The code of the plan.
	Plan *string `json:"plan,omitempty"`
}

// VectorPushRequest defines model for VectorPushRequest.
type VectorPushRequest = []EventObject

// WorkflowRunEventsMetric defines model for WorkflowRunEventsMetric.
type WorkflowRunEventsMetric struct {
	FAILED    int       `json:"FAILED"`
	PENDING   int       `json:"PENDING"`
	QUEUED    int       `json:"QUEUED"`
	RUNNING   int       `json:"RUNNING"`
	SUCCEEDED int       `json:"SUCCEEDED"`
	Time      time.Time `json:"time"`
}

// WorkflowRunEventsMetricsCounts defines model for WorkflowRunEventsMetricsCounts.
type WorkflowRunEventsMetricsCounts struct {
	Results *[]WorkflowRunEventsMetric `json:"results,omitempty"`
}

// IacLogsListParams defines parameters for IacLogsList.
type IacLogsListParams struct {
	// DeployKey The deploy key
	DeployKey string `form:"deployKey" json:"deployKey"`
}

// LogListParams defines parameters for LogList.
type LogListParams struct {
	// After When the logs should start
	After *time.Time `form:"after,omitempty" json:"after,omitempty"`

	// Before When the logs should end
	Before *time.Time `form:"before,omitempty" json:"before,omitempty"`

	// Search The search query to filter for
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Direction The direction to sort the logs
	Direction *LogListParamsDirection `form:"direction,omitempty" json:"direction,omitempty"`
}

// LogListParamsDirection defines parameters for LogList.
type LogListParamsDirection string

// MetricsCpuGetParams defines parameters for MetricsCpuGet.
type MetricsCpuGetParams struct {
	// After When the metrics should start
	After *time.Time `form:"after,omitempty" json:"after,omitempty"`

	// Before When the metrics should end
	Before *time.Time `form:"before,omitempty" json:"before,omitempty"`
}

// MetricsDiskGetParams defines parameters for MetricsDiskGet.
type MetricsDiskGetParams struct {
	// After When the metrics should start
	After *time.Time `form:"after,omitempty" json:"after,omitempty"`

	// Before When the metrics should end
	Before *time.Time `form:"before,omitempty" json:"before,omitempty"`
}

// MetricsMemoryGetParams defines parameters for MetricsMemoryGet.
type MetricsMemoryGetParams struct {
	// After When the metrics should start
	After *time.Time `form:"after,omitempty" json:"after,omitempty"`

	// Before When the metrics should end
	Before *time.Time `form:"before,omitempty" json:"before,omitempty"`
}

// WorkflowRunEventsGetMetricsParams defines parameters for WorkflowRunEventsGetMetrics.
type WorkflowRunEventsGetMetricsParams struct {
	// CreatedAfter The time after the workflow run was created
	CreatedAfter *time.Time `form:"createdAfter,omitempty" json:"createdAfter,omitempty"`

	// FinishedBefore The time before the workflow run was completed
	FinishedBefore *time.Time `form:"finishedBefore,omitempty" json:"finishedBefore,omitempty"`
}

// SubscriptionUpsertJSONRequestBody defines body for SubscriptionUpsert for application/json ContentType.
type SubscriptionUpsertJSONRequestBody = UpdateTenantSubscription

// InfraAsCodeCreateJSONRequestBody defines body for InfraAsCodeCreate for application/json ContentType.
type InfraAsCodeCreateJSONRequestBody = InfraAsCodeRequest

// ManagedWorkerUpdateJSONRequestBody defines body for ManagedWorkerUpdate for application/json ContentType.
type ManagedWorkerUpdateJSONRequestBody = UpdateManagedWorkerRequest

// LogCreateJSONRequestBody defines body for LogCreate for application/json ContentType.
type LogCreateJSONRequestBody = VectorPushRequest

// ManagedWorkerCreateJSONRequestBody defines body for ManagedWorkerCreate for application/json ContentType.
type ManagedWorkerCreateJSONRequestBody = CreateManagedWorkerRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// LagoMessageCreate request
	LagoMessageCreate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantBillingStateGet request
	TenantBillingStateGet(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BillingPortalLinkGet request
	BillingPortalLinkGet(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubscriptionUpsertWithBody request with any body
	SubscriptionUpsertWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubscriptionUpsert(ctx context.Context, tenant openapi_types.UUID, body SubscriptionUpsertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildGet request
	BuildGet(ctx context.Context, build openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BuildLogsList request
	BuildLogsList(ctx context.Context, build openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GithubAppListInstallations request
	GithubAppListInstallations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GithubAppListRepos request
	GithubAppListRepos(ctx context.Context, ghInstallation openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GithubAppListBranches request
	GithubAppListBranches(ctx context.Context, ghInstallation openapi_types.UUID, ghRepoOwner string, ghRepoName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GithubUpdateGlobalWebhook request
	GithubUpdateGlobalWebhook(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GithubUpdateTenantWebhook request
	GithubUpdateTenantWebhook(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InfraAsCodeCreateWithBody request with any body
	InfraAsCodeCreateWithBody(ctx context.Context, infraAsCodeRequest openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InfraAsCodeCreate(ctx context.Context, infraAsCodeRequest openapi_types.UUID, body InfraAsCodeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManagedWorkerDelete request
	ManagedWorkerDelete(ctx context.Context, managedWorker openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManagedWorkerGet request
	ManagedWorkerGet(ctx context.Context, managedWorker openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManagedWorkerUpdateWithBody request with any body
	ManagedWorkerUpdateWithBody(ctx context.Context, managedWorker openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ManagedWorkerUpdate(ctx context.Context, managedWorker openapi_types.UUID, body ManagedWorkerUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManagedWorkerEventsList request
	ManagedWorkerEventsList(ctx context.Context, managedWorker openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IacLogsList request
	IacLogsList(ctx context.Context, managedWorker openapi_types.UUID, params *IacLogsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManagedWorkerInstancesList request
	ManagedWorkerInstancesList(ctx context.Context, managedWorker openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogList request
	LogList(ctx context.Context, managedWorker openapi_types.UUID, params *LogListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricsCpuGet request
	MetricsCpuGet(ctx context.Context, managedWorker openapi_types.UUID, params *MetricsCpuGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricsDiskGet request
	MetricsDiskGet(ctx context.Context, managedWorker openapi_types.UUID, params *MetricsDiskGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetricsMemoryGet request
	MetricsMemoryGet(ctx context.Context, managedWorker openapi_types.UUID, params *MetricsMemoryGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetadataGet request
	MetadataGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RuntimeConfigListActions request
	RuntimeConfigListActions(ctx context.Context, runtimeConfig openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FeatureFlagsList request
	FeatureFlagsList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogCreateWithBody request with any body
	LogCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LogCreate(ctx context.Context, tenant openapi_types.UUID, body LogCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManagedWorkerList request
	ManagedWorkerList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManagedWorkerCreateWithBody request with any body
	ManagedWorkerCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ManagedWorkerCreate(ctx context.Context, tenant openapi_types.UUID, body ManagedWorkerCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkflowRunEventsGetMetrics request
	WorkflowRunEventsGetMetrics(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunEventsGetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateGithubAppOauthCallback request
	UserUpdateGithubAppOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateGithubAppOauthStart request
	UserUpdateGithubAppOauthStart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) LagoMessageCreate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLagoMessageCreateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantBillingStateGet(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantBillingStateGetRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BillingPortalLinkGet(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBillingPortalLinkGetRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscriptionUpsertWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscriptionUpsertRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscriptionUpsert(ctx context.Context, tenant openapi_types.UUID, body SubscriptionUpsertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscriptionUpsertRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildGet(ctx context.Context, build openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildGetRequest(c.Server, build)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildLogsList(ctx context.Context, build openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildLogsListRequest(c.Server, build)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GithubAppListInstallations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGithubAppListInstallationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GithubAppListRepos(ctx context.Context, ghInstallation openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGithubAppListReposRequest(c.Server, ghInstallation)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GithubAppListBranches(ctx context.Context, ghInstallation openapi_types.UUID, ghRepoOwner string, ghRepoName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGithubAppListBranchesRequest(c.Server, ghInstallation, ghRepoOwner, ghRepoName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GithubUpdateGlobalWebhook(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGithubUpdateGlobalWebhookRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GithubUpdateTenantWebhook(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGithubUpdateTenantWebhookRequest(c.Server, webhook)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InfraAsCodeCreateWithBody(ctx context.Context, infraAsCodeRequest openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInfraAsCodeCreateRequestWithBody(c.Server, infraAsCodeRequest, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InfraAsCodeCreate(ctx context.Context, infraAsCodeRequest openapi_types.UUID, body InfraAsCodeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInfraAsCodeCreateRequest(c.Server, infraAsCodeRequest, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagedWorkerDelete(ctx context.Context, managedWorker openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagedWorkerDeleteRequest(c.Server, managedWorker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagedWorkerGet(ctx context.Context, managedWorker openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagedWorkerGetRequest(c.Server, managedWorker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagedWorkerUpdateWithBody(ctx context.Context, managedWorker openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagedWorkerUpdateRequestWithBody(c.Server, managedWorker, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagedWorkerUpdate(ctx context.Context, managedWorker openapi_types.UUID, body ManagedWorkerUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagedWorkerUpdateRequest(c.Server, managedWorker, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagedWorkerEventsList(ctx context.Context, managedWorker openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagedWorkerEventsListRequest(c.Server, managedWorker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IacLogsList(ctx context.Context, managedWorker openapi_types.UUID, params *IacLogsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIacLogsListRequest(c.Server, managedWorker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagedWorkerInstancesList(ctx context.Context, managedWorker openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagedWorkerInstancesListRequest(c.Server, managedWorker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogList(ctx context.Context, managedWorker openapi_types.UUID, params *LogListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogListRequest(c.Server, managedWorker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricsCpuGet(ctx context.Context, managedWorker openapi_types.UUID, params *MetricsCpuGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricsCpuGetRequest(c.Server, managedWorker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricsDiskGet(ctx context.Context, managedWorker openapi_types.UUID, params *MetricsDiskGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricsDiskGetRequest(c.Server, managedWorker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetricsMemoryGet(ctx context.Context, managedWorker openapi_types.UUID, params *MetricsMemoryGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricsMemoryGetRequest(c.Server, managedWorker, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetadataGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetadataGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RuntimeConfigListActions(ctx context.Context, runtimeConfig openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRuntimeConfigListActionsRequest(c.Server, runtimeConfig)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FeatureFlagsList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFeatureFlagsListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogCreate(ctx context.Context, tenant openapi_types.UUID, body LogCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagedWorkerList(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagedWorkerListRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagedWorkerCreateWithBody(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagedWorkerCreateRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagedWorkerCreate(ctx context.Context, tenant openapi_types.UUID, body ManagedWorkerCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagedWorkerCreateRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkflowRunEventsGetMetrics(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunEventsGetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkflowRunEventsGetMetricsRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateGithubAppOauthCallback(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateGithubAppOauthCallbackRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateGithubAppOauthStart(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateGithubAppOauthStartRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewLagoMessageCreateRequest generates requests for LagoMessageCreate
func NewLagoMessageCreateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/lago/webhook")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantBillingStateGetRequest generates requests for TenantBillingStateGet
func NewTenantBillingStateGetRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBillingPortalLinkGetRequest generates requests for BillingPortalLinkGet
func NewBillingPortalLinkGetRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/tenants/%s/billing-portal-link", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubscriptionUpsertRequest calls the generic SubscriptionUpsert builder with application/json body
func NewSubscriptionUpsertRequest(server string, tenant openapi_types.UUID, body SubscriptionUpsertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubscriptionUpsertRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewSubscriptionUpsertRequestWithBody generates requests for SubscriptionUpsert with any type of body
func NewSubscriptionUpsertRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/billing/tenants/%s/subscription", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBuildGetRequest generates requests for BuildGet
func NewBuildGetRequest(server string, build openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "build", runtime.ParamLocationPath, build)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/build/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildLogsListRequest generates requests for BuildLogsList
func NewBuildLogsListRequest(server string, build openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "build", runtime.ParamLocationPath, build)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/build/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGithubAppListInstallationsRequest generates requests for GithubAppListInstallations
func NewGithubAppListInstallationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/github-app/installations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGithubAppListReposRequest generates requests for GithubAppListRepos
func NewGithubAppListReposRequest(server string, ghInstallation openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gh-installation", runtime.ParamLocationPath, ghInstallation)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/github-app/installations/%s/repos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGithubAppListBranchesRequest generates requests for GithubAppListBranches
func NewGithubAppListBranchesRequest(server string, ghInstallation openapi_types.UUID, ghRepoOwner string, ghRepoName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gh-installation", runtime.ParamLocationPath, ghInstallation)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "gh-repo-owner", runtime.ParamLocationPath, ghRepoOwner)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "gh-repo-name", runtime.ParamLocationPath, ghRepoName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/github-app/installations/%s/repos/%s/%s/branches", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGithubUpdateGlobalWebhookRequest generates requests for GithubUpdateGlobalWebhook
func NewGithubUpdateGlobalWebhookRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/github/webhook")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGithubUpdateTenantWebhookRequest generates requests for GithubUpdateTenantWebhook
func NewGithubUpdateTenantWebhookRequest(server string, webhook openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhook", runtime.ParamLocationPath, webhook)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/github/webhook/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInfraAsCodeCreateRequest calls the generic InfraAsCodeCreate builder with application/json body
func NewInfraAsCodeCreateRequest(server string, infraAsCodeRequest openapi_types.UUID, body InfraAsCodeCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInfraAsCodeCreateRequestWithBody(server, infraAsCodeRequest, "application/json", bodyReader)
}

// NewInfraAsCodeCreateRequestWithBody generates requests for InfraAsCodeCreate with any type of body
func NewInfraAsCodeCreateRequestWithBody(server string, infraAsCodeRequest openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "infra-as-code-request", runtime.ParamLocationPath, infraAsCodeRequest)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/infra-as-code/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewManagedWorkerDeleteRequest generates requests for ManagedWorkerDelete
func NewManagedWorkerDeleteRequest(server string, managedWorker openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "managed-worker", runtime.ParamLocationPath, managedWorker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/managed-worker/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewManagedWorkerGetRequest generates requests for ManagedWorkerGet
func NewManagedWorkerGetRequest(server string, managedWorker openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "managed-worker", runtime.ParamLocationPath, managedWorker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/managed-worker/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewManagedWorkerUpdateRequest calls the generic ManagedWorkerUpdate builder with application/json body
func NewManagedWorkerUpdateRequest(server string, managedWorker openapi_types.UUID, body ManagedWorkerUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewManagedWorkerUpdateRequestWithBody(server, managedWorker, "application/json", bodyReader)
}

// NewManagedWorkerUpdateRequestWithBody generates requests for ManagedWorkerUpdate with any type of body
func NewManagedWorkerUpdateRequestWithBody(server string, managedWorker openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "managed-worker", runtime.ParamLocationPath, managedWorker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/managed-worker/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewManagedWorkerEventsListRequest generates requests for ManagedWorkerEventsList
func NewManagedWorkerEventsListRequest(server string, managedWorker openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "managed-worker", runtime.ParamLocationPath, managedWorker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/managed-worker/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIacLogsListRequest generates requests for IacLogsList
func NewIacLogsListRequest(server string, managedWorker openapi_types.UUID, params *IacLogsListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "managed-worker", runtime.ParamLocationPath, managedWorker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/managed-worker/%s/iac-logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deployKey", runtime.ParamLocationQuery, params.DeployKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewManagedWorkerInstancesListRequest generates requests for ManagedWorkerInstancesList
func NewManagedWorkerInstancesListRequest(server string, managedWorker openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "managed-worker", runtime.ParamLocationPath, managedWorker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/managed-worker/%s/instances", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogListRequest generates requests for LogList
func NewLogListRequest(server string, managedWorker openapi_types.UUID, params *LogListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "managed-worker", runtime.ParamLocationPath, managedWorker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/managed-worker/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetricsCpuGetRequest generates requests for MetricsCpuGet
func NewMetricsCpuGetRequest(server string, managedWorker openapi_types.UUID, params *MetricsCpuGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "managed-worker", runtime.ParamLocationPath, managedWorker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/managed-worker/%s/metrics/cpu", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetricsDiskGetRequest generates requests for MetricsDiskGet
func NewMetricsDiskGetRequest(server string, managedWorker openapi_types.UUID, params *MetricsDiskGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "managed-worker", runtime.ParamLocationPath, managedWorker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/managed-worker/%s/metrics/disk", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetricsMemoryGetRequest generates requests for MetricsMemoryGet
func NewMetricsMemoryGetRequest(server string, managedWorker openapi_types.UUID, params *MetricsMemoryGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "managed-worker", runtime.ParamLocationPath, managedWorker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/managed-worker/%s/metrics/memory", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetadataGetRequest generates requests for MetadataGet
func NewMetadataGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/metadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRuntimeConfigListActionsRequest generates requests for RuntimeConfigListActions
func NewRuntimeConfigListActionsRequest(server string, runtimeConfig openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "runtime-config", runtime.ParamLocationPath, runtimeConfig)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/runtime-config/%s/actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFeatureFlagsListRequest generates requests for FeatureFlagsList
func NewFeatureFlagsListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/tenants/%s/feature-flags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogCreateRequest calls the generic LogCreate builder with application/json body
func NewLogCreateRequest(server string, tenant openapi_types.UUID, body LogCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLogCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewLogCreateRequestWithBody generates requests for LogCreate with any type of body
func NewLogCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/tenants/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewManagedWorkerListRequest generates requests for ManagedWorkerList
func NewManagedWorkerListRequest(server string, tenant openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/tenants/%s/managed-worker", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewManagedWorkerCreateRequest calls the generic ManagedWorkerCreate builder with application/json body
func NewManagedWorkerCreateRequest(server string, tenant openapi_types.UUID, body ManagedWorkerCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewManagedWorkerCreateRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewManagedWorkerCreateRequestWithBody generates requests for ManagedWorkerCreate with any type of body
func NewManagedWorkerCreateRequestWithBody(server string, tenant openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/tenants/%s/managed-worker", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorkflowRunEventsGetMetricsRequest generates requests for WorkflowRunEventsGetMetrics
func NewWorkflowRunEventsGetMetricsRequest(server string, tenant openapi_types.UUID, params *WorkflowRunEventsGetMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/tenants/%s/runs-metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfter", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FinishedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "finishedBefore", runtime.ParamLocationQuery, *params.FinishedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateGithubAppOauthCallbackRequest generates requests for UserUpdateGithubAppOauthCallback
func NewUserUpdateGithubAppOauthCallbackRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/users/github-app/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateGithubAppOauthStartRequest generates requests for UserUpdateGithubAppOauthStart
func NewUserUpdateGithubAppOauthStartRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cloud/users/github-app/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// LagoMessageCreateWithResponse request
	LagoMessageCreateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LagoMessageCreateResponse, error)

	// TenantBillingStateGetWithResponse request
	TenantBillingStateGetWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantBillingStateGetResponse, error)

	// BillingPortalLinkGetWithResponse request
	BillingPortalLinkGetWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*BillingPortalLinkGetResponse, error)

	// SubscriptionUpsertWithBodyWithResponse request with any body
	SubscriptionUpsertWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubscriptionUpsertResponse, error)

	SubscriptionUpsertWithResponse(ctx context.Context, tenant openapi_types.UUID, body SubscriptionUpsertJSONRequestBody, reqEditors ...RequestEditorFn) (*SubscriptionUpsertResponse, error)

	// BuildGetWithResponse request
	BuildGetWithResponse(ctx context.Context, build openapi_types.UUID, reqEditors ...RequestEditorFn) (*BuildGetResponse, error)

	// BuildLogsListWithResponse request
	BuildLogsListWithResponse(ctx context.Context, build openapi_types.UUID, reqEditors ...RequestEditorFn) (*BuildLogsListResponse, error)

	// GithubAppListInstallationsWithResponse request
	GithubAppListInstallationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GithubAppListInstallationsResponse, error)

	// GithubAppListReposWithResponse request
	GithubAppListReposWithResponse(ctx context.Context, ghInstallation openapi_types.UUID, reqEditors ...RequestEditorFn) (*GithubAppListReposResponse, error)

	// GithubAppListBranchesWithResponse request
	GithubAppListBranchesWithResponse(ctx context.Context, ghInstallation openapi_types.UUID, ghRepoOwner string, ghRepoName string, reqEditors ...RequestEditorFn) (*GithubAppListBranchesResponse, error)

	// GithubUpdateGlobalWebhookWithResponse request
	GithubUpdateGlobalWebhookWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GithubUpdateGlobalWebhookResponse, error)

	// GithubUpdateTenantWebhookWithResponse request
	GithubUpdateTenantWebhookWithResponse(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*GithubUpdateTenantWebhookResponse, error)

	// InfraAsCodeCreateWithBodyWithResponse request with any body
	InfraAsCodeCreateWithBodyWithResponse(ctx context.Context, infraAsCodeRequest openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InfraAsCodeCreateResponse, error)

	InfraAsCodeCreateWithResponse(ctx context.Context, infraAsCodeRequest openapi_types.UUID, body InfraAsCodeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*InfraAsCodeCreateResponse, error)

	// ManagedWorkerDeleteWithResponse request
	ManagedWorkerDeleteWithResponse(ctx context.Context, managedWorker openapi_types.UUID, reqEditors ...RequestEditorFn) (*ManagedWorkerDeleteResponse, error)

	// ManagedWorkerGetWithResponse request
	ManagedWorkerGetWithResponse(ctx context.Context, managedWorker openapi_types.UUID, reqEditors ...RequestEditorFn) (*ManagedWorkerGetResponse, error)

	// ManagedWorkerUpdateWithBodyWithResponse request with any body
	ManagedWorkerUpdateWithBodyWithResponse(ctx context.Context, managedWorker openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagedWorkerUpdateResponse, error)

	ManagedWorkerUpdateWithResponse(ctx context.Context, managedWorker openapi_types.UUID, body ManagedWorkerUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagedWorkerUpdateResponse, error)

	// ManagedWorkerEventsListWithResponse request
	ManagedWorkerEventsListWithResponse(ctx context.Context, managedWorker openapi_types.UUID, reqEditors ...RequestEditorFn) (*ManagedWorkerEventsListResponse, error)

	// IacLogsListWithResponse request
	IacLogsListWithResponse(ctx context.Context, managedWorker openapi_types.UUID, params *IacLogsListParams, reqEditors ...RequestEditorFn) (*IacLogsListResponse, error)

	// ManagedWorkerInstancesListWithResponse request
	ManagedWorkerInstancesListWithResponse(ctx context.Context, managedWorker openapi_types.UUID, reqEditors ...RequestEditorFn) (*ManagedWorkerInstancesListResponse, error)

	// LogListWithResponse request
	LogListWithResponse(ctx context.Context, managedWorker openapi_types.UUID, params *LogListParams, reqEditors ...RequestEditorFn) (*LogListResponse, error)

	// MetricsCpuGetWithResponse request
	MetricsCpuGetWithResponse(ctx context.Context, managedWorker openapi_types.UUID, params *MetricsCpuGetParams, reqEditors ...RequestEditorFn) (*MetricsCpuGetResponse, error)

	// MetricsDiskGetWithResponse request
	MetricsDiskGetWithResponse(ctx context.Context, managedWorker openapi_types.UUID, params *MetricsDiskGetParams, reqEditors ...RequestEditorFn) (*MetricsDiskGetResponse, error)

	// MetricsMemoryGetWithResponse request
	MetricsMemoryGetWithResponse(ctx context.Context, managedWorker openapi_types.UUID, params *MetricsMemoryGetParams, reqEditors ...RequestEditorFn) (*MetricsMemoryGetResponse, error)

	// MetadataGetWithResponse request
	MetadataGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetadataGetResponse, error)

	// RuntimeConfigListActionsWithResponse request
	RuntimeConfigListActionsWithResponse(ctx context.Context, runtimeConfig openapi_types.UUID, reqEditors ...RequestEditorFn) (*RuntimeConfigListActionsResponse, error)

	// FeatureFlagsListWithResponse request
	FeatureFlagsListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*FeatureFlagsListResponse, error)

	// LogCreateWithBodyWithResponse request with any body
	LogCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogCreateResponse, error)

	LogCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body LogCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*LogCreateResponse, error)

	// ManagedWorkerListWithResponse request
	ManagedWorkerListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*ManagedWorkerListResponse, error)

	// ManagedWorkerCreateWithBodyWithResponse request with any body
	ManagedWorkerCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagedWorkerCreateResponse, error)

	ManagedWorkerCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body ManagedWorkerCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagedWorkerCreateResponse, error)

	// WorkflowRunEventsGetMetricsWithResponse request
	WorkflowRunEventsGetMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunEventsGetMetricsParams, reqEditors ...RequestEditorFn) (*WorkflowRunEventsGetMetricsResponse, error)

	// UserUpdateGithubAppOauthCallbackWithResponse request
	UserUpdateGithubAppOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGithubAppOauthCallbackResponse, error)

	// UserUpdateGithubAppOauthStartWithResponse request
	UserUpdateGithubAppOauthStartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGithubAppOauthStartResponse, error)
}

type LagoMessageCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r LagoMessageCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LagoMessageCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantBillingStateGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantBillingState
	JSON400      *APIErrors
	JSON403      *APIError
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r TenantBillingStateGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantBillingStateGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BillingPortalLinkGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Url The url to the billing portal
		Url *string `json:"url,omitempty"`
	}
	JSON400 *APIErrors
	JSON403 *APIErrors
}

// Status returns HTTPResponse.Status
func (r BillingPortalLinkGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BillingPortalLinkGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubscriptionUpsertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantSubscription
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r SubscriptionUpsertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscriptionUpsertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Build
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r BuildGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildLogsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogLineList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r BuildLogsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildLogsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GithubAppListInstallationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListGithubAppInstallationsResponse
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r GithubAppListInstallationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GithubAppListInstallationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GithubAppListReposResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListGithubReposResponse
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r GithubAppListReposResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GithubAppListReposResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GithubAppListBranchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListGithubBranchesResponse
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r GithubAppListBranchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GithubAppListBranchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GithubUpdateGlobalWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r GithubUpdateGlobalWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GithubUpdateGlobalWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GithubUpdateTenantWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON401      *APIErrors
	JSON405      *APIErrors
}

// Status returns HTTPResponse.Status
func (r GithubUpdateTenantWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GithubUpdateTenantWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InfraAsCodeCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r InfraAsCodeCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InfraAsCodeCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManagedWorkerDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManagedWorker
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r ManagedWorkerDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManagedWorkerDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManagedWorkerGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManagedWorker
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r ManagedWorkerGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManagedWorkerGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManagedWorkerUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManagedWorker
	JSON400      *APIErrors
	JSON403      *APIErrors
	JSON404      *APIErrors
}

// Status returns HTTPResponse.Status
func (r ManagedWorkerUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManagedWorkerUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManagedWorkerEventsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManagedWorkerEventList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r ManagedWorkerEventsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManagedWorkerEventsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IacLogsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogLineList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r IacLogsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IacLogsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManagedWorkerInstancesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstanceList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r ManagedWorkerInstancesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManagedWorkerInstancesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogLineList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r LogListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricsCpuGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Matrix
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r MetricsCpuGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricsCpuGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricsDiskGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Matrix
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r MetricsDiskGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricsDiskGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricsMemoryGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Matrix
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r MetricsMemoryGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricsMemoryGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetadataGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *APICloudMetadata
	JSON400      *APIErrors
}

// Status returns HTTPResponse.Status
func (r MetadataGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetadataGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RuntimeConfigListActionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuntimeConfigActionsResponse
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r RuntimeConfigListActionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RuntimeConfigListActionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FeatureFlagsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FeatureFlags
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r FeatureFlagsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FeatureFlagsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r LogCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManagedWorkerListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManagedWorkerList
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r ManagedWorkerListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManagedWorkerListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManagedWorkerCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManagedWorker
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r ManagedWorkerCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManagedWorkerCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkflowRunEventsGetMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowRunEventsMetricsCounts
	JSON400      *APIErrors
	JSON403      *APIErrors
}

// Status returns HTTPResponse.Status
func (r WorkflowRunEventsGetMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkflowRunEventsGetMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateGithubAppOauthCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateGithubAppOauthCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateGithubAppOauthCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateGithubAppOauthStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateGithubAppOauthStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateGithubAppOauthStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// LagoMessageCreateWithResponse request returning *LagoMessageCreateResponse
func (c *ClientWithResponses) LagoMessageCreateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LagoMessageCreateResponse, error) {
	rsp, err := c.LagoMessageCreate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLagoMessageCreateResponse(rsp)
}

// TenantBillingStateGetWithResponse request returning *TenantBillingStateGetResponse
func (c *ClientWithResponses) TenantBillingStateGetWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*TenantBillingStateGetResponse, error) {
	rsp, err := c.TenantBillingStateGet(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantBillingStateGetResponse(rsp)
}

// BillingPortalLinkGetWithResponse request returning *BillingPortalLinkGetResponse
func (c *ClientWithResponses) BillingPortalLinkGetWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*BillingPortalLinkGetResponse, error) {
	rsp, err := c.BillingPortalLinkGet(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBillingPortalLinkGetResponse(rsp)
}

// SubscriptionUpsertWithBodyWithResponse request with arbitrary body returning *SubscriptionUpsertResponse
func (c *ClientWithResponses) SubscriptionUpsertWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubscriptionUpsertResponse, error) {
	rsp, err := c.SubscriptionUpsertWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscriptionUpsertResponse(rsp)
}

func (c *ClientWithResponses) SubscriptionUpsertWithResponse(ctx context.Context, tenant openapi_types.UUID, body SubscriptionUpsertJSONRequestBody, reqEditors ...RequestEditorFn) (*SubscriptionUpsertResponse, error) {
	rsp, err := c.SubscriptionUpsert(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscriptionUpsertResponse(rsp)
}

// BuildGetWithResponse request returning *BuildGetResponse
func (c *ClientWithResponses) BuildGetWithResponse(ctx context.Context, build openapi_types.UUID, reqEditors ...RequestEditorFn) (*BuildGetResponse, error) {
	rsp, err := c.BuildGet(ctx, build, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildGetResponse(rsp)
}

// BuildLogsListWithResponse request returning *BuildLogsListResponse
func (c *ClientWithResponses) BuildLogsListWithResponse(ctx context.Context, build openapi_types.UUID, reqEditors ...RequestEditorFn) (*BuildLogsListResponse, error) {
	rsp, err := c.BuildLogsList(ctx, build, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildLogsListResponse(rsp)
}

// GithubAppListInstallationsWithResponse request returning *GithubAppListInstallationsResponse
func (c *ClientWithResponses) GithubAppListInstallationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GithubAppListInstallationsResponse, error) {
	rsp, err := c.GithubAppListInstallations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGithubAppListInstallationsResponse(rsp)
}

// GithubAppListReposWithResponse request returning *GithubAppListReposResponse
func (c *ClientWithResponses) GithubAppListReposWithResponse(ctx context.Context, ghInstallation openapi_types.UUID, reqEditors ...RequestEditorFn) (*GithubAppListReposResponse, error) {
	rsp, err := c.GithubAppListRepos(ctx, ghInstallation, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGithubAppListReposResponse(rsp)
}

// GithubAppListBranchesWithResponse request returning *GithubAppListBranchesResponse
func (c *ClientWithResponses) GithubAppListBranchesWithResponse(ctx context.Context, ghInstallation openapi_types.UUID, ghRepoOwner string, ghRepoName string, reqEditors ...RequestEditorFn) (*GithubAppListBranchesResponse, error) {
	rsp, err := c.GithubAppListBranches(ctx, ghInstallation, ghRepoOwner, ghRepoName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGithubAppListBranchesResponse(rsp)
}

// GithubUpdateGlobalWebhookWithResponse request returning *GithubUpdateGlobalWebhookResponse
func (c *ClientWithResponses) GithubUpdateGlobalWebhookWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GithubUpdateGlobalWebhookResponse, error) {
	rsp, err := c.GithubUpdateGlobalWebhook(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGithubUpdateGlobalWebhookResponse(rsp)
}

// GithubUpdateTenantWebhookWithResponse request returning *GithubUpdateTenantWebhookResponse
func (c *ClientWithResponses) GithubUpdateTenantWebhookWithResponse(ctx context.Context, webhook openapi_types.UUID, reqEditors ...RequestEditorFn) (*GithubUpdateTenantWebhookResponse, error) {
	rsp, err := c.GithubUpdateTenantWebhook(ctx, webhook, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGithubUpdateTenantWebhookResponse(rsp)
}

// InfraAsCodeCreateWithBodyWithResponse request with arbitrary body returning *InfraAsCodeCreateResponse
func (c *ClientWithResponses) InfraAsCodeCreateWithBodyWithResponse(ctx context.Context, infraAsCodeRequest openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InfraAsCodeCreateResponse, error) {
	rsp, err := c.InfraAsCodeCreateWithBody(ctx, infraAsCodeRequest, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInfraAsCodeCreateResponse(rsp)
}

func (c *ClientWithResponses) InfraAsCodeCreateWithResponse(ctx context.Context, infraAsCodeRequest openapi_types.UUID, body InfraAsCodeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*InfraAsCodeCreateResponse, error) {
	rsp, err := c.InfraAsCodeCreate(ctx, infraAsCodeRequest, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInfraAsCodeCreateResponse(rsp)
}

// ManagedWorkerDeleteWithResponse request returning *ManagedWorkerDeleteResponse
func (c *ClientWithResponses) ManagedWorkerDeleteWithResponse(ctx context.Context, managedWorker openapi_types.UUID, reqEditors ...RequestEditorFn) (*ManagedWorkerDeleteResponse, error) {
	rsp, err := c.ManagedWorkerDelete(ctx, managedWorker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagedWorkerDeleteResponse(rsp)
}

// ManagedWorkerGetWithResponse request returning *ManagedWorkerGetResponse
func (c *ClientWithResponses) ManagedWorkerGetWithResponse(ctx context.Context, managedWorker openapi_types.UUID, reqEditors ...RequestEditorFn) (*ManagedWorkerGetResponse, error) {
	rsp, err := c.ManagedWorkerGet(ctx, managedWorker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagedWorkerGetResponse(rsp)
}

// ManagedWorkerUpdateWithBodyWithResponse request with arbitrary body returning *ManagedWorkerUpdateResponse
func (c *ClientWithResponses) ManagedWorkerUpdateWithBodyWithResponse(ctx context.Context, managedWorker openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagedWorkerUpdateResponse, error) {
	rsp, err := c.ManagedWorkerUpdateWithBody(ctx, managedWorker, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagedWorkerUpdateResponse(rsp)
}

func (c *ClientWithResponses) ManagedWorkerUpdateWithResponse(ctx context.Context, managedWorker openapi_types.UUID, body ManagedWorkerUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagedWorkerUpdateResponse, error) {
	rsp, err := c.ManagedWorkerUpdate(ctx, managedWorker, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagedWorkerUpdateResponse(rsp)
}

// ManagedWorkerEventsListWithResponse request returning *ManagedWorkerEventsListResponse
func (c *ClientWithResponses) ManagedWorkerEventsListWithResponse(ctx context.Context, managedWorker openapi_types.UUID, reqEditors ...RequestEditorFn) (*ManagedWorkerEventsListResponse, error) {
	rsp, err := c.ManagedWorkerEventsList(ctx, managedWorker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagedWorkerEventsListResponse(rsp)
}

// IacLogsListWithResponse request returning *IacLogsListResponse
func (c *ClientWithResponses) IacLogsListWithResponse(ctx context.Context, managedWorker openapi_types.UUID, params *IacLogsListParams, reqEditors ...RequestEditorFn) (*IacLogsListResponse, error) {
	rsp, err := c.IacLogsList(ctx, managedWorker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIacLogsListResponse(rsp)
}

// ManagedWorkerInstancesListWithResponse request returning *ManagedWorkerInstancesListResponse
func (c *ClientWithResponses) ManagedWorkerInstancesListWithResponse(ctx context.Context, managedWorker openapi_types.UUID, reqEditors ...RequestEditorFn) (*ManagedWorkerInstancesListResponse, error) {
	rsp, err := c.ManagedWorkerInstancesList(ctx, managedWorker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagedWorkerInstancesListResponse(rsp)
}

// LogListWithResponse request returning *LogListResponse
func (c *ClientWithResponses) LogListWithResponse(ctx context.Context, managedWorker openapi_types.UUID, params *LogListParams, reqEditors ...RequestEditorFn) (*LogListResponse, error) {
	rsp, err := c.LogList(ctx, managedWorker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogListResponse(rsp)
}

// MetricsCpuGetWithResponse request returning *MetricsCpuGetResponse
func (c *ClientWithResponses) MetricsCpuGetWithResponse(ctx context.Context, managedWorker openapi_types.UUID, params *MetricsCpuGetParams, reqEditors ...RequestEditorFn) (*MetricsCpuGetResponse, error) {
	rsp, err := c.MetricsCpuGet(ctx, managedWorker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricsCpuGetResponse(rsp)
}

// MetricsDiskGetWithResponse request returning *MetricsDiskGetResponse
func (c *ClientWithResponses) MetricsDiskGetWithResponse(ctx context.Context, managedWorker openapi_types.UUID, params *MetricsDiskGetParams, reqEditors ...RequestEditorFn) (*MetricsDiskGetResponse, error) {
	rsp, err := c.MetricsDiskGet(ctx, managedWorker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricsDiskGetResponse(rsp)
}

// MetricsMemoryGetWithResponse request returning *MetricsMemoryGetResponse
func (c *ClientWithResponses) MetricsMemoryGetWithResponse(ctx context.Context, managedWorker openapi_types.UUID, params *MetricsMemoryGetParams, reqEditors ...RequestEditorFn) (*MetricsMemoryGetResponse, error) {
	rsp, err := c.MetricsMemoryGet(ctx, managedWorker, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricsMemoryGetResponse(rsp)
}

// MetadataGetWithResponse request returning *MetadataGetResponse
func (c *ClientWithResponses) MetadataGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetadataGetResponse, error) {
	rsp, err := c.MetadataGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetadataGetResponse(rsp)
}

// RuntimeConfigListActionsWithResponse request returning *RuntimeConfigListActionsResponse
func (c *ClientWithResponses) RuntimeConfigListActionsWithResponse(ctx context.Context, runtimeConfig openapi_types.UUID, reqEditors ...RequestEditorFn) (*RuntimeConfigListActionsResponse, error) {
	rsp, err := c.RuntimeConfigListActions(ctx, runtimeConfig, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRuntimeConfigListActionsResponse(rsp)
}

// FeatureFlagsListWithResponse request returning *FeatureFlagsListResponse
func (c *ClientWithResponses) FeatureFlagsListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*FeatureFlagsListResponse, error) {
	rsp, err := c.FeatureFlagsList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFeatureFlagsListResponse(rsp)
}

// LogCreateWithBodyWithResponse request with arbitrary body returning *LogCreateResponse
func (c *ClientWithResponses) LogCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogCreateResponse, error) {
	rsp, err := c.LogCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogCreateResponse(rsp)
}

func (c *ClientWithResponses) LogCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body LogCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*LogCreateResponse, error) {
	rsp, err := c.LogCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogCreateResponse(rsp)
}

// ManagedWorkerListWithResponse request returning *ManagedWorkerListResponse
func (c *ClientWithResponses) ManagedWorkerListWithResponse(ctx context.Context, tenant openapi_types.UUID, reqEditors ...RequestEditorFn) (*ManagedWorkerListResponse, error) {
	rsp, err := c.ManagedWorkerList(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagedWorkerListResponse(rsp)
}

// ManagedWorkerCreateWithBodyWithResponse request with arbitrary body returning *ManagedWorkerCreateResponse
func (c *ClientWithResponses) ManagedWorkerCreateWithBodyWithResponse(ctx context.Context, tenant openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagedWorkerCreateResponse, error) {
	rsp, err := c.ManagedWorkerCreateWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagedWorkerCreateResponse(rsp)
}

func (c *ClientWithResponses) ManagedWorkerCreateWithResponse(ctx context.Context, tenant openapi_types.UUID, body ManagedWorkerCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagedWorkerCreateResponse, error) {
	rsp, err := c.ManagedWorkerCreate(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagedWorkerCreateResponse(rsp)
}

// WorkflowRunEventsGetMetricsWithResponse request returning *WorkflowRunEventsGetMetricsResponse
func (c *ClientWithResponses) WorkflowRunEventsGetMetricsWithResponse(ctx context.Context, tenant openapi_types.UUID, params *WorkflowRunEventsGetMetricsParams, reqEditors ...RequestEditorFn) (*WorkflowRunEventsGetMetricsResponse, error) {
	rsp, err := c.WorkflowRunEventsGetMetrics(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkflowRunEventsGetMetricsResponse(rsp)
}

// UserUpdateGithubAppOauthCallbackWithResponse request returning *UserUpdateGithubAppOauthCallbackResponse
func (c *ClientWithResponses) UserUpdateGithubAppOauthCallbackWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGithubAppOauthCallbackResponse, error) {
	rsp, err := c.UserUpdateGithubAppOauthCallback(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateGithubAppOauthCallbackResponse(rsp)
}

// UserUpdateGithubAppOauthStartWithResponse request returning *UserUpdateGithubAppOauthStartResponse
func (c *ClientWithResponses) UserUpdateGithubAppOauthStartWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserUpdateGithubAppOauthStartResponse, error) {
	rsp, err := c.UserUpdateGithubAppOauthStart(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateGithubAppOauthStartResponse(rsp)
}

// ParseLagoMessageCreateResponse parses an HTTP response from a LagoMessageCreateWithResponse call
func ParseLagoMessageCreateResponse(rsp *http.Response) (*LagoMessageCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LagoMessageCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTenantBillingStateGetResponse parses an HTTP response from a TenantBillingStateGetWithResponse call
func ParseTenantBillingStateGetResponse(rsp *http.Response) (*TenantBillingStateGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantBillingStateGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantBillingState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseBillingPortalLinkGetResponse parses an HTTP response from a BillingPortalLinkGetWithResponse call
func ParseBillingPortalLinkGetResponse(rsp *http.Response) (*BillingPortalLinkGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BillingPortalLinkGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Url The url to the billing portal
			Url *string `json:"url,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSubscriptionUpsertResponse parses an HTTP response from a SubscriptionUpsertWithResponse call
func ParseSubscriptionUpsertResponse(rsp *http.Response) (*SubscriptionUpsertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscriptionUpsertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantSubscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBuildGetResponse parses an HTTP response from a BuildGetWithResponse call
func ParseBuildGetResponse(rsp *http.Response) (*BuildGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBuildLogsListResponse parses an HTTP response from a BuildLogsListWithResponse call
func ParseBuildLogsListResponse(rsp *http.Response) (*BuildLogsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildLogsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogLineList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGithubAppListInstallationsResponse parses an HTTP response from a GithubAppListInstallationsWithResponse call
func ParseGithubAppListInstallationsResponse(rsp *http.Response) (*GithubAppListInstallationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GithubAppListInstallationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListGithubAppInstallationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseGithubAppListReposResponse parses an HTTP response from a GithubAppListReposWithResponse call
func ParseGithubAppListReposResponse(rsp *http.Response) (*GithubAppListReposResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GithubAppListReposResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListGithubReposResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseGithubAppListBranchesResponse parses an HTTP response from a GithubAppListBranchesWithResponse call
func ParseGithubAppListBranchesResponse(rsp *http.Response) (*GithubAppListBranchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GithubAppListBranchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListGithubBranchesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseGithubUpdateGlobalWebhookResponse parses an HTTP response from a GithubUpdateGlobalWebhookWithResponse call
func ParseGithubUpdateGlobalWebhookResponse(rsp *http.Response) (*GithubUpdateGlobalWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GithubUpdateGlobalWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseGithubUpdateTenantWebhookResponse parses an HTTP response from a GithubUpdateTenantWebhookWithResponse call
func ParseGithubUpdateTenantWebhookResponse(rsp *http.Response) (*GithubUpdateTenantWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GithubUpdateTenantWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	}

	return response, nil
}

// ParseInfraAsCodeCreateResponse parses an HTTP response from a InfraAsCodeCreateWithResponse call
func ParseInfraAsCodeCreateResponse(rsp *http.Response) (*InfraAsCodeCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InfraAsCodeCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseManagedWorkerDeleteResponse parses an HTTP response from a ManagedWorkerDeleteWithResponse call
func ParseManagedWorkerDeleteResponse(rsp *http.Response) (*ManagedWorkerDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManagedWorkerDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManagedWorker
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseManagedWorkerGetResponse parses an HTTP response from a ManagedWorkerGetWithResponse call
func ParseManagedWorkerGetResponse(rsp *http.Response) (*ManagedWorkerGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManagedWorkerGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManagedWorker
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseManagedWorkerUpdateResponse parses an HTTP response from a ManagedWorkerUpdateWithResponse call
func ParseManagedWorkerUpdateResponse(rsp *http.Response) (*ManagedWorkerUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManagedWorkerUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManagedWorker
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseManagedWorkerEventsListResponse parses an HTTP response from a ManagedWorkerEventsListWithResponse call
func ParseManagedWorkerEventsListResponse(rsp *http.Response) (*ManagedWorkerEventsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManagedWorkerEventsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManagedWorkerEventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseIacLogsListResponse parses an HTTP response from a IacLogsListWithResponse call
func ParseIacLogsListResponse(rsp *http.Response) (*IacLogsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IacLogsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogLineList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseManagedWorkerInstancesListResponse parses an HTTP response from a ManagedWorkerInstancesListWithResponse call
func ParseManagedWorkerInstancesListResponse(rsp *http.Response) (*ManagedWorkerInstancesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManagedWorkerInstancesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstanceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseLogListResponse parses an HTTP response from a LogListWithResponse call
func ParseLogListResponse(rsp *http.Response) (*LogListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogLineList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseMetricsCpuGetResponse parses an HTTP response from a MetricsCpuGetWithResponse call
func ParseMetricsCpuGetResponse(rsp *http.Response) (*MetricsCpuGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricsCpuGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Matrix
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseMetricsDiskGetResponse parses an HTTP response from a MetricsDiskGetWithResponse call
func ParseMetricsDiskGetResponse(rsp *http.Response) (*MetricsDiskGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricsDiskGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Matrix
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseMetricsMemoryGetResponse parses an HTTP response from a MetricsMemoryGetWithResponse call
func ParseMetricsMemoryGetResponse(rsp *http.Response) (*MetricsMemoryGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricsMemoryGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Matrix
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseMetadataGetResponse parses an HTTP response from a MetadataGetWithResponse call
func ParseMetadataGetResponse(rsp *http.Response) (*MetadataGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetadataGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest APICloudMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseRuntimeConfigListActionsResponse parses an HTTP response from a RuntimeConfigListActionsWithResponse call
func ParseRuntimeConfigListActionsResponse(rsp *http.Response) (*RuntimeConfigListActionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RuntimeConfigListActionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuntimeConfigActionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseFeatureFlagsListResponse parses an HTTP response from a FeatureFlagsListWithResponse call
func ParseFeatureFlagsListResponse(rsp *http.Response) (*FeatureFlagsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FeatureFlagsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FeatureFlags
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseLogCreateResponse parses an HTTP response from a LogCreateWithResponse call
func ParseLogCreateResponse(rsp *http.Response) (*LogCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseManagedWorkerListResponse parses an HTTP response from a ManagedWorkerListWithResponse call
func ParseManagedWorkerListResponse(rsp *http.Response) (*ManagedWorkerListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManagedWorkerListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManagedWorkerList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseManagedWorkerCreateResponse parses an HTTP response from a ManagedWorkerCreateWithResponse call
func ParseManagedWorkerCreateResponse(rsp *http.Response) (*ManagedWorkerCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManagedWorkerCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManagedWorker
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseWorkflowRunEventsGetMetricsResponse parses an HTTP response from a WorkflowRunEventsGetMetricsWithResponse call
func ParseWorkflowRunEventsGetMetricsResponse(rsp *http.Response) (*WorkflowRunEventsGetMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkflowRunEventsGetMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowRunEventsMetricsCounts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUserUpdateGithubAppOauthCallbackResponse parses an HTTP response from a UserUpdateGithubAppOauthCallbackWithResponse call
func ParseUserUpdateGithubAppOauthCallbackResponse(rsp *http.Response) (*UserUpdateGithubAppOauthCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateGithubAppOauthCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserUpdateGithubAppOauthStartResponse parses an HTTP response from a UserUpdateGithubAppOauthStartWithResponse call
func ParseUserUpdateGithubAppOauthStartResponse(rsp *http.Response) (*UserUpdateGithubAppOauthStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateGithubAppOauthStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
