// Generated from /Users/gabrielruttner/dev/hatchet/examples/python/retries/worker.py
export const content = "from hatchet_sdk import Context, EmptyModel, Hatchet\n\nhatchet = Hatchet(debug=True)\n\nsimple_workflow = hatchet.workflow(name=\"SimpleRetryWorkflow\")\nbackoff_workflow = hatchet.workflow(name=\"BackoffWorkflow\")\n\n\n# ❓ Simple Step Retries\n@simple_workflow.task(retries=3)\ndef always_fail(input: EmptyModel, ctx: Context) -> dict[str, str]:\n    raise Exception(\"simple task failed\")\n\n\n# ‼️\n\n\n# ❓ Retries with Count\n@simple_workflow.task(retries=3)\ndef fail_twice(input: EmptyModel, ctx: Context) -> dict[str, str]:\n    if ctx.retry_count < 2:\n        raise Exception(\"simple task failed\")\n\n    return {\"status\": \"success\"}\n\n\n# ‼️\n\n\n# ❓ Retries with Backoff\n@backoff_workflow.task(\n    retries=10,\n    # 👀 Maximum number of seconds to wait between retries\n    backoff_max_seconds=10,\n    # 👀 Factor to increase the wait time between retries.\n    # This sequence will be 2s, 4s, 8s, 10s, 10s, 10s... due to the maxSeconds limit\n    backoff_factor=2.0,\n)\ndef backoff_task(input: EmptyModel, ctx: Context) -> dict[str, str]:\n    if ctx.retry_count < 3:\n        raise Exception(\"backoff task failed\")\n\n    return {\"status\": \"success\"}\n\n\n# ‼️\n\n\ndef main() -> None:\n    worker = hatchet.worker(\"backoff-worker\", slots=4, workflows=[backoff_workflow])\n    worker.start()\n\n\nif __name__ == \"__main__\":\n    main()\n";
export const language = "py";
