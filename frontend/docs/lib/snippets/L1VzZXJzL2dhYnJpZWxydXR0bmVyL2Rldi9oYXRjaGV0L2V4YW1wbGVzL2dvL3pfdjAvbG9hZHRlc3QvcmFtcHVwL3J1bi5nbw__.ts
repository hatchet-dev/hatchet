// Generated from /Users/gabrielruttner/dev/hatchet/examples/go/z_v0/loadtest/rampup/run.go
export const content = "package rampup\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/hatchet-dev/hatchet/pkg/client\"\n\t\"github.com/hatchet-dev/hatchet/pkg/worker\"\n)\n\ntype stepOneOutput struct {\n\tMessage string `json:\"message\"`\n}\n\nfunc getConcurrencyKey(ctx worker.HatchetContext) (string, error) {\n\treturn \"my-key\", nil\n}\n\nfunc run(ctx context.Context, delay time.Duration, concurrency int, maxAcceptableDuration time.Duration, hook chan<- time.Duration, executedCh chan<- int64) (int64, int64) {\n\tc, err := client.New(\n\t\tclient.WithLogLevel(\"warn\"),\n\t)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tw, err := worker.NewWorker(\n\t\tworker.WithClient(\n\t\t\tc,\n\t\t),\n\t\tworker.WithLogLevel(\"warn\"),\n\t\tworker.WithMaxRuns(200),\n\t)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmx := sync.Mutex{}\n\tvar count int64\n\tvar uniques int64\n\tvar executed []int64\n\n\tvar concurrencyOpts *worker.WorkflowConcurrency\n\tif concurrency > 0 {\n\t\tconcurrencyOpts = worker.Concurrency(getConcurrencyKey).MaxRuns(int32(concurrency))\n\t}\n\n\terr = w.On(\n\t\tworker.Event(\"load-test:event\"),\n\t\t&worker.WorkflowJob{\n\t\t\tName:        \"load-test\",\n\t\t\tDescription: \"Load testing\",\n\t\t\tConcurrency: concurrencyOpts,\n\t\t\tSteps: []*worker.WorkflowStep{\n\t\t\t\tworker.Fn(func(ctx worker.HatchetContext) (result *stepOneOutput, err error) {\n\t\t\t\t\tvar input Event\n\t\t\t\t\terr = ctx.WorkflowInput(&input)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\n\t\t\t\t\ttook := time.Since(input.CreatedAt)\n\n\t\t\t\t\tl.Debug().Msgf(\"executing %d took %s\", input.ID, took)\n\n\t\t\t\t\tif took > maxAcceptableDuration {\n\t\t\t\t\t\thook <- took\n\t\t\t\t\t}\n\n\t\t\t\t\texecutedCh <- input.ID\n\n\t\t\t\t\tmx.Lock()\n\n\t\t\t\t\t// detect duplicate in executed slice\n\t\t\t\t\tvar duplicate bool\n\t\t\t\t\tfor i := 0; i < len(executed)-1; i++ {\n\t\t\t\t\t\tif executed[i] == input.ID {\n\t\t\t\t\t\t\tduplicate = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif duplicate {\n\t\t\t\t\t\tl.Warn().Str(\"step-run-id\", ctx.StepRunId()).Msgf(\"duplicate %d\", input.ID)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tuniques += 1\n\t\t\t\t\t}\n\t\t\t\t\tcount += 1\n\t\t\t\t\texecuted = append(executed, input.ID)\n\t\t\t\t\tmx.Unlock()\n\n\t\t\t\t\ttime.Sleep(delay)\n\n\t\t\t\t\treturn &stepOneOutput{\n\t\t\t\t\t\tMessage: \"This ran at: \" + time.Now().Format(time.RFC3339Nano),\n\t\t\t\t\t}, nil\n\t\t\t\t}).SetName(\"step-one\"),\n\t\t\t},\n\t\t},\n\t)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tcleanup, err := w.Start()\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"error starting worker: %w\", err))\n\t}\n\n\t<-ctx.Done()\n\n\tif err := cleanup(); err != nil {\n\t\tpanic(fmt.Errorf(\"error cleaning up: %w\", err))\n\t}\n\n\tmx.Lock()\n\tdefer mx.Unlock()\n\treturn count, uniques\n}\n";
export const language = "go";
