import { Snippet } from '@/lib/generated/snips/types';

const snippet: Snippet = {
  'language': 'go',
  'content': 'package main\n\nimport (\n\t\'context\'\n\t\'fmt\'\n\t\'log\'\n\t\'time\'\n)\n\ntype avgResult struct {\n\tcount int64\n\tavg   time.Duration\n}\n\nfunc do(duration time.Duration, eventsPerSecond int, delay time.Duration, wait time.Duration, concurrency int, workerDelay time.Duration, slots int, failureRate float32, payloadSize string, eventFanout int) error {\n\tl.Info().Msgf(\'testing with duration=%s, eventsPerSecond=%d, delay=%s, wait=%s, concurrency=%d\', duration, eventsPerSecond, delay, wait, concurrency)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tafter := 10 * time.Second\n\n\tgo func() {\n\t\ttime.Sleep(duration + after + wait + 5*time.Second)\n\t\tcancel()\n\t}()\n\n\tch := make(chan int64, 2)\n\tdurations := make(chan time.Duration, eventsPerSecond)\n\n\t// Compute running average for executed durations using a rolling average.\n\tdurationsResult := make(chan avgResult)\n\tgo func() {\n\t\tvar count int64\n\t\tvar avg time.Duration\n\t\tfor d := range durations {\n\t\t\tcount++\n\t\t\tif count == 1 {\n\t\t\t\tavg = d\n\t\t\t} else {\n\t\t\t\tavg = avg + (d-avg)/time.Duration(count)\n\t\t\t}\n\t\t}\n\t\tdurationsResult <- avgResult{count: count, avg: avg}\n\t}()\n\n\tgo func() {\n\t\tif workerDelay > 0 {\n\t\t\tl.Info().Msgf(\'wait %s before starting the worker\', workerDelay)\n\t\t\ttime.Sleep(workerDelay)\n\t\t}\n\t\tl.Info().Msg(\'starting worker now\')\n\t\tcount, uniques := run(ctx, delay, durations, concurrency, slots, failureRate, eventFanout)\n\t\tclose(durations)\n\t\tch <- count\n\t\tch <- uniques\n\t}()\n\n\ttime.Sleep(after)\n\n\tscheduled := make(chan time.Duration, eventsPerSecond)\n\n\t// Compute running average for scheduled times using a rolling average.\n\tscheduledResult := make(chan avgResult)\n\tgo func() {\n\t\tvar count int64\n\t\tvar avg time.Duration\n\t\tfor d := range scheduled {\n\t\t\tcount++\n\t\t\tif count == 1 {\n\t\t\t\tavg = d\n\t\t\t} else {\n\t\t\t\tavg = avg + (d-avg)/time.Duration(count)\n\t\t\t}\n\t\t}\n\t\tscheduledResult <- avgResult{count: count, avg: avg}\n\t}()\n\n\temitted := emit(ctx, eventsPerSecond, duration, scheduled, payloadSize)\n\tclose(scheduled)\n\n\texecuted := <-ch\n\tuniques := <-ch\n\n\tfinalDurationResult := <-durationsResult\n\tfinalScheduledResult := <-scheduledResult\n\n\tlog.Printf(\'ℹ️ emitted %d, executed %d, uniques %d, using %d events/s\', emitted, executed, uniques, eventsPerSecond)\n\n\tif executed == 0 {\n\t\treturn fmt.Errorf(\'❌ no events executed\')\n\t}\n\n\tlog.Printf(\'ℹ️ final average duration per executed event: %s\', finalDurationResult.avg)\n\tlog.Printf(\'ℹ️ final average scheduling time per event: %s\', finalScheduledResult.avg)\n\n\tif int64(eventFanout)*emitted != executed {\n\t\tlog.Printf(\'⚠️ warning: emitted and executed counts do not match: %d != %d\', int64(eventFanout)*emitted, executed)\n\t}\n\n\tif int64(eventFanout)*emitted != uniques {\n\t\treturn fmt.Errorf(\'❌ emitted and unique executed counts do not match: %d != %d\', int64(eventFanout)*emitted, uniques)\n\t}\n\n\tlog.Printf(\'✅ success\')\n\n\treturn nil\n}\n',
  'source': 'out/go/z_v0/loadtest/cli/do.go',
  'blocks': {},
  'highlights': {}
};  // Then replace double quotes with single quotes

export default snippet;
