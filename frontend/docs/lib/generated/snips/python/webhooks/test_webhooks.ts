import { Snippet } from '@/lib/generated/snips/types';

const snippet: Snippet = {
  "language": "python",
  "content": "import asyncio\nimport base64\nimport hashlib\nimport hmac\nimport json\nfrom collections.abc import AsyncGenerator\nfrom contextlib import asynccontextmanager\nfrom datetime import datetime, timezone\nfrom typing import Any\nfrom uuid import uuid4\n\nimport aiohttp\nimport pytest\n\nfrom examples.webhooks.worker import WebhookInput\nfrom hatchet_sdk import Hatchet\nfrom hatchet_sdk.clients.rest.api.webhook_api import WebhookApi\nfrom hatchet_sdk.clients.rest.models.v1_create_webhook_request import (\n    V1CreateWebhookRequest,\n)\nfrom hatchet_sdk.clients.rest.models.v1_create_webhook_request_api_key import (\n    V1CreateWebhookRequestAPIKey,\n)\nfrom hatchet_sdk.clients.rest.models.v1_create_webhook_request_basic_auth import (\n    V1CreateWebhookRequestBasicAuth,\n)\nfrom hatchet_sdk.clients.rest.models.v1_create_webhook_request_hmac import (\n    V1CreateWebhookRequestHMAC,\n)\nfrom hatchet_sdk.clients.rest.models.v1_event import V1Event\nfrom hatchet_sdk.clients.rest.models.v1_task_status import V1TaskStatus\nfrom hatchet_sdk.clients.rest.models.v1_task_summary import V1TaskSummary\nfrom hatchet_sdk.clients.rest.models.v1_webhook import V1Webhook\nfrom hatchet_sdk.clients.rest.models.v1_webhook_api_key_auth import V1WebhookAPIKeyAuth\nfrom hatchet_sdk.clients.rest.models.v1_webhook_basic_auth import V1WebhookBasicAuth\nfrom hatchet_sdk.clients.rest.models.v1_webhook_hmac_algorithm import (\n    V1WebhookHMACAlgorithm,\n)\nfrom hatchet_sdk.clients.rest.models.v1_webhook_hmac_auth import V1WebhookHMACAuth\nfrom hatchet_sdk.clients.rest.models.v1_webhook_hmac_encoding import (\n    V1WebhookHMACEncoding,\n)\nfrom hatchet_sdk.clients.rest.models.v1_webhook_source_name import V1WebhookSourceName\n\nTEST_BASIC_USERNAME = \"test_user\"\nTEST_BASIC_PASSWORD = \"test_password\"\nTEST_API_KEY_HEADER = \"X-API-Key\"\nTEST_API_KEY_VALUE = \"test_api_key_123\"\nTEST_HMAC_SIGNATURE_HEADER = \"X-Signature\"\nTEST_HMAC_SECRET = \"test_hmac_secret\"\n\n\n@pytest.fixture\ndef webhook_body() -> WebhookInput:\n    return WebhookInput(type=\"test\", message=\"Hello, world!\")\n\n\n@pytest.fixture\ndef test_run_id() -> str:\n    return str(uuid4())\n\n\n@pytest.fixture\ndef test_start() -> datetime:\n    return datetime.now(timezone.utc)\n\n\ndef create_hmac_signature(\n    payload: bytes,\n    secret: str,\n    algorithm: V1WebhookHMACAlgorithm = V1WebhookHMACAlgorithm.SHA256,\n    encoding: V1WebhookHMACEncoding = V1WebhookHMACEncoding.HEX,\n) -> str:\n    algorithm_map = {\n        V1WebhookHMACAlgorithm.SHA1: hashlib.sha1,\n        V1WebhookHMACAlgorithm.SHA256: hashlib.sha256,\n        V1WebhookHMACAlgorithm.SHA512: hashlib.sha512,\n        V1WebhookHMACAlgorithm.MD5: hashlib.md5,\n    }\n\n    hash_func = algorithm_map[algorithm]\n    signature = hmac.new(secret.encode(), payload, hash_func).digest()\n\n    if encoding == V1WebhookHMACEncoding.HEX:\n        return signature.hex()\n    if encoding == V1WebhookHMACEncoding.BASE64:\n        return base64.b64encode(signature).decode()\n    if encoding == V1WebhookHMACEncoding.BASE64URL:\n        return base64.urlsafe_b64encode(signature).decode()\n\n    raise ValueError(f\"Unsupported encoding: {encoding}\")\n\n\nasync def send_webhook_request(\n    url: str,\n    body: WebhookInput,\n    auth_type: str,\n    auth_data: dict[str, Any] | None = None,\n    headers: dict[str, str] | None = None,\n) -> aiohttp.ClientResponse:\n    request_headers = headers or {}\n    auth = None\n\n    if auth_type == \"BASIC\" and auth_data:\n        auth = aiohttp.BasicAuth(auth_data[\"username\"], auth_data[\"password\"])\n    elif auth_type == \"API_KEY\" and auth_data:\n        request_headers[auth_data[\"header_name\"]] = auth_data[\"api_key\"]\n    elif auth_type == \"HMAC\" and auth_data:\n        payload = json.dumps(body.model_dump()).encode()\n        signature = create_hmac_signature(\n            payload,\n            auth_data[\"secret\"],\n            auth_data.get(\"algorithm\", V1WebhookHMACAlgorithm.SHA256),\n            auth_data.get(\"encoding\", V1WebhookHMACEncoding.HEX),\n        )\n        request_headers[auth_data[\"header_name\"]] = signature\n\n    async with aiohttp.ClientSession() as session:\n        return await session.post(\n            url, json=body.model_dump(), auth=auth, headers=request_headers\n        )\n\n\nasync def wait_for_event(\n    hatchet: Hatchet,\n    webhook_name: str,\n    test_start: datetime,\n) -> V1Event | None:\n    await asyncio.sleep(1)\n\n    events = await hatchet.event.aio_list(since=test_start)\n\n    if events.rows is None:\n        return None\n\n    return next(\n        (\n            event\n            for event in events.rows\n            if event.triggering_webhook_name == webhook_name\n        ),\n        None,\n    )\n\n\nasync def wait_for_workflow_run(\n    hatchet: Hatchet, event_id: str, test_start: datetime\n) -> V1TaskSummary | None:\n    await asyncio.sleep(5)\n\n    runs = await hatchet.runs.aio_list(\n        since=test_start,\n        additional_metadata={\n            \"hatchet__event_id\": event_id,\n        },\n    )\n\n    if len(runs.rows) == 0:\n        return None\n\n    return runs.rows[0]\n\n\n@asynccontextmanager\nasync def basic_auth_webhook(\n    hatchet: Hatchet,\n    test_run_id: str,\n    username: str = TEST_BASIC_USERNAME,\n    password: str = TEST_BASIC_PASSWORD,\n    source_name: V1WebhookSourceName = V1WebhookSourceName.GENERIC,\n) -> AsyncGenerator[V1Webhook, None]:\n    ## Hack to get the API client\n    client = hatchet.metrics.client()\n    webhook_api = WebhookApi(client)\n\n    webhook_request = V1CreateWebhookRequestBasicAuth(\n        sourceName=source_name,\n        name=f\"test-webhook-basic-{test_run_id}\",\n        eventKeyExpression=\"'webhook:' + input.type\",\n        authType=\"BASIC\",\n        auth=V1WebhookBasicAuth(\n            username=username,\n            password=password,\n        ),\n    )\n\n    incoming_webhook = webhook_api.v1_webhook_create(\n        tenant=hatchet.tenant_id,\n        v1_create_webhook_request=V1CreateWebhookRequest(webhook_request),\n    )\n\n    try:\n        yield incoming_webhook\n    finally:\n        webhook_api.v1_webhook_delete(\n            tenant=hatchet.tenant_id,\n            v1_webhook=incoming_webhook.name,\n        )\n\n\n@asynccontextmanager\nasync def api_key_webhook(\n    hatchet: Hatchet,\n    test_run_id: str,\n    header_name: str = TEST_API_KEY_HEADER,\n    api_key: str = TEST_API_KEY_VALUE,\n    source_name: V1WebhookSourceName = V1WebhookSourceName.GENERIC,\n) -> AsyncGenerator[V1Webhook, None]:\n    client = hatchet.metrics.client()\n    webhook_api = WebhookApi(client)\n\n    webhook_request = V1CreateWebhookRequestAPIKey(\n        sourceName=source_name,\n        name=f\"test-webhook-apikey-{test_run_id}\",\n        eventKeyExpression=\"'webhook:' + input.type\",\n        authType=\"API_KEY\",\n        auth=V1WebhookAPIKeyAuth(\n            headerName=header_name,\n            apiKey=api_key,\n        ),\n    )\n\n    incoming_webhook = webhook_api.v1_webhook_create(\n        tenant=hatchet.tenant_id,\n        v1_create_webhook_request=V1CreateWebhookRequest(webhook_request),\n    )\n\n    try:\n        yield incoming_webhook\n    finally:\n        webhook_api.v1_webhook_delete(\n            tenant=hatchet.tenant_id,\n            v1_webhook=incoming_webhook.name,\n        )\n\n\n@asynccontextmanager\nasync def hmac_webhook(\n    hatchet: Hatchet,\n    test_run_id: str,\n    signature_header_name: str = TEST_HMAC_SIGNATURE_HEADER,\n    signing_secret: str = TEST_HMAC_SECRET,\n    algorithm: V1WebhookHMACAlgorithm = V1WebhookHMACAlgorithm.SHA256,\n    encoding: V1WebhookHMACEncoding = V1WebhookHMACEncoding.HEX,\n    source_name: V1WebhookSourceName = V1WebhookSourceName.GENERIC,\n) -> AsyncGenerator[V1Webhook, None]:\n    client = hatchet.metrics.client()\n    webhook_api = WebhookApi(client)\n\n    webhook_request = V1CreateWebhookRequestHMAC(\n        sourceName=source_name,\n        name=f\"test-webhook-hmac-{test_run_id}\",\n        eventKeyExpression=\"'webhook:' + input.type\",\n        authType=\"HMAC\",\n        auth=V1WebhookHMACAuth(\n            algorithm=algorithm,\n            encoding=encoding,\n            signatureHeaderName=signature_header_name,\n            signingSecret=signing_secret,\n        ),\n    )\n\n    incoming_webhook = webhook_api.v1_webhook_create(\n        tenant=hatchet.tenant_id,\n        v1_create_webhook_request=V1CreateWebhookRequest(webhook_request),\n    )\n\n    try:\n        yield incoming_webhook\n    finally:\n        webhook_api.v1_webhook_delete(\n            tenant=hatchet.tenant_id,\n            v1_webhook=incoming_webhook.name,\n        )\n\n\ndef url(tenant_id: str, webhook_name: str) -> str:\n    return f\"http://localhost:8080/api/v1/stable/tenants/{tenant_id}/webhooks/{webhook_name}\"\n\n\nasync def assert_has_runs(\n    hatchet: Hatchet,\n    test_start: datetime,\n    webhook_body: WebhookInput,\n    incoming_webhook: V1Webhook,\n) -> None:\n    triggered_event = await wait_for_event(hatchet, incoming_webhook.name, test_start)\n    assert triggered_event is not None\n    assert triggered_event.key == f\"webhook:{webhook_body.type}\"\n    assert triggered_event.payload == webhook_body.model_dump()\n\n    workflow_run = await wait_for_workflow_run(\n        hatchet, triggered_event.metadata.id, test_start\n    )\n    assert workflow_run is not None\n    assert workflow_run.status == V1TaskStatus.COMPLETED\n    assert workflow_run.additional_metadata is not None\n\n    assert (\n        workflow_run.additional_metadata[\"hatchet__event_id\"]\n        == triggered_event.metadata.id\n    )\n    assert workflow_run.additional_metadata[\"hatchet__event_key\"] == triggered_event.key\n    assert workflow_run.status == V1TaskStatus.COMPLETED\n\n\nasync def assert_event_not_created(\n    hatchet: Hatchet,\n    test_start: datetime,\n    incoming_webhook: V1Webhook,\n) -> None:\n    triggered_event = await wait_for_event(hatchet, incoming_webhook.name, test_start)\n    assert triggered_event is None\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_basic_auth_success(\n    hatchet: Hatchet,\n    test_run_id: str,\n    test_start: datetime,\n    webhook_body: WebhookInput,\n) -> None:\n    async with basic_auth_webhook(hatchet, test_run_id) as incoming_webhook:\n        async with await send_webhook_request(\n            url(hatchet.tenant_id, incoming_webhook.name),\n            webhook_body,\n            \"BASIC\",\n            {\"username\": TEST_BASIC_USERNAME, \"password\": TEST_BASIC_PASSWORD},\n        ) as response:\n            assert response.status == 200\n            data = await response.json()\n            assert data == {\"message\": \"ok\"}\n\n        await assert_has_runs(\n            hatchet,\n            test_start,\n            webhook_body,\n            incoming_webhook,\n        )\n\n\n@pytest.mark.parametrize(\n    \"username,password\",\n    [\n        (\"test_user\", \"incorrect_password\"),\n        (\"incorrect_user\", \"test_password\"),\n        (\"incorrect_user\", \"incorrect_password\"),\n        (\"\", \"\"),\n    ],\n)\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_basic_auth_failure(\n    hatchet: Hatchet,\n    test_run_id: str,\n    test_start: datetime,\n    webhook_body: WebhookInput,\n    username: str,\n    password: str,\n) -> None:\n    \"\"\"Test basic authentication failures.\"\"\"\n    async with basic_auth_webhook(hatchet, test_run_id) as incoming_webhook:\n        async with await send_webhook_request(\n            url(hatchet.tenant_id, incoming_webhook.name),\n            webhook_body,\n            \"BASIC\",\n            {\"username\": username, \"password\": password},\n        ) as response:\n            assert response.status == 403\n\n        await assert_event_not_created(\n            hatchet,\n            test_start,\n            incoming_webhook,\n        )\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_basic_auth_missing_credentials(\n    hatchet: Hatchet,\n    test_run_id: str,\n    test_start: datetime,\n    webhook_body: WebhookInput,\n) -> None:\n    async with basic_auth_webhook(hatchet, test_run_id) as incoming_webhook:\n        async with await send_webhook_request(\n            url(hatchet.tenant_id, incoming_webhook.name), webhook_body, \"NONE\"\n        ) as response:\n            assert response.status == 403\n\n        await assert_event_not_created(\n            hatchet,\n            test_start,\n            incoming_webhook,\n        )\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_api_key_success(\n    hatchet: Hatchet,\n    test_run_id: str,\n    test_start: datetime,\n    webhook_body: WebhookInput,\n) -> None:\n    async with api_key_webhook(hatchet, test_run_id) as incoming_webhook:\n        async with await send_webhook_request(\n            url(hatchet.tenant_id, incoming_webhook.name),\n            webhook_body,\n            \"API_KEY\",\n            {\"header_name\": TEST_API_KEY_HEADER, \"api_key\": TEST_API_KEY_VALUE},\n        ) as response:\n            assert response.status == 200\n            data = await response.json()\n            assert data == {\"message\": \"ok\"}\n\n        await assert_has_runs(\n            hatchet,\n            test_start,\n            webhook_body,\n            incoming_webhook,\n        )\n\n\n@pytest.mark.parametrize(\n    \"api_key\",\n    [\n        \"incorrect_api_key\",\n        \"\",\n        \"partial_key\",\n    ],\n)\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_api_key_failure(\n    hatchet: Hatchet,\n    test_run_id: str,\n    test_start: datetime,\n    webhook_body: WebhookInput,\n    api_key: str,\n) -> None:\n    async with api_key_webhook(hatchet, test_run_id) as incoming_webhook:\n        async with await send_webhook_request(\n            url(hatchet.tenant_id, incoming_webhook.name),\n            webhook_body,\n            \"API_KEY\",\n            {\"header_name\": TEST_API_KEY_HEADER, \"api_key\": api_key},\n        ) as response:\n            assert response.status == 403\n\n        await assert_event_not_created(\n            hatchet,\n            test_start,\n            incoming_webhook,\n        )\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_api_key_missing_header(\n    hatchet: Hatchet,\n    test_run_id: str,\n    test_start: datetime,\n    webhook_body: WebhookInput,\n) -> None:\n    async with api_key_webhook(hatchet, test_run_id) as incoming_webhook:\n        async with await send_webhook_request(\n            url(hatchet.tenant_id, incoming_webhook.name), webhook_body, \"NONE\"\n        ) as response:\n            assert response.status == 403\n\n        await assert_event_not_created(\n            hatchet,\n            test_start,\n            incoming_webhook,\n        )\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_hmac_success(\n    hatchet: Hatchet,\n    test_run_id: str,\n    test_start: datetime,\n    webhook_body: WebhookInput,\n) -> None:\n    async with hmac_webhook(hatchet, test_run_id) as incoming_webhook:\n        async with await send_webhook_request(\n            url(hatchet.tenant_id, incoming_webhook.name),\n            webhook_body,\n            \"HMAC\",\n            {\n                \"header_name\": TEST_HMAC_SIGNATURE_HEADER,\n                \"secret\": TEST_HMAC_SECRET,\n                \"algorithm\": V1WebhookHMACAlgorithm.SHA256,\n                \"encoding\": V1WebhookHMACEncoding.HEX,\n            },\n        ) as response:\n            assert response.status == 200\n            data = await response.json()\n            assert data == {\"message\": \"ok\"}\n\n        await assert_has_runs(\n            hatchet,\n            test_start,\n            webhook_body,\n            incoming_webhook,\n        )\n\n\n@pytest.mark.parametrize(\n    \"algorithm,encoding\",\n    [\n        (V1WebhookHMACAlgorithm.SHA1, V1WebhookHMACEncoding.HEX),\n        (V1WebhookHMACAlgorithm.SHA256, V1WebhookHMACEncoding.BASE64),\n        (V1WebhookHMACAlgorithm.SHA512, V1WebhookHMACEncoding.BASE64URL),\n        (V1WebhookHMACAlgorithm.MD5, V1WebhookHMACEncoding.HEX),\n    ],\n)\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_hmac_different_algorithms_and_encodings(\n    hatchet: Hatchet,\n    test_run_id: str,\n    test_start: datetime,\n    webhook_body: WebhookInput,\n    algorithm: V1WebhookHMACAlgorithm,\n    encoding: V1WebhookHMACEncoding,\n) -> None:\n    async with hmac_webhook(\n        hatchet, test_run_id, algorithm=algorithm, encoding=encoding\n    ) as incoming_webhook:\n        async with await send_webhook_request(\n            url(hatchet.tenant_id, incoming_webhook.name),\n            webhook_body,\n            \"HMAC\",\n            {\n                \"header_name\": TEST_HMAC_SIGNATURE_HEADER,\n                \"secret\": TEST_HMAC_SECRET,\n                \"algorithm\": algorithm,\n                \"encoding\": encoding,\n            },\n        ) as response:\n            assert response.status == 200\n            data = await response.json()\n            assert data == {\"message\": \"ok\"}\n\n        await assert_has_runs(\n            hatchet,\n            test_start,\n            webhook_body,\n            incoming_webhook,\n        )\n\n\n@pytest.mark.parametrize(\n    \"secret\",\n    [\n        \"incorrect_secret\",\n        \"\",\n        \"partial_secret\",\n    ],\n)\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_hmac_signature_failure(\n    hatchet: Hatchet,\n    test_run_id: str,\n    test_start: datetime,\n    webhook_body: WebhookInput,\n    secret: str,\n) -> None:\n    async with hmac_webhook(hatchet, test_run_id) as incoming_webhook:\n        async with await send_webhook_request(\n            url(hatchet.tenant_id, incoming_webhook.name),\n            webhook_body,\n            \"HMAC\",\n            {\n                \"header_name\": TEST_HMAC_SIGNATURE_HEADER,\n                \"secret\": secret,\n                \"algorithm\": V1WebhookHMACAlgorithm.SHA256,\n                \"encoding\": V1WebhookHMACEncoding.HEX,\n            },\n        ) as response:\n            assert response.status == 403\n\n        await assert_event_not_created(\n            hatchet,\n            test_start,\n            incoming_webhook,\n        )\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_hmac_missing_signature_header(\n    hatchet: Hatchet,\n    test_run_id: str,\n    test_start: datetime,\n    webhook_body: WebhookInput,\n) -> None:\n    async with hmac_webhook(hatchet, test_run_id) as incoming_webhook:\n        async with await send_webhook_request(\n            url(hatchet.tenant_id, incoming_webhook.name), webhook_body, \"NONE\"\n        ) as response:\n            assert response.status == 403\n\n        await assert_event_not_created(\n            hatchet,\n            test_start,\n            incoming_webhook,\n        )\n\n\n@pytest.mark.parametrize(\n    \"source_name\",\n    [\n        V1WebhookSourceName.GENERIC,\n        V1WebhookSourceName.GITHUB,\n    ],\n)\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_different_source_types(\n    hatchet: Hatchet,\n    test_run_id: str,\n    test_start: datetime,\n    webhook_body: WebhookInput,\n    source_name: V1WebhookSourceName,\n) -> None:\n    async with basic_auth_webhook(\n        hatchet, test_run_id, source_name=source_name\n    ) as incoming_webhook:\n        async with await send_webhook_request(\n            url(hatchet.tenant_id, incoming_webhook.name),\n            webhook_body,\n            \"BASIC\",\n            {\"username\": TEST_BASIC_USERNAME, \"password\": TEST_BASIC_PASSWORD},\n        ) as response:\n            assert response.status == 200\n            data = await response.json()\n            assert data == {\"message\": \"ok\"}\n\n        await assert_has_runs(\n            hatchet,\n            test_start,\n            webhook_body,\n            incoming_webhook,\n        )\n",
  "source": "out/python/webhooks/test_webhooks.py",
  "blocks": {},
  "highlights": {}
};

export default snippet;
