import { snippets } from "@/lib/generated/snippets";
import { Snippet } from "@/components/code";
import { Callout, Card, Cards, Steps, Tabs } from "nextra/components";
import UniversalTabs from "@/components/UniversalTabs";

# Wait For Events

Wait For Events is a feature of **durable tasks** that lets a task pause until an external event arrives before continuing. Even if the task is interrupted and requeued while waiting, the event will still be processed — when it resumes, it reads the event from the durable event log and continues.

<Callout type="info">
  Waiting for an event puts the task into an [evictable state](/concepts/durable-workflows/durable-task-execution/task-eviction) — the worker slot is freed and the task is re-queued when the event arrives.
</Callout>

<Callout type="info">
  DAG workflows have an analogous feature: [Event Conditions](/concepts/durable-workflows/directed-acyclic-graphs/event-conditions). In a DAG, event conditions are declared upfront on the task definition. Use a durable task when the decision to wait is made dynamically at runtime.
</Callout>

Events are delivered to durable tasks by [pushing events](/concepts/pushing-events) into Hatchet using the event client. The event key you push must match the key your task is waiting for.

## Declaring a wait for event

Wait For Event is declared using the context method `WaitFor` (or utility method `WaitForEvent`) on the `DurableContext` object.

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
  <Tabs.Tab title="Python">

<Snippet src={snippets.python.durable_event.worker.durable_event} />

</Tabs.Tab>
<Tabs.Tab title="Typescript">

<Snippet src={snippets.typescript.durable_event.workflow.durable_event} />

</Tabs.Tab>
<Tabs.Tab title="Go">

<Snippet src={snippets.go.durable.event.main.durable_event} />

</Tabs.Tab>
  <Tabs.Tab title="Ruby">
    <Snippet src={snippets.ruby.durable_event.worker.durable_event} />
  </Tabs.Tab>
</UniversalTabs>

## Event filters

Events can be filtered using [CEL](https://github.com/google/cel-spec) expressions. For example, to only receive `user:update` events for a specific user, you can use the following filter:

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
  <Tabs.Tab title="Python">

<Snippet src={snippets.python.durable_event.worker.durable_event_with_filter} />

</Tabs.Tab>
<Tabs.Tab title="Typescript">

<Snippet
  src={snippets.typescript.durable_event.workflow.durable_event_with_filter}
/>

</Tabs.Tab>
<Tabs.Tab title="Go">

<Snippet src={snippets.go.durable.event.main.durable_event_with_filter} />

</Tabs.Tab>
  <Tabs.Tab title="Ruby">
    <Snippet src={snippets.ruby.durable_event.worker.durable_event_with_filter} />
  </Tabs.Tab>
</UniversalTabs>

## Pushing events

For a waiting task to resume, something must [push an event](/concepts/pushing-events) into Hatchet with a matching key. You can do this from any service that has access to the Hatchet client  - it does not need to be the same worker.

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
  <Tabs.Tab title="Python">
    <Snippet src={snippets.python.events.event.event_trigger} />
  </Tabs.Tab>
  <Tabs.Tab title="Typescript">
    <Snippet src={snippets.typescript.on_event.event.pushing_an_event} />
  </Tabs.Tab>
  <Tabs.Tab title="Go">
    <Snippet src={snippets.go.on_event.main.pushing_an_event} />
  </Tabs.Tab>
  <Tabs.Tab title="Ruby">
    <Snippet src={snippets.ruby.events.event.event_trigger} />
  </Tabs.Tab>
</UniversalTabs>

When the pushed event's key matches what a durable task is waiting for (and passes any CEL filter), the task is re-queued and resumes from its checkpoint.
