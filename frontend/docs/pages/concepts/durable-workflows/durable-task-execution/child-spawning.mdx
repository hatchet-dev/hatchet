import { Callout, Cards, Tabs } from "nextra/components";
import UniversalTabs from "@/components/UniversalTabs";
import { Snippet } from "@/components/code";
import { snippets } from "@/lib/generated/snippets";

# Spawning Children from Durable Tasks

A durable task can spawn child tasks - including other durable tasks or entire DAG workflows - at runtime. This is one of the core reasons to choose durable tasks over DAGs: the shape of work is decided as the task runs, not declared upfront.

<Callout type="info">
  Waiting for child results puts the parent task into an [evictable
  state](/concepts/durable-workflows/durable-task-execution/task-eviction) â€” the
  worker slot is freed and the parent is re-queued when results are available.
</Callout>

## Why spawn from a durable task?

Because the parent is evicted while children execute, this means:

- **No slot waste** - the parent doesn't hold a worker slot while N children run across your fleet.
- **No deadlocks** - because the parent is evicted, it can't starve its own children for slots.
- **Dynamic N** - you decide how many children to spawn based on runtime data (input size, API responses, agent reasoning).

## Spawning child tasks

Use the context object to spawn a child task from within a durable task. The child runs independently on any available worker.

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
<Tabs.Tab title="Python">

<Snippet src={snippets.python.fanout.example_child_spawn.child_spawn} />

</Tabs.Tab>
<Tabs.Tab title="Typescript">

<Snippet
  src={snippets.typescript.child_workflows.workflow.parent_with_single_child}
/>

</Tabs.Tab>
<Tabs.Tab title="Go">

<Snippet src={snippets.go.child_workflows.main.spawning_a_child_workflow} />

</Tabs.Tab>
  <Tabs.Tab title="Ruby">
    <Snippet src={snippets.ruby.fanout.example_child_spawn.child_spawn} />
  </Tabs.Tab>
</UniversalTabs>

## Parallel fan-out

Spawn many children at once and wait for all results. The parent is evicted during the wait, so it consumes no resources while children run.

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
<Tabs.Tab title="Python">

<Snippet src={snippets.python.fanout.trigger.bulk_run_children} />

</Tabs.Tab>
<Tabs.Tab title="Typescript">

<Snippet
  src={snippets.typescript.child_workflows.workflow.declaring_a_parent}
/>

</Tabs.Tab>
<Tabs.Tab title="Go">

<Snippet src={snippets.go.child_workflows.main.parallel_child_task_execution} />

</Tabs.Tab>
  <Tabs.Tab title="Ruby">
    <Snippet src={snippets.ruby.fanout.trigger.bulk_run_children} />
  </Tabs.Tab>
</UniversalTabs>

## What children can be

A durable task can spawn any runnable - the child doesn't have to be the same type as the parent:

| Child type       | Example                                                                           |
| ---------------- | --------------------------------------------------------------------------------- |
| **Regular task** | Spawn a stateless task for a quick computation or API call.                       |
| **Durable task** | Spawn another durable task that has its own checkpoints, sleeps, and event waits. |
| **DAG workflow** | Spawn an entire multi-task workflow and wait for its final output.                |

This means a single durable task can orchestrate a mix of simple tasks and complex workflows, all determined at runtime.

## Common patterns

### Dynamic fan-out / fan-in

Process a list of items whose length is only known at runtime. Spawn one child per item, collect all results, then continue.

### Agent loops

An AI agent reasons about what to do, spawns a subtask (or a sub-workflow), inspects the result, and decides whether to continue, branch, or stop. Each iteration spawns new children dynamically.

### Recursive workflows

A durable task spawns child durable tasks, each of which may spawn their own children. This creates a tree of work that's entirely driven by runtime logic - useful for crawlers, recursive search, and tree-structured computations.

## Error handling

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
<Tabs.Tab title="Python">

<Snippet src={snippets.python.fanout.example_child_spawn.error_handling} />

</Tabs.Tab>
<Tabs.Tab title="Typescript">

<Snippet
  src={snippets.typescript.child_workflows.workflow.parent_with_error_handling}
/>

</Tabs.Tab>
<Tabs.Tab title="Go">

<Snippet src={snippets.go.child_workflows.main.error_handling} />

</Tabs.Tab>
  <Tabs.Tab title="Ruby">
    <Snippet src={snippets.ruby.fanout.example_child_spawn.error_handling} />
  </Tabs.Tab>
</UniversalTabs>

<Callout type="info">
  For the general child spawning API (task definitions, options, deduplication),
  see [Procedural Child Task
  Spawning](/concepts/durable-workflows/directed-acyclic-graphs/child-spawning).
</Callout>
