import { Snippet } from "@/components/code";
import { snippets } from "@/lib/generated/snippets";

import { Callout, Tabs } from "nextra/components";
import UniversalTabs from "@/components/UniversalTabs";

# Parent Conditions

Parent conditions let a DAG task decide whether to run based on the output of a parent task. This enables branching logic within a DAG: different paths can execute depending on runtime data, while the overall graph structure remains fixed and visible in the dashboard.

## Usage modes

Parent conditions can be used with two operators:

- **`skip_if`** — skip the task if the parent output matches the condition.
- **`cancel_if`** — cancel the task (and its downstream dependents) if the parent output matches the condition.

<Callout type="warning">
  A task cancelled by `cancel_if` behaves like any other cancellation in Hatchet
  — downstream tasks will be cancelled as well.
</Callout>

## Branching example

A common pattern is to create two sibling tasks with complementary parent conditions. For example, one task runs when a value is greater than 50 and the other runs when it is less than or equal to 50. Only one branch executes per run.

First, declare a base task that returns a value:

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
  <Tabs.Tab title="Python">
    <Snippet src={snippets.python.conditions.worker.add_base_task} />
  </Tabs.Tab>
  <Tabs.Tab title="Typescript">
    <Snippet
      src={
        snippets.typescript.dag_match_condition.complex_workflow.add_base_task
      }
    />
  </Tabs.Tab>
  <Tabs.Tab title="Go">
    <Snippet src={snippets.go.conditions.main.add_base_task} />
  </Tabs.Tab>
  <Tabs.Tab title="Ruby">
    <Snippet src={snippets.ruby.conditions.worker.add_base_task} />
  </Tabs.Tab>
</UniversalTabs>

Then add two branches that use `ParentCondition` with `skip_if`:

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
  <Tabs.Tab title="Python">
    <Snippet src={snippets.python.conditions.worker.add_branching} />
  </Tabs.Tab>
  <Tabs.Tab title="Typescript">
    <Snippet
      src={
        snippets.typescript.dag_match_condition.complex_workflow.add_branching
      }
    />
  </Tabs.Tab>
  <Tabs.Tab title="Go">
    <Snippet src={snippets.go.conditions.main.add_branching} />
  </Tabs.Tab>
  <Tabs.Tab title="Ruby">
    <Snippet src={snippets.ruby.conditions.worker.add_branching} />
  </Tabs.Tab>
</UniversalTabs>

These two tasks check whether the output of the base task was greater or less than `50`, respectively. Only one of the two will run per workflow execution.

## Checking if a task was skipped

Downstream tasks can check whether a parent was skipped using `ctx.was_skipped`:

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
  <Tabs.Tab title="Python">
<Snippet src={snippets.python.conditions.worker.add_sum}/>

  </Tabs.Tab>
  <Tabs.Tab title="Typescript">
<Snippet src={snippets.typescript.dag_match_condition.complex_workflow.add_sum}/>
  </Tabs.Tab>
  <Tabs.Tab title="Go">
    <Snippet src={snippets.go.conditions.main.add_sum}/>
  </Tabs.Tab>
  <Tabs.Tab title="Ruby">
    <Snippet src={snippets.ruby.conditions.worker.add_sum} />
  </Tabs.Tab>
</UniversalTabs>

## Combining with other conditions

Parent conditions can be combined with event and sleep conditions using or groups. See [Combining Conditions](/concepts/durable-workflows/directed-acyclic-graphs/combining-conditions) for details.
