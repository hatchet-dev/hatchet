import { Snippet } from "@/components/code";
import { snippets } from "@/lib/generated/snippets";
import { Callout, Tabs } from "nextra/components";
import UniversalTabs from "@/components/UniversalTabs";

# Combining Conditions

DAG tasks can declare multiple conditions that work together to control when and whether a task runs. Conditions of different types — [parent conditions](/concepts/durable-workflows/directed-acyclic-graphs/parent-conditions), [event conditions](/concepts/durable-workflows/directed-acyclic-graphs/event-conditions), and [sleep conditions](/concepts/durable-workflows/directed-acyclic-graphs/sleep-conditions) — can be mixed on a single task using **or groups**.

## Or groups

An **or group** is a set of conditions combined with an `Or` operator. The group evaluates to `True` if **at least one** of its conditions is satisfied. Multiple or groups on the same task are combined with `AND` — every group must have at least one satisfied condition for the task to proceed.

This lets you express arbitrarily complex sets of conditions in [conjunctive normal form](https://en.wikipedia.org/wiki/Conjunctive_normal_form) (CNF).

## Sleep + Event example

The most common combination is a sleep condition with an event condition: proceed when an external signal arrives _or_ after a timeout (whichever comes first). This is ideal for human-in-the-loop workflows where you want a deadline.

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
  <Tabs.Tab title="Python">
    <Snippet src={snippets.python.conditions.worker.add_wait_for_event} />

    `or_()` wraps a `SleepCondition` and a `UserEventCondition` into a single or group. The task will start as soon as either the sleep expires or the event arrives.
  </Tabs.Tab>
  <Tabs.Tab title="Typescript">
    <Snippet
      src={
        snippets.typescript.dag_match_condition.complex_workflow
          .add_wait_for_event
      }
    />

    `Or()` wraps a `SleepCondition` and a `UserEventCondition` into a single or group. The task will start as soon as either the sleep expires or the event arrives.
  </Tabs.Tab>
  <Tabs.Tab title="Go">
    <Snippet src={snippets.go.conditions.main.add_wait_for_event} />

    `hatchet.WithWaitFor` and `hatchet.WithSkipIf` attach conditions to the task. The task will wait for the sleep to expire before starting, and will be skipped if the event arrives.
  </Tabs.Tab>
  <Tabs.Tab title="Ruby">
    <Snippet src={snippets.ruby.conditions.worker.add_wait_for_event} />

    `Hatchet.or_()` wraps a `SleepCondition` and a `UserEventCondition` into a single or group. The task will start as soon as either the sleep expires or the event arrives.
  </Tabs.Tab>
</UniversalTabs>

## Multiple or groups

For more complex logic, you can declare multiple or groups on a single task. Consider three conditions:

- **Condition A**: Parent output is greater than 50
- **Condition B**: Sleep for 30 seconds
- **Condition C**: Receive the `payment:processed` event

To proceed if (A _or_ B) **and** (A _or_ C), declare two or groups:

1. Group 1: `A or B`
2. Group 2: `A or C`

The task will run once both groups are satisfied. If A is true, both groups pass immediately. If A is false, the task needs both B (sleep expires) and C (event arrives).

## Common combinations

| Combination | Use case |
| --- | --- |
| Sleep + Event | Proceed after a timeout _or_ when an external signal arrives (whichever comes first) |
| Parent + Event | Proceed if a parent output meets a threshold _or_ a manual override event arrives |
| Parent + Sleep | Proceed if a parent indicates readiness _or_ after a maximum wait time |
| All three | Complex gates combining data-driven, time-based, and event-driven conditions |

<Callout type="info">
  Durable tasks have an analogous feature: [or groups in durable wait conditions](/concepts/durable-workflows/durable-task-execution#or-groups). In a DAG, or groups are declared upfront on the task definition. In a durable task, they're passed to `WaitFor` at runtime.
</Callout>
