import { Snippet } from "@/components/code";
import { snippets } from "@/lib/generated/snippets";

import { Callout, Tabs } from "nextra/components";
import UniversalTabs from "@/components/UniversalTabs";

# Event Conditions

Event conditions let a DAG task react to external events. A task can wait for an event before running, be skipped when an event arrives, or be cancelled by an event.

<Callout type="info">
  Durable tasks have an analogous feature: [Wait For Events](/concepts/durable-workflows/durable-task-execution/durable-events). In a DAG, event conditions are declared upfront on the task definition. In a durable task, `WaitForEvent` is called at runtime from within the function body. Use a DAG event condition when the wait is part of a fixed pipeline; use a durable task when the decision to wait is made dynamically.
</Callout>

## Usage modes

Event conditions can be used with three operators:

- **`wait_for`** — the task waits for the event before starting.
- **`skip_if`** — the task is skipped if the event arrives.
- **`cancel_if`** — the task is cancelled if the event arrives.

<Callout type="warning">
  A task cancelled by `cancel_if` behaves like any other cancellation in Hatchet — downstream tasks will be cancelled as well.
</Callout>

## Waiting for an event

Declare a task with a `wait_for` event condition. The task will not start until the specified event is pushed into Hatchet.

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
  <Tabs.Tab title="Python">
    <Snippet src={snippets.python.conditions.worker.add_wait_for_event} />
  </Tabs.Tab>
  <Tabs.Tab title="Typescript">
    <Snippet
      src={
        snippets.typescript.dag_match_condition.complex_workflow
          .add_wait_for_event
      }
    />
  </Tabs.Tab>
  <Tabs.Tab title="Go">
    <Snippet src={snippets.go.conditions.main.add_wait_for_event} />
  </Tabs.Tab>
  <Tabs.Tab title="Ruby">
    <Snippet src={snippets.ruby.conditions.worker.add_wait_for_event} />
  </Tabs.Tab>
</UniversalTabs>

## Skipping on an event

Declare a task with a `skip_if` event condition. The task will be skipped if the event arrives before the task starts.

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
  <Tabs.Tab title="Python">
    <Snippet src={snippets.python.conditions.worker.add_skip_on_event} />
  </Tabs.Tab>
  <Tabs.Tab title="Typescript">
    <Snippet
      src={
        snippets.typescript.dag_match_condition.complex_workflow
          .add_skip_on_event
      }
    />
  </Tabs.Tab>
  <Tabs.Tab title="Go">
    <Snippet src={snippets.go.conditions.main.add_skip_on_event} />
  </Tabs.Tab>
  <Tabs.Tab title="Ruby">
    <Snippet src={snippets.ruby.conditions.worker.add_skip_on_event} />
  </Tabs.Tab>
</UniversalTabs>

## Event filters

Events can be filtered using [CEL](https://github.com/google/cel-spec) expressions. For example, to only receive `user:update` events for a specific user, you can filter on the event payload. This works identically to [event filters in durable tasks](/concepts/durable-workflows/durable-task-execution/durable-events#event-filters) — the CEL expression is evaluated against the event payload, and the condition only matches if the expression returns `true`.

## Pushing events

For a waiting task to proceed, something must [push an event](/concepts/pushing-events) into Hatchet with a matching key. You can do this from any service that has access to the Hatchet client — it does not need to be the same worker.

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
  <Tabs.Tab title="Python">
    <Snippet src={snippets.python.events.event.event_trigger} />
  </Tabs.Tab>
  <Tabs.Tab title="Typescript">
    <Snippet src={snippets.typescript.on_event.event.pushing_an_event} />
  </Tabs.Tab>
  <Tabs.Tab title="Go">
    <Snippet src={snippets.go.on_event.main.pushing_an_event} />
  </Tabs.Tab>
  <Tabs.Tab title="Ruby">
    <Snippet src={snippets.ruby.events.event.event_trigger} />
  </Tabs.Tab>
</UniversalTabs>

## Combining with other conditions

Event conditions can be combined with parent and sleep conditions using or groups. For example, you can wait for _either_ an event or a timeout (whichever comes first). See [Combining Conditions](/concepts/durable-workflows/directed-acyclic-graphs/combining-conditions) for details.
