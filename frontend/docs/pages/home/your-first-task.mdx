import { Callout, Card, Cards, Steps, Tabs } from "nextra/components";
import UniversalTabs from "@/components/UniversalTabs";
import { GithubSnippet, getSnippets } from "@/components/code";

export const SimpleTs = {
  path: "src/v1/examples/simple/workflow.ts",
};

export const SimpleRunTs = {
  path: "src/v1/examples/simple/run.ts",
};

export const SimplePy = {
  path: "examples/simple/worker.py",
};

export const getStaticProps = ({}) =>
  getSnippets([SimpleTs, SimpleRunTs, SimplePy]);

# Declaring Your First Task

In Hatchet, the fundamental unit of invocable work is a [Task](#defining-a-task). Each task is an atomic function.

As we continue to build with Hatchet, we'll add additional configuration options to compose tasks into workflows with [DAGs](./dags.mdx) or [procedural child spawning](./child-spawning.mdx).

## Defining a Task

Start by declaring a task with a name. The task object can declare additional task-level configuration options which we'll cover later.

The returned object is an instance of the `StandaloneTaskWorkflow` class, which is the primary interface for interacting with the task (i.e. [running](./run-with-results.mdx), [enqueuing](./enqueue-runs.mdx), [scheduling](./scheduled-runs.mdx), etc).

<UniversalTabs items={["Python", "Typescript", "Go"]}>
  <Tabs.Tab title="Python">

```python
from hatchet_sdk import Context, EmptyModel, Hatchet

hatchet = Hatchet(debug=True)

simple = hatchet.workflow(name="SimpleWorkflow")
```

</Tabs.Tab>
<Tabs.Tab title="Typescript">
<GithubSnippet src={SimpleTs} target="Declaring a Task" />
<Callout variant="info">
  Declaring input and output types are optional, but recommended. When
  declaring output types, the keys of the object will be the names of the
  tasks in the workflow where the output will be returned.
</Callout>
</Tabs.Tab>
<Tabs.Tab title="Go">

```go
  w.RegisterWorkflow(
      &worker.WorkflowJob{
          Name:        "simple-workflow",
          Description: "Simple one-task workflow.",
          On:          worker.Event("user:created"),
          Steps: []*worker.WorkflowStep{
              worker.Fn(func(ctx worker.HatchetContext) error {
                  return nil
              }),
          },
      },
  )
```

</Tabs.Tab>
</UniversalTabs>

## Running a Task

With your task defined, you can import it wherever you need to use it and invoke it with the `run` method.

<UniversalTabs items={["Python", "Typescript", "Go"]}>
  <Tabs.Tab title="Python">

```python
from hatchet_sdk import Context, EmptyModel, Hatchet

hatchet = Hatchet(debug=True)

simple = hatchet.workflow(name="SimpleWorkflow")
```

</Tabs.Tab>
<Tabs.Tab title="Typescript">
<GithubSnippet src={SimpleRunTs} target="Running a Task" />
<Callout variant="info">
  Declaring input and output types are optional, but recommended. When
  declaring output types, the keys of the object will be the names of the
  tasks in the workflow where the output will be returned.
</Callout>
</Tabs.Tab>
<Tabs.Tab title="Go">

Example coming soon!

</Tabs.Tab>
</UniversalTabs>

There are many ways to run a task, including:

- [Running a task with results](./run-with-results.mdx)
- [Enqueuing a task](./enqueue-runs.mdx)
- [Scheduling a task](./scheduled-runs.mdx)
- [Scheduling a task with a cron schedule](./cron-schedules.mdx)

Now that you have defined a complete task, you can move on to [creating a worker to execute the task](./workers.mdx).
