import { Callout, Card, Cards, Steps, Tabs } from "nextra/components";
import UniversalTabs from "@/components/UniversalTabs";
import { GithubSnippet, getSnippets } from "@/components/code";

export const SimpleTs = {
  path: "src/v1/examples/simple/workflow.ts",
};
export const SimplePy = {
  path: "examples/simple/worker.py",
};

export const getStaticProps = ({}) => getSnippets([SimpleTs, SimplePy]);

# Declaring Your First Workflow

In Hatchet, the fundamental unit of invocable work is a [Workflow](#defining-a-workflow). Each workflow is a collection of [Tasks](#defining-a-task), which are atomic functions. The simplest workflow can be a single task.

As we continue to build with Hatchet, we'll add additional configuration options to the workflow and task objects to support more complex workflows.

## Declarative Workflow Design (DAGs)

Hatchet workflows are designed in a **Directed Acyclic Graph (DAG)** format, where each task is a node in the graph, and the dependencies between tasks are the edges. This structure ensures that workflows are organized, predictable, and free from circular dependencies. By defining the sequence and dependencies of tasks upfront, you can easily understand the actual runtime state as compared to the expected state when debugging or troubleshooting.

## Defining a Workflow

Start by declaring a workflow with a name. The workflow object can declare additional workflow-level configuration options which we'll cover later.

The returned object is an instance of the `Workflow` class, which is the primary interface for interacting with the workflow (i.e. [running](./run-with-results.mdx), [enqueuing](./enqueue-runs.mdx), [scheduling](./scheduled-runs.mdx), etc).

<UniversalTabs items={["Python", "Typescript", "Go"]}>
  <Tabs.Tab title="Python">

```python
from hatchet_sdk import Context, EmptyModel, Hatchet

hatchet = Hatchet(debug=True)

simple = hatchet.workflow(name="SimpleWorkflow")
```

</Tabs.Tab>
<Tabs.Tab title="Typescript">
<GithubSnippet src={SimpleTs} target="Declaring a Workflow" />
<Callout variant="info">
  Declaring input and output types are optional, but recommended. When
  declaring output types, the keys of the object will be the names of the
  tasks in the workflow where the output will be returned.
</Callout>
</Tabs.Tab>
<Tabs.Tab title="Go">

```go
  w.RegisterWorkflow(
      &worker.WorkflowJob{
          Name:        "simple-workflow",
          Description: "Simple one-task workflow.",
          On:          worker.Event("user:created"),
          Steps: []*worker.WorkflowStep{
              worker.Fn(func(ctx worker.HatchetContext) error {
                  return nil
              }),
          },
      },
  )
```

</Tabs.Tab>
</UniversalTabs>

## Defining a Task

Now that we have a workflow, we can define a task to be executed as part of the workflow. Tasks are defined by calling the `task` method on the workflow object.

The `task` method takes a name and a function that defines the task's behavior. The function will receive the workflow's input and return the task's output. Tasks also accept a number of other configuration options, which are covered elsewhere in our documentation.

<UniversalTabs items={["Python", "Typescript"]}>
{/* TODO V1 DOCS -- RE-ENABLE GO <UniversalTabs items={["Python", "Typescript", "Go"]}> */}
<Tabs.Tab title="Python">
  In Python, the `task` method is a decorator, which is used like this to wrap a function:

```python
@simple.task()
def task_1(input: EmptyModel, ctx: Context) -> None:
    print("executed task_1")
```

The function takes two arguments: `input`, which is a Pydantic model, and `ctx`, which is the Hatchet `Context` object. We'll discuss both of these more later.

<Callout type="info">
In the internals of Hatchet, the task is called using _positional arguments_, meaning that you can name `input` and `ctx` whatever you like.

For instance, `def task_1(foo: EmptyModel, bar: Context) -> None:` is perfectly valid.

</Callout>

</Tabs.Tab>
<Tabs.Tab title="Typescript">
  <GithubSnippet src={SimpleTs} target="Binding a Task to a Workflow" />
  The `fn` argument is a function that takes the workflow's input and a
  context object. The context object contains information about the workflow
  run (e.g. the run ID, the workflow's input, etc). It can be synchronous or
  asynchronous.
</Tabs.Tab>
{/* <Tabs.Tab title="Go">TODO V1 DOCS</Tabs.Tab> */}
</UniversalTabs>

## Running a Workflow

Now that you have defined a complete workflow with a task, you can move on to [creating a worker to execute the workflow](./workers.mdx).
