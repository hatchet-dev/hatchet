import { Callout, Card, Cards, Steps, Tabs } from "nextra/components";
import UniversalTabs from "@/components/UniversalTabs";
import { GithubSnippet, getSnippets } from "@/components/code";

export const SimpleTs = {
  path: "src/v1/examples/simple/workflow.ts",
};
export const SimplePy = {
  path: "examples/simple/worker.py",
};

export const getStaticProps = ({}) => getSnippets([SimpleTs, SimplePy]);

# Declaring Your First Workflow

In Hatchet the fundamental unit of invocable work is a [Workflow](#defining-a-workflow) which is a collection of [Tasks](#defining-a-task) which are atomic functions. The simplest workflow can be a single task.

As we continue to build with Hatchet, we'll add additional configuration options to the workflow and task objects to support more complex workflows.

## Declarative Workflow Design (DAGs)

Hatchet workflows are designed in a **Directed Acyclic Graph (DAG)** format, where each task is a node in the graph, and the dependencies between tasks are the edges. This structure ensures that workflows are organized, predictable, and free from circular dependencies. By defining the sequence and dependencies of tasks upfront, you can easily understand the actual runtime state as compared to the expected state when debugging or troubleshooting.


## Defining a Workflow

Start by declaring a workflow with a name. The workflow object can declare additional workflow-level configuration options which we'll cover later.

The returned object is an instance of the `Workflow` class which is the primary interface for interacting with the workflow (i.e. [running](./run-with-results.mdx), [enqueuing](./enqueue-runs.mdx), [scheduling](./scheduled-runs.mdx), etc).

<UniversalTabs items={["Python", "Typescript", "Go"]}>
  <Tabs.Tab title="Python">
  ```python
    from hatchet_sdk import Context, EmptyModel, Hatchet

    hatchet = Hatchet(debug=True)

    simple = hatchet.workflow(name="SimpleWorkflow")

````

</Tabs.Tab>
<Tabs.Tab title="Typescript">
  <GithubSnippet src={SimpleTs} target="Declaring a Workflow" />
  <Callout variant="info">
    Declaring input and output types are optional, but recommended. When
    declaring output types, the keys of the object will be the names of the
    tasks in the workflow where the output will be returned.
  </Callout>
</Tabs.Tab>
<Tabs.Tab title="Go">
  ```go
    w.RegisterWorkflow(
        &worker.WorkflowJob{
            Name:        "simple-workflow",
            Description: "Simple one-task workflow.",
            On:          worker.Event("user:created"),
            Steps: []*worker.WorkflowStep{
                worker.Fn(func(ctx worker.HatchetContext) error {
                    return nil
                }),
            },
        },
    )
  ```
</Tabs.Tab>
</UniversalTabs>

## Defining a Task

Now that we have a workflow, we can define a task to be executed as part of the workflow. Tasks are defined by calling the `task` method on the workflow object.

The `task` method takes a name and a function that defines the task's behavior. The function will receive the workflow's input and return the task's output.

<UniversalTabs items={["Python", "Typescript"]}>
{/* <UniversalTabs items={["Python", "Typescript", "Go"]}> */}
<Tabs.Tab title="Python">
  ```python
  @simple.task()
  def task_1(input: EmptyModel, ctx: Context) -> None:
      print("executed task_1")
  ```

</Tabs.Tab>
<Tabs.Tab title="Typescript">
  <GithubSnippet src={SimpleTs} target="Binding a Task to a Workflow" />
  The `fn` argument is a function that takes the workflow's input and a
  context object. The context object contains information about the workflow
  run (e.g. the run ID, the workflow's input, etc). It can be synchronous or
  asynchronous.
</Tabs.Tab>
{/* <Tabs.Tab title="Go">TODO V1 DOCS</Tabs.Tab> */}
</UniversalTabs>

## Running a Workflow

Now that you have defined a complete workflow with a task, you can move on to [declaring a worker to execute the workflow](./workers.mdx).
