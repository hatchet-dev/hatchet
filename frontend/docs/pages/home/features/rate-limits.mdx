import { Callout, Card, Cards, Steps, Tabs } from "nextra/components";

# Rate Limiting Step Runs

You can use Hatchet to enforce rate limits on step runs in your workflows. Rate limiting allows you to control the rate at which step runs consume resources, such as external API calls, database queries, or other services. By defining rate limits, you can prevent step runs from exceeding a certain number of requests per minute, hour, or other time window.


## How It Works

1. Decalre a global rate limit that can be consumed by any step run across all workflow runs.
2. Specify the units of consumption for a specific key for a step.

Hatchet will enforce the rate limits you define by tracking the number of units consumed by each step run. If a step run exceeds the rate limit, Hatchet will re-queue the step run until the rate limit is no longer exceeded.

## Declare Your Global Limits

First, we need to define the global rate limits that can be consumed by any step run across all workflow runs. These limits are defined by the `put_rate_limit` method in the `Admin` client within your code.

For example, a key could be an external service API endpoint, and the limit could be the number of requests allowed per minute. The duration could be the time window for the rate limit, such as per second, minute, or hour.

Here's an example of how to define your limits:

<Tabs items={['Python', 'Typescript', 'Go']}>
  <Tabs.Tab>
``` python
    def put_rate_limit(self, key: str, limit: int, duration: RateLimitDuration = RateLimitDuration.SECOND):

````

example:

```python
    hatchet.admin.put_rate_limit('example-limit', 10, RateLimitDuration.MINUTE)
````
  </Tabs.Tab>
  <Tabs.Tab>
```typescript copy
  async put_rate_limit(
    key: string,
    limit: number,
    duration: RateLimitDuration = RateLimitDuration.SECOND
  )
````

example:
```typescript
  await hatchet.admin.put_rate_limit('test-limit', 1, RateLimitDuration.MINUTE);
````

  </Tabs.Tab>
  <Tabs.Tab>
```go copy
	err = c.Admin().PutRateLimit("example-limit", &types.RateLimitOpts{
		Max:      3,
		Duration: "second",
	})
````

  </Tabs.Tab>
</Tabs>

## Consuming Your Rate Limits

With your Rate limit `key` defined, you can now specify the units of consumption for a specific key for a step. This is done by adding the `rate_limits` configuration to your step definition in your workflow.

<Tabs items={['Python', 'Typescript', 'Go']}>
  <Tabs.Tab>
``` python
@hatchet.step(rate_limits = [RateLimit(key='example-limit', units=1)])
def step1(self, context: Context):
    print("executed step1")
    pass
````
  </Tabs.Tab>
  <Tabs.Tab>
```typescript copy
const workflow: Workflow = {
  // ... the rest of the workflow definition
  steps: [
    {
      name: 'step1',
      rate_limits: [{ key: 'example-limit', units: 1 }],
      run: async (ctx) => {
        console.log('starting step1 with the following input', ctx.workflowInput());
        return { step1: 'step1 results!' };
      },
    },
  ],
};
````
  </Tabs.Tab>
  <Tabs.Tab>
```go copy
	err = w.On(
		worker.NoTrigger(),
		&worker.WorkflowJob{
			Name:        "rate-limit-workflow",
			Description: "This illustrates rate limiting.",
			Steps: []*worker.WorkflowStep{
				worker.Fn(StepOne).SetName("step-one").SetRateLimit(
					worker.RateLimit{
						Units: 1,
						Key:   "example-limit",
					},
				),
			},
		},
	)
````
  </Tabs.Tab>
</Tabs>

### Limiting Workflow Runs

Often it might be desirable to rate limit an entire workflow run. The recommended approch is to specify a rate limits configuration on the entry step (i.e. the first step in the workflow). This will gate the execution of all downstream steps in the workflow.