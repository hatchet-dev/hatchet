import { GithubSnippet, getSnippets } from "@/components/code";
import { Callout } from "nextra/components";

export const WaitsTs = {
  path: "src/v1/examples/simple/workflow.ts",
};
export const WaitsPy = {
  path: "examples/waits/worker.py",
};

export const getStaticProps = ({}) => getSnippets([WaitsPy, WaitsTs]);

## V1 New Features

For the past several months, weâ€™ve been working on a complete rewrite of the Hatchet queue with a focus on performance and a set of feature requests which werenâ€™t possible in the v0 architecture.

Here, we'll go into a bit more depth on new features in V1.

## New features

At a high level, Hatchet v1 supports the following new features:

- Complex/conditional workflow logic, like skipping or branching workflows
- Durable execution features: workflow signaling and durable sleep
- A documented, stable REST API for interacting with workflows
- Each SDK received a new `v1.0.x` release with the following improvements:
  - Python received improved support for Pydantic validation, dynamic workflow composition, simpler workflow and task declaration, and significantly improved type support.
  - Typescript received a new factory method for building workflows, and improved typing and validation support
  - Go received improvements for registering workflows and defining tasks.
- Improved bulk cancellations and replays

## Complex / Conditional Workflow Logic

Hatchet V1 introduces the ability to add conditions to tasks in your workflows that determine whether or not a task should be run, based on a number of conditions. There are three types of `Condition`s in Hatchet V1:

1. Sleep conditions, which sleep for a specified duration before continuing
2. Event conditions, which wait for an event (and optionally a CEL expression evaluated on the payload of that event) before deciding how to continue
3. Parent conditions, which wait for a parent task to complete and then decide how to progress based on its output.

These conditions can also be combined using an `Or` operator into groups of conditions where at least one must be satisfied in order for the group to evaluate to `True`.

Conditions can be used at task _declaration_ time in three ways:

1. They can be used in a `wait_for` fashion, where a task will wait for the conditions to evaluate to `True` before being run.
2. They can be used in a `skip_if` fashion, where a task will be skipped if the conditions evaluate to `True`.
3. They can be used in a `cancel_if` fashion, where a task will be cancelled if the conditions evaluate to `True`.

Check out [the conditional logic example](./v1-dags.mdx) for a detailed example of how to use conditional logic in your V1 workflows.

## Durable Execution

Hatchet V1 supports a new set of durable execution features that build off of the [conditions listed above](#complex--conditional-workflow-logic). In the V1 SDKs, you can now call `context.wait_for` to durably wait for either an event or a sleep condition to complete before continuing your task.

<Callout type="info" emoji="ðŸª“">
  If you register any durable tasks, the Hatchet SDK will run a second "durable" worker when starting your main worker for running the durable tasks. This durable worker will show up as a second worker in the Hatchet Dashboard.

**If you register _any_ durable tasks on a workflow, _all_ of the tasks in that workflow will be run by the durable worker.**

</Callout>

Check out the [durable execution example](./v1-durable-execution.mdx) for a detailed example of how to use Hatchet's new durable execution features in your V1 workflows.

## Bulk Cancellations and Replays

Another new feature in V1 is the ability to cancel or replay workflow runs in bulk, which you can now do either in the Hatchet Dashboard or programmatically via the SDKs and the REST API.

There are two ways of bulk cancelling or replaying workflows in both cases:

1. You can provide a list of workflow run ids to cancel or replay, which will cancel or replay all of the workflows in the list.
2. You can provide a list of filters, similar to the list of filters on workflow runs in the Dashboard, and cancel or replay runs matching those filters. For instance, if you wanted to replay all failed runs of a `SimpleWorkflow` from the past fifteen minutes that had the `foo` field in `additional_metadata` set to `bar`, you could apply those filters and replay all of the matching runs.

## SDK improvements

We've made a number of significant improvements to our SDKs in the V1 release. You can read about the improvements to each SDK in their corresponding migration guides:

- [Python SDK](./migration-guide-python.mdx)
- [TypeScript](./migration-guide-typescript.mdx)
- Go (coming soon)

{/* TODO V1 DOCS - Go migration guide */}
