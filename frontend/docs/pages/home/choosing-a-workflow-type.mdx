import { Callout, Cards, Steps } from "nextra/components";
import PatternComparison from "@/components/PatternComparison";

# Choosing a Workflow Type

Hatchet supports two workflow types: **Workflows (DAGs)** and **Durable Workflows**. They solve different problems. This page helps you decide which to use.

## The Short Version

Use **Workflows (DAGs)** when you know the shape of work ahead of time — a set of tasks with declared dependencies. Use **Durable Workflows** when your logic needs to pause, wait, or make decisions inline that can't be expressed as a static graph.

<Callout type="info">
  If you're unsure, start with a DAG workflow. You can always refactor to durable later if you need inline pausing or complex procedural logic.
</Callout>

## Side-by-Side Comparison

<PatternComparison
  rows={[
    { label: "Structure", workflow: "DAG of tasks with declared dependencies. Hatchet determines execution order.", durable: "A single long-running function with checkpoint calls (SleepFor, WaitForEvent, RunChild)." },
    { label: "Parallelism", workflow: "Independent tasks run in parallel automatically based on the dependency graph.", durable: "Parallelism requires explicit child task spawning with RunChild." },
    { label: "State management", workflow: "Task outputs are cached and passed to downstream tasks automatically.", durable: "State is stored in a durable event log and replayed on restart." },
    { label: "Pausing and waiting", workflow: "Declarative conditions on task definitions (wait_for, skip_if, cancel_if).", durable: "Inline SleepFor and WaitForEvent calls within your function code." },
    { label: "Failure recovery", workflow: "Failed tasks are retried individually. Completed tasks are not re-run.", durable: "The function replays from the last checkpoint. Completed operations are skipped." },
    { label: "Worker slots", workflow: "Each task holds a slot for its duration.", durable: "Slot is freed during SleepFor, WaitForEvent, and RunChild waits." },
    { label: "Determinism", workflow: "Not required — each task is independent.", durable: "Required — the function must produce the same sequence of operations on replay." },
  ]}
  recommendation="both"
  recommendationText="Neither type is universally better. DAG workflows are simpler and cover most use cases. Durable workflows add capabilities for long waits, inline pausing, and crash-resilient procedural logic."
/>

## When to Use DAG Workflows

DAG workflows are the right choice when:

- **The workflow shape is known ahead of time.** You have tasks A, B, C, D with fixed dependencies. This is the most common case for ETL pipelines, CI/CD, data processing, and multi-step transforms.

- **Independent tasks should run in parallel.** Hatchet parallelizes tasks that don't depend on each other automatically. You don't need to manage concurrency yourself.

- **You want simplicity.** DAGs are inherently deterministic — there's no replay logic to reason about. Each task is an isolated function with clear inputs and outputs.

- **Branching is based on static conditions.** Use `skip_if`, `wait_for`, and `cancel_if` to route workflows based on parent task outputs or external events.

```
Workflow: ETL Pipeline

  ┌─────────┐     ┌──────────┐     ┌──────────┐
  │ Extract │ ──→ │Transform │ ──→ │   Load   │
  └─────────┘     └──────────┘     └──────────┘

Each task runs independently. If Transform fails,
only Transform is retried — Extract is not re-run.
```

## When to Use Durable Workflows

Durable workflows are the right choice when:

- **Your logic needs to pause for a long time.** Waiting hours for a human approval, sleeping for days before a follow-up, or pausing until an external callback arrives. The worker slot is freed during the wait.

- **Branching depends on runtime state or external events.** Instead of declaring conditions upfront, you write `if/else` logic around `WaitForEvent` and `RunChild` calls. The branching is determined as the function executes.

- **You need crash-resilient procedural logic.** A function that calls `RunChild` three times in sequence, with decisions between each call. If it crashes after the second call, it replays and skips the first two.

- **Fan-outs are large and children take a long time.** A parent that spawns 1000 children and waits for all of them should use a durable workflow so it doesn't hold a slot during the wait.

```
Durable Workflow: Approval Flow

  do_work()
  ──→ ctx.sleep_for("24h")          ← slot freed
  ──→ event = ctx.wait_for_event()  ← slot freed
  ──→ if event.approved:
       ctx.run_child(proceed)
     else:
       ctx.run_child(rollback)

The entire flow is a single function. State survives
crashes. The worker slot is not held during waits.
```

## Decision Flowchart

<Steps>

### Does your workflow need to pause for minutes, hours, or days?

**Yes** → Use a durable workflow. `SleepFor` and `WaitForEvent` free the worker slot during the wait.

**No** → Continue to the next question.

### Is the workflow structure known ahead of time?

**Yes** → Use a DAG workflow. Declare your tasks and dependencies; Hatchet handles execution order and parallelism.

**No** → If the number or type of tasks depends on runtime data (e.g., processing a variable-length list), use [child spawning](/home/child-spawning) within either workflow type. If the logic is highly procedural with decisions between steps, consider a durable workflow.

### Does your workflow fan out to many long-running children?

**Yes** → Use a durable workflow for the parent so it doesn't hold a slot while waiting. The children can be regular tasks.

**No** → Use a DAG workflow.

</Steps>

## Combining Both Types

You don't have to choose one type for your entire application. A common pattern is:

- **DAG workflows for pipelines**: ETL, data processing, CI/CD — anything with a fixed structure.
- **Durable workflows for coordination**: Long waits, human approvals, agent loops.
- **Regular tasks as children of durable workflows**: The durable parent handles orchestration and waits; the children are simple tasks that do the actual work.

<Callout type="warning">
  Durable workflows require **deterministic** code — the function must produce the same sequence of checkpoint operations on every replay. Don't call databases or APIs directly inside a durable task. Instead, wrap those calls in child tasks using `RunChild`. See [Durable Workflows](/home/durable-workflows-overview) for details.
</Callout>

## Per-Pattern Recommendations

Each [pattern](/home/patterns/fanout) page includes a comparison of how it works in DAG workflows versus durable workflows. Here's a summary:

| Pattern | Recommended type | Reason |
|---------|-----------------|--------|
| [Fanout](/home/patterns/fanout) | Durable (for large fan-outs) | Parent slot is freed while waiting for children |
| [Pipelines](/home/patterns/pre-determined-pipelines) | DAG | Fixed structure maps directly to a DAG with automatic parallelism |
| [Branching](/home/patterns/branching) | DAG (for static branches) | `skip_if` and `cancel_if` are simpler than inline conditional logic |
| [Cycles](/home/patterns/cycles) | Either | Both use `RunChild`; durable adds slot release during long pauses between iterations |
| [Long Waits](/home/patterns/long-waits) | Durable | Inline `SleepFor`/`WaitForEvent` with slot release |

## Next Steps

<Cards>
  <Cards.Card title="Workflows (DAGs)" href="/home/workflows-overview">
    Learn how to define workflows with task dependencies and automatic parallelism.
  </Cards.Card>
  <Cards.Card title="Durable Workflows" href="/home/durable-workflows-overview">
    Learn how durable execution checkpoints, pauses, and resumes across failures.
  </Cards.Card>
  <Cards.Card title="DAGs in Detail" href="/home/dags">
    Full guide to defining multi-task workflows with dependencies and conditions.
  </Cards.Card>
  <Cards.Card title="Durable Sleep" href="/home/durable-sleep">
    Pause durable tasks for exact durations with timing guarantees.
  </Cards.Card>
</Cards>
