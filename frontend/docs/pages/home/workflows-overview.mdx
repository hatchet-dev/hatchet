import { Callout, Cards, Steps } from "nextra/components";
import WorkflowDiagram from "@/components/WorkflowDiagram";

# Workflows (DAGs)

A **workflow** is a set of tasks connected by dependencies. You define the shape of work upfront (which tasks run, in what order, and what depends on what) and Hatchet handles execution, retries, and observability for you.

Workflows in Hatchet are **Directed Acyclic Graphs (DAGs)**: each task is a node, dependencies are edges, and there are no circular paths. This structure makes workflows predictable, debuggable, and easy to reason about.

<WorkflowDiagram />

## What a Workflow Gives You

<Steps>

### Declarative task dependencies

Define which tasks depend on which. Hatchet automatically executes tasks in the right order and parallelizes independent tasks.

### Automatic retries and error handling

Each task has configurable [retry policies](/home/retry-policies) and [timeouts](/home/timeouts). If a task fails, Hatchet retries it without re-running already-completed tasks.

### Full observability

Every task execution is tracked in the Hatchet dashboard, including inputs, outputs, durations, and errors. You can see exactly where a workflow succeeded or failed.

### Cached intermediate results

Task outputs are stored and passed to downstream tasks. If a workflow is partially complete when a failure occurs, completed tasks don't need to re-run.

</Steps>

## Anatomy of a Workflow

| Concept        | Description                                                                                                                                                                        |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Task**       | An atomic unit of work. A function that takes input and returns output                                                                                                             |
| **Dependency** | A parent-child relationship between tasks. A child task waits for its parents to complete                                                                                          |
| **Input**      | Data passed to the workflow when it's triggered                                                                                                                                    |
| **Output**     | Data returned by each task, accessible to downstream tasks                                                                                                                         |
| **Trigger**    | How a workflow starts: [direct run](/home/run-with-results), [event](/home/run-on-event), [cron](/home/cron-runs), [schedule](/home/scheduled-runs), or [webhooks](/home/webhooks) |

<Callout type="info">
  Workflows can be as simple as a single task or as complex as dozens of tasks
  with branching, fan-out, and conditional logic. Start simple and compose as
  needed.
</Callout>

## Next Steps

<Cards>
  <Cards.Card title="Durable Workflows" href="/home/durable-workflows-overview">
    Learn how durable workflows checkpoint, pause, and resume across failures.
  </Cards.Card>
  <Cards.Card title="DAGs in Detail" href="/home/dags">
    Define multi-task workflows with dependencies, parent outputs, and parallel
    execution.
  </Cards.Card>
  <Cards.Card title="Child Spawning" href="/home/child-spawning">
    Dynamically create child tasks at runtime for fan-out, loops, and agent
    patterns.
  </Cards.Card>
  <Cards.Card title="Patterns" href="/home/patterns/fanout">
    Explore common workflow patterns: fanout, branching, cycles, and more.
  </Cards.Card>
</Cards>
