import { Callout, Cards, Steps } from "nextra/components";
import LongWaitDiagram from "@/components/LongWaitDiagramWrapper";
import PatternComparison from "@/components/PatternComparison";

# Long Waits

A **long wait** is a workflow pattern where a task pauses execution for an extended period (hours, days, or even weeks) and then resumes exactly where it left off. Hatchet's durable tasks make this possible without holding a worker slot open: the task is evicted during the wait and re-scheduled when the wait completes.

<LongWaitDiagram />

## How It Works

<Steps>

### Task performs initial work

The durable task runs its logic up to the point where it needs to wait, preparing data, making API calls, or setting up state.

### Task enters a long wait

The task calls a durable sleep (for a fixed duration) or waits for a durable event (an external signal). During this time, the worker slot is freed, and the task is not consuming resources.

### Task resumes and completes

When the sleep expires or the event arrives, Hatchet re-schedules the task on an available worker. The task picks up exactly where it left off, with all prior state intact.

</Steps>

<Callout type="info">
  Long waits require **durable tasks**. Regular tasks cannot pause and resume
  across worker restarts. See [Durable Sleep](/home/durable-sleep) and [Durable
  Events](/home/durable-events) for API details.
</Callout>

## Types of Long Waits

| Type              | Mechanism            | Resumes When...                                                          |
| ----------------- | -------------------- | ------------------------------------------------------------------------ |
| **Durable Sleep** | `SleepFor(duration)` | The specified duration has elapsed                                       |
| **Durable Event** | `WaitForEvent(key)`  | An external event matching the key (and optional CEL filter) is received |

<Callout type="warning">
  Durable sleeps are **exact**. If a task sleeps for 24 hours and is
  interrupted after 23 hours, it will only sleep for 1 more hour on restart, not
  another full 24 hours. This is what makes durable sleep different from a
  regular sleep call.
</Callout>

## In Workflows vs Durable Workflows

Long waits are the pattern where the difference between workflows and durable workflows matters most.

<PatternComparison
  rows={[
    { label: "Sleep", workflow: "Use a sleep condition on a task declaration (wait_for with sleep)", durable: "Use SleepFor inline; exact timing survives interruptions" },
    { label: "Event waits", workflow: "Use an event condition on a task declaration (wait_for with event)", durable: "Use WaitForEvent inline; events are stored in the durable log" },
    { label: "Slot usage", workflow: "Task slot is not held during condition waits", durable: "Task slot is freed during SleepFor/WaitForEvent" },
    { label: "Inline logic", workflow: "Wait logic is separate from task code (declarative)", durable: "Wait logic is inline with task code (procedural)" },
    { label: "Best for", workflow: "Simple waits between DAG tasks", durable: "Complex workflows mixing waits with business logic" },
  ]}
  recommendation="durable"
  recommendationText="Both approaches free the worker slot during waits. The key difference is where you express the wait: DAG workflows use declarative conditions, while durable workflows use inline SleepFor/WaitForEvent calls. Choose based on whether your wait logic is simple (DAGs) or interleaved with complex business logic (durable)."
/>

## Use Cases

<Cards>
  <Cards.Card title="Delayed Notifications" href="/home/durable-sleep">
    Send a follow-up email or push notification hours or days after an initial
    action.
  </Cards.Card>
  <Cards.Card title="Human-in-the-Loop Approval" href="/home/durable-events">
    Pause a workflow until a human approves, rejects, or provides input via an
    external event.
  </Cards.Card>
  <Cards.Card title="Scheduled Follow-Ups" href="/home/durable-sleep">
    Implement drip campaigns, trial expiration checks, or periodic status polls
    with precise timing.
  </Cards.Card>
  <Cards.Card title="External System Callbacks" href="/home/durable-events">
    Wait for a webhook, payment confirmation, or third-party API callback before
    proceeding.
  </Cards.Card>
</Cards>

## Next Steps

- [Durable Sleep](/home/durable-sleep): pause for a fixed duration with exact timing guarantees
- [Durable Events](/home/durable-events): wait for external signals with optional CEL filters
- [Conditional Workflows](/home/conditional-workflows): combine long waits with branching logic
- [Cycles](/home/patterns/cycles): use long waits inside iterative loops
