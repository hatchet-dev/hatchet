import { Callout, Cards, Steps } from "nextra/components";
import FanoutDiagram from "@/components/FanoutDiagram";
import PatternComparison from "@/components/PatternComparison";

# Fanout

The **fanout pattern** lets a parent task dynamically spawn N child tasks in parallel, wait for all of them to complete, and optionally collect their results. It is the go-to approach when the number of parallel units of work is determined at runtime (for example, processing every item in a list, running inference on a batch of inputs, or sending notifications to a set of users).

<FanoutDiagram />

## How It Works

<Steps>

### Define parent and child tasks

The parent task contains the spawning logic. The child task defines the unit of work to be performed for each item.

### Parent spawns N children at runtime

When the parent task executes, it iterates over its input data and spawns one child task per item. All children run in parallel across your worker fleet.

### Collect results

The parent may choose to await all child completions and aggregate their results into a single return value.

</Steps>

<Callout type="info">
  Fanout is built on top of [Procedural Child Spawning](/home/child-spawning).
  See that page for full code examples on defining tasks, spawning children,
  parallel execution, and error handling.
</Callout>

<Callout type="warning">
  When fanning out to large numbers of children, make sure your workers have
  enough slots to handle the concurrent load. See [Worker Slots](/home/workers)
  for details on configuring slot capacity.
</Callout>

## In Workflows vs Durable Workflows

<PatternComparison
  rows={[
    { label: "How it works", workflow: "Parent task spawns children and may choose to await results", durable: "Same as DAGs" },
    { label: "Slot usage", workflow: "Parent holds a slot while waiting for children", durable: "Parent slot is freed during the wait, ideal for large fan-outs" },
    { label: "Crash recovery", workflow: "Parent retries from scratch if it fails mid-fanout", durable: "Parent replays from checkpoint and only spawns children tasks that need to run" },
    { label: "Best for", workflow: "Small-to-medium fan-outs where parent completes quickly", durable: "Large deterministic fan-outs that may require long waits or sleeps" },
  ]}
  recommendationText="If your fan-out spawns many children that take a long time to complete, use a durable workflow so the parent doesn't hold a worker slot while waiting."
/>

## Use Cases

<Cards>
  <Cards.Card title="Batch Processing" href="/home/bulk-run">
    Process thousands of items (images, documents, records) in parallel with
    automatic load distribution across workers.
  </Cards.Card>
  <Cards.Card title="Map-Reduce Pipelines" href="/home/dags">
    Fan out to map tasks, then reduce results in a downstream DAG step.
  </Cards.Card>
  <Cards.Card title="Multi-Provider AI Inference" href="/home/child-spawning">
    Send the same prompt to multiple LLM providers concurrently and pick the
    best response.
  </Cards.Card>
  <Cards.Card title="Notification Delivery" href="/home/rate-limits">
    Fan out to send notifications to N users while respecting per-provider rate
    limits.
  </Cards.Card>
</Cards>

## Next Steps

- [Procedural Child Spawning](/home/child-spawning): learn the full child task API
- [DAG Workflows](/home/dags): combine fanout with declarative task dependencies
- [Concurrency Control](/home/concurrency): limit how many children run simultaneously
- [Rate Limits](/home/rate-limits): throttle child task execution rates
