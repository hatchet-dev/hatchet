import { Callout, Cards, Steps } from "nextra/components";
import CycleDiagram from "@/components/CycleDiagramWrapper";
import PatternComparison from "@/components/PatternComparison";

# Cycles

A **cycle** is a workflow pattern where a task re-runs itself repeatedly until a condition is met. Since Hatchet workflows are DAGs (no circular dependencies), cycles are implemented by having a task spawn a new child run of itself — effectively creating an iterative loop through child task spawning.

<CycleDiagram />

## How It Works

<Steps>

### Task performs work

The task executes its logic — making an API call, running an LLM inference, checking a status, or processing a batch of data.

### Evaluate a termination condition

After each execution, the task checks whether the loop should continue. This could be a result quality threshold, a maximum iteration count, or an external signal.

### Re-spawn or complete

If the condition is not met, the task spawns a new child run of itself with updated input. If the condition is met, the task returns its final result.

</Steps>

<Callout type="info">
  Cycles use [Procedural Child Spawning](/home/child-spawning) under the hood —
  each iteration is a new child task run. This gives you full observability into
  every iteration in the Hatchet dashboard.
</Callout>

## When to Use Cycles

| Pattern                  | Use Cycles When...                                                              |
| ------------------------ | ------------------------------------------------------------------------------- |
| **Polling**              | You need to check an external system until a resource is ready                  |
| **Iterative Refinement** | An AI agent refines its output over multiple passes until quality is sufficient |
| **Pagination**           | You process paginated API results one page at a time                            |
| **Retry with Backoff**   | Built-in retries aren't sufficient and you need custom retry logic with state   |
| **Agent Loops**          | An AI agent reasons, acts, observes, and loops until a goal is achieved         |

<Callout type="warning">
  Always include a termination condition (max iterations, timeout, or quality
  threshold) to prevent infinite loops. Each iteration consumes a worker slot,
  so unbounded cycles can exhaust your worker capacity.
</Callout>

## In Workflows vs Durable Workflows

<PatternComparison
  rows={[
    { label: "Loop mechanism", workflow: "Task spawns a child run of itself via RunChild", durable: "Same — RunChild is checkpointed, so completed iterations survive crashes" },
    { label: "Slot usage", workflow: "Each iteration holds a slot for its full duration", durable: "Slot is freed between iterations if you add SleepFor or WaitForEvent waits" },
    { label: "State between iterations", workflow: "Passed as input to the child task", durable: "Can also be stored inline in the durable event log" },
    { label: "Best for", workflow: "Fast iterations (API polling, agent loops)", durable: "Cycles with long waits between iterations (e.g., retry with 1-hour backoff)" },
  ]}
  recommendation="both"
  recommendationText="Both workflow types use the same RunChild mechanism for cycles. Choose durable workflows when iterations involve long pauses (sleeping between retries, waiting for events) so you don't hold slots idle."
/>

## Use Cases

<Cards>
  <Cards.Card title="AI Agent Loops" href="/home/child-spawning">
    Build agents that reason, take action, observe results, and loop until they
    achieve their goal.
  </Cards.Card>
  <Cards.Card title="Polling External APIs" href="/home/child-spawning">
    Check an external service repeatedly until a resource is ready or a status
    changes.
  </Cards.Card>
  <Cards.Card title="Iterative Data Processing" href="/home/child-spawning">
    Process data in successive passes, refining results until convergence.
  </Cards.Card>
  <Cards.Card title="Custom Retry Logic" href="/home/retry-policies">
    Implement application-specific retry strategies with state carried between
    attempts.
  </Cards.Card>
</Cards>

## Next Steps

- [Procedural Child Spawning](/home/child-spawning) — the mechanism that powers cycle iteration
- [Retry Policies](/home/retry-policies) — built-in retry support for simpler retry scenarios
- [Branching](/home/patterns/branching) — combine cycles with conditional logic
- [Fanout](/home/patterns/fanout) — spawn parallel tasks instead of sequential iterations
