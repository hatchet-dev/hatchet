import { Callout, Tabs } from "nextra/components";
import UniversalTabs from "@/components/UniversalTabs";
import { Snippet } from "@/components/code";
import { snippets } from "@/lib/generated/snippets";

# Running Tasks

Once you have a running worker, you'll want to run your tasks. Hatchet provides a number of ways of triggering task runs, from which you should select the one(s) that best suit(s) your use case.

1. Tasks can be [run, and have their results waited on](./run-with-results.mdx)
2. Tasks can be [enqueued without waiting for their results ("fire and forget")](./run-no-wait.mdx).
3. Tasks can be run on [cron schedules](./cron-runs.mdx).
4. Tasks can be [triggered by events](./run-on-event.mdx).
5. Tasks can be [scheduled for a later time](./scheduled-runs.mdx).

Each of these methods for triggering tasks have their own uses in different scenarios, and the next few sections will give some examples of each.

These methods can be invoked directly from the workflow definition, or from other services.

## Invoking Tasks from your Application

Often it is useful to trigger tasks from your application (i.e. an API service). Hatchet consistently serializes inputs so the invocation of a task is the same regardless of the language or framework you are using.

### Creating a "Stub" Task on your External Service (Recommended)

The recommended way to trigger a task from an external service is to create a "stub" task on your external service. This is a hatchet task or workflow that has the same name and input/output types as the task you want to trigger on your hatchet worker, but without the function or other configuration.

This allows you to have polyglot, fully typed interface with full sdk support.

<UniversalTabs items={["Typescript", "Python", "Go"]}>
<Tabs.Tab title="Typescript">

<Snippet
  src={
    snippets.typescript.simple.stub_workflow
      .declaring_an_external_workflow_reference
  }
/>

</Tabs.Tab>
<Tabs.Tab title="Python">

Consider a task with an implementation like this:

<Snippet src={snippets.python.stubs.implementation.all} />

To trigger this task from a separate service, for instance, in a microservices architecture, where the code is not shared, start by defining models that match the input and output types of the task defined above.

<Snippet src={snippets.python.stubs.stub_trigger.define_models} />

Next, create the stub task.

<Snippet src={snippets.python.stubs.stub_trigger.create_a_stub_task} />

Finally, use the stub to trigger the underlying task, and (optionally) retrieve the result.

<Snippet src={snippets.python.stubs.stub_trigger.trigger_the_task} />

</Tabs.Tab>
<Tabs.Tab title="Go">

```go
Example Coming Soon
```

</Tabs.Tab>
</UniversalTabs>
