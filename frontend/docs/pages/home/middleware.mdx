import { snippets } from "@/lib/generated/snippets";
import { Snippet } from "@/components/code";
import { Callout, Card, Cards, Steps, Tabs } from "nextra/components";
import UniversalTabs from "@/components/UniversalTabs";

# Middleware & Dependency Injection

Middleware lets you run logic **before** and **after** every task on a client, without touching individual task definitions. Common uses include injecting request IDs, enriching inputs with shared data, and normalizing or augmenting outputs.

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
  <Tabs.Tab title="Python">
    Hatchet's Python SDK uses FastAPI-style dependency injection to run logic
    before tasks and inject the results as parameters. Dependencies are declared
    as functions and wired into tasks with `Depends`.
  </Tabs.Tab>
  <Tabs.Tab title="Typescript">
    Middleware hooks are registered on the client with `withMiddleware` and are
    fully type-safe — the extra fields returned by `pre` hooks are merged into
    every task's input type, and fields from `post` hooks are merged into every
    task's output type.
  </Tabs.Tab>
  <Tabs.Tab title="Go">
    <Callout type="info">
      Middleware support for the Go SDK is coming soon. Join our
      [Discord](https://hatchet.run/discord) to stay up to date.
    </Callout>
  </Tabs.Tab>
  <Tabs.Tab title="Ruby">
    In Ruby, this pattern uses callable objects (lambdas/procs) passed as `deps`
    when defining tasks. Dependencies are evaluated before each task run and
    made available via `ctx.deps`.
  </Tabs.Tab>
</UniversalTabs>

## Defining Middleware

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
  <Tabs.Tab title="Python">
    Define your dependency functions — they receive the workflow input and context, and their return values are injected into the task as parameters.

    <Snippet src={snippets.python.dependency_injection.worker.declare_dependencies} />

  </Tabs.Tab>
  <Tabs.Tab title="Typescript">
    Create a client and attach middleware with `pre` and `post` hooks. `pre` runs before the task and merges its return value into the task input. `post` runs after the task and merges its return value into the task output.

    <Snippet src={snippets.typescript.middleware.client.init_a_client_with_middleware} />

    ### Chaining Pre Hooks

    You can pass an array of functions to `pre` to run multiple hooks in sequence. Each hook's return value is merged into the input for subsequent hooks and the task itself.

    <Snippet src={snippets.typescript.middleware.client.chaining_middleware} />

  </Tabs.Tab>
  <Tabs.Tab title="Go">
    <Callout type="info">
      Middleware support for the Go SDK is coming soon. Join our [Discord](https://hatchet.run/discord) to stay up to date.
    </Callout>
  </Tabs.Tab>
  <Tabs.Tab title="Ruby">
    Define your dependencies as callable objects (lambdas). They receive the input, context, and optionally a hash of previously resolved dependencies for chaining.

    <Snippet src={snippets.ruby.dependency_injection.worker.declare_dependencies_ruby_uses_callable_objects_instead_of_pythons_depends} />

  </Tabs.Tab>
</UniversalTabs>

## Using Middleware in Tasks

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
  <Tabs.Tab title="Python">
    Inject dependencies into your tasks using `Depends` and type annotations. The dependency results are passed directly as function parameters.

    <Snippet src={snippets.python.dependency_injection.worker.inject_dependencies} />

    <Callout type="warning" emoji="⚠️">
      Your dependency functions must take two positional arguments: the workflow input and the `Context` (the same as any other task).
    </Callout>

  </Tabs.Tab>
  <Tabs.Tab title="Typescript">
    Tasks created from a middleware-enabled client automatically receive the merged input and output types. There is no extra configuration needed on the task itself.

    <Snippet src={snippets.typescript.middleware.workflow.all} />

    The task's `input` parameter includes fields from `TaskInput`, the client's `GlobalInputType`, and any values injected by `pre` middleware (e.g. `dependency`). The return type is similarly merged with `post` middleware output.

  </Tabs.Tab>
  <Tabs.Tab title="Go">
    <Callout type="info">
      Middleware support for the Go SDK is coming soon. Join our [Discord](https://hatchet.run/discord) to stay up to date.
    </Callout>
  </Tabs.Tab>
  <Tabs.Tab title="Ruby">
    Pass a `deps` hash when defining a task. The resolved dependency values are available inside the task block via `ctx.deps`.

    <Snippet src={snippets.ruby.dependency_injection.worker.inject_dependencies} />

  </Tabs.Tab>
</UniversalTabs>

## Running a Worker

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
  <Tabs.Tab title="Python">
    No special worker configuration is needed — dependencies are evaluated automatically each time a task runs.
  </Tabs.Tab>
  <Tabs.Tab title="Typescript">
    Workers are created from the same middleware-enabled client. No special setup is required — the middleware hooks are applied automatically when tasks execute.

    <Snippet src={snippets.typescript.middleware.worker.all} />

  </Tabs.Tab>
  <Tabs.Tab title="Go">
    <Callout type="info">
      Middleware support for the Go SDK is coming soon. Join our [Discord](https://hatchet.run/discord) to stay up to date.
    </Callout>
  </Tabs.Tab>
  <Tabs.Tab title="Ruby">
    No special worker configuration is needed — dependencies are resolved automatically before each task execution.
  </Tabs.Tab>
</UniversalTabs>
