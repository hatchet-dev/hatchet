import { Callout, Cards, Steps } from "nextra/components";
import CycleDiagram from "@/components/CycleDiagramWrapper";
import PatternComparison from "@/components/PatternComparison";

# Cycles

A **cycle** is a workflow pattern where a task re-runs itself repeatedly until a condition is met. Since Hatchet workflows are DAGs (no circular dependencies), cycles are implemented by having a task spawn a new child run of itself, effectively creating an iterative loop through child task spawning.

<CycleDiagram />

## How It Works

<Steps>

### Task performs work

The task executes its logic: making an API call, running an LLM inference, checking a status, or processing a batch of data.

### Evaluate a termination condition

After each execution, the task checks whether the loop should continue. This could be a result quality threshold, a maximum iteration count, or an external signal.

### Re-spawn or complete

If the condition is not met, the task spawns a new child run of itself with updated input. If the condition is met, the task returns its final result.

</Steps>

<Callout type="info">
  Cycles use [Procedural Child
  Spawning](/concepts/durable-workflows/directed-acyclic-graphs/child-spawning)
  under the hood; each iteration is a new child task run. This gives you full
  observability into every iteration in the Hatchet dashboard.
</Callout>

## When to Use Cycles

| Pattern                  | Use Cycles When...                                                              |
| ------------------------ | ------------------------------------------------------------------------------- |
| **Polling**              | You need to check an external system until a resource is ready                  |
| **Iterative Refinement** | An AI agent refines its output over multiple passes until quality is sufficient |
| **Pagination**           | You process paginated API results one page at a time                            |
| **Retry with Backoff**   | Built-in retries aren't sufficient and you need custom retry logic with state   |
| **Agent Loops**          | An AI agent reasons, acts, observes, and loops until a goal is achieved         |

<Callout type="warning">
  Always include a termination condition (max iterations, timeout, or quality
  threshold) to prevent infinite loops. Each iteration consumes a worker slot,
  so unbounded cycles can exhaust your worker capacity.
</Callout>

## In Workflows vs Durable Workflows (WIP)

## Use Cases

<Cards>
  <Cards.Card
    title="AI Agent Loops"
    href="/concepts/durable-workflows/directed-acyclic-graphs/child-spawning"
  >
    Build agents that reason, take action, observe results, and loop until they
    achieve their goal.
  </Cards.Card>
  <Cards.Card
    title="Polling External APIs"
    href="/concepts/durable-workflows/directed-acyclic-graphs/child-spawning"
  >
    Check an external service repeatedly until a resource is ready or a status
    changes.
  </Cards.Card>
  <Cards.Card
    title="Iterative Data Processing"
    href="/concepts/durable-workflows/directed-acyclic-graphs/child-spawning"
  >
    Process data in successive passes, refining results until convergence.
  </Cards.Card>
  <Cards.Card title="Custom Retry Logic" href="/concepts/retry-policies">
    Implement application-specific retry strategies with state carried between
    attempts.
  </Cards.Card>
</Cards>

## Next Steps

- [Procedural Child Spawning](/concepts/durable-workflows/directed-acyclic-graphs/child-spawning): the mechanism that powers cycle iteration
- [Retry Policies](/concepts/retry-policies): built-in retry support for simpler retry scenarios
- [Branching](/patterns/branching): combine cycles with conditional logic
- [Fanout](/patterns/fanout): spawn parallel tasks instead of sequential iterations
