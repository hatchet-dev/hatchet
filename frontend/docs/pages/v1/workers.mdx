import { Callout, Card, Cards, Steps, Tabs } from "nextra/components";
import UniversalTabs from "@/components/UniversalTabs";
import { GithubSnippet, getSnippets } from "@/components/code";

export const SimpleTs = {
  path: "src/v1/examples/simple/worker.ts",
};

export const getStaticProps = ({}) => getSnippets([SimpleTs]);

# Workers

In Hatchet, a worker is a process that executes workflow tasks.

## Declaring a Worker

Now that we have a [hatchet client](./introduction.mdx) and a [workflow declaration](./basic-workflows.mdx) we can declare a worker that can execute the workflow tasks.

Declare a worker by calling the `worker` method on the hatchet client. The `worker` method takes a name and an optional configuration object.

<UniversalTabs items={["Python", "Typescript", "Go"]}>
  <Tabs.Tab title="Python">
    ```python
    def main() -> None:
      worker = hatchet.worker("test-worker", slots=1, workflows=[simple])
      worker.start()

    if __name__ == "__main__":
        main()
    ```

  </Tabs.Tab>
  <Tabs.Tab title="Typescript">
    ### Register the Worker
    <GithubSnippet src={SimpleTs} target="Declaring a Worker" />

    ### Add an Entrypoint Script

    Add a script to your `package.json` to start the worker (changing the file path to the location of your worker file):

    ```json
    "scripts": {
      "start:worker": "ts-node src/v1/examples/simple/worker.ts"
    }
    ```

    ### Run the Worker

    Start the worker by running the script you just added to your `package.json`:
    <UniversalTabs items={["npm", "pnpm", "yarn"]} optionKey="packageManager">
      <Tabs.Tab title="npm">
        ```bash
        npm run start:worker
        ```
      </Tabs.Tab>
      <Tabs.Tab title="pnpm">
        ```bash
        pnpm run start:worker
        ```
      </Tabs.Tab>
      <Tabs.Tab title="yarn">
        ```bash
        yarn start:worker
        ```
      </Tabs.Tab>
    </UniversalTabs>

  </Tabs.Tab>
  <Tabs.Tab title="Go">
    ```go
  	w, err := worker.NewWorker(
      worker.WithClient(
        c,
      ),
    )

    cleanup, err := w.Start()
    ```

  </Tabs.Tab>
</UniversalTabs>

## Understanding Slots

Slots are the number of concurrent _task_ runs that a worker can execute. For instance, if you set `slots=5` on your worker, then your worker will be able to run five tasks concurrently before new tasks start needing to wait in the queue before being picked up.

As a simple example, if we have a worker with `slots` set to `1` and we have a single task declared that sleeps for 1 second, then if we submit more than one task per second, the tasks will begin to queue up, as the worker can only handle one task at a time. Increasing the number of `slots` on your worker will allow you to handle more concurrent work (and thus more throughput, in many cases), without needing to run more workers.

An important caveat is that slot-level concurrency is only helpful up to the point where the worker is not bottlenecked by another resource, such as CPU, memory, or network bandwidth. If your worker is bottlenecked by one of these resources, increasing the number of slots will not improve throughput.
