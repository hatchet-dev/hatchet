import { Callout, Card, Cards, Steps, Tabs } from "nextra/components";
import UniversalTabs from "@/components/UniversalTabs";
import { GithubSnippet, getSnippets } from "@/components/code";

export const SimpleTs = {
  path: "src/v1/examples/simple/run.ts",
};

export const getStaticProps = ({}) => getSnippets([SimpleTs]);

# Running a Workflow with Results

> This example assumes we have a [workflow](./basic-workflows.mdx) registered on a running [worker](./workers.mdx).

Often times you may want to run a workflow and wait for it to complete. This is useful for workflows that take a long time to complete or are critical to the immediate operation of your application.

<UniversalTabs items={["Python", "Typescript", "Go"]}>
  <Tabs.Tab title="Python">

You can use your `Workflow` object to run a workflow and wait for it to complete by calling the `run` method. This method will block until the workflow completes and return the result.

```python
from src.workflows import my_workflow, MyWorkflowInputModel

result = my_workflow.run(MyWorkflowInputModel(foo="bar"))
```

You can also `await` the result of `aio_run`:

```python
result = await my_workflow.aio_run(input=MyWorkflowInputModel(foo="bar"))
```

Note that the type of `input` here is a Pydantic model that matches the input schema of your workflow.

  </Tabs.Tab>
  <Tabs.Tab title="Typescript">
    <GithubSnippet src={SimpleTs} target="Running a Workflow with Results" />
  </Tabs.Tab>
  <Tabs.Tab title="Go">TODO V1 DOCS</Tabs.Tab>
</UniversalTabs>

{/* TODO V1 DOCS: Fanout, Loops, and Conditional Logic */}
