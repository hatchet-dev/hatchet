import { snippets } from "@/lib/generated/snippets";
import { Snippet } from "@/components/code";
import { Callout, Card, Cards, Steps, Tabs } from "nextra/components";
import UniversalTabs from "@/components/UniversalTabs";

# Workers

Workers are the backbone of Hatchet, responsible for executing the individual tasks. They operate across different nodes in your infrastructure, allowing for distributed and scalable task execution.

## How Workers Operate

In Hatchet, workers are long-running processes that wait for instructions from the Hatchet engine to execute specific steps. They communicate with the Hatchet engine to receive tasks, execute them, and report back the results.

## Declaring a Worker

Now that we have a [task declared](./your-first-task.mdx) we can create a worker that can execute the task.

Declare a worker by calling the `worker` method on the Hatchet client. The `worker` method takes a name and an optional configuration object.

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
  <Tabs.Tab title="Python">
  <Snippet src={snippets.python.dag.worker.declare_a_worker}/>

    <Callout type="warning">
      If you are using Windows, attempting to run a worker will result in an error:

      ```
      AttributeError: module 'signal' has no attribute 'SIGQUIT'
      ```

      However you can use the [Windows Subsystem for Linux (WSL)](https://learn.microsoft.com/en-us/windows/wsl/install) to run your workers. After
      you install your Python environment (e.g. via `uv` or `poetry`) in WSL, you can then
      run your workers inside that environment.  You can still run client code (e.g. to
      trigger task runs or query the API) in your native Windows environment, but your
      workers have to be run in WSL.

      Another option is to run workers in Docker containers.
    </Callout>

  </Tabs.Tab>
  <Tabs.Tab title="Typescript">
    ### Register the Worker

    <Snippet src={snippets.typescript.simple.worker.declaring_a_worker} />

    ### Add an Entrypoint Script

    Add a script to your `package.json` to start the worker (changing the file path to the location of your worker file):

    ```json
    "scripts": {
      "start:worker": "ts-node src/v1/examples/simple/worker.ts"
    }
    ```

    ### Run the Worker

    Start the worker by running the script you just added to your `package.json`:
    <UniversalTabs items={["npm", "pnpm", "yarn"]} optionKey="packageManager">
      <Tabs.Tab title="npm">
        ```bash
        npm run start:worker
        ```
      </Tabs.Tab>
      <Tabs.Tab title="pnpm">
        ```bash
        pnpm run start:worker
        ```
      </Tabs.Tab>
      <Tabs.Tab title="yarn">
        ```bash
        yarn start:worker
        ```
      </Tabs.Tab>
    </UniversalTabs>

  </Tabs.Tab>
  <Tabs.Tab title="Go">
    <Snippet src={snippets.go.simple.main.starting_a_worker} />

    Then start the worker by running:
    ```bash
    go run main.go
    ```

    <Callout type="info">
      Note there are both `worker.Start` and `worker.StartBlocking` methods. The `StartBlocking` method will block the main thread until the worker is stopped, while the `Start` method will return immediately and you'll need to call `worker.Stop` to stop the worker.
    </Callout>

  </Tabs.Tab>
  <Tabs.Tab title="Ruby">
    ### Add the Hatchet SDK to your Gemfile

    ```ruby
    gem "hatchet-sdk"
    ```

    Then install with:

    ```bash
    bundle install
    ```

    ### Register the Worker

    <Snippet src={snippets.ruby.dag.worker.declare_a_worker} />

    ### Run the Worker

    Start the worker by running:

    ```bash
    bundle exec ruby worker.rb
    ```

  </Tabs.Tab>
</UniversalTabs>

And that's it! Once you run your script to start the worker, you'll see some logs like this, which tell you that your worker is running.

<Callout type="info">
  For self-hosted users, you may need to set other gRPC configuration options to
  ensure your worker can connect to the Hatchet engine. See the
  [Self-Hosting](../self-hosting/worker-configuration-options.mdx) docs for more
  information.
</Callout>

```
[DEBUG] ðŸª“ -- 2025-03-24 15:11:32,755 - creating new event loop
[INFO]  ðŸª“ -- 2025-03-24 15:11:32,755 - ------------------------------------------
[INFO]  ðŸª“ -- 2025-03-24 15:11:32,755 - STARTING HATCHET...
[DEBUG] ðŸª“ -- 2025-03-24 15:11:32,755 - worker runtime starting on PID: 26406
[DEBUG] ðŸª“ -- 2025-03-24 15:11:32,758 - action listener starting on PID: 26434
[INFO]  ðŸª“ -- 2025-03-24 15:11:32,760 - starting runner...
[DEBUG] ðŸª“ -- 2025-03-24 15:11:32,761 - starting action listener health check...
[DEBUG] ðŸª“ -- 2025-03-24 15:11:32,764 - 'test-worker' waiting for ['simpletask:step1']
[DEBUG] ðŸª“ -- 2025-03-24 15:11:33,413 - starting action listener: test-worker
[DEBUG] ðŸª“ -- 2025-03-24 15:11:33,542 - acquired action listener: efc4aaf2-be4a-4964-a578-db6465f9297e
[DEBUG] ðŸª“ -- 2025-03-24 15:11:33,542 - sending heartbeat
[DEBUG] ðŸª“ -- 2025-03-24 15:11:37,658 - sending heartbeat
```

<Callout type="info">
  Note that many of these logs are `debug` logs, which only are shown if the
  `debug` option on the Hatchet client is set to `True`
</Callout>

## Next steps

Now that you have a worker running, you can [run your first task](/essentials/running-your-task). When you're ready to go deeper:

- [Understanding Slots](/concepts/understanding-slots) â€” control how many tasks a worker runs concurrently.
- [Running with Docker](/concepts/docker) â€” containerize your workers for deployment.
- [Worker Health Checks](/concepts/worker-healthchecks) â€” expose health and metrics endpoints.
- [Preparing for Production](/essentials/production) â€” monitoring, error handling, scaling, and operational best practices.
