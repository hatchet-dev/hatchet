import { snippets } from "@/lib/generated/snippets";
import { Snippet } from "@/components/code";
import { Callout, Card, Cards, Steps, Tabs } from "nextra/components";
import UniversalTabs from "@/components/UniversalTabs";

# Workers

Workers are long-running processes in your infrastructure that execute tasks. Each worker maintains a persistent gRPC connection to the Hatchet engine, receives task assignments, runs your code, and reports results back. You can run workers locally during development, in containers, or on VMs â€” and scale them independently from the Hatchet services.

You register tasks on a worker so Hatchet knows where to send work. When a task is triggered, Hatchet assigns it to a worker that has a free [slot](/concepts/understanding-slots). Slots prevent overassignment â€” each worker only accepts as many tasks as it can handle concurrently.

## Declaring a Worker

With a [task declared](./your-first-task.mdx), create a worker to execute it. Call the `worker` method on the Hatchet client with a name and the tasks it should handle.

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
  <Tabs.Tab title="Python">
  <Snippet src={snippets.python.dag.worker.declare_a_worker}/>

    <Callout type="warning">
      **Windows users:** Workers require [WSL](https://learn.microsoft.com/en-us/windows/wsl/install) or [Docker](/concepts/docker). Client code (triggering tasks, querying the API) works natively on Windows, but workers must run in a Linux environment.
    </Callout>

  </Tabs.Tab>
  <Tabs.Tab title="Typescript">
    <Snippet src={snippets.typescript.simple.worker.declaring_a_worker} />
  </Tabs.Tab>
  <Tabs.Tab title="Go">
    <Snippet src={snippets.go.simple.main.starting_a_worker} />

    <Callout type="info">
      There are both `worker.Start` and `worker.StartBlocking` methods. `StartBlocking` blocks the main thread until the worker is stopped, while `Start` returns immediately and requires a later call to `worker.Stop`.
    </Callout>

  </Tabs.Tab>
  <Tabs.Tab title="Ruby">
    <Snippet src={snippets.ruby.dag.worker.declare_a_worker} />
  </Tabs.Tab>
</UniversalTabs>

## Starting a Worker

<Tabs items={["CLI (recommended)", "Script"]}>
  <Tabs.Tab>

The fastest way to run a worker during development is with the Hatchet CLI. This handles authentication and hot-reloads your worker when code changes:

```bash
hatchet worker dev
```

  </Tabs.Tab>
  <Tabs.Tab>

You can also run the worker script directly. This requires a `HATCHET_CLIENT_TOKEN` to be set â€” see [Advanced Setup](/essentials/advanced) for how to provision one.

<UniversalTabs items={["Python", "Typescript", "Go", "Ruby"]}>
  <Tabs.Tab title="Python">
```bash
python worker.py
```
  </Tabs.Tab>
  <Tabs.Tab title="Typescript">

Add a script to your `package.json`:

```json
"scripts": {
  "start:worker": "ts-node src/worker.ts"
}
```

Then run it:

```bash
npm run start:worker
```

  </Tabs.Tab>
  <Tabs.Tab title="Go">
```bash
go run main.go
```
  </Tabs.Tab>
  <Tabs.Tab title="Ruby">
```bash
bundle exec ruby worker.rb
```
  </Tabs.Tab>
</UniversalTabs>

  </Tabs.Tab>
</Tabs>

Once the worker starts, you'll see logs confirming it's connected:

```
[INFO]  ðŸª“ -- STARTING HATCHET...
[DEBUG] ðŸª“ -- 'test-worker' waiting for ['simpletask:step1']
[DEBUG] ðŸª“ -- acquired action listener: efc4aaf2-...
[DEBUG] ðŸª“ -- sending heartbeat
```

<Callout type="info">
  For self-hosted users, you may need to set additional gRPC configuration options.
  See the [Self-Hosting](../self-hosting/worker-configuration-options.mdx) docs for details.
</Callout>

## Next steps

Now that you have a worker running, you can [run your first task](/essentials/running-your-task).

Want to dive deeper? The [Workers concepts page](/concepts/workers) covers the worker lifecycle, slots, scaling strategies, and task assignment in detail.
