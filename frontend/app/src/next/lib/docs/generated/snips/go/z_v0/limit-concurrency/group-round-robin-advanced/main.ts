import { Snippet } from '@/next/lib/docs/generated/snips/types';

const snippet: Snippet = {
  'language': 'go',
  'content': 'package main\n\nimport (\n\t\'context\'\n\t\'fmt\'\n\t\'sync\'\n\t\'time\'\n\n\t\'github.com/joho/godotenv\'\n\n\t\'github.com/hatchet-dev/hatchet/pkg/client\'\n\t\'github.com/hatchet-dev/hatchet/pkg/client/types\'\n\t\'github.com/hatchet-dev/hatchet/pkg/cmdutils\'\n\t\'github.com/hatchet-dev/hatchet/pkg/worker\'\n)\n\ntype concurrencyLimitEvent struct {\n\tConcurrencyKey string `json:\'concurrency_key\'`\n\tUserId         int    `json:\'user_id\'`\n}\n\ntype stepOneOutput struct {\n\tMessage                 string `json:\'message\'`\n\tConcurrencyWhenFinished int    `json:\'concurrency_when_finished\'`\n}\n\nfunc main() {\n\terr := godotenv.Load()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tctx, cancel := cmdutils.NewInterruptContext()\n\tdefer cancel()\n\n\tif err := run(ctx); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc getConcurrencyKey(ctx worker.HatchetContext) (string, error) {\n\treturn \'concurrency\', nil\n}\n\nvar done = make(chan struct{})\nvar errChan = make(chan error)\n\nvar workflowCount int\nvar countMux sync.Mutex\n\nfunc run(ctx context.Context) error {\n\tc, err := client.New()\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\'error creating client: %w\', err)\n\t}\n\n\tw, err := worker.NewWorker(\n\t\tworker.WithClient(\n\t\t\tc,\n\t\t),\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\'error creating worker: %w\', err)\n\t}\n\n\t// runningCount := 0\n\n\tcountMux := sync.Mutex{}\n\n\tvar countMap = make(map[string]int)\n\tmaxConcurrent := 2\n\n\terr = w.RegisterWorkflow(\n\n\t\t&worker.WorkflowJob{\n\t\t\tName:        \'concurrency-limit-round-robin-existing-workflows\',\n\t\t\tDescription: \'This limits concurrency to maxConcurrent runs at a time.\',\n\t\t\tOn:          worker.Events(\'test:concurrency-limit-round-robin-existing-workflows\'),\n\t\t\tConcurrency: worker.Expression(\'input.concurrency_key\').MaxRuns(int32(maxConcurrent)).LimitStrategy(types.GroupRoundRobin),\n\n\t\t\tSteps: []*worker.WorkflowStep{\n\t\t\t\tworker.Fn(func(ctx worker.HatchetContext) (result *stepOneOutput, err error) {\n\t\t\t\t\tinput := &concurrencyLimitEvent{}\n\n\t\t\t\t\terr = ctx.WorkflowInput(input)\n\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, fmt.Errorf(\'error getting input: %w\', err)\n\t\t\t\t\t}\n\t\t\t\t\tconcurrencyKey := input.ConcurrencyKey\n\t\t\t\t\tcountMux.Lock()\n\n\t\t\t\t\tif countMap[concurrencyKey]+1 > maxConcurrent {\n\t\t\t\t\t\tcountMux.Unlock()\n\t\t\t\t\t\te := fmt.Errorf(\'concurrency limit exceeded for %d we have %d workers running\', input.UserId, countMap[concurrencyKey])\n\t\t\t\t\t\terrChan <- e\n\t\t\t\t\t\treturn nil, e\n\t\t\t\t\t}\n\t\t\t\t\tcountMap[concurrencyKey]++\n\n\t\t\t\t\tcountMux.Unlock()\n\n\t\t\t\t\tfmt.Println(\'received event\', input.UserId)\n\n\t\t\t\t\ttime.Sleep(10 * time.Second)\n\n\t\t\t\t\tfmt.Println(\'processed event\', input.UserId)\n\n\t\t\t\t\tcountMux.Lock()\n\t\t\t\t\tcountMap[concurrencyKey]--\n\t\t\t\t\tcountMux.Unlock()\n\n\t\t\t\t\tdone <- struct{}{}\n\n\t\t\t\t\treturn &stepOneOutput{}, nil\n\t\t\t\t},\n\t\t\t\t).SetName(\'step-one\'),\n\t\t\t},\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\'error registering workflow: %w\', err)\n\t}\n\n\tgo func() {\n\t\tvar workflowRuns []*client.WorkflowRun\n\n\t\tfor i := 0; i < 1; i++ {\n\t\t\tworkflowCount++\n\t\t\tevent := concurrencyLimitEvent{\n\t\t\t\tConcurrencyKey: \'key\',\n\t\t\t\tUserId:         i,\n\t\t\t}\n\t\t\tworkflowRuns = append(workflowRuns, &client.WorkflowRun{\n\t\t\t\tName:  \'concurrency-limit-round-robin-existing-workflows\',\n\t\t\t\tInput: event,\n\t\t\t})\n\n\t\t}\n\n\t\t// create a second one with a different key\n\n\t\t// so the bug we are testing here is that total concurrency for any one group should be 2\n\t\t// but if we have more than one group we end up with 4 running when only 2 + 1 are eligible to run\n\n\t\tfor i := 0; i < 3; i++ {\n\t\t\tworkflowCount++\n\n\t\t\tevent := concurrencyLimitEvent{\n\t\t\t\tConcurrencyKey: \'secondKey\',\n\t\t\t\tUserId:         i,\n\t\t\t}\n\t\t\tworkflowRuns = append(workflowRuns, &client.WorkflowRun{\n\t\t\t\tName:  \'concurrency-limit-round-robin-existing-workflows\',\n\t\t\t\tInput: event,\n\t\t\t})\n\n\t\t}\n\n\t\t_, err := c.Admin().BulkRunWorkflow(workflowRuns)\n\t\tif err != nil {\n\t\t\tfmt.Println(\'error running workflow\', err)\n\t\t}\n\n\t\tfmt.Println(\'ran workflows\')\n\n\t}()\n\n\ttime.Sleep(2 * time.Second)\n\tcleanup, err := w.Start()\n\tif err != nil {\n\t\treturn fmt.Errorf(\'error starting worker: %w\', err)\n\t}\n\tdefer cleanup()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil\n\t\tcase <-time.After(20 * time.Second):\n\t\t\treturn fmt.Errorf(\'timeout\')\n\t\tcase err := <-errChan:\n\t\t\treturn err\n\t\tcase <-done:\n\t\t\tcountMux.Lock()\n\t\t\tworkflowCount--\n\t\t\tcountMux.Unlock()\n\t\t\tif workflowCount == 0 {\n\t\t\t\ttime.Sleep(1 * time.Second)\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t}\n\t}\n}\n',
  'source': 'out/go/z_v0/limit-concurrency/group-round-robin-advanced/main.go',
  'blocks': {},
  'highlights': {}
};  // Then replace double quotes with single quotes

export default snippet;
