import { Snippet } from '@/next/lib/docs/generated/snips/types';

const snippet: Snippet = {
  language: 'go',
  content:
    "//go:build load\n\npackage rampup\n\nimport (\n\t'context'\n\t'log'\n\t'os'\n\t'sync'\n\t'testing'\n\t'time'\n\n\t'github.com/hatchet-dev/hatchet/internal/testutils'\n\t'github.com/hatchet-dev/hatchet/pkg/config/shared'\n\t'github.com/hatchet-dev/hatchet/pkg/logger'\n)\n\nfunc TestRampUp(t *testing.T) {\n\ttestutils.Prepare(t)\n\n\ttype args struct {\n\t\tduration time.Duration\n\t\tincrease time.Duration\n\t\tamount   int\n\t\tdelay    time.Duration\n\t\twait     time.Duration\n\t\t// includeDroppedEvents is whether to fail on events that were dropped due to being scheduled too late\n\t\tincludeDroppedEvents bool\n\t\t// maxAcceptableDuration is the maximum acceptable duration for a single event to be scheduled (from start to finish)\n\t\tmaxAcceptableDuration time.Duration\n\t\t// maxAcceptableSchedule is the maximum acceptable time for an event to be purely scheduled, regardless of whether it will run or not\n\t\tmaxAcceptableSchedule time.Duration\n\t\tconcurrency           int\n\t\tstartEventsPerSecond  int\n\t}\n\n\tl = logger.NewStdErr(\n\t\t&shared.LoggerConfigFile{\n\t\t\tLevel:  'warn',\n\t\t\tFormat: 'console',\n\t\t},\n\t\t'loadtest',\n\t)\n\n\t// get ramp up duration from env\n\tmaxAcceptableDurationSeconds := 2 * time.Second\n\n\tif os.Getenv('RAMP_UP_DURATION_TIMEOUT') != '' {\n\t\tvar parseErr error\n\t\tmaxAcceptableDurationSeconds, parseErr = time.ParseDuration(os.Getenv('RAMP_UP_DURATION_TIMEOUT'))\n\n\t\tif parseErr != nil {\n\t\t\tt.Fatalf('could not parse RAMP_UP_DURATION_TIMEOUT %s: %s', os.Getenv('RAMP_UP_DURATION_TIMEOUT'), parseErr)\n\t\t}\n\t}\n\n\tlog.Printf('TestRampUp with maxAcceptableDurationSeconds: %s', maxAcceptableDurationSeconds.String())\n\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{{\n\t\tname: 'normal test',\n\t\targs: args{\n\t\t\tstartEventsPerSecond:  1,\n\t\t\tduration:              300 * time.Second,\n\t\t\tincrease:              10 * time.Second,\n\t\t\tamount:                1,\n\t\t\tdelay:                 0 * time.Second,\n\t\t\twait:                  30 * time.Second,\n\t\t\tincludeDroppedEvents:  true,\n\t\t\tmaxAcceptableDuration: maxAcceptableDurationSeconds,\n\t\t\tmaxAcceptableSchedule: 2 * time.Second,\n\t\t\tconcurrency:           0,\n\t\t},\n\t}}\n\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Minute)\n\n\tsetup := sync.WaitGroup{}\n\n\tgo func() {\n\t\tsetup.Add(1)\n\t\tlog.Printf('setup start')\n\t\ttestutils.SetupEngine(ctx, t)\n\t\tsetup.Done()\n\t\tlog.Printf('setup end')\n\t}()\n\n\t// TODO instead of waiting, figure out when the engine setup is complete\n\ttime.Sleep(15 * time.Second)\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\n\t\t\tif err := do(tt.args.duration, tt.args.startEventsPerSecond, tt.args.amount, tt.args.increase, tt.args.delay, tt.args.wait, tt.args.maxAcceptableDuration, tt.args.maxAcceptableSchedule, tt.args.includeDroppedEvents, tt.args.concurrency); (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf('do() error = %v, wantErr %v', err, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n\n\tcancel()\n\n\tlog.Printf('test complete')\n\tsetup.Wait()\n\tlog.Printf('cleanup complete')\n}\n",
  source: 'out/go/z_v0/loadtest/rampup/ramp_up_e2e_test.go',
  blocks: {},
  highlights: {},
}; // Then replace double quotes with single quotes

export default snippet;
