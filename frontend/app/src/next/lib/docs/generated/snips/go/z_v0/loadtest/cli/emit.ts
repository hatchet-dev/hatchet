import { Snippet } from '@/next/lib/docs/generated/snips/types';

const snippet: Snippet = {
  language: 'go',
  content:
    "package main\n\nimport (\n\t'context'\n\t'fmt'\n\t'strconv'\n\t'strings'\n\t'sync'\n\t'sync/atomic'\n\t'time'\n\n\t'github.com/hatchet-dev/hatchet/pkg/client'\n)\n\ntype Event struct {\n\tID        int64     `json:'id'`\n\tCreatedAt time.Time `json:'created_at'`\n\tPayload   string    `json:'payload'`\n}\n\nfunc parseSize(s string) int {\n\ts = strings.ToLower(strings.TrimSpace(s))\n\tvar multiplier int\n\tif strings.HasSuffix(s, 'kb') {\n\t\tmultiplier = 1024\n\t\ts = strings.TrimSuffix(s, 'kb')\n\t} else if strings.HasSuffix(s, 'mb') {\n\t\tmultiplier = 1024 * 1024\n\t\ts = strings.TrimSuffix(s, 'mb')\n\t} else {\n\t\tmultiplier = 1\n\t}\n\tnum, err := strconv.Atoi(strings.TrimSpace(s))\n\tif err != nil {\n\t\tpanic(fmt.Errorf('invalid size argument: %w', err))\n\t}\n\treturn num * multiplier\n}\n\nfunc emit(ctx context.Context, amountPerSecond int, duration time.Duration, scheduled chan<- time.Duration, payloadArg string) int64 {\n\tc, err := client.New()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar id int64\n\n\t// Precompute payload data.\n\tpayloadSize := parseSize(payloadArg)\n\tpayloadData := strings.Repeat('a', payloadSize)\n\n\t// Create a buffered channel for events.\n\tjobCh := make(chan Event, amountPerSecond*2)\n\n\t// Worker pool to handle event pushes.\n\tnumWorkers := 10\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < numWorkers; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor ev := range jobCh {\n\t\t\t\tl.Info().Msgf('pushing event %d', ev.ID)\n\t\t\t\terr := c.Event().Push(context.Background(), 'load-test:event', ev, client.WithEventMetadata(map[string]string{\n\t\t\t\t\t'event_id': fmt.Sprintf('%d', ev.ID),\n\t\t\t\t}))\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(fmt.Errorf('error pushing event: %w', err))\n\t\t\t\t}\n\t\t\t\ttook := time.Since(ev.CreatedAt)\n\t\t\t\tl.Info().Msgf('pushed event %d took %s', ev.ID, took)\n\t\t\t\tscheduled <- took\n\t\t\t}\n\t\t}()\n\t}\n\n\tticker := time.NewTicker(time.Second / time.Duration(amountPerSecond))\n\tdefer ticker.Stop()\n\ttimer := time.NewTimer(duration)\n\tdefer timer.Stop()\n\nloop:\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tl.Info().Msg('done emitting events due to interruption')\n\t\t\tbreak loop\n\t\tcase <-timer.C:\n\t\t\tl.Info().Msg('done emitting events due to timer')\n\t\t\tbreak loop\n\t\tcase <-ticker.C:\n\t\t\tnewID := atomic.AddInt64(&id, 1)\n\t\t\tev := Event{\n\t\t\t\tID:        newID,\n\t\t\t\tCreatedAt: time.Now(),\n\t\t\t\tPayload:   payloadData,\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase jobCh <- ev:\n\t\t\tcase <-ctx.Done():\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t}\n\t}\n\n\tclose(jobCh)\n\twg.Wait()\n\treturn id\n}\n",
  source: 'out/go/z_v0/loadtest/cli/emit.go',
  blocks: {},
  highlights: {},
}; // Then replace double quotes with single quotes

export default snippet;
