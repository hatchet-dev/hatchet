import { Snippet } from '@/next/lib/docs/generated/snips/types';

const snippet: Snippet = {
  'language': 'go',
  'content': 'package main\n\nimport (\n\t\'context\'\n\t\'fmt\'\n\t\'strconv\'\n\t\'strings\'\n\t\'sync\'\n\t\'sync/atomic\'\n\t\'time\'\n\n\t\'github.com/hatchet-dev/hatchet/pkg/client\'\n)\n\ntype Event struct {\n\tID        int64     `json:\'id\'`\n\tCreatedAt time.Time `json:\'created_at\'`\n\tPayload   string    `json:\'payload\'`\n}\n\nfunc parseSize(s string) int {\n\ts = strings.ToLower(strings.TrimSpace(s))\n\tvar multiplier int\n\tif strings.HasSuffix(s, \'kb\') {\n\t\tmultiplier = 1024\n\t\ts = strings.TrimSuffix(s, \'kb\')\n\t} else if strings.HasSuffix(s, \'mb\') {\n\t\tmultiplier = 1024 * 1024\n\t\ts = strings.TrimSuffix(s, \'mb\')\n\t} else {\n\t\tmultiplier = 1\n\t}\n\tnum, err := strconv.Atoi(strings.TrimSpace(s))\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\'invalid size argument: %w\', err))\n\t}\n\treturn num * multiplier\n}\n\nfunc emit(ctx context.Context, amountPerSecond int, duration time.Duration, scheduled chan<- time.Duration, payloadArg string) int64 {\n\tc, err := client.New()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar id int64\n\n\t// Precompute payload data.\n\tpayloadSize := parseSize(payloadArg)\n\tpayloadData := strings.Repeat(\'a\', payloadSize)\n\n\t// Create a buffered channel for events.\n\tjobCh := make(chan Event, amountPerSecond*2)\n\n\t// Worker pool to handle event pushes.\n\tnumWorkers := 10\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < numWorkers; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor ev := range jobCh {\n\t\t\t\tl.Info().Msgf(\'pushing event %d\', ev.ID)\n\t\t\t\terr := c.Event().Push(context.Background(), \'load-test:event\', ev, client.WithEventMetadata(map[string]string{\n\t\t\t\t\t\'event_id\': fmt.Sprintf(\'%d\', ev.ID),\n\t\t\t\t}))\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(fmt.Errorf(\'error pushing event: %w\', err))\n\t\t\t\t}\n\t\t\t\ttook := time.Since(ev.CreatedAt)\n\t\t\t\tl.Info().Msgf(\'pushed event %d took %s\', ev.ID, took)\n\t\t\t\tscheduled <- took\n\t\t\t}\n\t\t}()\n\t}\n\n\tticker := time.NewTicker(time.Second / time.Duration(amountPerSecond))\n\tdefer ticker.Stop()\n\ttimer := time.NewTimer(duration)\n\tdefer timer.Stop()\n\nloop:\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tl.Info().Msg(\'done emitting events due to interruption\')\n\t\t\tbreak loop\n\t\tcase <-timer.C:\n\t\t\tl.Info().Msg(\'done emitting events due to timer\')\n\t\t\tbreak loop\n\t\tcase <-ticker.C:\n\t\t\tnewID := atomic.AddInt64(&id, 1)\n\t\t\tev := Event{\n\t\t\t\tID:        newID,\n\t\t\t\tCreatedAt: time.Now(),\n\t\t\t\tPayload:   payloadData,\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase jobCh <- ev:\n\t\t\tcase <-ctx.Done():\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t}\n\t}\n\n\tclose(jobCh)\n\twg.Wait()\n\treturn id\n}\n',
  'source': 'out/go/z_v0/loadtest/cli/emit.go',
  'blocks': {},
  'highlights': {}
};  // Then replace double quotes with single quotes

export default snippet;
