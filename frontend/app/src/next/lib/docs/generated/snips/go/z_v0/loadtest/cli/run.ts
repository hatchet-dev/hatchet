import { Snippet } from '@/next/lib/docs/generated/snips/types';

const snippet: Snippet = {
  'language': 'go',
  'content': 'package main\n\nimport (\n\t\'context\'\n\t\'fmt\'\n\t\'math/rand/v2\'\n\t\'sync\'\n\t\'time\'\n\n\t\'github.com/hatchet-dev/hatchet/pkg/client\'\n\t\'github.com/hatchet-dev/hatchet/pkg/worker\'\n)\n\ntype stepOneOutput struct {\n\tMessage string `json:\'message\'`\n}\n\nfunc run(ctx context.Context, delay time.Duration, executions chan<- time.Duration, concurrency, slots int, failureRate float32, eventFanout int) (int64, int64) {\n\tc, err := client.New(\n\t\tclient.WithLogLevel(\'warn\'),\n\t)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tw, err := worker.NewWorker(\n\t\tworker.WithClient(\n\t\t\tc,\n\t\t),\n\t\tworker.WithLogLevel(\'warn\'),\n\t\tworker.WithMaxRuns(slots),\n\t)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmx := sync.Mutex{}\n\tvar count int64\n\tvar uniques int64\n\tvar executed []int64\n\n\tvar concurrencyOpts *worker.WorkflowConcurrency\n\tif concurrency > 0 {\n\t\tconcurrencyOpts = worker.Expression(\'\'global\'\').MaxRuns(int32(concurrency))\n\t}\n\n\tstep := func(ctx worker.HatchetContext) (result *stepOneOutput, err error) {\n\t\tvar input Event\n\t\terr = ctx.WorkflowInput(&input)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttook := time.Since(input.CreatedAt)\n\t\tl.Info().Msgf(\'executing %d took %s\', input.ID, took)\n\n\t\tmx.Lock()\n\t\texecutions <- took\n\t\t// detect duplicate in executed slice\n\t\tvar duplicate bool\n\t\t// for i := 0; i < len(executed)-1; i++ {\n\t\t// \tif executed[i] == input.ID {\n\t\t// \t\tduplicate = true\n\t\t// \t\tbreak\n\t\t// \t}\n\t\t// }\n\t\tif duplicate {\n\t\t\tl.Warn().Str(\'step-run-id\', ctx.StepRunId()).Msgf(\'duplicate %d\', input.ID)\n\t\t}\n\t\tif !duplicate {\n\t\t\tuniques++\n\t\t}\n\t\tcount++\n\t\texecuted = append(executed, input.ID)\n\t\tmx.Unlock()\n\n\t\ttime.Sleep(delay)\n\n\t\tif failureRate > 0 {\n\t\t\tif rand.Float32() < failureRate {\n\t\t\t\treturn nil, fmt.Errorf(\'random failure\')\n\t\t\t}\n\t\t}\n\n\t\treturn &stepOneOutput{\n\t\t\tMessage: \'This ran at: \' + time.Now().Format(time.RFC3339Nano),\n\t\t}, nil\n\t}\n\n\tfor i := range eventFanout {\n\t\terr = w.RegisterWorkflow(\n\t\t\t&worker.WorkflowJob{\n\t\t\t\tName:        fmt.Sprintf(\'load-test-%d\', i),\n\t\t\t\tDescription: \'Load testing\',\n\t\t\t\tOn:          worker.Event(\'load-test:event\'),\n\t\t\t\tConcurrency: concurrencyOpts,\n\t\t\t\t// ScheduleTimeout: \'30s\',\n\t\t\t\tSteps: []*worker.WorkflowStep{\n\t\t\t\t\tworker.Fn(step).SetName(\'step-one\').SetTimeout(\'5m\'),\n\t\t\t\t},\n\t\t\t},\n\t\t)\n\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tcleanup, err := w.Start()\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\'error starting worker: %w\', err))\n\t}\n\n\t<-ctx.Done()\n\n\tif err := cleanup(); err != nil {\n\t\tpanic(fmt.Errorf(\'error cleaning up: %w\', err))\n\t}\n\n\tmx.Lock()\n\tdefer mx.Unlock()\n\treturn count, uniques\n}\n',
  'source': 'out/go/z_v0/loadtest/cli/run.go',
  'blocks': {},
  'highlights': {}
};  // Then replace double quotes with single quotes

export default snippet;
