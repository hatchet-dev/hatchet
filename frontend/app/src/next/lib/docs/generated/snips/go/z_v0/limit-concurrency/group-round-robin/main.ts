import { Snippet } from '@/next/lib/docs/generated/snips/types';

const snippet: Snippet = {
  'language': 'go',
  'content': 'package main\n\nimport (\n\t\'context\'\n\t\'fmt\'\n\t\'time\'\n\n\t\'github.com/joho/godotenv\'\n\n\t\'github.com/hatchet-dev/hatchet/pkg/client\'\n\t\'github.com/hatchet-dev/hatchet/pkg/client/types\'\n\t\'github.com/hatchet-dev/hatchet/pkg/cmdutils\'\n\t\'github.com/hatchet-dev/hatchet/pkg/worker\'\n)\n\ntype concurrencyLimitEvent struct {\n\tUserId int `json:\'user_id\'`\n}\n\ntype stepOneOutput struct {\n\tMessage string `json:\'message\'`\n}\n\nfunc main() {\n\terr := godotenv.Load()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tevents := make(chan string, 50)\n\tif err := run(cmdutils.InterruptChan(), events); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc getConcurrencyKey(ctx worker.HatchetContext) (string, error) {\n\tinput := &concurrencyLimitEvent{}\n\terr := ctx.WorkflowInput(input)\n\n\tif err != nil {\n\t\treturn \'\', fmt.Errorf(\'error getting input: %w\', err)\n\t}\n\n\treturn fmt.Sprintf(\'%d\', input.UserId), nil\n}\n\nfunc run(ch <-chan interface{}, events chan<- string) error {\n\tc, err := client.New()\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\'error creating client: %w\', err)\n\t}\n\n\tw, err := worker.NewWorker(\n\t\tworker.WithClient(\n\t\t\tc,\n\t\t),\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\'error creating worker: %w\', err)\n\t}\n\n\ttestSvc := w.NewService(\'test\')\n\n\terr = testSvc.On(\n\t\tworker.Events(\'concurrency-test-event-rr\'),\n\t\t&worker.WorkflowJob{\n\t\t\tName:        \'concurrency-limit-round-robin\',\n\t\t\tDescription: \'This limits concurrency to 2 runs at a time.\',\n\t\t\tConcurrency: worker.Concurrency(getConcurrencyKey).MaxRuns(2).LimitStrategy(types.GroupRoundRobin),\n\t\t\tSteps: []*worker.WorkflowStep{\n\t\t\t\tworker.Fn(func(ctx worker.HatchetContext) (result *stepOneOutput, err error) {\n\t\t\t\t\tinput := &concurrencyLimitEvent{}\n\n\t\t\t\t\terr = ctx.WorkflowInput(input)\n\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, fmt.Errorf(\'error getting input: %w\', err)\n\t\t\t\t\t}\n\n\t\t\t\t\tfmt.Println(\'received event\', input.UserId)\n\n\t\t\t\t\ttime.Sleep(5 * time.Second)\n\n\t\t\t\t\tfmt.Println(\'processed event\', input.UserId)\n\n\t\t\t\t\treturn nil, nil\n\t\t\t\t},\n\t\t\t\t).SetName(\'step-one\'),\n\t\t\t},\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\'error registering workflow: %w\', err)\n\t}\n\n\tinterruptCtx, cancel := cmdutils.InterruptContextFromChan(ch)\n\tdefer cancel()\n\n\tcleanup, err := w.Start()\n\tif err != nil {\n\t\treturn fmt.Errorf(\'error starting worker: %w\', err)\n\t}\n\n\tgo func() {\n\t\t// sleep with interrupt context\n\t\tselect {\n\t\tcase <-interruptCtx.Done(): // context cancelled\n\t\t\tfmt.Println(\'interrupted\')\n\t\t\treturn\n\t\tcase <-time.After(2 * time.Second): // timeout\n\t\t}\n\n\t\tfor i := 0; i < 20; i++ {\n\t\t\tvar event concurrencyLimitEvent\n\n\t\t\tif i < 10 {\n\t\t\t\tevent = concurrencyLimitEvent{0}\n\t\t\t} else {\n\t\t\t\tevent = concurrencyLimitEvent{1}\n\t\t\t}\n\n\t\t\tc.Event().Push(context.Background(), \'concurrency-test-event-rr\', event)\n\t\t}\n\n\t\tselect {\n\t\tcase <-interruptCtx.Done(): // context cancelled\n\t\t\tfmt.Println(\'interrupted\')\n\t\t\treturn\n\t\tcase <-time.After(10 * time.Second): //timeout\n\t\t}\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-interruptCtx.Done():\n\t\t\tif err := cleanup(); err != nil {\n\t\t\t\treturn fmt.Errorf(\'error cleaning up: %w\', err)\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t}\n}\n',
  'source': 'out/go/z_v0/limit-concurrency/group-round-robin/main.go',
  'blocks': {},
  'highlights': {}
};  // Then replace double quotes with single quotes

export default snippet;
