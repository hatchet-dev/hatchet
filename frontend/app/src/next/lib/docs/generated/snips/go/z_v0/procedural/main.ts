import { Snippet } from '@/next/lib/docs/generated/snips/types';

const snippet: Snippet = {
  language: 'go',
  content:
    'package main\n\nimport (\n\t"fmt"\n\t"sync"\n\t"time"\n\n\t"github.com/joho/godotenv"\n\t"golang.org/x/sync/errgroup"\n\n\t"github.com/hatchet-dev/hatchet/pkg/client"\n\t"github.com/hatchet-dev/hatchet/pkg/cmdutils"\n\t"github.com/hatchet-dev/hatchet/pkg/worker"\n)\n\nconst NUM_CHILDREN = 50\n\ntype proceduralChildInput struct {\n\tIndex int `json:"index"`\n}\n\ntype proceduralChildOutput struct {\n\tIndex int `json:"index"`\n}\n\ntype proceduralParentOutput struct {\n\tChildSum int `json:"child_sum"`\n}\n\nfunc main() {\n\terr := godotenv.Load()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tevents := make(chan string, 5*NUM_CHILDREN)\n\tinterrupt := cmdutils.InterruptChan()\n\n\tcleanup, err := run(events)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t<-interrupt\n\n\tif err := cleanup(); err != nil {\n\t\tpanic(fmt.Errorf("error cleaning up: %w", err))\n\t}\n}\n\nfunc run(events chan<- string) (func() error, error) {\n\tc, err := client.New()\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf("error creating client: %w", err)\n\t}\n\n\tw, err := worker.NewWorker(\n\t\tworker.WithClient(\n\t\t\tc,\n\t\t),\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf("error creating worker: %w", err)\n\t}\n\n\ttestSvc := w.NewService("test")\n\n\terr = testSvc.On(\n\t\tworker.NoTrigger(),\n\t\t&worker.WorkflowJob{\n\t\t\tName:        "procedural-parent-workflow",\n\t\t\tDescription: "This is a test of procedural workflows.",\n\t\t\tSteps: []*worker.WorkflowStep{\n\t\t\t\tworker.Fn(\n\t\t\t\t\tfunc(ctx worker.HatchetContext) (result *proceduralParentOutput, err error) {\n\t\t\t\t\t\tchildWorkflows := make([]*client.Workflow, NUM_CHILDREN)\n\n\t\t\t\t\t\tfor i := 0; i < NUM_CHILDREN; i++ {\n\t\t\t\t\t\t\tchildInput := proceduralChildInput{\n\t\t\t\t\t\t\t\tIndex: i,\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tchildWorkflow, err := ctx.SpawnWorkflow("procedural-child-workflow", childInput, &worker.SpawnWorkflowOpts{\n\t\t\t\t\t\t\t\tAdditionalMetadata: &map[string]string{\n\t\t\t\t\t\t\t\t\t"childKey": "childValue",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tchildWorkflows[i] = childWorkflow\n\n\t\t\t\t\t\t\tevents <- fmt.Sprintf("child-%d-started", i)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\teg := errgroup.Group{}\n\n\t\t\t\t\t\teg.SetLimit(NUM_CHILDREN)\n\n\t\t\t\t\t\tchildOutputs := make([]int, 0)\n\t\t\t\t\t\tchildOutputsMu := sync.Mutex{}\n\n\t\t\t\t\t\tfor i, childWorkflow := range childWorkflows {\n\t\t\t\t\t\t\teg.Go(func(i int, childWorkflow *client.Workflow) func() error {\n\t\t\t\t\t\t\t\treturn func() error {\n\t\t\t\t\t\t\t\t\tchildResult, err := childWorkflow.Result()\n\n\t\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tchildOutput := proceduralChildOutput{}\n\n\t\t\t\t\t\t\t\t\terr = childResult.StepOutput("step-one", &childOutput)\n\n\t\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tchildOutputsMu.Lock()\n\t\t\t\t\t\t\t\t\tchildOutputs = append(childOutputs, childOutput.Index)\n\t\t\t\t\t\t\t\t\tchildOutputsMu.Unlock()\n\n\t\t\t\t\t\t\t\t\tevents <- fmt.Sprintf("child-%d-completed", childOutput.Index)\n\n\t\t\t\t\t\t\t\t\treturn nil\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}(i, childWorkflow))\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfinishedCh := make(chan struct{})\n\n\t\t\t\t\t\tgo func() {\n\t\t\t\t\t\t\tdefer close(finishedCh)\n\t\t\t\t\t\t\terr = eg.Wait()\n\t\t\t\t\t\t}()\n\n\t\t\t\t\t\ttimer := time.NewTimer(60 * time.Second)\n\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase <-finishedCh:\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase <-timer.C:\n\t\t\t\t\t\t\tincomplete := make([]int, 0)\n\t\t\t\t\t\t\t// print non-complete children\n\t\t\t\t\t\t\tfor i := range childWorkflows {\n\t\t\t\t\t\t\t\tcompleted := false\n\t\t\t\t\t\t\t\tfor _, childOutput := range childOutputs {\n\t\t\t\t\t\t\t\t\tif childOutput == i {\n\t\t\t\t\t\t\t\t\t\tcompleted = true\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif !completed {\n\t\t\t\t\t\t\t\t\tincomplete = append(incomplete, i)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn nil, fmt.Errorf("timed out waiting for the following child workflows to complete: %v", incomplete)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsum := 0\n\n\t\t\t\t\t\tfor _, childOutput := range childOutputs {\n\t\t\t\t\t\t\tsum += childOutput\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn &proceduralParentOutput{\n\t\t\t\t\t\t\tChildSum: sum,\n\t\t\t\t\t\t}, nil\n\t\t\t\t\t},\n\t\t\t\t).SetTimeout("10m"),\n\t\t\t},\n\t\t},\n\t)\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf("error registering workflow: %w", err)\n\t}\n\n\terr = testSvc.On(\n\t\tworker.NoTrigger(),\n\t\t&worker.WorkflowJob{\n\t\t\tName:        "procedural-child-workflow",\n\t\t\tDescription: "This is a test of procedural workflows.",\n\t\t\tSteps: []*worker.WorkflowStep{\n\t\t\t\tworker.Fn(\n\t\t\t\t\tfunc(ctx worker.HatchetContext) (result *proceduralChildOutput, err error) {\n\t\t\t\t\t\tinput := proceduralChildInput{}\n\n\t\t\t\t\t\terr = ctx.WorkflowInput(&input)\n\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn &proceduralChildOutput{\n\t\t\t\t\t\t\tIndex: input.Index,\n\t\t\t\t\t\t}, nil\n\t\t\t\t\t},\n\t\t\t\t).SetName("step-one"),\n\t\t\t},\n\t\t},\n\t)\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf("error registering workflow: %w", err)\n\t}\n\n\tgo func() {\n\t\ttime.Sleep(1 * time.Second)\n\n\t\t_, err := c.Admin().RunWorkflow("procedural-parent-workflow", nil)\n\n\t\tif err != nil {\n\t\t\tpanic(fmt.Errorf("error running workflow: %w", err))\n\t\t}\n\t}()\n\n\tcleanup, err := w.Start()\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn cleanup, nil\n}\n',
  source: 'out/go/z_v0/procedural/main.go',
  blocks: {},
  highlights: {},
};

export default snippet;
