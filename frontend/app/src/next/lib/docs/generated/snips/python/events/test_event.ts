import { Snippet } from '@/next/lib/docs/generated/snips/types';

const snippet: Snippet = {
  language: 'python',
  content:
    "import asyncio\nfrom typing import AsyncGenerator\nfrom uuid import uuid4\n\nimport pytest\nimport pytest_asyncio\n\nfrom examples.events.worker import event_workflow\nfrom hatchet_sdk.clients.admin import CreateFilterRequest\nfrom hatchet_sdk.clients.events import (\n    BulkPushEventOptions,\n    BulkPushEventWithMetadata,\n    PushEventOptions,\n)\nfrom hatchet_sdk.hatchet import Hatchet\n\n\n@pytest.mark.asyncio(loop_scope='session')\nasync def test_event_push(hatchet: Hatchet) -> None:\n    e = hatchet.event.push('user:create', {'should_skip': False})\n\n    assert e.eventId is not None\n\n\n@pytest.mark.asyncio(loop_scope='session')\nasync def test_async_event_push(hatchet: Hatchet) -> None:\n    e = await hatchet.event.aio_push('user:create', {'should_skip': False})\n\n    assert e.eventId is not None\n\n\n@pytest.mark.asyncio(loop_scope='session')\nasync def test_async_event_bulk_push(hatchet: Hatchet) -> None:\n    events = [\n        BulkPushEventWithMetadata(\n            key='event1',\n            payload={'message': 'This is event 1', 'should_skip': False},\n            additional_metadata={'source': 'test', 'user_id': 'user123'},\n        ),\n        BulkPushEventWithMetadata(\n            key='event2',\n            payload={'message': 'This is event 2', 'should_skip': False},\n            additional_metadata={'source': 'test', 'user_id': 'user456'},\n        ),\n        BulkPushEventWithMetadata(\n            key='event3',\n            payload={'message': 'This is event 3', 'should_skip': False},\n            additional_metadata={'source': 'test', 'user_id': 'user789'},\n        ),\n    ]\n    opts = BulkPushEventOptions(namespace='bulk-test')\n\n    e = await hatchet.event.aio_bulk_push(events, opts)\n\n    assert len(e) == 3\n\n    # Sort both lists of events by their key to ensure comparison order\n    sorted_events = sorted(events, key=lambda x: x.key)\n    sorted_returned_events = sorted(e, key=lambda x: x.key)\n    namespace = 'bulk-test'\n\n    # Check that the returned events match the original events\n    for original_event, returned_event in zip(sorted_events, sorted_returned_events):\n        assert returned_event.key == namespace + original_event.key\n\n\n@pytest.mark.asyncio(loop_scope='session')\nasync def test_event_engine_behavior(hatchet: Hatchet) -> None:\n    test_run_id = str(uuid4())\n    events = [\n        BulkPushEventWithMetadata(\n            key='user:create',\n            payload={'message': 'This is event 1'},\n            additional_metadata={\n                'should_have_runs': True,\n                'test_run_id': test_run_id,\n            },\n        ),\n        BulkPushEventWithMetadata(\n            key='thisisafakeeventfoobarbaz',\n            payload={'message': 'This is a fake event'},\n            additional_metadata={\n                'should_have_runs': False,\n                'test_run_id': test_run_id,\n            },\n        ),\n    ]\n\n    result = await hatchet.event.aio_bulk_push(events)\n\n    assert len(result) == len(events)\n\n    await asyncio.sleep(5)\n\n    persisted = (await hatchet.event.aio_list(limit=100)).rows or []\n\n    assert {e.eventId for e in result}.issubset({e.metadata.id for e in persisted})\n\n    for event in persisted or []:\n        meta = event.additional_metadata or {}\n        if meta.get('test_run_id') != test_run_id:\n            continue\n\n        should_have_runs = meta.get('should_have_runs')\n\n        runs = (\n            await hatchet.runs.aio_list(triggering_event_external_id=event.metadata.id)\n        ).rows\n\n        if should_have_runs:\n            assert len(runs) > 0\n        else:\n            assert len(runs) == 0\n\n\n@pytest_asyncio.fixture(scope='function', loop_scope='session')\nasync def filter_fixture(hatchet: Hatchet) -> AsyncGenerator[str, None]:\n    test_run_id = str(uuid4())\n    print('\\n\\nWorkflow id', event_workflow.id, '\\n\\n')\n    id = await hatchet._client.admin.aio_put_filter(\n        event_filter=CreateFilterRequest(\n            workflow_id=event_workflow.id,\n            expression='input.should_skip == true',\n            resource_hint=test_run_id,\n        )\n    )\n\n    yield test_run_id\n\n    await hatchet._client.admin.aio_delete_filter(id)\n\n\n@pytest.mark.asyncio(loop_scope='session')\nasync def test_event_skipping_filtering(hatchet: Hatchet, filter_fixture: str) -> None:\n    test_run_id = filter_fixture\n    events = [\n        BulkPushEventWithMetadata(\n            key='user:create',\n            payload={'message': 'This is event 1', 'should_skip': False},\n            additional_metadata={\n                'should_have_runs': True,\n                'test_run_id': test_run_id,\n                'key': 1,\n            },\n            resource_hint=test_run_id,\n        ),\n        BulkPushEventWithMetadata(\n            key='user:create',\n            payload={'message': 'This is event 2', 'should_skip': True},\n            additional_metadata={\n                'should_have_runs': False,\n                'test_run_id': test_run_id,\n                'key': 2,\n            },\n            resource_hint=test_run_id,\n        ),\n        BulkPushEventWithMetadata(\n            key='user:create',\n            payload={\n                'message': 'This event is missing the resource hint',\n                'should_skip': False,\n            },\n            additional_metadata={\n                'should_have_runs': True,\n                'test_run_id': test_run_id,\n                'key': 3,\n            },\n        ),\n        BulkPushEventWithMetadata(\n            key='user:create',\n            payload={\n                'message': 'This event is missing the resource hint',\n                'should_skip': True,\n            },\n            additional_metadata={\n                'should_have_runs': True,\n                'test_run_id': test_run_id,\n                'key': 4,\n            },\n        ),\n        BulkPushEventWithMetadata(\n            key='thisisafakeeventfoobarbaz',\n            payload={'message': 'This is a fake event', 'should_skip': False},\n            additional_metadata={\n                'should_have_runs': False,\n                'test_run_id': test_run_id,\n                'key': 5,\n            },\n            resource_hint=test_run_id,\n        ),\n        BulkPushEventWithMetadata(\n            key='thisisafakeeventfoobarbaz',\n            payload={'message': 'This is a fake event', 'should_skip': False},\n            additional_metadata={\n                'should_have_runs': False,\n                'test_run_id': test_run_id,\n                'key': 6,\n            },\n            resource_hint=test_run_id,\n        ),\n    ]\n\n    result = await hatchet.event.aio_bulk_push(events)\n\n    assert len(result) == len(events)\n\n    await asyncio.sleep(5)\n\n    persisted = (await hatchet.event.aio_list(limit=100)).rows or []\n\n    assert {e.eventId for e in result}.issubset({e.metadata.id for e in persisted})\n\n    for event in persisted or []:\n        meta = event.additional_metadata or {}\n        if meta.get('test_run_id') != test_run_id:\n            continue\n\n        should_have_runs = meta.get('should_have_runs')\n\n        runs = (\n            await hatchet.runs.aio_list(triggering_event_external_id=event.metadata.id)\n        ).rows\n\n        if should_have_runs:\n            assert len(runs) > 0\n        else:\n            assert len(runs) == 0\n\n\n@pytest.mark.asyncio(loop_scope='session')\nasync def test_event_skipping_filtering_no_bulk(\n    hatchet: Hatchet, filter_fixture: str\n) -> None:\n    test_run_id = filter_fixture\n\n    tasks = [\n        hatchet.event.aio_push(\n            event_key='user:create',\n            payload={'message': 'This is event 1', 'should_skip': False},\n            options=PushEventOptions(\n                resource_hint=test_run_id,\n                additional_metadata={\n                    'should_have_runs': True,\n                    'test_run_id': test_run_id,\n                    'key': 1,\n                },\n            ),\n        ),\n        hatchet.event.aio_push(\n            event_key='user:create',\n            payload={'message': 'This is event 2', 'should_skip': True},\n            options=PushEventOptions(\n                resource_hint=test_run_id,\n                additional_metadata={\n                    'should_have_runs': False,\n                    'test_run_id': test_run_id,\n                    'key': 2,\n                },\n            ),\n        ),\n        hatchet.event.aio_push(\n            event_key='user:create',\n            payload={\n                'message': 'This event is missing the resource hint',\n                'should_skip': False,\n            },\n            options=PushEventOptions(\n                additional_metadata={\n                    'should_have_runs': True,\n                    'test_run_id': test_run_id,\n                    'key': 3,\n                },\n            ),\n        ),\n        hatchet.event.aio_push(\n            event_key='user:create',\n            payload={\n                'message': 'This event is missing the resource hint',\n                'should_skip': True,\n            },\n            options=PushEventOptions(\n                additional_metadata={\n                    'should_have_runs': True,\n                    'test_run_id': test_run_id,\n                    'key': 4,\n                },\n            ),\n        ),\n        hatchet.event.aio_push(\n            event_key='thisisafakeeventfoobarbaz',\n            payload={'message': 'This is a fake event', 'should_skip': False},\n            options=PushEventOptions(\n                resource_hint=test_run_id,\n                additional_metadata={\n                    'should_have_runs': False,\n                    'test_run_id': test_run_id,\n                    'key': 5,\n                },\n            ),\n        ),\n        hatchet.event.aio_push(\n            event_key='thisisafakeeventfoobarbaz',\n            payload={'message': 'This is a fake event', 'should_skip': False},\n            options=PushEventOptions(\n                resource_hint=test_run_id,\n                additional_metadata={\n                    'should_have_runs': False,\n                    'test_run_id': test_run_id,\n                    'key': 6,\n                },\n            ),\n        ),\n    ]\n\n    result = await asyncio.gather(*tasks)\n\n    assert len(result) == len(tasks)\n\n    await asyncio.sleep(5)\n\n    persisted = (await hatchet.event.aio_list(limit=100)).rows or []\n\n    assert {e.eventId for e in result}.issubset({e.metadata.id for e in persisted})\n\n    for event in persisted or []:\n        meta = event.additional_metadata or {}\n        if meta.get('test_run_id') != test_run_id:\n            continue\n\n        should_have_runs = meta.get('should_have_runs')\n\n        runs = (\n            await hatchet.runs.aio_list(triggering_event_external_id=event.metadata.id)\n        ).rows\n\n        if should_have_runs:\n            assert len(runs) > 0\n        else:\n            assert len(runs) == 0\n",
  source: 'out/python/events/test_event.py',
  blocks: {},
  highlights: {},
}; // Then replace double quotes with single quotes

export default snippet;
