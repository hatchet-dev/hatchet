import { Snippet } from '@/next/lib/docs/generated/snips/types';

const snippet: Snippet = {
  'language': 'go',
  'content': 'package main\n\nimport (\n\t\'fmt\'\n\t\'os\'\n\t\'time\'\n\n\tv1_workflows \'github.com/hatchet-dev/hatchet/examples/go/workflows\'\n\t\'github.com/hatchet-dev/hatchet/pkg/cmdutils\'\n\tv1 \'github.com/hatchet-dev/hatchet/pkg/v1\'\n\t\'github.com/hatchet-dev/hatchet/pkg/v1/worker\'\n\t\'github.com/hatchet-dev/hatchet/pkg/v1/workflow\'\n\t\'github.com/joho/godotenv\'\n)\n\nfunc main() {\n\terr := godotenv.Load()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\thatchet, err := v1.NewHatchetClient()\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Get workflow name from command line arguments\n\tvar workflowName string\n\tif len(os.Args) > 1 {\n\t\tworkflowName = os.Args[1]\n\t\tfmt.Println(\'workflow name provided:\', workflowName)\n\t}\n\n\t// Define workflows map\n\tworkflowMap := map[string][]workflow.WorkflowBase{\n\t\t\'dag\':           {v1_workflows.DagWorkflow(hatchet)},\n\t\t\'on-failure\':    {v1_workflows.OnFailure(hatchet)},\n\t\t\'simple\':        {v1_workflows.Simple(hatchet)},\n\t\t\'sleep\':         {v1_workflows.DurableSleep(hatchet)},\n\t\t\'child\':         {v1_workflows.Parent(hatchet), v1_workflows.Child(hatchet)},\n\t\t\'cancellation\':  {v1_workflows.Cancellation(hatchet)},\n\t\t\'timeout\':       {v1_workflows.Timeout(hatchet)},\n\t\t\'sticky\':        {v1_workflows.Sticky(hatchet), v1_workflows.StickyDag(hatchet), v1_workflows.Child(hatchet)},\n\t\t\'retries\':       {v1_workflows.Retries(hatchet), v1_workflows.RetriesWithCount(hatchet), v1_workflows.WithBackoff(hatchet)},\n\t\t\'on-cron\':       {v1_workflows.OnCron(hatchet)},\n\t\t\'non-retryable\': {v1_workflows.NonRetryableError(hatchet)},\n\t\t\'priority\':      {v1_workflows.Priority(hatchet)},\n\t}\n\n\t// Add an \'all\' option that registers all workflows\n\tallWorkflows := []workflow.WorkflowBase{}\n\tfor _, wfs := range workflowMap {\n\t\tallWorkflows = append(allWorkflows, wfs...)\n\t}\n\tworkflowMap[\'all\'] = allWorkflows\n\n\t// Lookup workflow from map\n\tworkflow, ok := workflowMap[workflowName]\n\tif !ok {\n\t\tfmt.Println(\'Invalid workflow name provided. Usage: go run examples/v1/worker/start.go [workflow-name]\')\n\t\tfmt.Println(\'Available workflows:\', getAvailableWorkflows(workflowMap))\n\t\tos.Exit(1)\n\t}\n\n\tvar slots int\n\tif workflowName == \'priority\' {\n\t\tslots = 1\n\t} else {\n\t\tslots = 100\n\t}\n\n\tworker, err := hatchet.Worker(\n\t\tworker.WorkerOpts{\n\t\t\tName:      fmt.Sprintf(\'%s-worker\', workflowName),\n\t\t\tWorkflows: workflow,\n\t\t\tSlots:     slots,\n\t\t},\n\t)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tinterruptCtx, cancel := cmdutils.NewInterruptContext()\n\n\terr = worker.StartBlocking(interruptCtx)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tgo func() {\n\t\ttime.Sleep(10 * time.Second)\n\t\tcancel()\n\t}()\n}\n\n// Helper function to get available workflows as a formatted string\nfunc getAvailableWorkflows(workflowMap map[string][]workflow.WorkflowBase) string {\n\tvar workflows string\n\tcount := 0\n\tfor name := range workflowMap {\n\t\tif count > 0 {\n\t\t\tworkflows += \', \'\n\t\t}\n\t\tworkflows += fmt.Sprintf(\'\'%s\'\', name)\n\t\tcount++\n\t}\n\treturn workflows\n}\n',
  'source': 'out/go/worker/start.go',
  'blocks': {},
  'highlights': {}
};  // Then replace double quotes with single quotes

export default snippet;
