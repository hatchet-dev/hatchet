import { Snippet } from '@/next/lib/docs/generated/snips/types';

const snippet: Snippet = {
  'language': 'go',
  'content': 'package main\n\nimport (\n\t\'fmt\'\n\t\'log\'\n\t\'time\'\n\n\t\'github.com/joho/godotenv\'\n\n\t\'github.com/hatchet-dev/hatchet/pkg/client\'\n\t\'github.com/hatchet-dev/hatchet/pkg/client/types\'\n\t\'github.com/hatchet-dev/hatchet/pkg/cmdutils\'\n\t\'github.com/hatchet-dev/hatchet/pkg/worker\'\n)\n\ntype userCreateEvent struct {\n\tUsername string            `json:\'username\'`\n\tUserID   string            `json:\'user_id\'`\n\tData     map[string]string `json:\'data\'`\n}\n\ntype stepOneOutput struct {\n\tMessage string `json:\'message\'`\n}\n\nfunc main() {\n\terr := godotenv.Load()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tevents := make(chan string, 50)\n\tinterrupt := cmdutils.InterruptChan()\n\n\tcleanup, err := run(events)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t<-interrupt\n\n\tif err := cleanup(); err != nil {\n\n\t\tpanic(fmt.Errorf(\'error cleaning up: %w\', err))\n\t}\n}\n\nfunc run(events chan<- string) (func() error, error) {\n\tc, err := client.New()\n\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\'error creating client: %w\', err)\n\t}\n\n\tw, err := worker.NewWorker(\n\t\tworker.WithClient(\n\t\t\tc,\n\t\t),\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\'error creating worker: %w\', err)\n\t}\n\n\terr = w.RegisterWorkflow(\n\t\t&worker.WorkflowJob{\n\t\t\tOn:          worker.Events(\'user:create:concurrency\'),\n\t\t\tName:        \'simple-concurrency\',\n\t\t\tDescription: \'This runs to test concurrency.\',\n\t\t\tConcurrency: worker.Expression(\'\'concurrency\'\').MaxRuns(1).LimitStrategy(types.GroupRoundRobin),\n\t\t\tSteps: []*worker.WorkflowStep{\n\t\t\t\tworker.Fn(func(ctx worker.HatchetContext) (result *stepOneOutput, err error) {\n\t\t\t\t\tinput := &userCreateEvent{}\n\n\t\t\t\t\terr = ctx.WorkflowInput(input)\n\n\t\t\t\t\t// we sleep to simulate a long running task\n\t\t\t\t\ttime.Sleep(10 * time.Second)\n\n\t\t\t\t\tif err != nil {\n\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\n\t\t\t\t\tif ctx.Err() != nil {\n\t\t\t\t\t\treturn nil, ctx.Err()\n\t\t\t\t\t}\n\n\t\t\t\t\tlog.Printf(\'step-one\')\n\t\t\t\t\tevents <- \'step-one\'\n\n\t\t\t\t\treturn &stepOneOutput{\n\t\t\t\t\t\tMessage: \'Username is: \' + input.Username,\n\t\t\t\t\t}, nil\n\t\t\t\t},\n\t\t\t\t).SetName(\'step-one\'),\n\t\t\t\tworker.Fn(func(ctx worker.HatchetContext) (result *stepOneOutput, err error) {\n\t\t\t\t\tinput := &stepOneOutput{}\n\t\t\t\t\terr = ctx.StepOutput(\'step-one\', input)\n\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\n\t\t\t\t\tif ctx.Err() != nil {\n\t\t\t\t\t\treturn nil, ctx.Err()\n\t\t\t\t\t}\n\n\t\t\t\t\tlog.Printf(\'step-two\')\n\t\t\t\t\tevents <- \'step-two\'\n\n\t\t\t\t\treturn &stepOneOutput{\n\t\t\t\t\t\tMessage: \'Above message is: \' + input.Message,\n\t\t\t\t\t}, nil\n\t\t\t\t}).SetName(\'step-two\').AddParents(\'step-one\'),\n\t\t\t},\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\'error registering workflow: %w\', err)\n\t}\n\ttestEvent := userCreateEvent{\n\t\tUsername: \'echo-test\',\n\t\tUserID:   \'1234\',\n\t\tData: map[string]string{\n\t\t\t\'test\': \'test\',\n\t\t},\n\t}\n\tgo func() {\n\t\t// do this 10 times to test concurrency\n\t\tfor i := 0; i < 10; i++ {\n\n\t\t\twfr_id, err := c.Admin().RunWorkflow(\'simple-concurrency\', testEvent)\n\n\t\t\tlog.Println(\'Starting workflow run id: \', wfr_id)\n\n\t\t\tif err != nil {\n\t\t\t\tpanic(fmt.Errorf(\'error running workflow: %w\', err))\n\t\t\t}\n\n\t\t}\n\t}()\n\n\tcleanup, err := w.Start()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn cleanup, nil\n}\n',
  'source': 'out/go/z_v0/concurrency/main.go',
  'blocks': {},
  'highlights': {}
};  // Then replace double quotes with single quotes

export default snippet;
