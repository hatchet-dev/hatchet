import { Snippet } from '@/next/lib/docs/generated/snips/types';

const snippet: Snippet = {
  language: 'typescript ',
  content:
    "import sleep from '@hatchet-dev/typescript-sdk-dev/typescript-sdk/util/sleep';\nimport { randomUUID } from 'crypto';\nimport { Event } from '@hatchet-dev/typescript-sdk-dev/typescript-sdk/protoc/events';\nimport { SIMPLE_EVENT, lower, Input } from './workflow';\nimport { hatchet } from '../hatchet-client';\nimport { Worker } from '../../client/worker/worker';\n\nxdescribe('events-e2e', () => {\n  let worker: Worker;\n  let testRunId: string;\n\n  beforeEach(async () => {\n    testRunId = randomUUID();\n\n    worker = await hatchet.worker('event-worker');\n    await worker.registerWorkflow(lower);\n\n    void worker.start();\n  });\n\n  afterAll(async () => {\n    await worker.stop();\n    await sleep(2000);\n  });\n\n  async function setupEventFilter(expression?: string, payload: Record<string, string> = {}) {\n    const finalExpression =\n      expression || `input.ShouldSkip == false && payload.testRunId == '${testRunId}'`;\n\n    const workflowId = (await hatchet.workflows.get(lower.name)).metadata.id;\n\n    const filter = await hatchet.filters.create({\n      workflowId,\n      expression: finalExpression,\n      scope: testRunId,\n      payload: { testRunId, ...payload },\n    });\n\n    return async () => {\n      await hatchet.filters.delete(filter.metadata.id);\n    };\n  }\n\n  // Helper function to wait for events to process and fetch runs\n  async function waitForEventsToProcess(events: Event[]): Promise<Record<string, any[]>> {\n    await sleep(3000);\n\n    const persisted = (await hatchet.events.list({ limit: 100 })).rows || [];\n\n    // Ensure all our events are persisted\n    const eventIds = new Set(events.map((e) => e.eventId));\n    const persistedIds = new Set(persisted.map((e) => e.metadata.id));\n    expect(Array.from(eventIds).every((id) => persistedIds.has(id))).toBeTruthy();\n\n    let attempts = 0;\n    const maxAttempts = 15;\n    const eventToRuns: Record<string, any[]> = {};\n\n    while (true) {\n      console.log('Waiting for event runs to complete...');\n      if (attempts > maxAttempts) {\n        console.log('Timed out waiting for event runs to complete.');\n        return {};\n      }\n\n      attempts += 1;\n\n      // For each event, fetch its runs\n      const runsPromises = events.map(async (event) => {\n        const runs = await hatchet.runs.list({\n          triggeringEventExternalId: event.eventId,\n        });\n\n        // Extract metadata from event\n        const meta = event.additionalMetadata ? JSON.parse(event.additionalMetadata) : {};\n\n        const payload = event.payload ? JSON.parse(event.payload) : {};\n\n        return {\n          event: {\n            id: event.eventId,\n            payload,\n            meta,\n            shouldHaveRuns: Boolean(meta.should_have_runs),\n            testRunId: meta.test_run_id,\n          },\n          runs: runs.rows || [],\n        };\n      });\n\n      const eventRuns = await Promise.all(runsPromises);\n\n      // If all events have no runs yet, wait and retry\n      if (eventRuns.every(({ runs }) => runs.length === 0)) {\n        await sleep(1000);\n\n        continue;\n      }\n\n      // Store runs by event ID\n      for (const { event, runs } of eventRuns) {\n        eventToRuns[event.id] = runs;\n      }\n\n      // Check if any runs are still in progress\n      const anyInProgress = Object.values(eventToRuns).some((runs) =>\n        runs.some((run) => run.status === 'QUEUED' || run.status === 'RUNNING')\n      );\n\n      if (anyInProgress) {\n        await sleep(1000);\n\n        continue;\n      }\n\n      break;\n    }\n\n    return eventToRuns;\n  }\n\n  // Helper to verify runs match expectations\n  function verifyEventRuns(eventData: any, runs: any[]) {\n    if (eventData.shouldHaveRuns) {\n      expect(runs.length).toBeGreaterThan(0);\n    } else {\n      expect(runs.length).toBe(0);\n    }\n  }\n\n  // Helper to create bulk push event objects\n  function createBulkPushEvent({\n    index = 1,\n    ShouldSkip = false,\n    shouldHaveRuns = true,\n    key = SIMPLE_EVENT,\n    payload = {},\n    scope = null,\n  }: {\n    index?: number;\n    ShouldSkip?: boolean;\n    shouldHaveRuns?: boolean;\n    key?: string;\n    payload?: Record<string, any>;\n    scope?: string | null;\n  }) {\n    return {\n      key,\n      payload: {\n        ShouldSkip,\n        Message: `This is event ${index}`,\n        ...payload,\n      },\n      additionalMetadata: {\n        should_have_runs: shouldHaveRuns,\n        test_run_id: testRunId,\n        key,\n        index,\n      },\n      scope: scope || undefined,\n    };\n  }\n\n  // Helper to create payload object\n  function createEventPayload(ShouldSkip: boolean): Input {\n    return { ShouldSkip, Message: 'This is event 1' };\n  }\n\n  it('should push an event', async () => {\n    const event = await hatchet.events.push(SIMPLE_EVENT, createEventPayload(false));\n    expect(event.eventId).toBeTruthy();\n  }, 10000);\n\n  it('should push an event asynchronously', async () => {\n    const event = await hatchet.events.push(SIMPLE_EVENT, createEventPayload(false));\n    expect(event.eventId).toBeTruthy();\n  }, 10000);\n\n  it('should bulk push events', async () => {\n    const events = [\n      {\n        key: SIMPLE_EVENT,\n        payload: { Message: 'This is event 1', ShouldSkip: false },\n        additionalMetadata: { source: 'test', user_id: 'user123' },\n      },\n      {\n        key: SIMPLE_EVENT,\n        payload: { Message: 'This is event 2', ShouldSkip: false },\n        additionalMetadata: { source: 'test', user_id: 'user456' },\n      },\n      {\n        key: SIMPLE_EVENT,\n        payload: { Message: 'This is event 3', ShouldSkip: false },\n        additionalMetadata: { source: 'test', user_id: 'user789' },\n      },\n    ];\n\n    const result = await hatchet.events.bulkPush(SIMPLE_EVENT, events);\n\n    expect(result.events.length).toBe(3);\n\n    // Sort and verify namespacing\n    const sortedEvents = [...events].sort((a, b) => a.key.localeCompare(b.key));\n    const sortedResults = [...result.events].sort((a, b) => a.key.localeCompare(b.key));\n\n    sortedEvents.forEach((originalEvent, index) => {\n      const returnedEvent = sortedResults[index];\n      expect(returnedEvent.key).toBe(originalEvent.key);\n    });\n  }, 15000);\n\n  it('should process events according to event engine behavior', async () => {\n    const eventPromises = [\n      createBulkPushEvent({}),\n      createBulkPushEvent({\n        key: 'thisisafakeeventfoobarbaz',\n        shouldHaveRuns: false,\n      }),\n    ].map((event) => convertBulkToSingle(event));\n    const events = await Promise.all(eventPromises);\n\n    const eventToRuns = await waitForEventsToProcess(events);\n\n    // Verify each event's runs\n    Object.keys(eventToRuns).forEach((eventId) => {\n      const runs = eventToRuns[eventId];\n      const eventInfo = events.find((e) => e.eventId === eventId);\n\n      if (eventInfo) {\n        const meta = JSON.parse(eventInfo.additionalMetadata || '{}');\n        verifyEventRuns(\n          {\n            shouldHaveRuns: Boolean(meta.should_have_runs),\n          },\n          runs\n        );\n      }\n    });\n  }, 30000);\n\n  function generateBulkEvents() {\n    return [\n      createBulkPushEvent({\n        index: 1,\n        ShouldSkip: false,\n        shouldHaveRuns: true,\n      }),\n      createBulkPushEvent({\n        index: 2,\n        ShouldSkip: true,\n        shouldHaveRuns: true,\n      }),\n      createBulkPushEvent({\n        index: 3,\n        ShouldSkip: false,\n        shouldHaveRuns: true,\n        scope: testRunId,\n      }),\n      createBulkPushEvent({\n        index: 4,\n        ShouldSkip: true,\n        shouldHaveRuns: false,\n        scope: testRunId,\n      }),\n      createBulkPushEvent({\n        index: 5,\n        ShouldSkip: true,\n        shouldHaveRuns: false,\n        scope: testRunId,\n        key: 'thisisafakeeventfoobarbaz',\n      }),\n      createBulkPushEvent({\n        index: 6,\n        ShouldSkip: false,\n        shouldHaveRuns: false,\n        scope: testRunId,\n        key: 'thisisafakeeventfoobarbaz',\n      }),\n    ];\n  }\n\n  async function convertBulkToSingle(event: any) {\n    return hatchet.events.push(event.key, event.payload, {\n      scope: event.scope,\n      additionalMetadata: event.additionalMetadata,\n      priority: event.priority,\n    });\n  }\n\n  it('should handle event skipping and filtering without bulk push', async () => {\n    const cleanup = await setupEventFilter();\n\n    try {\n      const rawEvents = generateBulkEvents();\n      const eventPromises = rawEvents.map((event) => convertBulkToSingle(event));\n      const events = await Promise.all(eventPromises);\n\n      const eventToRuns = await waitForEventsToProcess(events);\n\n      // Verify each event's runs\n      Object.keys(eventToRuns).forEach((eventId) => {\n        const runs = eventToRuns[eventId];\n        const eventInfo = events.find((e) => e.eventId === eventId);\n\n        if (eventInfo) {\n          const meta = JSON.parse(eventInfo.additionalMetadata || '{}');\n          verifyEventRuns(\n            {\n              shouldHaveRuns: Boolean(meta.should_have_runs),\n            },\n            runs\n          );\n        }\n      });\n    } finally {\n      await cleanup();\n    }\n  }, 30000);\n\n  it('should filter events by payload expression not matching', async () => {\n    const cleanup = await setupEventFilter('input.ShouldSkip == false && payload.foobar == 'baz'', {\n      foobar: 'qux',\n    });\n\n    try {\n      const event = await hatchet.events.push(\n        SIMPLE_EVENT,\n        { Message: 'This is event 1', ShouldSkip: false },\n        {\n          scope: testRunId,\n          additionalMetadata: {\n            should_have_runs: 'false',\n            test_run_id: testRunId,\n            key: '1',\n          },\n        }\n      );\n\n      const eventToRuns = await waitForEventsToProcess([event]);\n      expect(Object.keys(eventToRuns).length).toBe(0);\n    } finally {\n      await cleanup();\n    }\n  }, 20000);\n\n  it('should filter events by payload expression matching', async () => {\n    const cleanup = await setupEventFilter('input.ShouldSkip == false && payload.foobar == 'baz'', {\n      foobar: 'baz',\n    });\n\n    try {\n      const event = await hatchet.events.push(\n        SIMPLE_EVENT,\n        { Message: 'This is event 1', ShouldSkip: false },\n        {\n          scope: testRunId,\n          additionalMetadata: {\n            should_have_runs: 'true',\n            test_run_id: testRunId,\n            key: '1',\n          },\n        }\n      );\n\n      const eventToRuns = await waitForEventsToProcess([event]);\n      const runs = Object.values(eventToRuns)[0] || [];\n      expect(runs.length).toBeGreaterThan(0);\n    } finally {\n      await cleanup();\n    }\n  }, 20000);\n});\n",
  source: 'out/typescript/on_event/event.e2e.ts',
  blocks: {},
  highlights: {},
}; // Then replace double quotes with single quotes

export default snippet;
