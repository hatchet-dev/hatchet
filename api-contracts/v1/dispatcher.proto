syntax = "proto3";

option go_package = "github.com/hatchet-dev/hatchet/internal/services/shared/proto/v1";

package v1;

import "v1/shared/condition.proto";
import "workflows/workflows.proto";

service V1Dispatcher {
    rpc DurableTask(stream DurableTaskRequest) returns (stream DurableTaskResponse) {}

    // NOTE: deprecated after DurableEventLog is implemented
    rpc RegisterDurableEvent(RegisterDurableEventRequest) returns (RegisterDurableEventResponse) {}
    rpc ListenForDurableEvent(stream ListenForDurableEventRequest) returns (stream DurableEvent) {}
}

message DurableTaskRequestRegisterWorker {
    string worker_id = 1;
}

message DurableTaskResponseRegisterWorker {
    string worker_id = 1;
}

enum DurableTaskEventKind {
    DURABLE_TASK_TRIGGER_KIND_UNSPECIFIED = 0;
    DURABLE_TASK_TRIGGER_KIND_RUN = 1;
    DURABLE_TASK_TRIGGER_KIND_WAIT_FOR = 2;
    DURABLE_TASK_TRIGGER_KIND_MEMO = 3;
}

message DurableTaskEventRequest {
    // The invocation_count is a monotonically increasing count that uniquely identifies an "attempt"
    // at running a durable task. Each time the task is started, it gets a new invocation count (which has)
    // incremented by one since the previous invocation. This allows the server (and the worker) to have a way of
    // differentiating between different attempts of the same task running in different places, to prevent race conditions
    // and other problems from duplication. It also allows for older invocations to be evicted cleanly
    int64 invocation_count = 1;
    string durable_task_external_id = 2;
    DurableTaskEventKind kind = 3;
    optional bytes payload = 4;
    optional DurableEventListenerConditions wait_for_conditions = 5;

    // Fields for DURABLE_TASK_TRIGGER_KIND_RUN (spawning child workflows)
    optional TriggerWorkflowRequest trigger_opts  = 6;
}

// todo: figure out how to share this type
message TriggerWorkflowRequest {
    string name = 1;

    // (optional) the input data for the workflow
    string input = 2;

    // (optional) the parent workflow run id
    optional string parent_id = 3;

    // (optional) the parent task external run id
    optional string parent_task_run_external_id = 4;

    // (optional) the index of the child workflow. if this is set, matches on the index or the
    // child key will return an existing workflow run if the parent id, parent task run id, and
    // child index/key match an existing workflow run.
    optional int32 child_index = 5;

    // (optional) the key for the child. if this is set, matches on the index or the
    // child key will return an existing workflow run if the parent id, parent task run id, and
    // child index/key match an existing workflow run.
    optional string child_key = 6;

    // (optional) additional metadata for the workflow
    optional string additional_metadata = 7;

    // (optional) desired worker id for the workflow run,
    // requires the workflow definition to have a sticky strategy
    optional string desired_worker_id = 8;

    // (optional) override for the priority of the workflow tasks, will set all tasks to this priority
    optional int32 priority = 9;
}

message DurableTaskEventAckResponse {
    int64 invocation_count = 1;
    string durable_task_external_id = 2;
    int64 node_id = 3;
}

message DurableTaskRegisterCallbackRequest {
    int64 invocation_count = 1;
    string durable_task_external_id = 2;
    int64 node_id = 3;
}

message DurableTaskRegisterCallbackAckResponse {
    int64 invocation_count = 1;
    string durable_task_external_id = 2;
    int64 node_id = 3;
}

message DurableTaskCallbackCompletedResponse {
    int64 invocation_count = 1;
    string durable_task_external_id = 2;
    int64 node_id = 3;
    bytes payload = 4;
}

message DurableTaskEvictInvocationRequest {
    int64 invocation_count = 1;
    string durable_task_external_id = 2;
}

message DurableTaskRequest {
    oneof message {
        DurableTaskRequestRegisterWorker register_worker = 1;
        DurableTaskEventRequest event = 2;
        DurableTaskRegisterCallbackRequest register_callback = 3;
        DurableTaskEvictInvocationRequest evict_invocation = 4;
    }
}

message DurableTaskResponse {
    oneof message {
        DurableTaskResponseRegisterWorker register_worker = 1;
        DurableTaskEventAckResponse trigger_ack = 2;
        DurableTaskRegisterCallbackAckResponse register_callback_ack = 3;
        DurableTaskCallbackCompletedResponse callback_completed = 4;
    }
}

message RegisterDurableEventRequest {
    string task_id = 1; // external uuid for the task run
    string signal_key = 2; // the signal key for the event
    DurableEventListenerConditions conditions = 3; // the task conditions for creating the task
}

message RegisterDurableEventResponse {
}

message ListenForDurableEventRequest {
    string task_id = 1; // single listener per worker
    string signal_key = 2; // the match id for the listener
}

message DurableEvent {
    string task_id = 1;
    string signal_key = 2;
    bytes data = 3; // the data for the event
}
